// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mojo/public/tools/fuzzers/mojolpm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#ifdef KYTHE_IS_RUNNING
#pragma kythe_metadata "mojo/public/tools/fuzzers/mojolpm.pb.h.meta"
#endif  // KYTHE_IS_RUNNING
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
namespace mojolpm {
class CreateDataPipeOptions;
class CreateDataPipeOptionsDefaultTypeInternal;
extern CreateDataPipeOptionsDefaultTypeInternal _CreateDataPipeOptions_default_instance_;
class DataPipeConsumerClose;
class DataPipeConsumerCloseDefaultTypeInternal;
extern DataPipeConsumerCloseDefaultTypeInternal _DataPipeConsumerClose_default_instance_;
class DataPipeConsumerHandle;
class DataPipeConsumerHandleDefaultTypeInternal;
extern DataPipeConsumerHandleDefaultTypeInternal _DataPipeConsumerHandle_default_instance_;
class DataPipeProducerClose;
class DataPipeProducerCloseDefaultTypeInternal;
extern DataPipeProducerCloseDefaultTypeInternal _DataPipeProducerClose_default_instance_;
class DataPipeProducerHandle;
class DataPipeProducerHandleDefaultTypeInternal;
extern DataPipeProducerHandleDefaultTypeInternal _DataPipeProducerHandle_default_instance_;
class DataPipeRead;
class DataPipeReadDefaultTypeInternal;
extern DataPipeReadDefaultTypeInternal _DataPipeRead_default_instance_;
class DataPipeWrite;
class DataPipeWriteDefaultTypeInternal;
extern DataPipeWriteDefaultTypeInternal _DataPipeWrite_default_instance_;
class Handle;
class HandleDefaultTypeInternal;
extern HandleDefaultTypeInternal _Handle_default_instance_;
class MessagePipeHandle;
class MessagePipeHandleDefaultTypeInternal;
extern MessagePipeHandleDefaultTypeInternal _MessagePipeHandle_default_instance_;
class PlatformHandle;
class PlatformHandleDefaultTypeInternal;
extern PlatformHandleDefaultTypeInternal _PlatformHandle_default_instance_;
class SharedBufferHandle;
class SharedBufferHandleDefaultTypeInternal;
extern SharedBufferHandleDefaultTypeInternal _SharedBufferHandle_default_instance_;
}  // namespace mojolpm
PROTOBUF_NAMESPACE_OPEN
template<> ::mojolpm::CreateDataPipeOptions* Arena::CreateMaybeMessage<::mojolpm::CreateDataPipeOptions>(Arena*);
template<> ::mojolpm::DataPipeConsumerClose* Arena::CreateMaybeMessage<::mojolpm::DataPipeConsumerClose>(Arena*);
template<> ::mojolpm::DataPipeConsumerHandle* Arena::CreateMaybeMessage<::mojolpm::DataPipeConsumerHandle>(Arena*);
template<> ::mojolpm::DataPipeProducerClose* Arena::CreateMaybeMessage<::mojolpm::DataPipeProducerClose>(Arena*);
template<> ::mojolpm::DataPipeProducerHandle* Arena::CreateMaybeMessage<::mojolpm::DataPipeProducerHandle>(Arena*);
template<> ::mojolpm::DataPipeRead* Arena::CreateMaybeMessage<::mojolpm::DataPipeRead>(Arena*);
template<> ::mojolpm::DataPipeWrite* Arena::CreateMaybeMessage<::mojolpm::DataPipeWrite>(Arena*);
template<> ::mojolpm::Handle* Arena::CreateMaybeMessage<::mojolpm::Handle>(Arena*);
template<> ::mojolpm::MessagePipeHandle* Arena::CreateMaybeMessage<::mojolpm::MessagePipeHandle>(Arena*);
template<> ::mojolpm::PlatformHandle* Arena::CreateMaybeMessage<::mojolpm::PlatformHandle>(Arena*);
template<> ::mojolpm::SharedBufferHandle* Arena::CreateMaybeMessage<::mojolpm::SharedBufferHandle>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mojolpm {

// ===================================================================

class Handle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.Handle) */ {
 public:
  inline Handle() : Handle(nullptr) {}
  virtual ~Handle();

  Handle(const Handle& from);
  Handle(Handle&& from) noexcept
    : Handle() {
    *this = ::std::move(from);
  }

  inline Handle& operator=(const Handle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handle& operator=(Handle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Handle& default_instance();

  static inline const Handle* internal_default_instance() {
    return reinterpret_cast<const Handle*>(
               &_Handle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Handle& a, Handle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Handle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Handle* New() const final {
    return CreateMaybeMessage<Handle>(nullptr);
  }

  Handle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Handle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Handle& from);
  void MergeFrom(const Handle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.Handle";
  }
  protected:
  explicit Handle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mojolpm.Handle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class CreateDataPipeOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.CreateDataPipeOptions) */ {
 public:
  inline CreateDataPipeOptions() : CreateDataPipeOptions(nullptr) {}
  virtual ~CreateDataPipeOptions();

  CreateDataPipeOptions(const CreateDataPipeOptions& from);
  CreateDataPipeOptions(CreateDataPipeOptions&& from) noexcept
    : CreateDataPipeOptions() {
    *this = ::std::move(from);
  }

  inline CreateDataPipeOptions& operator=(const CreateDataPipeOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDataPipeOptions& operator=(CreateDataPipeOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateDataPipeOptions& default_instance();

  static inline const CreateDataPipeOptions* internal_default_instance() {
    return reinterpret_cast<const CreateDataPipeOptions*>(
               &_CreateDataPipeOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateDataPipeOptions& a, CreateDataPipeOptions& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CreateDataPipeOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDataPipeOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateDataPipeOptions* New() const final {
    return CreateMaybeMessage<CreateDataPipeOptions>(nullptr);
  }

  CreateDataPipeOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateDataPipeOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateDataPipeOptions& from);
  void MergeFrom(const CreateDataPipeOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDataPipeOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.CreateDataPipeOptions";
  }
  protected:
  explicit CreateDataPipeOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagsFieldNumber = 2,
    kElementNumBytesFieldNumber = 3,
    kCapacityNumBytesFieldNumber = 4,
  };
  // required uint32 flags = 2;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 element_num_bytes = 3;
  bool has_element_num_bytes() const;
  private:
  bool _internal_has_element_num_bytes() const;
  public:
  void clear_element_num_bytes();
  ::PROTOBUF_NAMESPACE_ID::uint32 element_num_bytes() const;
  void set_element_num_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_element_num_bytes() const;
  void _internal_set_element_num_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 capacity_num_bytes = 4;
  bool has_capacity_num_bytes() const;
  private:
  bool _internal_has_capacity_num_bytes() const;
  public:
  void clear_capacity_num_bytes();
  ::PROTOBUF_NAMESPACE_ID::uint32 capacity_num_bytes() const;
  void set_capacity_num_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_capacity_num_bytes() const;
  void _internal_set_capacity_num_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mojolpm.CreateDataPipeOptions)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 element_num_bytes_;
  ::PROTOBUF_NAMESPACE_ID::uint32 capacity_num_bytes_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class DataPipeConsumerHandle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.DataPipeConsumerHandle) */ {
 public:
  inline DataPipeConsumerHandle() : DataPipeConsumerHandle(nullptr) {}
  virtual ~DataPipeConsumerHandle();

  DataPipeConsumerHandle(const DataPipeConsumerHandle& from);
  DataPipeConsumerHandle(DataPipeConsumerHandle&& from) noexcept
    : DataPipeConsumerHandle() {
    *this = ::std::move(from);
  }

  inline DataPipeConsumerHandle& operator=(const DataPipeConsumerHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPipeConsumerHandle& operator=(DataPipeConsumerHandle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataPipeConsumerHandle& default_instance();

  enum InstanceCase {
    kOld = 1,
    kNew = 2,
    INSTANCE_NOT_SET = 0,
  };

  static inline const DataPipeConsumerHandle* internal_default_instance() {
    return reinterpret_cast<const DataPipeConsumerHandle*>(
               &_DataPipeConsumerHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DataPipeConsumerHandle& a, DataPipeConsumerHandle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataPipeConsumerHandle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPipeConsumerHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataPipeConsumerHandle* New() const final {
    return CreateMaybeMessage<DataPipeConsumerHandle>(nullptr);
  }

  DataPipeConsumerHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataPipeConsumerHandle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataPipeConsumerHandle& from);
  void MergeFrom(const DataPipeConsumerHandle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPipeConsumerHandle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.DataPipeConsumerHandle";
  }
  protected:
  explicit DataPipeConsumerHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldFieldNumber = 1,
    kNewFieldNumber = 2,
  };
  // uint32 old = 1;
  bool has_old() const;
  private:
  bool _internal_has_old() const;
  public:
  void clear_old();
  ::PROTOBUF_NAMESPACE_ID::uint32 old() const;
  void set_old(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_old() const;
  void _internal_set_old(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .mojolpm.CreateDataPipeOptions new = 2;
  bool has_new_() const;
  private:
  bool _internal_has_new_() const;
  public:
  void clear_new_();
  const ::mojolpm::CreateDataPipeOptions& new_() const;
  ::mojolpm::CreateDataPipeOptions* release_new_();
  ::mojolpm::CreateDataPipeOptions* mutable_new_();
  void set_allocated_new_(::mojolpm::CreateDataPipeOptions* new_);
  private:
  const ::mojolpm::CreateDataPipeOptions& _internal_new_() const;
  ::mojolpm::CreateDataPipeOptions* _internal_mutable_new_();
  public:
  void unsafe_arena_set_allocated_new_(
      ::mojolpm::CreateDataPipeOptions* new_);
  ::mojolpm::CreateDataPipeOptions* unsafe_arena_release_new_();

  void clear_instance();
  InstanceCase instance_case() const;
  // @@protoc_insertion_point(class_scope:mojolpm.DataPipeConsumerHandle)
 private:
  class _Internal;
  void set_has_old();
  void set_has_new_();

  inline bool has_instance() const;
  inline void clear_has_instance();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InstanceUnion {
    InstanceUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint32 old_;
    ::mojolpm::CreateDataPipeOptions* new__;
  } instance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class DataPipeProducerHandle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.DataPipeProducerHandle) */ {
 public:
  inline DataPipeProducerHandle() : DataPipeProducerHandle(nullptr) {}
  virtual ~DataPipeProducerHandle();

  DataPipeProducerHandle(const DataPipeProducerHandle& from);
  DataPipeProducerHandle(DataPipeProducerHandle&& from) noexcept
    : DataPipeProducerHandle() {
    *this = ::std::move(from);
  }

  inline DataPipeProducerHandle& operator=(const DataPipeProducerHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPipeProducerHandle& operator=(DataPipeProducerHandle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataPipeProducerHandle& default_instance();

  enum InstanceCase {
    kOld = 1,
    kNew = 2,
    INSTANCE_NOT_SET = 0,
  };

  static inline const DataPipeProducerHandle* internal_default_instance() {
    return reinterpret_cast<const DataPipeProducerHandle*>(
               &_DataPipeProducerHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DataPipeProducerHandle& a, DataPipeProducerHandle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataPipeProducerHandle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPipeProducerHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataPipeProducerHandle* New() const final {
    return CreateMaybeMessage<DataPipeProducerHandle>(nullptr);
  }

  DataPipeProducerHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataPipeProducerHandle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataPipeProducerHandle& from);
  void MergeFrom(const DataPipeProducerHandle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPipeProducerHandle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.DataPipeProducerHandle";
  }
  protected:
  explicit DataPipeProducerHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldFieldNumber = 1,
    kNewFieldNumber = 2,
  };
  // uint32 old = 1;
  bool has_old() const;
  private:
  bool _internal_has_old() const;
  public:
  void clear_old();
  ::PROTOBUF_NAMESPACE_ID::uint32 old() const;
  void set_old(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_old() const;
  void _internal_set_old(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .mojolpm.CreateDataPipeOptions new = 2;
  bool has_new_() const;
  private:
  bool _internal_has_new_() const;
  public:
  void clear_new_();
  const ::mojolpm::CreateDataPipeOptions& new_() const;
  ::mojolpm::CreateDataPipeOptions* release_new_();
  ::mojolpm::CreateDataPipeOptions* mutable_new_();
  void set_allocated_new_(::mojolpm::CreateDataPipeOptions* new_);
  private:
  const ::mojolpm::CreateDataPipeOptions& _internal_new_() const;
  ::mojolpm::CreateDataPipeOptions* _internal_mutable_new_();
  public:
  void unsafe_arena_set_allocated_new_(
      ::mojolpm::CreateDataPipeOptions* new_);
  ::mojolpm::CreateDataPipeOptions* unsafe_arena_release_new_();

  void clear_instance();
  InstanceCase instance_case() const;
  // @@protoc_insertion_point(class_scope:mojolpm.DataPipeProducerHandle)
 private:
  class _Internal;
  void set_has_old();
  void set_has_new_();

  inline bool has_instance() const;
  inline void clear_has_instance();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InstanceUnion {
    InstanceUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint32 old_;
    ::mojolpm::CreateDataPipeOptions* new__;
  } instance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class DataPipeRead PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.DataPipeRead) */ {
 public:
  inline DataPipeRead() : DataPipeRead(nullptr) {}
  virtual ~DataPipeRead();

  DataPipeRead(const DataPipeRead& from);
  DataPipeRead(DataPipeRead&& from) noexcept
    : DataPipeRead() {
    *this = ::std::move(from);
  }

  inline DataPipeRead& operator=(const DataPipeRead& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPipeRead& operator=(DataPipeRead&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataPipeRead& default_instance();

  static inline const DataPipeRead* internal_default_instance() {
    return reinterpret_cast<const DataPipeRead*>(
               &_DataPipeRead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DataPipeRead& a, DataPipeRead& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataPipeRead* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPipeRead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataPipeRead* New() const final {
    return CreateMaybeMessage<DataPipeRead>(nullptr);
  }

  DataPipeRead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataPipeRead>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataPipeRead& from);
  void MergeFrom(const DataPipeRead& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPipeRead* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.DataPipeRead";
  }
  protected:
  explicit DataPipeRead(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // required .mojolpm.DataPipeConsumerHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::mojolpm::DataPipeConsumerHandle& handle() const;
  ::mojolpm::DataPipeConsumerHandle* release_handle();
  ::mojolpm::DataPipeConsumerHandle* mutable_handle();
  void set_allocated_handle(::mojolpm::DataPipeConsumerHandle* handle);
  private:
  const ::mojolpm::DataPipeConsumerHandle& _internal_handle() const;
  ::mojolpm::DataPipeConsumerHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::mojolpm::DataPipeConsumerHandle* handle);
  ::mojolpm::DataPipeConsumerHandle* unsafe_arena_release_handle();

  // required uint32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mojolpm.DataPipeRead)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mojolpm::DataPipeConsumerHandle* handle_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class DataPipeWrite PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.DataPipeWrite) */ {
 public:
  inline DataPipeWrite() : DataPipeWrite(nullptr) {}
  virtual ~DataPipeWrite();

  DataPipeWrite(const DataPipeWrite& from);
  DataPipeWrite(DataPipeWrite&& from) noexcept
    : DataPipeWrite() {
    *this = ::std::move(from);
  }

  inline DataPipeWrite& operator=(const DataPipeWrite& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPipeWrite& operator=(DataPipeWrite&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataPipeWrite& default_instance();

  static inline const DataPipeWrite* internal_default_instance() {
    return reinterpret_cast<const DataPipeWrite*>(
               &_DataPipeWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DataPipeWrite& a, DataPipeWrite& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataPipeWrite* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPipeWrite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataPipeWrite* New() const final {
    return CreateMaybeMessage<DataPipeWrite>(nullptr);
  }

  DataPipeWrite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataPipeWrite>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataPipeWrite& from);
  void MergeFrom(const DataPipeWrite& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPipeWrite* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.DataPipeWrite";
  }
  protected:
  explicit DataPipeWrite(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kHandleFieldNumber = 1,
  };
  // required bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required .mojolpm.DataPipeProducerHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::mojolpm::DataPipeProducerHandle& handle() const;
  ::mojolpm::DataPipeProducerHandle* release_handle();
  ::mojolpm::DataPipeProducerHandle* mutable_handle();
  void set_allocated_handle(::mojolpm::DataPipeProducerHandle* handle);
  private:
  const ::mojolpm::DataPipeProducerHandle& _internal_handle() const;
  ::mojolpm::DataPipeProducerHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::mojolpm::DataPipeProducerHandle* handle);
  ::mojolpm::DataPipeProducerHandle* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:mojolpm.DataPipeWrite)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::mojolpm::DataPipeProducerHandle* handle_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class DataPipeConsumerClose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.DataPipeConsumerClose) */ {
 public:
  inline DataPipeConsumerClose() : DataPipeConsumerClose(nullptr) {}
  virtual ~DataPipeConsumerClose();

  DataPipeConsumerClose(const DataPipeConsumerClose& from);
  DataPipeConsumerClose(DataPipeConsumerClose&& from) noexcept
    : DataPipeConsumerClose() {
    *this = ::std::move(from);
  }

  inline DataPipeConsumerClose& operator=(const DataPipeConsumerClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPipeConsumerClose& operator=(DataPipeConsumerClose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataPipeConsumerClose& default_instance();

  static inline const DataPipeConsumerClose* internal_default_instance() {
    return reinterpret_cast<const DataPipeConsumerClose*>(
               &_DataPipeConsumerClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataPipeConsumerClose& a, DataPipeConsumerClose& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataPipeConsumerClose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPipeConsumerClose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataPipeConsumerClose* New() const final {
    return CreateMaybeMessage<DataPipeConsumerClose>(nullptr);
  }

  DataPipeConsumerClose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataPipeConsumerClose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataPipeConsumerClose& from);
  void MergeFrom(const DataPipeConsumerClose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPipeConsumerClose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.DataPipeConsumerClose";
  }
  protected:
  explicit DataPipeConsumerClose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mojolpm.DataPipeConsumerClose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class DataPipeProducerClose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.DataPipeProducerClose) */ {
 public:
  inline DataPipeProducerClose() : DataPipeProducerClose(nullptr) {}
  virtual ~DataPipeProducerClose();

  DataPipeProducerClose(const DataPipeProducerClose& from);
  DataPipeProducerClose(DataPipeProducerClose&& from) noexcept
    : DataPipeProducerClose() {
    *this = ::std::move(from);
  }

  inline DataPipeProducerClose& operator=(const DataPipeProducerClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPipeProducerClose& operator=(DataPipeProducerClose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataPipeProducerClose& default_instance();

  static inline const DataPipeProducerClose* internal_default_instance() {
    return reinterpret_cast<const DataPipeProducerClose*>(
               &_DataPipeProducerClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DataPipeProducerClose& a, DataPipeProducerClose& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataPipeProducerClose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPipeProducerClose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataPipeProducerClose* New() const final {
    return CreateMaybeMessage<DataPipeProducerClose>(nullptr);
  }

  DataPipeProducerClose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataPipeProducerClose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataPipeProducerClose& from);
  void MergeFrom(const DataPipeProducerClose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPipeProducerClose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.DataPipeProducerClose";
  }
  protected:
  explicit DataPipeProducerClose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mojolpm.DataPipeProducerClose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class MessagePipeHandle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.MessagePipeHandle) */ {
 public:
  inline MessagePipeHandle() : MessagePipeHandle(nullptr) {}
  virtual ~MessagePipeHandle();

  MessagePipeHandle(const MessagePipeHandle& from);
  MessagePipeHandle(MessagePipeHandle&& from) noexcept
    : MessagePipeHandle() {
    *this = ::std::move(from);
  }

  inline MessagePipeHandle& operator=(const MessagePipeHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagePipeHandle& operator=(MessagePipeHandle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessagePipeHandle& default_instance();

  static inline const MessagePipeHandle* internal_default_instance() {
    return reinterpret_cast<const MessagePipeHandle*>(
               &_MessagePipeHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MessagePipeHandle& a, MessagePipeHandle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MessagePipeHandle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagePipeHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessagePipeHandle* New() const final {
    return CreateMaybeMessage<MessagePipeHandle>(nullptr);
  }

  MessagePipeHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessagePipeHandle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessagePipeHandle& from);
  void MergeFrom(const MessagePipeHandle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagePipeHandle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.MessagePipeHandle";
  }
  protected:
  explicit MessagePipeHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mojolpm.MessagePipeHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class SharedBufferHandle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.SharedBufferHandle) */ {
 public:
  inline SharedBufferHandle() : SharedBufferHandle(nullptr) {}
  virtual ~SharedBufferHandle();

  SharedBufferHandle(const SharedBufferHandle& from);
  SharedBufferHandle(SharedBufferHandle&& from) noexcept
    : SharedBufferHandle() {
    *this = ::std::move(from);
  }

  inline SharedBufferHandle& operator=(const SharedBufferHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedBufferHandle& operator=(SharedBufferHandle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SharedBufferHandle& default_instance();

  static inline const SharedBufferHandle* internal_default_instance() {
    return reinterpret_cast<const SharedBufferHandle*>(
               &_SharedBufferHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SharedBufferHandle& a, SharedBufferHandle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SharedBufferHandle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedBufferHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SharedBufferHandle* New() const final {
    return CreateMaybeMessage<SharedBufferHandle>(nullptr);
  }

  SharedBufferHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SharedBufferHandle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SharedBufferHandle& from);
  void MergeFrom(const SharedBufferHandle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SharedBufferHandle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.SharedBufferHandle";
  }
  protected:
  explicit SharedBufferHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mojolpm.SharedBufferHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// -------------------------------------------------------------------

class PlatformHandle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mojolpm.PlatformHandle) */ {
 public:
  inline PlatformHandle() : PlatformHandle(nullptr) {}
  virtual ~PlatformHandle();

  PlatformHandle(const PlatformHandle& from);
  PlatformHandle(PlatformHandle&& from) noexcept
    : PlatformHandle() {
    *this = ::std::move(from);
  }

  inline PlatformHandle& operator=(const PlatformHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlatformHandle& operator=(PlatformHandle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlatformHandle& default_instance();

  static inline const PlatformHandle* internal_default_instance() {
    return reinterpret_cast<const PlatformHandle*>(
               &_PlatformHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PlatformHandle& a, PlatformHandle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PlatformHandle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlatformHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlatformHandle* New() const final {
    return CreateMaybeMessage<PlatformHandle>(nullptr);
  }

  PlatformHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlatformHandle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlatformHandle& from);
  void MergeFrom(const PlatformHandle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlatformHandle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mojolpm.PlatformHandle";
  }
  protected:
  explicit PlatformHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto);
    return ::descriptor_table_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mojolpm.PlatformHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Handle

// -------------------------------------------------------------------

// CreateDataPipeOptions

// required uint32 flags = 2;
inline bool CreateDataPipeOptions::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateDataPipeOptions::has_flags() const {
  return _internal_has_flags();
}
inline void CreateDataPipeOptions::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDataPipeOptions::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDataPipeOptions::flags() const {
  // @@protoc_insertion_point(field_get:mojolpm.CreateDataPipeOptions.flags)
  return _internal_flags();
}
inline void CreateDataPipeOptions::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  flags_ = value;
}
inline void CreateDataPipeOptions::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:mojolpm.CreateDataPipeOptions.flags)
}

// required uint32 element_num_bytes = 3;
inline bool CreateDataPipeOptions::_internal_has_element_num_bytes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateDataPipeOptions::has_element_num_bytes() const {
  return _internal_has_element_num_bytes();
}
inline void CreateDataPipeOptions::clear_element_num_bytes() {
  element_num_bytes_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDataPipeOptions::_internal_element_num_bytes() const {
  return element_num_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDataPipeOptions::element_num_bytes() const {
  // @@protoc_insertion_point(field_get:mojolpm.CreateDataPipeOptions.element_num_bytes)
  return _internal_element_num_bytes();
}
inline void CreateDataPipeOptions::_internal_set_element_num_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  element_num_bytes_ = value;
}
inline void CreateDataPipeOptions::set_element_num_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_element_num_bytes(value);
  // @@protoc_insertion_point(field_set:mojolpm.CreateDataPipeOptions.element_num_bytes)
}

// required uint32 capacity_num_bytes = 4;
inline bool CreateDataPipeOptions::_internal_has_capacity_num_bytes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CreateDataPipeOptions::has_capacity_num_bytes() const {
  return _internal_has_capacity_num_bytes();
}
inline void CreateDataPipeOptions::clear_capacity_num_bytes() {
  capacity_num_bytes_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDataPipeOptions::_internal_capacity_num_bytes() const {
  return capacity_num_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDataPipeOptions::capacity_num_bytes() const {
  // @@protoc_insertion_point(field_get:mojolpm.CreateDataPipeOptions.capacity_num_bytes)
  return _internal_capacity_num_bytes();
}
inline void CreateDataPipeOptions::_internal_set_capacity_num_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  capacity_num_bytes_ = value;
}
inline void CreateDataPipeOptions::set_capacity_num_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_capacity_num_bytes(value);
  // @@protoc_insertion_point(field_set:mojolpm.CreateDataPipeOptions.capacity_num_bytes)
}

// -------------------------------------------------------------------

// DataPipeConsumerHandle

// uint32 old = 1;
inline bool DataPipeConsumerHandle::_internal_has_old() const {
  return instance_case() == kOld;
}
inline bool DataPipeConsumerHandle::has_old() const {
  return _internal_has_old();
}
inline void DataPipeConsumerHandle::set_has_old() {
  _oneof_case_[0] = kOld;
}
inline void DataPipeConsumerHandle::clear_old() {
  if (_internal_has_old()) {
    instance_.old_ = 0u;
    clear_has_instance();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeConsumerHandle::_internal_old() const {
  if (_internal_has_old()) {
    return instance_.old_;
  }
  return 0u;
}
inline void DataPipeConsumerHandle::_internal_set_old(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_old()) {
    clear_instance();
    set_has_old();
  }
  instance_.old_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeConsumerHandle::old() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeConsumerHandle.old)
  return _internal_old();
}
inline void DataPipeConsumerHandle::set_old(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_old(value);
  // @@protoc_insertion_point(field_set:mojolpm.DataPipeConsumerHandle.old)
}

// .mojolpm.CreateDataPipeOptions new = 2;
inline bool DataPipeConsumerHandle::_internal_has_new_() const {
  return instance_case() == kNew;
}
inline bool DataPipeConsumerHandle::has_new_() const {
  return _internal_has_new_();
}
inline void DataPipeConsumerHandle::set_has_new_() {
  _oneof_case_[0] = kNew;
}
inline void DataPipeConsumerHandle::clear_new_() {
  if (_internal_has_new_()) {
    if (GetArena() == nullptr) {
      delete instance_.new__;
    }
    clear_has_instance();
  }
}
inline ::mojolpm::CreateDataPipeOptions* DataPipeConsumerHandle::release_new_() {
  // @@protoc_insertion_point(field_release:mojolpm.DataPipeConsumerHandle.new)
  if (_internal_has_new_()) {
    clear_has_instance();
      ::mojolpm::CreateDataPipeOptions* temp = instance_.new__;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    instance_.new__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mojolpm::CreateDataPipeOptions& DataPipeConsumerHandle::_internal_new_() const {
  return _internal_has_new_()
      ? *instance_.new__
      : reinterpret_cast< ::mojolpm::CreateDataPipeOptions&>(::mojolpm::_CreateDataPipeOptions_default_instance_);
}
inline const ::mojolpm::CreateDataPipeOptions& DataPipeConsumerHandle::new_() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeConsumerHandle.new)
  return _internal_new_();
}
inline ::mojolpm::CreateDataPipeOptions* DataPipeConsumerHandle::unsafe_arena_release_new_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mojolpm.DataPipeConsumerHandle.new)
  if (_internal_has_new_()) {
    clear_has_instance();
    ::mojolpm::CreateDataPipeOptions* temp = instance_.new__;
    instance_.new__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPipeConsumerHandle::unsafe_arena_set_allocated_new_(::mojolpm::CreateDataPipeOptions* new_) {
  clear_instance();
  if (new_) {
    set_has_new_();
    instance_.new__ = new_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mojolpm.DataPipeConsumerHandle.new)
}
inline ::mojolpm::CreateDataPipeOptions* DataPipeConsumerHandle::_internal_mutable_new_() {
  if (!_internal_has_new_()) {
    clear_instance();
    set_has_new_();
    instance_.new__ = CreateMaybeMessage< ::mojolpm::CreateDataPipeOptions >(GetArena());
  }
  return instance_.new__;
}
inline ::mojolpm::CreateDataPipeOptions* DataPipeConsumerHandle::mutable_new_() {
  // @@protoc_insertion_point(field_mutable:mojolpm.DataPipeConsumerHandle.new)
  return _internal_mutable_new_();
}

inline bool DataPipeConsumerHandle::has_instance() const {
  return instance_case() != INSTANCE_NOT_SET;
}
inline void DataPipeConsumerHandle::clear_has_instance() {
  _oneof_case_[0] = INSTANCE_NOT_SET;
}
inline DataPipeConsumerHandle::InstanceCase DataPipeConsumerHandle::instance_case() const {
  return DataPipeConsumerHandle::InstanceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataPipeProducerHandle

// uint32 old = 1;
inline bool DataPipeProducerHandle::_internal_has_old() const {
  return instance_case() == kOld;
}
inline bool DataPipeProducerHandle::has_old() const {
  return _internal_has_old();
}
inline void DataPipeProducerHandle::set_has_old() {
  _oneof_case_[0] = kOld;
}
inline void DataPipeProducerHandle::clear_old() {
  if (_internal_has_old()) {
    instance_.old_ = 0u;
    clear_has_instance();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeProducerHandle::_internal_old() const {
  if (_internal_has_old()) {
    return instance_.old_;
  }
  return 0u;
}
inline void DataPipeProducerHandle::_internal_set_old(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_old()) {
    clear_instance();
    set_has_old();
  }
  instance_.old_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeProducerHandle::old() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeProducerHandle.old)
  return _internal_old();
}
inline void DataPipeProducerHandle::set_old(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_old(value);
  // @@protoc_insertion_point(field_set:mojolpm.DataPipeProducerHandle.old)
}

// .mojolpm.CreateDataPipeOptions new = 2;
inline bool DataPipeProducerHandle::_internal_has_new_() const {
  return instance_case() == kNew;
}
inline bool DataPipeProducerHandle::has_new_() const {
  return _internal_has_new_();
}
inline void DataPipeProducerHandle::set_has_new_() {
  _oneof_case_[0] = kNew;
}
inline void DataPipeProducerHandle::clear_new_() {
  if (_internal_has_new_()) {
    if (GetArena() == nullptr) {
      delete instance_.new__;
    }
    clear_has_instance();
  }
}
inline ::mojolpm::CreateDataPipeOptions* DataPipeProducerHandle::release_new_() {
  // @@protoc_insertion_point(field_release:mojolpm.DataPipeProducerHandle.new)
  if (_internal_has_new_()) {
    clear_has_instance();
      ::mojolpm::CreateDataPipeOptions* temp = instance_.new__;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    instance_.new__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mojolpm::CreateDataPipeOptions& DataPipeProducerHandle::_internal_new_() const {
  return _internal_has_new_()
      ? *instance_.new__
      : reinterpret_cast< ::mojolpm::CreateDataPipeOptions&>(::mojolpm::_CreateDataPipeOptions_default_instance_);
}
inline const ::mojolpm::CreateDataPipeOptions& DataPipeProducerHandle::new_() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeProducerHandle.new)
  return _internal_new_();
}
inline ::mojolpm::CreateDataPipeOptions* DataPipeProducerHandle::unsafe_arena_release_new_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mojolpm.DataPipeProducerHandle.new)
  if (_internal_has_new_()) {
    clear_has_instance();
    ::mojolpm::CreateDataPipeOptions* temp = instance_.new__;
    instance_.new__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPipeProducerHandle::unsafe_arena_set_allocated_new_(::mojolpm::CreateDataPipeOptions* new_) {
  clear_instance();
  if (new_) {
    set_has_new_();
    instance_.new__ = new_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mojolpm.DataPipeProducerHandle.new)
}
inline ::mojolpm::CreateDataPipeOptions* DataPipeProducerHandle::_internal_mutable_new_() {
  if (!_internal_has_new_()) {
    clear_instance();
    set_has_new_();
    instance_.new__ = CreateMaybeMessage< ::mojolpm::CreateDataPipeOptions >(GetArena());
  }
  return instance_.new__;
}
inline ::mojolpm::CreateDataPipeOptions* DataPipeProducerHandle::mutable_new_() {
  // @@protoc_insertion_point(field_mutable:mojolpm.DataPipeProducerHandle.new)
  return _internal_mutable_new_();
}

inline bool DataPipeProducerHandle::has_instance() const {
  return instance_case() != INSTANCE_NOT_SET;
}
inline void DataPipeProducerHandle::clear_has_instance() {
  _oneof_case_[0] = INSTANCE_NOT_SET;
}
inline DataPipeProducerHandle::InstanceCase DataPipeProducerHandle::instance_case() const {
  return DataPipeProducerHandle::InstanceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataPipeRead

// required .mojolpm.DataPipeConsumerHandle handle = 1;
inline bool DataPipeRead::_internal_has_handle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || handle_ != nullptr);
  return value;
}
inline bool DataPipeRead::has_handle() const {
  return _internal_has_handle();
}
inline void DataPipeRead::clear_handle() {
  if (handle_ != nullptr) handle_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mojolpm::DataPipeConsumerHandle& DataPipeRead::_internal_handle() const {
  const ::mojolpm::DataPipeConsumerHandle* p = handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::mojolpm::DataPipeConsumerHandle&>(
      ::mojolpm::_DataPipeConsumerHandle_default_instance_);
}
inline const ::mojolpm::DataPipeConsumerHandle& DataPipeRead::handle() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeRead.handle)
  return _internal_handle();
}
inline void DataPipeRead::unsafe_arena_set_allocated_handle(
    ::mojolpm::DataPipeConsumerHandle* handle) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  handle_ = handle;
  if (handle) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mojolpm.DataPipeRead.handle)
}
inline ::mojolpm::DataPipeConsumerHandle* DataPipeRead::release_handle() {
  _has_bits_[0] &= ~0x00000001u;
  ::mojolpm::DataPipeConsumerHandle* temp = handle_;
  handle_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mojolpm::DataPipeConsumerHandle* DataPipeRead::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:mojolpm.DataPipeRead.handle)
  _has_bits_[0] &= ~0x00000001u;
  ::mojolpm::DataPipeConsumerHandle* temp = handle_;
  handle_ = nullptr;
  return temp;
}
inline ::mojolpm::DataPipeConsumerHandle* DataPipeRead::_internal_mutable_handle() {
  _has_bits_[0] |= 0x00000001u;
  if (handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::mojolpm::DataPipeConsumerHandle>(GetArena());
    handle_ = p;
  }
  return handle_;
}
inline ::mojolpm::DataPipeConsumerHandle* DataPipeRead::mutable_handle() {
  // @@protoc_insertion_point(field_mutable:mojolpm.DataPipeRead.handle)
  return _internal_mutable_handle();
}
inline void DataPipeRead::set_allocated_handle(::mojolpm::DataPipeConsumerHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete handle_;
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(handle);
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:mojolpm.DataPipeRead.handle)
}

// required uint32 size = 2;
inline bool DataPipeRead::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataPipeRead::has_size() const {
  return _internal_has_size();
}
inline void DataPipeRead::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeRead::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeRead::size() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeRead.size)
  return _internal_size();
}
inline void DataPipeRead::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
}
inline void DataPipeRead::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:mojolpm.DataPipeRead.size)
}

// -------------------------------------------------------------------

// DataPipeWrite

// required .mojolpm.DataPipeProducerHandle handle = 1;
inline bool DataPipeWrite::_internal_has_handle() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || handle_ != nullptr);
  return value;
}
inline bool DataPipeWrite::has_handle() const {
  return _internal_has_handle();
}
inline void DataPipeWrite::clear_handle() {
  if (handle_ != nullptr) handle_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mojolpm::DataPipeProducerHandle& DataPipeWrite::_internal_handle() const {
  const ::mojolpm::DataPipeProducerHandle* p = handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::mojolpm::DataPipeProducerHandle&>(
      ::mojolpm::_DataPipeProducerHandle_default_instance_);
}
inline const ::mojolpm::DataPipeProducerHandle& DataPipeWrite::handle() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeWrite.handle)
  return _internal_handle();
}
inline void DataPipeWrite::unsafe_arena_set_allocated_handle(
    ::mojolpm::DataPipeProducerHandle* handle) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  handle_ = handle;
  if (handle) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mojolpm.DataPipeWrite.handle)
}
inline ::mojolpm::DataPipeProducerHandle* DataPipeWrite::release_handle() {
  _has_bits_[0] &= ~0x00000002u;
  ::mojolpm::DataPipeProducerHandle* temp = handle_;
  handle_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mojolpm::DataPipeProducerHandle* DataPipeWrite::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:mojolpm.DataPipeWrite.handle)
  _has_bits_[0] &= ~0x00000002u;
  ::mojolpm::DataPipeProducerHandle* temp = handle_;
  handle_ = nullptr;
  return temp;
}
inline ::mojolpm::DataPipeProducerHandle* DataPipeWrite::_internal_mutable_handle() {
  _has_bits_[0] |= 0x00000002u;
  if (handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::mojolpm::DataPipeProducerHandle>(GetArena());
    handle_ = p;
  }
  return handle_;
}
inline ::mojolpm::DataPipeProducerHandle* DataPipeWrite::mutable_handle() {
  // @@protoc_insertion_point(field_mutable:mojolpm.DataPipeWrite.handle)
  return _internal_mutable_handle();
}
inline void DataPipeWrite::set_allocated_handle(::mojolpm::DataPipeProducerHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete handle_;
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(handle);
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:mojolpm.DataPipeWrite.handle)
}

// required bytes data = 2;
inline bool DataPipeWrite::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataPipeWrite::has_data() const {
  return _internal_has_data();
}
inline void DataPipeWrite::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataPipeWrite::data() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeWrite.data)
  return _internal_data();
}
inline void DataPipeWrite::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:mojolpm.DataPipeWrite.data)
}
inline std::string* DataPipeWrite::mutable_data() {
  // @@protoc_insertion_point(field_mutable:mojolpm.DataPipeWrite.data)
  return _internal_mutable_data();
}
inline const std::string& DataPipeWrite::_internal_data() const {
  return data_.Get();
}
inline void DataPipeWrite::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataPipeWrite::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mojolpm.DataPipeWrite.data)
}
inline void DataPipeWrite::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mojolpm.DataPipeWrite.data)
}
inline void DataPipeWrite::set_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mojolpm.DataPipeWrite.data)
}
inline std::string* DataPipeWrite::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataPipeWrite::release_data() {
  // @@protoc_insertion_point(field_release:mojolpm.DataPipeWrite.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataPipeWrite::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mojolpm.DataPipeWrite.data)
}

// -------------------------------------------------------------------

// DataPipeConsumerClose

// required uint32 id = 1;
inline bool DataPipeConsumerClose::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataPipeConsumerClose::has_id() const {
  return _internal_has_id();
}
inline void DataPipeConsumerClose::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeConsumerClose::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeConsumerClose::id() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeConsumerClose.id)
  return _internal_id();
}
inline void DataPipeConsumerClose::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void DataPipeConsumerClose::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mojolpm.DataPipeConsumerClose.id)
}

// -------------------------------------------------------------------

// DataPipeProducerClose

// required uint32 id = 1;
inline bool DataPipeProducerClose::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataPipeProducerClose::has_id() const {
  return _internal_has_id();
}
inline void DataPipeProducerClose::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeProducerClose::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPipeProducerClose::id() const {
  // @@protoc_insertion_point(field_get:mojolpm.DataPipeProducerClose.id)
  return _internal_id();
}
inline void DataPipeProducerClose::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void DataPipeProducerClose::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mojolpm.DataPipeProducerClose.id)
}

// -------------------------------------------------------------------

// MessagePipeHandle

// -------------------------------------------------------------------

// SharedBufferHandle

// -------------------------------------------------------------------

// PlatformHandle

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mojolpm

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mojo_2fpublic_2ftools_2ffuzzers_2fmojolpm_2eproto
