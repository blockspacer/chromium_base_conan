// mojo/public/tools/fuzzers/fuzz.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif


#include "mojo/public/tools/fuzzers/fuzz.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"


#ifndef MOJO_PUBLIC_TOOLS_FUZZERS_FUZZ_MOJOM_JUMBO_H_
#define MOJO_PUBLIC_TOOLS_FUZZERS_FUZZ_MOJOM_JUMBO_H_
#endif


namespace fuzz {
namespace mojom {


void FuzzDummyInterfaceInterceptorForTesting::Ping() {
  GetForwardingInterface()->Ping();
}
FuzzDummyInterfaceAsyncWaiter::FuzzDummyInterfaceAsyncWaiter(
    FuzzDummyInterface* proxy) : proxy_(proxy) {}

FuzzDummyInterfaceAsyncWaiter::~FuzzDummyInterfaceAsyncWaiter() = default;




void FuzzInterfaceInterceptorForTesting::FuzzBasic() {
  GetForwardingInterface()->FuzzBasic();
}
void FuzzInterfaceInterceptorForTesting::FuzzBasicResp(FuzzBasicRespCallback callback) {
  GetForwardingInterface()->FuzzBasicResp(std::move(callback));
}
void FuzzInterfaceInterceptorForTesting::FuzzBasicSyncResp(FuzzBasicSyncRespCallback callback) {
  GetForwardingInterface()->FuzzBasicSyncResp(std::move(callback));
}
void FuzzInterfaceInterceptorForTesting::FuzzArgs(FuzzStructPtr a, FuzzStructPtr b) {
  GetForwardingInterface()->FuzzArgs(std::move(a), std::move(b));
}
void FuzzInterfaceInterceptorForTesting::FuzzArgsResp(FuzzStructPtr a, FuzzStructPtr b, FuzzArgsRespCallback callback) {
  GetForwardingInterface()->FuzzArgsResp(std::move(a), std::move(b), std::move(callback));
}
void FuzzInterfaceInterceptorForTesting::FuzzArgsSyncResp(FuzzStructPtr a, FuzzStructPtr b, FuzzArgsSyncRespCallback callback) {
  GetForwardingInterface()->FuzzArgsSyncResp(std::move(a), std::move(b), std::move(callback));
}
void FuzzInterfaceInterceptorForTesting::FuzzAssociated(::mojo::PendingAssociatedReceiver<FuzzDummyInterface> receiver) {
  GetForwardingInterface()->FuzzAssociated(std::move(receiver));
}
FuzzInterfaceAsyncWaiter::FuzzInterfaceAsyncWaiter(
    FuzzInterface* proxy) : proxy_(proxy) {}

FuzzInterfaceAsyncWaiter::~FuzzInterfaceAsyncWaiter() = default;

void FuzzInterfaceAsyncWaiter::FuzzBasicResp(
    ) {
  base::RunLoop loop;
  proxy_->FuzzBasicResp(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void FuzzInterfaceAsyncWaiter::FuzzBasicSyncResp(
    ) {
  base::RunLoop loop;
  proxy_->FuzzBasicSyncResp(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void FuzzInterfaceAsyncWaiter::FuzzArgsResp(
    FuzzStructPtr a, FuzzStructPtr b) {
  base::RunLoop loop;
  proxy_->FuzzArgsResp(std::move(a),std::move(b),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void FuzzInterfaceAsyncWaiter::FuzzArgsSyncResp(
    FuzzStructPtr a, FuzzStructPtr b) {
  base::RunLoop loop;
  proxy_->FuzzArgsSyncResp(std::move(a),std::move(b),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}





}  // namespace mojom
}  // namespace fuzz

#if defined(__clang__)
#pragma clang diagnostic pop
#endif