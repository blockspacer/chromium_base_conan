// mojo/public/interfaces/bindings/tests/validation_test_interfaces.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'mojo/public/interfaces/bindings/tests/validation_test_interfaces.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('mojo.test');


  var EnumA = {};
  EnumA.ENUM_A_0 = 0;
  EnumA.ENUM_A_1 = 1;
  EnumA.MIN_VALUE = 0;
  EnumA.MAX_VALUE = 1;

  EnumA.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  EnumA.toKnownEnumValue = function(value) {
    return value;
  };

  EnumA.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var EnumB = {};
  EnumB.ENUM_B_0 = 0;
  EnumB.ENUM_B_1 = 1;
  EnumB.ENUM_B_2 = 2;
  EnumB.MIN_VALUE = 0;
  EnumB.MAX_VALUE = 2;

  EnumB.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  EnumB.toKnownEnumValue = function(value) {
    return value;
  };

  EnumB.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var EmptyEnum = {};

  EmptyEnum.isKnownEnumValue = function(value) {
    return false;
  };

  EmptyEnum.toKnownEnumValue = function(value) {
    return value;
  };

  EmptyEnum.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ExtensibleEmptyEnum = {};

  ExtensibleEmptyEnum.isKnownEnumValue = function(value) {
    return false;
  };

  ExtensibleEmptyEnum.toKnownEnumValue = function(value) {
    return value;
  };

  ExtensibleEmptyEnum.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var BasicEnum = {};
  BasicEnum.A = 0;
  BasicEnum.B = 1;
  BasicEnum.C = 0;
  BasicEnum.D = -3;
  BasicEnum.E = 10;
  BasicEnum.MIN_VALUE = -3;
  BasicEnum.MAX_VALUE = 10;

  BasicEnum.isKnownEnumValue = function(value) {
    switch (value) {
    case -3:
    case 0:
    case 1:
    case 10:
      return true;
    }
    return false;
  };

  BasicEnum.toKnownEnumValue = function(value) {
    return value;
  };

  BasicEnum.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function StructA(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StructA.prototype.initDefaults_ = function() {
    this.i = 0;
  };
  StructA.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StructA.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  StructA.encodedSize = codec.kStructHeaderSize + 8;

  StructA.decode = function(decoder) {
    var packed;
    var val = new StructA();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.i =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  StructA.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StructA.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.i);
  };
  function StructB(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StructB.prototype.initDefaults_ = function() {
    this.structA = null;
  };
  StructB.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StructB.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StructB.structA
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StructA, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  StructB.encodedSize = codec.kStructHeaderSize + 8;

  StructB.decode = function(decoder) {
    var packed;
    var val = new StructB();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.structA =
        decoder.decodeStructPointer(StructA);
    return val;
  };

  StructB.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StructB.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StructA, val.structA);
  };
  function StructC(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StructC.prototype.initDefaults_ = function() {
    this.data = null;
  };
  StructC.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StructC.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StructC.data
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  StructC.encodedSize = codec.kStructHeaderSize + 8;

  StructC.decode = function(decoder) {
    var packed;
    var val = new StructC();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data =
        decoder.decodeArrayPointer(codec.Uint8);
    return val;
  };

  StructC.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StructC.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.Uint8, val.data);
  };
  function StructD(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StructD.prototype.initDefaults_ = function() {
    this.messagePipes = null;
  };
  StructD.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StructD.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StructD.messagePipes
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 4, codec.Handle, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  StructD.encodedSize = codec.kStructHeaderSize + 8;

  StructD.decode = function(decoder) {
    var packed;
    var val = new StructD();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.messagePipes =
        decoder.decodeArrayPointer(codec.Handle);
    return val;
  };

  StructD.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StructD.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.Handle, val.messagePipes);
  };
  function StructE(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StructE.prototype.initDefaults_ = function() {
    this.structD = null;
    this.dataPipeConsumer = null;
  };
  StructE.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StructE.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StructE.structD
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StructD, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StructE.dataPipeConsumer
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  StructE.encodedSize = codec.kStructHeaderSize + 16;

  StructE.decode = function(decoder) {
    var packed;
    var val = new StructE();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.structD =
        decoder.decodeStructPointer(StructD);
    val.dataPipeConsumer =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  StructE.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StructE.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StructD, val.structD);
    encoder.encodeStruct(codec.Handle, val.dataPipeConsumer);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function StructF(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StructF.prototype.initDefaults_ = function() {
    this.fixedSizeArray = null;
  };
  StructF.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StructF.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StructF.fixedSizeArray
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 1, codec.Uint8, false, [3], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  StructF.encodedSize = codec.kStructHeaderSize + 8;

  StructF.decode = function(decoder) {
    var packed;
    var val = new StructF();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.fixedSizeArray =
        decoder.decodeArrayPointer(codec.Uint8);
    return val;
  };

  StructF.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StructF.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.Uint8, val.fixedSizeArray);
  };
  function StructG(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StructG.prototype.initDefaults_ = function() {
    this.i = 0;
    this.b = false;
    this.structA = null;
    this.str = null;
  };
  StructG.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StructG.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16},
      {version: 1, numBytes: 24},
      {version: 3, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    // version check StructG.structA
    if (!messageValidator.isFieldInStructVersion(offset, 1))
      return validator.validationError.NONE;
    // validate StructG.structA
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, StructA, true);
    if (err !== validator.validationError.NONE)
        return err;



    // version check StructG.str
    if (!messageValidator.isFieldInStructVersion(offset, 3))
      return validator.validationError.NONE;
    // validate StructG.str
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, true)
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  StructG.encodedSize = codec.kStructHeaderSize + 24;

  StructG.decode = function(decoder) {
    var packed;
    var val = new StructG();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.i =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.b = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    if (version >= 1) {
      val.structA =
          decoder.decodeStructPointer(StructA);
    } else {
      val.structA = null;
    }
    if (version >= 3) {
      val.str =
          decoder.decodeStruct(codec.NullableString);
    } else {
      val.str = null;
    }
    return val;
  };

  StructG.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StructG.encodedSize);
    encoder.writeUint32(3);
    encoder.encodeStruct(codec.Int32, val.i);
    packed = 0;
    packed |= (val.b & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(StructA, val.structA);
    encoder.encodeStruct(codec.NullableString, val.str);
  };
  function BasicStruct(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  BasicStruct.prototype.initDefaults_ = function() {
    this.a = 0;
  };
  BasicStruct.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  BasicStruct.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  BasicStruct.encodedSize = codec.kStructHeaderSize + 8;

  BasicStruct.decode = function(decoder) {
    var packed;
    var val = new BasicStruct();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  BasicStruct.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(BasicStruct.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.a);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function StructWithEnum(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  StructWithEnum.EnumWithin = {};
  StructWithEnum.EnumWithin.A = 0;
  StructWithEnum.EnumWithin.B = 1;
  StructWithEnum.EnumWithin.C = 2;
  StructWithEnum.EnumWithin.D = 3;
  StructWithEnum.EnumWithin.MIN_VALUE = 0;
  StructWithEnum.EnumWithin.MAX_VALUE = 3;

  StructWithEnum.EnumWithin.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  StructWithEnum.EnumWithin.toKnownEnumValue = function(value) {
    return value;
  };

  StructWithEnum.EnumWithin.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  StructWithEnum.prototype.initDefaults_ = function() {
  };
  StructWithEnum.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StructWithEnum.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  StructWithEnum.encodedSize = codec.kStructHeaderSize + 0;

  StructWithEnum.decode = function(decoder) {
    var packed;
    var val = new StructWithEnum();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  StructWithEnum.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StructWithEnum.encodedSize);
    encoder.writeUint32(0);
  };
  function Recursive(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Recursive.prototype.initDefaults_ = function() {
    this.recursive = null;
  };
  Recursive.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Recursive.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Recursive.recursive
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, Recursive, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Recursive.encodedSize = codec.kStructHeaderSize + 8;

  Recursive.decode = function(decoder) {
    var packed;
    var val = new Recursive();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.recursive =
        decoder.decodeStructPointer(Recursive);
    return val;
  };

  Recursive.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Recursive.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(Recursive, val.recursive);
  };
  function BoundsCheckTestInterface_Method0_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  BoundsCheckTestInterface_Method0_Params.prototype.initDefaults_ = function() {
    this.param0 = 0;
  };
  BoundsCheckTestInterface_Method0_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  BoundsCheckTestInterface_Method0_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  BoundsCheckTestInterface_Method0_Params.encodedSize = codec.kStructHeaderSize + 8;

  BoundsCheckTestInterface_Method0_Params.decode = function(decoder) {
    var packed;
    var val = new BoundsCheckTestInterface_Method0_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  BoundsCheckTestInterface_Method0_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(BoundsCheckTestInterface_Method0_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint8, val.param0);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function BoundsCheckTestInterface_Method0_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  BoundsCheckTestInterface_Method0_ResponseParams.prototype.initDefaults_ = function() {
    this.param0 = 0;
  };
  BoundsCheckTestInterface_Method0_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  BoundsCheckTestInterface_Method0_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  BoundsCheckTestInterface_Method0_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  BoundsCheckTestInterface_Method0_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new BoundsCheckTestInterface_Method0_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  BoundsCheckTestInterface_Method0_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(BoundsCheckTestInterface_Method0_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint8, val.param0);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function BoundsCheckTestInterface_Method1_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  BoundsCheckTestInterface_Method1_Params.prototype.initDefaults_ = function() {
    this.param0 = 0;
  };
  BoundsCheckTestInterface_Method1_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  BoundsCheckTestInterface_Method1_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  BoundsCheckTestInterface_Method1_Params.encodedSize = codec.kStructHeaderSize + 8;

  BoundsCheckTestInterface_Method1_Params.decode = function(decoder) {
    var packed;
    var val = new BoundsCheckTestInterface_Method1_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  BoundsCheckTestInterface_Method1_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(BoundsCheckTestInterface_Method1_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint8, val.param0);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ConformanceTestInterface_Method0_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method0_Params.prototype.initDefaults_ = function() {
    this.param0 = 0;
  };
  ConformanceTestInterface_Method0_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method0_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method0_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method0_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method0_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ConformanceTestInterface_Method0_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method0_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.param0);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ConformanceTestInterface_Method1_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method1_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method1_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method1_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method1_Params.param0
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StructA, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method1_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method1_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method1_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStructPointer(StructA);
    return val;
  };

  ConformanceTestInterface_Method1_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method1_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StructA, val.param0);
  };
  function ConformanceTestInterface_Method2_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method2_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
    this.param1 = null;
  };
  ConformanceTestInterface_Method2_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method2_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method2_Params.param0
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StructB, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method2_Params.param1
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, StructA, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method2_Params.encodedSize = codec.kStructHeaderSize + 16;

  ConformanceTestInterface_Method2_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method2_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStructPointer(StructB);
    val.param1 =
        decoder.decodeStructPointer(StructA);
    return val;
  };

  ConformanceTestInterface_Method2_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method2_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StructB, val.param0);
    encoder.encodeStructPointer(StructA, val.param1);
  };
  function ConformanceTestInterface_Method3_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method3_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method3_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method3_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method3_Params.param0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 1, codec.PackedBool, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method3_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method3_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method3_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeArrayPointer(codec.PackedBool);
    return val;
  };

  ConformanceTestInterface_Method3_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method3_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.PackedBool, val.param0);
  };
  function ConformanceTestInterface_Method4_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method4_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
    this.param1 = null;
  };
  ConformanceTestInterface_Method4_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method4_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method4_Params.param0
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StructC, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method4_Params.param1
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method4_Params.encodedSize = codec.kStructHeaderSize + 16;

  ConformanceTestInterface_Method4_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method4_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStructPointer(StructC);
    val.param1 =
        decoder.decodeArrayPointer(codec.Uint8);
    return val;
  };

  ConformanceTestInterface_Method4_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method4_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StructC, val.param0);
    encoder.encodeArrayPointer(codec.Uint8, val.param1);
  };
  function ConformanceTestInterface_Method5_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method5_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
    this.param1 = null;
  };
  ConformanceTestInterface_Method5_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method5_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method5_Params.param0
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StructE, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method5_Params.param1
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method5_Params.encodedSize = codec.kStructHeaderSize + 16;

  ConformanceTestInterface_Method5_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method5_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStructPointer(StructE);
    val.param1 =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ConformanceTestInterface_Method5_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method5_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StructE, val.param0);
    encoder.encodeStruct(codec.Handle, val.param1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ConformanceTestInterface_Method6_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method6_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method6_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method6_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method6_Params.param0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.ArrayOf(codec.Uint8), false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method6_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method6_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method6_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeArrayPointer(new codec.ArrayOf(codec.Uint8));
    return val;
  };

  ConformanceTestInterface_Method6_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method6_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.ArrayOf(codec.Uint8), val.param0);
  };
  function ConformanceTestInterface_Method7_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method7_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
    this.param1 = null;
  };
  ConformanceTestInterface_Method7_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method7_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method7_Params.param0
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StructF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method7_Params.param1
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.NullableArrayOf(codec.Uint8, 3), false, [2, 3], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method7_Params.encodedSize = codec.kStructHeaderSize + 16;

  ConformanceTestInterface_Method7_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method7_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStructPointer(StructF);
    val.param1 =
        decoder.decodeArrayPointer(new codec.NullableArrayOf(codec.Uint8, 3));
    return val;
  };

  ConformanceTestInterface_Method7_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method7_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StructF, val.param0);
    encoder.encodeArrayPointer(new codec.NullableArrayOf(codec.Uint8, 3), val.param1);
  };
  function ConformanceTestInterface_Method8_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method8_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method8_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method8_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method8_Params.param0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.NullableArrayOf(codec.String), false, [0, 0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method8_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method8_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method8_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeArrayPointer(new codec.NullableArrayOf(codec.String));
    return val;
  };

  ConformanceTestInterface_Method8_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method8_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.NullableArrayOf(codec.String), val.param0);
  };
  function ConformanceTestInterface_Method9_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method9_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method9_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method9_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method9_Params.param0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.ArrayOf(codec.NullableHandle), true, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method9_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method9_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method9_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeArrayPointer(new codec.ArrayOf(codec.NullableHandle));
    return val;
  };

  ConformanceTestInterface_Method9_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method9_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.ArrayOf(codec.NullableHandle), val.param0);
  };
  function ConformanceTestInterface_Method10_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method10_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method10_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method10_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method10_Params.param0
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, codec.String, codec.Uint8, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method10_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method10_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method10_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeMapPointer(codec.String, codec.Uint8);
    return val;
  };

  ConformanceTestInterface_Method10_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method10_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeMapPointer(codec.String, codec.Uint8, val.param0);
  };
  function ConformanceTestInterface_Method11_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method11_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method11_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method11_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method11_Params.param0
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StructG, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method11_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method11_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method11_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStructPointer(StructG);
    return val;
  };

  ConformanceTestInterface_Method11_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method11_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StructG, val.param0);
  };
  function ConformanceTestInterface_Method12_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method12_Params.prototype.initDefaults_ = function() {
    this.param0 = 0;
  };
  ConformanceTestInterface_Method12_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method12_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method12_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method12_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method12_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ConformanceTestInterface_Method12_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method12_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.param0);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ConformanceTestInterface_Method12_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method12_ResponseParams.prototype.initDefaults_ = function() {
    this.param0 = 0;
  };
  ConformanceTestInterface_Method12_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method12_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method12_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method12_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method12_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ConformanceTestInterface_Method12_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method12_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.param0);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ConformanceTestInterface_Method13_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method13_Params.prototype.initDefaults_ = function() {
    this.param0 = new InterfaceAPtr();
    this.param1 = 0;
    this.param2 = new InterfaceAPtr();
  };
  ConformanceTestInterface_Method13_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method13_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method13_Params.param0
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, true);
    if (err !== validator.validationError.NONE)
        return err;



    // validate ConformanceTestInterface_Method13_Params.param2
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 12, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method13_Params.encodedSize = codec.kStructHeaderSize + 24;

  ConformanceTestInterface_Method13_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method13_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(new codec.NullableInterface(InterfaceAPtr));
    val.param1 =
        decoder.decodeStruct(codec.Uint32);
    val.param2 =
        decoder.decodeStruct(new codec.NullableInterface(InterfaceAPtr));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ConformanceTestInterface_Method13_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method13_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.NullableInterface(InterfaceAPtr), val.param0);
    encoder.encodeStruct(codec.Uint32, val.param1);
    encoder.encodeStruct(new codec.NullableInterface(InterfaceAPtr), val.param2);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ConformanceTestInterface_Method14_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method14_Params.prototype.initDefaults_ = function() {
    this.param0 = 0;
    this.param1 = 0;
  };
  ConformanceTestInterface_Method14_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method14_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method14_Params.param0
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, EnumA);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method14_Params.param1
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, EnumB);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method14_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method14_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method14_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(new codec.Enum(EnumA));
    val.param1 =
        decoder.decodeStruct(new codec.Enum(EnumB));
    return val;
  };

  ConformanceTestInterface_Method14_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method14_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.param0);
    encoder.encodeStruct(codec.Int32, val.param1);
  };
  function ConformanceTestInterface_Method15_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method15_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
    this.param1 = null;
  };
  ConformanceTestInterface_Method15_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method15_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method15_Params.param0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 4, new codec.Enum(EnumA), true, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method15_Params.param1
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 4, new codec.Enum(EnumB), true, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method15_Params.encodedSize = codec.kStructHeaderSize + 16;

  ConformanceTestInterface_Method15_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method15_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeArrayPointer(new codec.Enum(EnumA));
    val.param1 =
        decoder.decodeArrayPointer(new codec.Enum(EnumB));
    return val;
  };

  ConformanceTestInterface_Method15_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method15_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.Enum(EnumA), val.param0);
    encoder.encodeArrayPointer(new codec.Enum(EnumB), val.param1);
  };
  function ConformanceTestInterface_Method16_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method16_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method16_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method16_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method16_Params.param0
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, true, new codec.Enum(EnumA), new codec.Enum(EnumA), false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method16_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method16_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method16_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeMapPointer(new codec.Enum(EnumA), new codec.Enum(EnumA));
    return val;
  };

  ConformanceTestInterface_Method16_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method16_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeMapPointer(new codec.Enum(EnumA), new codec.Enum(EnumA), val.param0);
  };
  function ConformanceTestInterface_Method17_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method17_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method17_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method17_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method17_Params.param0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.Interface(InterfaceAPtr), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method17_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method17_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method17_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeArrayPointer(new codec.Interface(InterfaceAPtr));
    return val;
  };

  ConformanceTestInterface_Method17_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method17_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.Interface(InterfaceAPtr), val.param0);
  };
  function ConformanceTestInterface_Method18_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method18_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method18_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method18_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method18_Params.param0
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, UnionA, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method18_Params.encodedSize = codec.kStructHeaderSize + 16;

  ConformanceTestInterface_Method18_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method18_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(UnionA);
    return val;
  };

  ConformanceTestInterface_Method18_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method18_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(UnionA, val.param0);
  };
  function ConformanceTestInterface_Method19_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method19_Params.prototype.initDefaults_ = function() {
    this.recursive = null;
  };
  ConformanceTestInterface_Method19_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method19_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method19_Params.recursive
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, Recursive, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method19_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method19_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method19_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.recursive =
        decoder.decodeStructPointer(Recursive);
    return val;
  };

  ConformanceTestInterface_Method19_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method19_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(Recursive, val.recursive);
  };
  function ConformanceTestInterface_Method20_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method20_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  ConformanceTestInterface_Method20_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method20_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method20_Params.param0
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, new codec.PointerTo(StructB), codec.Uint8, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method20_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method20_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method20_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeMapPointer(new codec.PointerTo(StructB), codec.Uint8);
    return val;
  };

  ConformanceTestInterface_Method20_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method20_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeMapPointer(new codec.PointerTo(StructB), codec.Uint8, val.param0);
  };
  function ConformanceTestInterface_Method21_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method21_Params.prototype.initDefaults_ = function() {
    this.param0 = 0;
  };
  ConformanceTestInterface_Method21_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method21_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method21_Params.param0
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, ExtensibleEmptyEnum);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method21_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method21_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method21_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(new codec.Enum(ExtensibleEmptyEnum));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ConformanceTestInterface_Method21_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method21_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.param0);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ConformanceTestInterface_Method22_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ConformanceTestInterface_Method22_Params.prototype.initDefaults_ = function() {
    this.param0 = 0;
  };
  ConformanceTestInterface_Method22_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ConformanceTestInterface_Method22_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ConformanceTestInterface_Method22_Params.param0
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, EmptyEnum);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ConformanceTestInterface_Method22_Params.encodedSize = codec.kStructHeaderSize + 8;

  ConformanceTestInterface_Method22_Params.decode = function(decoder) {
    var packed;
    var val = new ConformanceTestInterface_Method22_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStruct(new codec.Enum(EmptyEnum));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ConformanceTestInterface_Method22_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ConformanceTestInterface_Method22_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.param0);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function IntegrationTestInterface_Method0_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IntegrationTestInterface_Method0_Params.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  IntegrationTestInterface_Method0_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IntegrationTestInterface_Method0_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IntegrationTestInterface_Method0_Params.param0
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, BasicStruct, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IntegrationTestInterface_Method0_Params.encodedSize = codec.kStructHeaderSize + 8;

  IntegrationTestInterface_Method0_Params.decode = function(decoder) {
    var packed;
    var val = new IntegrationTestInterface_Method0_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeStructPointer(BasicStruct);
    return val;
  };

  IntegrationTestInterface_Method0_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IntegrationTestInterface_Method0_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(BasicStruct, val.param0);
  };
  function IntegrationTestInterface_Method0_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IntegrationTestInterface_Method0_ResponseParams.prototype.initDefaults_ = function() {
    this.param0 = null;
  };
  IntegrationTestInterface_Method0_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IntegrationTestInterface_Method0_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IntegrationTestInterface_Method0_ResponseParams.param0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IntegrationTestInterface_Method0_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  IntegrationTestInterface_Method0_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new IntegrationTestInterface_Method0_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.param0 =
        decoder.decodeArrayPointer(codec.Uint8);
    return val;
  };

  IntegrationTestInterface_Method0_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IntegrationTestInterface_Method0_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.Uint8, val.param0);
  };

  function UnionA(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  UnionA.Tags = {
    structA: 0,
    b: 1,
  };

  UnionA.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  UnionA.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "structA",
        "b",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a UnionA member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(UnionA.prototype, "structA", {
    get: function() {
      if (this.$tag != UnionA.Tags.structA) {
        throw new ReferenceError(
            "UnionA.structA is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = UnionA.Tags.structA;
      this.$data = value;
    }
  });
  Object.defineProperty(UnionA.prototype, "b", {
    get: function() {
      if (this.$tag != UnionA.Tags.b) {
        throw new ReferenceError(
            "UnionA.b is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = UnionA.Tags.b;
      this.$data = value;
    }
  });


    UnionA.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case UnionA.Tags.structA:
          encoder.encodeStructPointer(StructA, val.structA);
          break;
        case UnionA.Tags.b:
          encoder.writeUint8(val.b ? 1 : 0);
          break;
      }
      encoder.align();
    };


    UnionA.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new UnionA();
      var tag = decoder.readUint32();
      switch (tag) {
        case UnionA.Tags.structA:
          result.structA = decoder.decodeStructPointer(StructA);
          break;
        case UnionA.Tags.b:
          result.b = decoder.readUint8() ? true : false;
          break;
      }
      decoder.align();

      return result;
    };


    UnionA.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case UnionA.Tags.structA:
          

    // validate UnionA.structA
    err = messageValidator.validateStructPointer(data_offset, StructA, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case UnionA.Tags.b:
          

          break;
      }

      return validator.validationError.NONE;
    };

  UnionA.encodedSize = 16;

  function InterfaceAPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(InterfaceA,
                                                   handleOrPtrInfo);
  }

  function InterfaceAAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        InterfaceA, associatedInterfacePtrInfo);
  }

  InterfaceAAssociatedPtr.prototype =
      Object.create(InterfaceAPtr.prototype);
  InterfaceAAssociatedPtr.prototype.constructor =
      InterfaceAAssociatedPtr;

  function InterfaceAProxy(receiver) {
    this.receiver_ = receiver;
  }

  function InterfaceAStub(delegate) {
    this.delegate_ = delegate;
  }

  InterfaceAStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  InterfaceAStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateInterfaceARequest(messageValidator) {
    return validator.validationError.NONE;
  }

  function validateInterfaceAResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var InterfaceA = {
    name: 'mojo.test.InterfaceA',
    kVersion: 0,
    ptrClass: InterfaceAPtr,
    proxyClass: InterfaceAProxy,
    stubClass: InterfaceAStub,
    validateRequest: validateInterfaceARequest,
    validateResponse: null,
  };
  InterfaceAStub.prototype.validator = validateInterfaceARequest;
  InterfaceAProxy.prototype.validator = null;
  var kBoundsCheckTestInterface_Method0_Name = 0;
  var kBoundsCheckTestInterface_Method1_Name = 1;

  function BoundsCheckTestInterfacePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(BoundsCheckTestInterface,
                                                   handleOrPtrInfo);
  }

  function BoundsCheckTestInterfaceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        BoundsCheckTestInterface, associatedInterfacePtrInfo);
  }

  BoundsCheckTestInterfaceAssociatedPtr.prototype =
      Object.create(BoundsCheckTestInterfacePtr.prototype);
  BoundsCheckTestInterfaceAssociatedPtr.prototype.constructor =
      BoundsCheckTestInterfaceAssociatedPtr;

  function BoundsCheckTestInterfaceProxy(receiver) {
    this.receiver_ = receiver;
  }
  BoundsCheckTestInterfacePtr.prototype.method0 = function() {
    return BoundsCheckTestInterfaceProxy.prototype.method0
        .apply(this.ptr.getProxy(), arguments);
  };

  BoundsCheckTestInterfaceProxy.prototype.method0 = function(param0) {
    var params_ = new BoundsCheckTestInterface_Method0_Params();
    params_.param0 = param0;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kBoundsCheckTestInterface_Method0_Name,
          codec.align(BoundsCheckTestInterface_Method0_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(BoundsCheckTestInterface_Method0_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(BoundsCheckTestInterface_Method0_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  BoundsCheckTestInterfacePtr.prototype.method1 = function() {
    return BoundsCheckTestInterfaceProxy.prototype.method1
        .apply(this.ptr.getProxy(), arguments);
  };

  BoundsCheckTestInterfaceProxy.prototype.method1 = function(param0) {
    var params_ = new BoundsCheckTestInterface_Method1_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kBoundsCheckTestInterface_Method1_Name,
        codec.align(BoundsCheckTestInterface_Method1_Params.encodedSize));
    builder.encodeStruct(BoundsCheckTestInterface_Method1_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function BoundsCheckTestInterfaceStub(delegate) {
    this.delegate_ = delegate;
  }
  BoundsCheckTestInterfaceStub.prototype.method0 = function(param0) {
    return this.delegate_ && this.delegate_.method0 && this.delegate_.method0(param0);
  }
  BoundsCheckTestInterfaceStub.prototype.method1 = function(param0) {
    return this.delegate_ && this.delegate_.method1 && this.delegate_.method1(param0);
  }

  BoundsCheckTestInterfaceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kBoundsCheckTestInterface_Method1_Name:
      var params = reader.decodeStruct(BoundsCheckTestInterface_Method1_Params);
      this.method1(params.param0);
      return true;
    default:
      return false;
    }
  };

  BoundsCheckTestInterfaceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kBoundsCheckTestInterface_Method0_Name:
      var params = reader.decodeStruct(BoundsCheckTestInterface_Method0_Params);
      this.method0(params.param0).then(function(response) {
        var responseParams =
            new BoundsCheckTestInterface_Method0_ResponseParams();
        responseParams.param0 = response.param0;
        var builder = new codec.MessageV1Builder(
            kBoundsCheckTestInterface_Method0_Name,
            codec.align(BoundsCheckTestInterface_Method0_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(BoundsCheckTestInterface_Method0_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateBoundsCheckTestInterfaceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kBoundsCheckTestInterface_Method0_Name:
        if (message.expectsResponse())
          paramsClass = BoundsCheckTestInterface_Method0_Params;
      break;
      case kBoundsCheckTestInterface_Method1_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = BoundsCheckTestInterface_Method1_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateBoundsCheckTestInterfaceResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kBoundsCheckTestInterface_Method0_Name:
        if (message.isResponse())
          paramsClass = BoundsCheckTestInterface_Method0_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var BoundsCheckTestInterface = {
    name: 'mojo.test.BoundsCheckTestInterface',
    kVersion: 0,
    ptrClass: BoundsCheckTestInterfacePtr,
    proxyClass: BoundsCheckTestInterfaceProxy,
    stubClass: BoundsCheckTestInterfaceStub,
    validateRequest: validateBoundsCheckTestInterfaceRequest,
    validateResponse: validateBoundsCheckTestInterfaceResponse,
  };
  BoundsCheckTestInterfaceStub.prototype.validator = validateBoundsCheckTestInterfaceRequest;
  BoundsCheckTestInterfaceProxy.prototype.validator = validateBoundsCheckTestInterfaceResponse;
  var kConformanceTestInterface_Method0_Name = 0;
  var kConformanceTestInterface_Method1_Name = 1;
  var kConformanceTestInterface_Method2_Name = 2;
  var kConformanceTestInterface_Method3_Name = 3;
  var kConformanceTestInterface_Method4_Name = 4;
  var kConformanceTestInterface_Method5_Name = 5;
  var kConformanceTestInterface_Method6_Name = 6;
  var kConformanceTestInterface_Method7_Name = 7;
  var kConformanceTestInterface_Method8_Name = 8;
  var kConformanceTestInterface_Method9_Name = 9;
  var kConformanceTestInterface_Method10_Name = 10;
  var kConformanceTestInterface_Method11_Name = 11;
  var kConformanceTestInterface_Method12_Name = 12;
  var kConformanceTestInterface_Method13_Name = 13;
  var kConformanceTestInterface_Method14_Name = 14;
  var kConformanceTestInterface_Method15_Name = 15;
  var kConformanceTestInterface_Method16_Name = 16;
  var kConformanceTestInterface_Method17_Name = 17;
  var kConformanceTestInterface_Method18_Name = 18;
  var kConformanceTestInterface_Method19_Name = 19;
  var kConformanceTestInterface_Method20_Name = 20;
  var kConformanceTestInterface_Method21_Name = 21;
  var kConformanceTestInterface_Method22_Name = 22;

  function ConformanceTestInterfacePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(ConformanceTestInterface,
                                                   handleOrPtrInfo);
  }

  function ConformanceTestInterfaceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        ConformanceTestInterface, associatedInterfacePtrInfo);
  }

  ConformanceTestInterfaceAssociatedPtr.prototype =
      Object.create(ConformanceTestInterfacePtr.prototype);
  ConformanceTestInterfaceAssociatedPtr.prototype.constructor =
      ConformanceTestInterfaceAssociatedPtr;

  function ConformanceTestInterfaceProxy(receiver) {
    this.receiver_ = receiver;
  }
  ConformanceTestInterfacePtr.prototype.method0 = function() {
    return ConformanceTestInterfaceProxy.prototype.method0
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method0 = function(param0) {
    var params_ = new ConformanceTestInterface_Method0_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method0_Name,
        codec.align(ConformanceTestInterface_Method0_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method0_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method1 = function() {
    return ConformanceTestInterfaceProxy.prototype.method1
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method1 = function(param0) {
    var params_ = new ConformanceTestInterface_Method1_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method1_Name,
        codec.align(ConformanceTestInterface_Method1_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method1_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method2 = function() {
    return ConformanceTestInterfaceProxy.prototype.method2
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method2 = function(param0, param1) {
    var params_ = new ConformanceTestInterface_Method2_Params();
    params_.param0 = param0;
    params_.param1 = param1;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method2_Name,
        codec.align(ConformanceTestInterface_Method2_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method2_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method3 = function() {
    return ConformanceTestInterfaceProxy.prototype.method3
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method3 = function(param0) {
    var params_ = new ConformanceTestInterface_Method3_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method3_Name,
        codec.align(ConformanceTestInterface_Method3_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method3_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method4 = function() {
    return ConformanceTestInterfaceProxy.prototype.method4
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method4 = function(param0, param1) {
    var params_ = new ConformanceTestInterface_Method4_Params();
    params_.param0 = param0;
    params_.param1 = param1;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method4_Name,
        codec.align(ConformanceTestInterface_Method4_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method4_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method5 = function() {
    return ConformanceTestInterfaceProxy.prototype.method5
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method5 = function(param0, param1) {
    var params_ = new ConformanceTestInterface_Method5_Params();
    params_.param0 = param0;
    params_.param1 = param1;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method5_Name,
        codec.align(ConformanceTestInterface_Method5_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method5_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method6 = function() {
    return ConformanceTestInterfaceProxy.prototype.method6
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method6 = function(param0) {
    var params_ = new ConformanceTestInterface_Method6_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method6_Name,
        codec.align(ConformanceTestInterface_Method6_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method6_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method7 = function() {
    return ConformanceTestInterfaceProxy.prototype.method7
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method7 = function(param0, param1) {
    var params_ = new ConformanceTestInterface_Method7_Params();
    params_.param0 = param0;
    params_.param1 = param1;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method7_Name,
        codec.align(ConformanceTestInterface_Method7_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method7_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method8 = function() {
    return ConformanceTestInterfaceProxy.prototype.method8
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method8 = function(param0) {
    var params_ = new ConformanceTestInterface_Method8_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method8_Name,
        codec.align(ConformanceTestInterface_Method8_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method8_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method9 = function() {
    return ConformanceTestInterfaceProxy.prototype.method9
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method9 = function(param0) {
    var params_ = new ConformanceTestInterface_Method9_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method9_Name,
        codec.align(ConformanceTestInterface_Method9_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method9_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method10 = function() {
    return ConformanceTestInterfaceProxy.prototype.method10
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method10 = function(param0) {
    var params_ = new ConformanceTestInterface_Method10_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method10_Name,
        codec.align(ConformanceTestInterface_Method10_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method10_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method11 = function() {
    return ConformanceTestInterfaceProxy.prototype.method11
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method11 = function(param0) {
    var params_ = new ConformanceTestInterface_Method11_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method11_Name,
        codec.align(ConformanceTestInterface_Method11_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method11_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method12 = function() {
    return ConformanceTestInterfaceProxy.prototype.method12
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method12 = function(param0) {
    var params_ = new ConformanceTestInterface_Method12_Params();
    params_.param0 = param0;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kConformanceTestInterface_Method12_Name,
          codec.align(ConformanceTestInterface_Method12_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(ConformanceTestInterface_Method12_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(ConformanceTestInterface_Method12_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  ConformanceTestInterfacePtr.prototype.method13 = function() {
    return ConformanceTestInterfaceProxy.prototype.method13
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method13 = function(param0, param1, param2) {
    var params_ = new ConformanceTestInterface_Method13_Params();
    params_.param0 = param0;
    params_.param1 = param1;
    params_.param2 = param2;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method13_Name,
        codec.align(ConformanceTestInterface_Method13_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method13_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method14 = function() {
    return ConformanceTestInterfaceProxy.prototype.method14
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method14 = function(param0, param1) {
    var params_ = new ConformanceTestInterface_Method14_Params();
    params_.param0 = param0;
    params_.param1 = param1;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method14_Name,
        codec.align(ConformanceTestInterface_Method14_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method14_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method15 = function() {
    return ConformanceTestInterfaceProxy.prototype.method15
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method15 = function(param0, param1) {
    var params_ = new ConformanceTestInterface_Method15_Params();
    params_.param0 = param0;
    params_.param1 = param1;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method15_Name,
        codec.align(ConformanceTestInterface_Method15_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method15_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method16 = function() {
    return ConformanceTestInterfaceProxy.prototype.method16
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method16 = function(param0) {
    var params_ = new ConformanceTestInterface_Method16_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method16_Name,
        codec.align(ConformanceTestInterface_Method16_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method16_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method17 = function() {
    return ConformanceTestInterfaceProxy.prototype.method17
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method17 = function(param0) {
    var params_ = new ConformanceTestInterface_Method17_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method17_Name,
        codec.align(ConformanceTestInterface_Method17_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method17_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method18 = function() {
    return ConformanceTestInterfaceProxy.prototype.method18
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method18 = function(param0) {
    var params_ = new ConformanceTestInterface_Method18_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method18_Name,
        codec.align(ConformanceTestInterface_Method18_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method18_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method19 = function() {
    return ConformanceTestInterfaceProxy.prototype.method19
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method19 = function(recursive) {
    var params_ = new ConformanceTestInterface_Method19_Params();
    params_.recursive = recursive;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method19_Name,
        codec.align(ConformanceTestInterface_Method19_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method19_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method20 = function() {
    return ConformanceTestInterfaceProxy.prototype.method20
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method20 = function(param0) {
    var params_ = new ConformanceTestInterface_Method20_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method20_Name,
        codec.align(ConformanceTestInterface_Method20_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method20_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method21 = function() {
    return ConformanceTestInterfaceProxy.prototype.method21
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method21 = function(param0) {
    var params_ = new ConformanceTestInterface_Method21_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method21_Name,
        codec.align(ConformanceTestInterface_Method21_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method21_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ConformanceTestInterfacePtr.prototype.method22 = function() {
    return ConformanceTestInterfaceProxy.prototype.method22
        .apply(this.ptr.getProxy(), arguments);
  };

  ConformanceTestInterfaceProxy.prototype.method22 = function(param0) {
    var params_ = new ConformanceTestInterface_Method22_Params();
    params_.param0 = param0;
    var builder = new codec.MessageV0Builder(
        kConformanceTestInterface_Method22_Name,
        codec.align(ConformanceTestInterface_Method22_Params.encodedSize));
    builder.encodeStruct(ConformanceTestInterface_Method22_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function ConformanceTestInterfaceStub(delegate) {
    this.delegate_ = delegate;
  }
  ConformanceTestInterfaceStub.prototype.method0 = function(param0) {
    return this.delegate_ && this.delegate_.method0 && this.delegate_.method0(param0);
  }
  ConformanceTestInterfaceStub.prototype.method1 = function(param0) {
    return this.delegate_ && this.delegate_.method1 && this.delegate_.method1(param0);
  }
  ConformanceTestInterfaceStub.prototype.method2 = function(param0, param1) {
    return this.delegate_ && this.delegate_.method2 && this.delegate_.method2(param0, param1);
  }
  ConformanceTestInterfaceStub.prototype.method3 = function(param0) {
    return this.delegate_ && this.delegate_.method3 && this.delegate_.method3(param0);
  }
  ConformanceTestInterfaceStub.prototype.method4 = function(param0, param1) {
    return this.delegate_ && this.delegate_.method4 && this.delegate_.method4(param0, param1);
  }
  ConformanceTestInterfaceStub.prototype.method5 = function(param0, param1) {
    return this.delegate_ && this.delegate_.method5 && this.delegate_.method5(param0, param1);
  }
  ConformanceTestInterfaceStub.prototype.method6 = function(param0) {
    return this.delegate_ && this.delegate_.method6 && this.delegate_.method6(param0);
  }
  ConformanceTestInterfaceStub.prototype.method7 = function(param0, param1) {
    return this.delegate_ && this.delegate_.method7 && this.delegate_.method7(param0, param1);
  }
  ConformanceTestInterfaceStub.prototype.method8 = function(param0) {
    return this.delegate_ && this.delegate_.method8 && this.delegate_.method8(param0);
  }
  ConformanceTestInterfaceStub.prototype.method9 = function(param0) {
    return this.delegate_ && this.delegate_.method9 && this.delegate_.method9(param0);
  }
  ConformanceTestInterfaceStub.prototype.method10 = function(param0) {
    return this.delegate_ && this.delegate_.method10 && this.delegate_.method10(param0);
  }
  ConformanceTestInterfaceStub.prototype.method11 = function(param0) {
    return this.delegate_ && this.delegate_.method11 && this.delegate_.method11(param0);
  }
  ConformanceTestInterfaceStub.prototype.method12 = function(param0) {
    return this.delegate_ && this.delegate_.method12 && this.delegate_.method12(param0);
  }
  ConformanceTestInterfaceStub.prototype.method13 = function(param0, param1, param2) {
    return this.delegate_ && this.delegate_.method13 && this.delegate_.method13(param0, param1, param2);
  }
  ConformanceTestInterfaceStub.prototype.method14 = function(param0, param1) {
    return this.delegate_ && this.delegate_.method14 && this.delegate_.method14(param0, param1);
  }
  ConformanceTestInterfaceStub.prototype.method15 = function(param0, param1) {
    return this.delegate_ && this.delegate_.method15 && this.delegate_.method15(param0, param1);
  }
  ConformanceTestInterfaceStub.prototype.method16 = function(param0) {
    return this.delegate_ && this.delegate_.method16 && this.delegate_.method16(param0);
  }
  ConformanceTestInterfaceStub.prototype.method17 = function(param0) {
    return this.delegate_ && this.delegate_.method17 && this.delegate_.method17(param0);
  }
  ConformanceTestInterfaceStub.prototype.method18 = function(param0) {
    return this.delegate_ && this.delegate_.method18 && this.delegate_.method18(param0);
  }
  ConformanceTestInterfaceStub.prototype.method19 = function(recursive) {
    return this.delegate_ && this.delegate_.method19 && this.delegate_.method19(recursive);
  }
  ConformanceTestInterfaceStub.prototype.method20 = function(param0) {
    return this.delegate_ && this.delegate_.method20 && this.delegate_.method20(param0);
  }
  ConformanceTestInterfaceStub.prototype.method21 = function(param0) {
    return this.delegate_ && this.delegate_.method21 && this.delegate_.method21(param0);
  }
  ConformanceTestInterfaceStub.prototype.method22 = function(param0) {
    return this.delegate_ && this.delegate_.method22 && this.delegate_.method22(param0);
  }

  ConformanceTestInterfaceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kConformanceTestInterface_Method0_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method0_Params);
      this.method0(params.param0);
      return true;
    case kConformanceTestInterface_Method1_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method1_Params);
      this.method1(params.param0);
      return true;
    case kConformanceTestInterface_Method2_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method2_Params);
      this.method2(params.param0, params.param1);
      return true;
    case kConformanceTestInterface_Method3_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method3_Params);
      this.method3(params.param0);
      return true;
    case kConformanceTestInterface_Method4_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method4_Params);
      this.method4(params.param0, params.param1);
      return true;
    case kConformanceTestInterface_Method5_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method5_Params);
      this.method5(params.param0, params.param1);
      return true;
    case kConformanceTestInterface_Method6_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method6_Params);
      this.method6(params.param0);
      return true;
    case kConformanceTestInterface_Method7_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method7_Params);
      this.method7(params.param0, params.param1);
      return true;
    case kConformanceTestInterface_Method8_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method8_Params);
      this.method8(params.param0);
      return true;
    case kConformanceTestInterface_Method9_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method9_Params);
      this.method9(params.param0);
      return true;
    case kConformanceTestInterface_Method10_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method10_Params);
      this.method10(params.param0);
      return true;
    case kConformanceTestInterface_Method11_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method11_Params);
      this.method11(params.param0);
      return true;
    case kConformanceTestInterface_Method13_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method13_Params);
      this.method13(params.param0, params.param1, params.param2);
      return true;
    case kConformanceTestInterface_Method14_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method14_Params);
      this.method14(params.param0, params.param1);
      return true;
    case kConformanceTestInterface_Method15_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method15_Params);
      this.method15(params.param0, params.param1);
      return true;
    case kConformanceTestInterface_Method16_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method16_Params);
      this.method16(params.param0);
      return true;
    case kConformanceTestInterface_Method17_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method17_Params);
      this.method17(params.param0);
      return true;
    case kConformanceTestInterface_Method18_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method18_Params);
      this.method18(params.param0);
      return true;
    case kConformanceTestInterface_Method19_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method19_Params);
      this.method19(params.recursive);
      return true;
    case kConformanceTestInterface_Method20_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method20_Params);
      this.method20(params.param0);
      return true;
    case kConformanceTestInterface_Method21_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method21_Params);
      this.method21(params.param0);
      return true;
    case kConformanceTestInterface_Method22_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method22_Params);
      this.method22(params.param0);
      return true;
    default:
      return false;
    }
  };

  ConformanceTestInterfaceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kConformanceTestInterface_Method12_Name:
      var params = reader.decodeStruct(ConformanceTestInterface_Method12_Params);
      this.method12(params.param0).then(function(response) {
        var responseParams =
            new ConformanceTestInterface_Method12_ResponseParams();
        responseParams.param0 = response.param0;
        var builder = new codec.MessageV1Builder(
            kConformanceTestInterface_Method12_Name,
            codec.align(ConformanceTestInterface_Method12_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(ConformanceTestInterface_Method12_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateConformanceTestInterfaceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kConformanceTestInterface_Method0_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method0_Params;
      break;
      case kConformanceTestInterface_Method1_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method1_Params;
      break;
      case kConformanceTestInterface_Method2_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method2_Params;
      break;
      case kConformanceTestInterface_Method3_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method3_Params;
      break;
      case kConformanceTestInterface_Method4_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method4_Params;
      break;
      case kConformanceTestInterface_Method5_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method5_Params;
      break;
      case kConformanceTestInterface_Method6_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method6_Params;
      break;
      case kConformanceTestInterface_Method7_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method7_Params;
      break;
      case kConformanceTestInterface_Method8_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method8_Params;
      break;
      case kConformanceTestInterface_Method9_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method9_Params;
      break;
      case kConformanceTestInterface_Method10_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method10_Params;
      break;
      case kConformanceTestInterface_Method11_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method11_Params;
      break;
      case kConformanceTestInterface_Method12_Name:
        if (message.expectsResponse())
          paramsClass = ConformanceTestInterface_Method12_Params;
      break;
      case kConformanceTestInterface_Method13_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method13_Params;
      break;
      case kConformanceTestInterface_Method14_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method14_Params;
      break;
      case kConformanceTestInterface_Method15_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method15_Params;
      break;
      case kConformanceTestInterface_Method16_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method16_Params;
      break;
      case kConformanceTestInterface_Method17_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method17_Params;
      break;
      case kConformanceTestInterface_Method18_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method18_Params;
      break;
      case kConformanceTestInterface_Method19_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method19_Params;
      break;
      case kConformanceTestInterface_Method20_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method20_Params;
      break;
      case kConformanceTestInterface_Method21_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method21_Params;
      break;
      case kConformanceTestInterface_Method22_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ConformanceTestInterface_Method22_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateConformanceTestInterfaceResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kConformanceTestInterface_Method12_Name:
        if (message.isResponse())
          paramsClass = ConformanceTestInterface_Method12_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var ConformanceTestInterface = {
    name: 'mojo.test.ConformanceTestInterface',
    kVersion: 0,
    ptrClass: ConformanceTestInterfacePtr,
    proxyClass: ConformanceTestInterfaceProxy,
    stubClass: ConformanceTestInterfaceStub,
    validateRequest: validateConformanceTestInterfaceRequest,
    validateResponse: validateConformanceTestInterfaceResponse,
  };
  ConformanceTestInterfaceStub.prototype.validator = validateConformanceTestInterfaceRequest;
  ConformanceTestInterfaceProxy.prototype.validator = validateConformanceTestInterfaceResponse;
  var kIntegrationTestInterface_Method0_Name = 0;

  function IntegrationTestInterfacePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(IntegrationTestInterface,
                                                   handleOrPtrInfo);
  }

  function IntegrationTestInterfaceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        IntegrationTestInterface, associatedInterfacePtrInfo);
  }

  IntegrationTestInterfaceAssociatedPtr.prototype =
      Object.create(IntegrationTestInterfacePtr.prototype);
  IntegrationTestInterfaceAssociatedPtr.prototype.constructor =
      IntegrationTestInterfaceAssociatedPtr;

  function IntegrationTestInterfaceProxy(receiver) {
    this.receiver_ = receiver;
  }
  IntegrationTestInterfacePtr.prototype.method0 = function() {
    return IntegrationTestInterfaceProxy.prototype.method0
        .apply(this.ptr.getProxy(), arguments);
  };

  IntegrationTestInterfaceProxy.prototype.method0 = function(param0) {
    var params_ = new IntegrationTestInterface_Method0_Params();
    params_.param0 = param0;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kIntegrationTestInterface_Method0_Name,
          codec.align(IntegrationTestInterface_Method0_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(IntegrationTestInterface_Method0_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(IntegrationTestInterface_Method0_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function IntegrationTestInterfaceStub(delegate) {
    this.delegate_ = delegate;
  }
  IntegrationTestInterfaceStub.prototype.method0 = function(param0) {
    return this.delegate_ && this.delegate_.method0 && this.delegate_.method0(param0);
  }

  IntegrationTestInterfaceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  IntegrationTestInterfaceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kIntegrationTestInterface_Method0_Name:
      var params = reader.decodeStruct(IntegrationTestInterface_Method0_Params);
      this.method0(params.param0).then(function(response) {
        var responseParams =
            new IntegrationTestInterface_Method0_ResponseParams();
        responseParams.param0 = response.param0;
        var builder = new codec.MessageV1Builder(
            kIntegrationTestInterface_Method0_Name,
            codec.align(IntegrationTestInterface_Method0_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(IntegrationTestInterface_Method0_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateIntegrationTestInterfaceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kIntegrationTestInterface_Method0_Name:
        if (message.expectsResponse())
          paramsClass = IntegrationTestInterface_Method0_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateIntegrationTestInterfaceResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kIntegrationTestInterface_Method0_Name:
        if (message.isResponse())
          paramsClass = IntegrationTestInterface_Method0_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var IntegrationTestInterface = {
    name: 'mojo.test.IntegrationTestInterface',
    kVersion: 0,
    ptrClass: IntegrationTestInterfacePtr,
    proxyClass: IntegrationTestInterfaceProxy,
    stubClass: IntegrationTestInterfaceStub,
    validateRequest: validateIntegrationTestInterfaceRequest,
    validateResponse: validateIntegrationTestInterfaceResponse,
  };
  IntegrationTestInterfaceStub.prototype.validator = validateIntegrationTestInterfaceRequest;
  IntegrationTestInterfaceProxy.prototype.validator = validateIntegrationTestInterfaceResponse;
  exports.EnumA = EnumA;
  exports.EnumB = EnumB;
  exports.EmptyEnum = EmptyEnum;
  exports.ExtensibleEmptyEnum = ExtensibleEmptyEnum;
  exports.BasicEnum = BasicEnum;
  exports.StructA = StructA;
  exports.StructB = StructB;
  exports.StructC = StructC;
  exports.StructD = StructD;
  exports.StructE = StructE;
  exports.StructF = StructF;
  exports.StructG = StructG;
  exports.BasicStruct = BasicStruct;
  exports.StructWithEnum = StructWithEnum;
  exports.Recursive = Recursive;
  exports.UnionA = UnionA;
  exports.InterfaceA = InterfaceA;
  exports.InterfaceAPtr = InterfaceAPtr;
  exports.InterfaceAAssociatedPtr = InterfaceAAssociatedPtr;
  exports.BoundsCheckTestInterface = BoundsCheckTestInterface;
  exports.BoundsCheckTestInterfacePtr = BoundsCheckTestInterfacePtr;
  exports.BoundsCheckTestInterfaceAssociatedPtr = BoundsCheckTestInterfaceAssociatedPtr;
  exports.ConformanceTestInterface = ConformanceTestInterface;
  exports.ConformanceTestInterfacePtr = ConformanceTestInterfacePtr;
  exports.ConformanceTestInterfaceAssociatedPtr = ConformanceTestInterfaceAssociatedPtr;
  exports.IntegrationTestInterface = IntegrationTestInterface;
  exports.IntegrationTestInterfacePtr = IntegrationTestInterfacePtr;
  exports.IntegrationTestInterfaceAssociatedPtr = IntegrationTestInterfaceAssociatedPtr;
})();