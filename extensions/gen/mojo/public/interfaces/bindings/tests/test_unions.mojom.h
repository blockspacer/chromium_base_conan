// mojo/public/interfaces/bindings/tests/test_unions.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
#include "mojo/public/interfaces/bindings/tests/test_unions.mojom-shared.h"
#include "mojo/public/interfaces/bindings/tests/test_unions.mojom-forward.h"
#include "mojo/public/interfaces/bindings/tests/sample_import.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"



#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif


namespace mojo {
namespace test {

class SmallCacheProxy;

template <typename ImplRefTraits>
class SmallCacheStub;

class SmallCacheRequestValidator;
class SmallCacheResponseValidator;


// @generated_from: mojo.test.SmallCache
class  SmallCache
    : public SmallCacheInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = SmallCacheInterfaceBase;
  using Proxy_ = SmallCacheProxy;

  template <typename ImplRefTraits>
  using Stub_ = SmallCacheStub<ImplRefTraits>;

  using RequestValidator_ = SmallCacheRequestValidator;
  using ResponseValidator_ = SmallCacheResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSetIntValueMinVersion = 0,
    kGetIntValueMinVersion = 0,
  };
  virtual ~SmallCache() {}

  
// @generated_from: mojo.test.SmallCache.SetIntValue
  virtual void SetIntValue(int64_t int_value) = 0;


  using GetIntValueCallback = base::OnceCallback<void(int64_t)>;
  
// @generated_from: mojo.test.SmallCache.GetIntValue
  virtual void GetIntValue(GetIntValueCallback callback) = 0;
};

class UnionInterfaceProxy;

template <typename ImplRefTraits>
class UnionInterfaceStub;

class UnionInterfaceRequestValidator;
class UnionInterfaceResponseValidator;


// @generated_from: mojo.test.UnionInterface
class  UnionInterface
    : public UnionInterfaceInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = UnionInterfaceInterfaceBase;
  using Proxy_ = UnionInterfaceProxy;

  template <typename ImplRefTraits>
  using Stub_ = UnionInterfaceStub<ImplRefTraits>;

  using RequestValidator_ = UnionInterfaceRequestValidator;
  using ResponseValidator_ = UnionInterfaceResponseValidator;
  enum MethodMinVersions : uint32_t {
    kEchoMinVersion = 0,
  };
  virtual ~UnionInterface() {}


  using EchoCallback = base::OnceCallback<void(PodUnionPtr)>;
  
// @generated_from: mojo.test.UnionInterface.Echo
  virtual void Echo(PodUnionPtr in_val, EchoCallback callback) = 0;
};



// @generated_from: mojo.test.SmallCache
class  SmallCacheProxy
    : public SmallCache {
 public:
  using InterfaceType = SmallCache;

  explicit SmallCacheProxy(mojo::MessageReceiverWithResponder* receiver);
  
// @generated_from: mojo.test.SmallCache.SetIntValue
  void SetIntValue(int64_t int_value) final;
  
// @generated_from: mojo.test.SmallCache.GetIntValue
  void GetIntValue(GetIntValueCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



// @generated_from: mojo.test.UnionInterface
class  UnionInterfaceProxy
    : public UnionInterface {
 public:
  using InterfaceType = UnionInterface;

  explicit UnionInterfaceProxy(mojo::MessageReceiverWithResponder* receiver);
  
// @generated_from: mojo.test.UnionInterface.Echo
  void Echo(PodUnionPtr in_val, EchoCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  SmallCacheStubDispatch {
 public:
  static bool Accept(SmallCache* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SmallCache* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SmallCache>>
class SmallCacheStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SmallCacheStub() {}
  ~SmallCacheStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SmallCacheStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SmallCacheStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  UnionInterfaceStubDispatch {
 public:
  static bool Accept(UnionInterface* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      UnionInterface* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<UnionInterface>>
class UnionInterfaceStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  UnionInterfaceStub() {}
  ~UnionInterfaceStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return UnionInterfaceStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return UnionInterfaceStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  SmallCacheRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  UnionInterfaceRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  SmallCacheResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  UnionInterfaceResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};






// @generated_from: mojo.test.DummyStruct
class  DummyStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DummyStruct, T>::value>;
  using DataView = DummyStructDataView;
  using Data_ = internal::DummyStruct_Data;

  template <typename... Args>
  static DummyStructPtr New(Args&&... args) {
    return DummyStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DummyStructPtr From(const U& u) {
    return mojo::TypeConverter<DummyStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DummyStruct>::Convert(*this);
  }


  DummyStruct();

  explicit DummyStruct(
      int8_t f_int8);

  ~DummyStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DummyStructPtr>
  DummyStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DummyStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DummyStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DummyStruct_UnserializedMessageContext<
            UserType, DummyStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DummyStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DummyStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DummyStruct_UnserializedMessageContext<
            UserType, DummyStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DummyStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.DummyStruct.f_int8
  int8_t f_int8;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}










// @generated_from: mojo.test.PodUnion
class  PodUnion {
 public:
  using DataView = PodUnionDataView;
  using Data_ = internal::PodUnion_Data;
  using Tag = Data_::PodUnion_Tag;

  static PodUnionPtr New() {
    return PodUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_int8|.
  static PodUnionPtr
  NewFInt8(
      int8_t f_int8) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int8(std::move(f_int8));
    return result;
  }
  // Construct an instance holding |f_int8_other|.
  static PodUnionPtr
  NewFInt8Other(
      int8_t f_int8_other) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int8_other(std::move(f_int8_other));
    return result;
  }
  // Construct an instance holding |f_uint8|.
  static PodUnionPtr
  NewFUint8(
      uint8_t f_uint8) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_uint8(std::move(f_uint8));
    return result;
  }
  // Construct an instance holding |f_int16|.
  static PodUnionPtr
  NewFInt16(
      int16_t f_int16) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int16(std::move(f_int16));
    return result;
  }
  // Construct an instance holding |f_uint16|.
  static PodUnionPtr
  NewFUint16(
      uint16_t f_uint16) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_uint16(std::move(f_uint16));
    return result;
  }
  // Construct an instance holding |f_int32|.
  static PodUnionPtr
  NewFInt32(
      int32_t f_int32) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int32(std::move(f_int32));
    return result;
  }
  // Construct an instance holding |f_uint32|.
  static PodUnionPtr
  NewFUint32(
      uint32_t f_uint32) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_uint32(std::move(f_uint32));
    return result;
  }
  // Construct an instance holding |f_int64|.
  static PodUnionPtr
  NewFInt64(
      int64_t f_int64) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int64(std::move(f_int64));
    return result;
  }
  // Construct an instance holding |f_uint64|.
  static PodUnionPtr
  NewFUint64(
      uint64_t f_uint64) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_uint64(std::move(f_uint64));
    return result;
  }
  // Construct an instance holding |f_float|.
  static PodUnionPtr
  NewFFloat(
      float f_float) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_float(std::move(f_float));
    return result;
  }
  // Construct an instance holding |f_double|.
  static PodUnionPtr
  NewFDouble(
      double f_double) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_double(std::move(f_double));
    return result;
  }
  // Construct an instance holding |f_bool|.
  static PodUnionPtr
  NewFBool(
      bool f_bool) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_bool(std::move(f_bool));
    return result;
  }
  // Construct an instance holding |f_enum|.
  static PodUnionPtr
  NewFEnum(
      AnEnum f_enum) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_enum(std::move(f_enum));
    return result;
  }
  // Construct an instance holding |f_extensible_enum|.
  static PodUnionPtr
  NewFExtensibleEnum(
      AnExtensibleEnum f_extensible_enum) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_extensible_enum(std::move(f_extensible_enum));
    return result;
  }

  template <typename U>
  static PodUnionPtr From(const U& u) {
    return mojo::TypeConverter<PodUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PodUnion>::Convert(*this);
  }

  PodUnion();
  ~PodUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = PodUnionPtr>
  PodUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, PodUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, PodUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.PodUnion.f_int8
  bool is_f_int8() const { return tag_ == Tag::F_INT8; }

  
// @generated_from: mojo.test.PodUnion.f_int8
  int8_t get_f_int8() const {
    DCHECK(tag_ == Tag::F_INT8);
    return data_.f_int8;
  }

  
// @generated_from: mojo.test.PodUnion.f_int8
  void set_f_int8(
      int8_t f_int8);
  
// @generated_from: mojo.test.PodUnion.f_int8_other
  bool is_f_int8_other() const { return tag_ == Tag::F_INT8_OTHER; }

  
// @generated_from: mojo.test.PodUnion.f_int8_other
  int8_t get_f_int8_other() const {
    DCHECK(tag_ == Tag::F_INT8_OTHER);
    return data_.f_int8_other;
  }

  
// @generated_from: mojo.test.PodUnion.f_int8_other
  void set_f_int8_other(
      int8_t f_int8_other);
  
// @generated_from: mojo.test.PodUnion.f_uint8
  bool is_f_uint8() const { return tag_ == Tag::F_UINT8; }

  
// @generated_from: mojo.test.PodUnion.f_uint8
  uint8_t get_f_uint8() const {
    DCHECK(tag_ == Tag::F_UINT8);
    return data_.f_uint8;
  }

  
// @generated_from: mojo.test.PodUnion.f_uint8
  void set_f_uint8(
      uint8_t f_uint8);
  
// @generated_from: mojo.test.PodUnion.f_int16
  bool is_f_int16() const { return tag_ == Tag::F_INT16; }

  
// @generated_from: mojo.test.PodUnion.f_int16
  int16_t get_f_int16() const {
    DCHECK(tag_ == Tag::F_INT16);
    return data_.f_int16;
  }

  
// @generated_from: mojo.test.PodUnion.f_int16
  void set_f_int16(
      int16_t f_int16);
  
// @generated_from: mojo.test.PodUnion.f_uint16
  bool is_f_uint16() const { return tag_ == Tag::F_UINT16; }

  
// @generated_from: mojo.test.PodUnion.f_uint16
  uint16_t get_f_uint16() const {
    DCHECK(tag_ == Tag::F_UINT16);
    return data_.f_uint16;
  }

  
// @generated_from: mojo.test.PodUnion.f_uint16
  void set_f_uint16(
      uint16_t f_uint16);
  
// @generated_from: mojo.test.PodUnion.f_int32
  bool is_f_int32() const { return tag_ == Tag::F_INT32; }

  
// @generated_from: mojo.test.PodUnion.f_int32
  int32_t get_f_int32() const {
    DCHECK(tag_ == Tag::F_INT32);
    return data_.f_int32;
  }

  
// @generated_from: mojo.test.PodUnion.f_int32
  void set_f_int32(
      int32_t f_int32);
  
// @generated_from: mojo.test.PodUnion.f_uint32
  bool is_f_uint32() const { return tag_ == Tag::F_UINT32; }

  
// @generated_from: mojo.test.PodUnion.f_uint32
  uint32_t get_f_uint32() const {
    DCHECK(tag_ == Tag::F_UINT32);
    return data_.f_uint32;
  }

  
// @generated_from: mojo.test.PodUnion.f_uint32
  void set_f_uint32(
      uint32_t f_uint32);
  
// @generated_from: mojo.test.PodUnion.f_int64
  bool is_f_int64() const { return tag_ == Tag::F_INT64; }

  
// @generated_from: mojo.test.PodUnion.f_int64
  int64_t get_f_int64() const {
    DCHECK(tag_ == Tag::F_INT64);
    return data_.f_int64;
  }

  
// @generated_from: mojo.test.PodUnion.f_int64
  void set_f_int64(
      int64_t f_int64);
  
// @generated_from: mojo.test.PodUnion.f_uint64
  bool is_f_uint64() const { return tag_ == Tag::F_UINT64; }

  
// @generated_from: mojo.test.PodUnion.f_uint64
  uint64_t get_f_uint64() const {
    DCHECK(tag_ == Tag::F_UINT64);
    return data_.f_uint64;
  }

  
// @generated_from: mojo.test.PodUnion.f_uint64
  void set_f_uint64(
      uint64_t f_uint64);
  
// @generated_from: mojo.test.PodUnion.f_float
  bool is_f_float() const { return tag_ == Tag::F_FLOAT; }

  
// @generated_from: mojo.test.PodUnion.f_float
  float get_f_float() const {
    DCHECK(tag_ == Tag::F_FLOAT);
    return data_.f_float;
  }

  
// @generated_from: mojo.test.PodUnion.f_float
  void set_f_float(
      float f_float);
  
// @generated_from: mojo.test.PodUnion.f_double
  bool is_f_double() const { return tag_ == Tag::F_DOUBLE; }

  
// @generated_from: mojo.test.PodUnion.f_double
  double get_f_double() const {
    DCHECK(tag_ == Tag::F_DOUBLE);
    return data_.f_double;
  }

  
// @generated_from: mojo.test.PodUnion.f_double
  void set_f_double(
      double f_double);
  
// @generated_from: mojo.test.PodUnion.f_bool
  bool is_f_bool() const { return tag_ == Tag::F_BOOL; }

  
// @generated_from: mojo.test.PodUnion.f_bool
  bool get_f_bool() const {
    DCHECK(tag_ == Tag::F_BOOL);
    return data_.f_bool;
  }

  
// @generated_from: mojo.test.PodUnion.f_bool
  void set_f_bool(
      bool f_bool);
  
// @generated_from: mojo.test.PodUnion.f_enum
  bool is_f_enum() const { return tag_ == Tag::F_ENUM; }

  
// @generated_from: mojo.test.PodUnion.f_enum
  AnEnum get_f_enum() const {
    DCHECK(tag_ == Tag::F_ENUM);
    return data_.f_enum;
  }

  
// @generated_from: mojo.test.PodUnion.f_enum
  void set_f_enum(
      AnEnum f_enum);
  
// @generated_from: mojo.test.PodUnion.f_extensible_enum
  bool is_f_extensible_enum() const { return tag_ == Tag::F_EXTENSIBLE_ENUM; }

  
// @generated_from: mojo.test.PodUnion.f_extensible_enum
  AnExtensibleEnum get_f_extensible_enum() const {
    DCHECK(tag_ == Tag::F_EXTENSIBLE_ENUM);
    return data_.f_extensible_enum;
  }

  
// @generated_from: mojo.test.PodUnion.f_extensible_enum
  void set_f_extensible_enum(
      AnExtensibleEnum f_extensible_enum);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PodUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<PodUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int8_t f_int8;
    int8_t f_int8_other;
    uint8_t f_uint8;
    int16_t f_int16;
    uint16_t f_uint16;
    int32_t f_int32;
    uint32_t f_uint32;
    int64_t f_int64;
    uint64_t f_uint64;
    float f_float;
    double f_double;
    bool f_bool;
    AnEnum f_enum;
    AnExtensibleEnum f_extensible_enum;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.ObjectUnion
class  ObjectUnion {
 public:
  using DataView = ObjectUnionDataView;
  using Data_ = internal::ObjectUnion_Data;
  using Tag = Data_::ObjectUnion_Tag;

  static ObjectUnionPtr New() {
    return ObjectUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_int8|.
  static ObjectUnionPtr
  NewFInt8(
      int8_t f_int8) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_int8(std::move(f_int8));
    return result;
  }
  // Construct an instance holding |f_string|.
  static ObjectUnionPtr
  NewFString(
      const std::string& f_string) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_string(std::move(f_string));
    return result;
  }
  // Construct an instance holding |f_dummy|.
  static ObjectUnionPtr
  NewFDummy(
      DummyStructPtr f_dummy) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_dummy(std::move(f_dummy));
    return result;
  }
  // Construct an instance holding |f_nullable|.
  static ObjectUnionPtr
  NewFNullable(
      DummyStructPtr f_nullable) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_nullable(std::move(f_nullable));
    return result;
  }
  // Construct an instance holding |f_array_int8|.
  static ObjectUnionPtr
  NewFArrayInt8(
      std::vector<int8_t> f_array_int8) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_array_int8(std::move(f_array_int8));
    return result;
  }
  // Construct an instance holding |f_map_int8|.
  static ObjectUnionPtr
  NewFMapInt8(
      const base::flat_map<std::string, int8_t>& f_map_int8) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_map_int8(std::move(f_map_int8));
    return result;
  }
  // Construct an instance holding |f_pod_union|.
  static ObjectUnionPtr
  NewFPodUnion(
      PodUnionPtr f_pod_union) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_pod_union(std::move(f_pod_union));
    return result;
  }
  // Construct an instance holding |f_small_structs|.
  static ObjectUnionPtr
  NewFSmallStructs(
      std::vector<SmallStructPtr> f_small_structs) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_small_structs(std::move(f_small_structs));
    return result;
  }

  template <typename U>
  static ObjectUnionPtr From(const U& u) {
    return mojo::TypeConverter<ObjectUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ObjectUnion>::Convert(*this);
  }

  ObjectUnion();
  ~ObjectUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = ObjectUnionPtr>
  ObjectUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, ObjectUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, ObjectUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.ObjectUnion.f_int8
  bool is_f_int8() const { return tag_ == Tag::F_INT8; }

  
// @generated_from: mojo.test.ObjectUnion.f_int8
  int8_t get_f_int8() const {
    DCHECK(tag_ == Tag::F_INT8);
    return data_.f_int8;
  }

  
// @generated_from: mojo.test.ObjectUnion.f_int8
  void set_f_int8(
      int8_t f_int8);
  
// @generated_from: mojo.test.ObjectUnion.f_string
  bool is_f_string() const { return tag_ == Tag::F_STRING; }

  
// @generated_from: mojo.test.ObjectUnion.f_string
  std::string& get_f_string() const {
    DCHECK(tag_ == Tag::F_STRING);
    return *(data_.f_string);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_string
  void set_f_string(
      const std::string& f_string);
  
// @generated_from: mojo.test.ObjectUnion.f_dummy
  bool is_f_dummy() const { return tag_ == Tag::F_DUMMY; }

  
// @generated_from: mojo.test.ObjectUnion.f_dummy
  DummyStructPtr& get_f_dummy() const {
    DCHECK(tag_ == Tag::F_DUMMY);
    return *(data_.f_dummy);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_dummy
  void set_f_dummy(
      DummyStructPtr f_dummy);
  
// @generated_from: mojo.test.ObjectUnion.f_nullable
  bool is_f_nullable() const { return tag_ == Tag::F_NULLABLE; }

  
// @generated_from: mojo.test.ObjectUnion.f_nullable
  DummyStructPtr& get_f_nullable() const {
    DCHECK(tag_ == Tag::F_NULLABLE);
    return *(data_.f_nullable);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_nullable
  void set_f_nullable(
      DummyStructPtr f_nullable);
  
// @generated_from: mojo.test.ObjectUnion.f_array_int8
  bool is_f_array_int8() const { return tag_ == Tag::F_ARRAY_INT8; }

  
// @generated_from: mojo.test.ObjectUnion.f_array_int8
  std::vector<int8_t>& get_f_array_int8() const {
    DCHECK(tag_ == Tag::F_ARRAY_INT8);
    return *(data_.f_array_int8);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_array_int8
  void set_f_array_int8(
      std::vector<int8_t> f_array_int8);
  
// @generated_from: mojo.test.ObjectUnion.f_map_int8
  bool is_f_map_int8() const { return tag_ == Tag::F_MAP_INT8; }

  
// @generated_from: mojo.test.ObjectUnion.f_map_int8
  base::flat_map<std::string, int8_t>& get_f_map_int8() const {
    DCHECK(tag_ == Tag::F_MAP_INT8);
    return *(data_.f_map_int8);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_map_int8
  void set_f_map_int8(
      const base::flat_map<std::string, int8_t>& f_map_int8);
  
// @generated_from: mojo.test.ObjectUnion.f_pod_union
  bool is_f_pod_union() const { return tag_ == Tag::F_POD_UNION; }

  
// @generated_from: mojo.test.ObjectUnion.f_pod_union
  PodUnionPtr& get_f_pod_union() const {
    DCHECK(tag_ == Tag::F_POD_UNION);
    return *(data_.f_pod_union);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_pod_union
  void set_f_pod_union(
      PodUnionPtr f_pod_union);
  
// @generated_from: mojo.test.ObjectUnion.f_small_structs
  bool is_f_small_structs() const { return tag_ == Tag::F_SMALL_STRUCTS; }

  
// @generated_from: mojo.test.ObjectUnion.f_small_structs
  std::vector<SmallStructPtr>& get_f_small_structs() const {
    DCHECK(tag_ == Tag::F_SMALL_STRUCTS);
    return *(data_.f_small_structs);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_small_structs
  void set_f_small_structs(
      std::vector<SmallStructPtr> f_small_structs);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ObjectUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<ObjectUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int8_t f_int8;
    std::string* f_string;
    DummyStructPtr* f_dummy;
    DummyStructPtr* f_nullable;
    std::vector<int8_t>* f_array_int8;
    base::flat_map<std::string, int8_t>* f_map_int8;
    PodUnionPtr* f_pod_union;
    std::vector<SmallStructPtr>* f_small_structs;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.HandleUnion
class  HandleUnion {
 public:
  using DataView = HandleUnionDataView;
  using Data_ = internal::HandleUnion_Data;
  using Tag = Data_::HandleUnion_Tag;

  static HandleUnionPtr New() {
    return HandleUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_handle|.
  static HandleUnionPtr
  NewFHandle(
      ::mojo::ScopedHandle f_handle) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_handle(std::move(f_handle));
    return result;
  }
  // Construct an instance holding |f_message_pipe|.
  static HandleUnionPtr
  NewFMessagePipe(
      ::mojo::ScopedMessagePipeHandle f_message_pipe) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_message_pipe(std::move(f_message_pipe));
    return result;
  }
  // Construct an instance holding |f_data_pipe_consumer|.
  static HandleUnionPtr
  NewFDataPipeConsumer(
      ::mojo::ScopedDataPipeConsumerHandle f_data_pipe_consumer) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_data_pipe_consumer(std::move(f_data_pipe_consumer));
    return result;
  }
  // Construct an instance holding |f_data_pipe_producer|.
  static HandleUnionPtr
  NewFDataPipeProducer(
      ::mojo::ScopedDataPipeProducerHandle f_data_pipe_producer) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_data_pipe_producer(std::move(f_data_pipe_producer));
    return result;
  }
  // Construct an instance holding |f_shared_buffer|.
  static HandleUnionPtr
  NewFSharedBuffer(
      ::mojo::ScopedSharedBufferHandle f_shared_buffer) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_shared_buffer(std::move(f_shared_buffer));
    return result;
  }
  // Construct an instance holding |f_platform|.
  static HandleUnionPtr
  NewFPlatform(
      ::mojo::PlatformHandle f_platform) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_platform(std::move(f_platform));
    return result;
  }
  // Construct an instance holding |f_small_cache|.
  static HandleUnionPtr
  NewFSmallCache(
      ::mojo::PendingRemote<SmallCache> f_small_cache) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_small_cache(std::move(f_small_cache));
    return result;
  }
  // Construct an instance holding |f_small_cache_receiver|.
  static HandleUnionPtr
  NewFSmallCacheReceiver(
      ::mojo::PendingReceiver<SmallCache> f_small_cache_receiver) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_small_cache_receiver(std::move(f_small_cache_receiver));
    return result;
  }

  template <typename U>
  static HandleUnionPtr From(const U& u) {
    return mojo::TypeConverter<HandleUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HandleUnion>::Convert(*this);
  }

  HandleUnion();
  ~HandleUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = HandleUnionPtr>
  HandleUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, HandleUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, HandleUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.HandleUnion.f_handle
  bool is_f_handle() const { return tag_ == Tag::F_HANDLE; }

  
// @generated_from: mojo.test.HandleUnion.f_handle
  ::mojo::ScopedHandle& get_f_handle() const {
    DCHECK(tag_ == Tag::F_HANDLE);
    return *(data_.f_handle);
  }

  
// @generated_from: mojo.test.HandleUnion.f_handle
  void set_f_handle(
      ::mojo::ScopedHandle f_handle);
  
// @generated_from: mojo.test.HandleUnion.f_message_pipe
  bool is_f_message_pipe() const { return tag_ == Tag::F_MESSAGE_PIPE; }

  
// @generated_from: mojo.test.HandleUnion.f_message_pipe
  ::mojo::ScopedMessagePipeHandle& get_f_message_pipe() const {
    DCHECK(tag_ == Tag::F_MESSAGE_PIPE);
    return *(data_.f_message_pipe);
  }

  
// @generated_from: mojo.test.HandleUnion.f_message_pipe
  void set_f_message_pipe(
      ::mojo::ScopedMessagePipeHandle f_message_pipe);
  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_consumer
  bool is_f_data_pipe_consumer() const { return tag_ == Tag::F_DATA_PIPE_CONSUMER; }

  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_consumer
  ::mojo::ScopedDataPipeConsumerHandle& get_f_data_pipe_consumer() const {
    DCHECK(tag_ == Tag::F_DATA_PIPE_CONSUMER);
    return *(data_.f_data_pipe_consumer);
  }

  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_consumer
  void set_f_data_pipe_consumer(
      ::mojo::ScopedDataPipeConsumerHandle f_data_pipe_consumer);
  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_producer
  bool is_f_data_pipe_producer() const { return tag_ == Tag::F_DATA_PIPE_PRODUCER; }

  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_producer
  ::mojo::ScopedDataPipeProducerHandle& get_f_data_pipe_producer() const {
    DCHECK(tag_ == Tag::F_DATA_PIPE_PRODUCER);
    return *(data_.f_data_pipe_producer);
  }

  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_producer
  void set_f_data_pipe_producer(
      ::mojo::ScopedDataPipeProducerHandle f_data_pipe_producer);
  
// @generated_from: mojo.test.HandleUnion.f_shared_buffer
  bool is_f_shared_buffer() const { return tag_ == Tag::F_SHARED_BUFFER; }

  
// @generated_from: mojo.test.HandleUnion.f_shared_buffer
  ::mojo::ScopedSharedBufferHandle& get_f_shared_buffer() const {
    DCHECK(tag_ == Tag::F_SHARED_BUFFER);
    return *(data_.f_shared_buffer);
  }

  
// @generated_from: mojo.test.HandleUnion.f_shared_buffer
  void set_f_shared_buffer(
      ::mojo::ScopedSharedBufferHandle f_shared_buffer);
  
// @generated_from: mojo.test.HandleUnion.f_platform
  bool is_f_platform() const { return tag_ == Tag::F_PLATFORM; }

  
// @generated_from: mojo.test.HandleUnion.f_platform
  ::mojo::PlatformHandle& get_f_platform() const {
    DCHECK(tag_ == Tag::F_PLATFORM);
    return *(data_.f_platform);
  }

  
// @generated_from: mojo.test.HandleUnion.f_platform
  void set_f_platform(
      ::mojo::PlatformHandle f_platform);
  
// @generated_from: mojo.test.HandleUnion.f_small_cache
  bool is_f_small_cache() const { return tag_ == Tag::F_SMALL_CACHE; }

  
// @generated_from: mojo.test.HandleUnion.f_small_cache
  ::mojo::PendingRemote<SmallCache>& get_f_small_cache() const {
    DCHECK(tag_ == Tag::F_SMALL_CACHE);
    return *(data_.f_small_cache);
  }

  
// @generated_from: mojo.test.HandleUnion.f_small_cache
  void set_f_small_cache(
      ::mojo::PendingRemote<SmallCache> f_small_cache);
  
// @generated_from: mojo.test.HandleUnion.f_small_cache_receiver
  bool is_f_small_cache_receiver() const { return tag_ == Tag::F_SMALL_CACHE_RECEIVER; }

  
// @generated_from: mojo.test.HandleUnion.f_small_cache_receiver
  ::mojo::PendingReceiver<SmallCache>& get_f_small_cache_receiver() const {
    DCHECK(tag_ == Tag::F_SMALL_CACHE_RECEIVER);
    return *(data_.f_small_cache_receiver);
  }

  
// @generated_from: mojo.test.HandleUnion.f_small_cache_receiver
  void set_f_small_cache_receiver(
      ::mojo::PendingReceiver<SmallCache> f_small_cache_receiver);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        HandleUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<HandleUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    ::mojo::ScopedHandle* f_handle;
    ::mojo::ScopedMessagePipeHandle* f_message_pipe;
    ::mojo::ScopedDataPipeConsumerHandle* f_data_pipe_consumer;
    ::mojo::ScopedDataPipeProducerHandle* f_data_pipe_producer;
    ::mojo::ScopedSharedBufferHandle* f_shared_buffer;
    ::mojo::PlatformHandle* f_platform;
    ::mojo::PendingRemote<SmallCache>* f_small_cache;
    ::mojo::PendingReceiver<SmallCache>* f_small_cache_receiver;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.OldUnion
class  OldUnion {
 public:
  using DataView = OldUnionDataView;
  using Data_ = internal::OldUnion_Data;
  using Tag = Data_::OldUnion_Tag;

  static OldUnionPtr New() {
    return OldUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_int8|.
  static OldUnionPtr
  NewFInt8(
      int8_t f_int8) {
    auto result = OldUnionPtr(base::in_place);
    result->set_f_int8(std::move(f_int8));
    return result;
  }

  template <typename U>
  static OldUnionPtr From(const U& u) {
    return mojo::TypeConverter<OldUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, OldUnion>::Convert(*this);
  }

  OldUnion();
  ~OldUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = OldUnionPtr>
  OldUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, OldUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, OldUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.OldUnion.f_int8
  bool is_f_int8() const { return tag_ == Tag::F_INT8; }

  
// @generated_from: mojo.test.OldUnion.f_int8
  int8_t get_f_int8() const {
    DCHECK(tag_ == Tag::F_INT8);
    return data_.f_int8;
  }

  
// @generated_from: mojo.test.OldUnion.f_int8
  void set_f_int8(
      int8_t f_int8);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        OldUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<OldUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int8_t f_int8;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.NewUnion
class  NewUnion {
 public:
  using DataView = NewUnionDataView;
  using Data_ = internal::NewUnion_Data;
  using Tag = Data_::NewUnion_Tag;

  static NewUnionPtr New() {
    return NewUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_int8|.
  static NewUnionPtr
  NewFInt8(
      int8_t f_int8) {
    auto result = NewUnionPtr(base::in_place);
    result->set_f_int8(std::move(f_int8));
    return result;
  }
  // Construct an instance holding |f_int16|.
  static NewUnionPtr
  NewFInt16(
      int16_t f_int16) {
    auto result = NewUnionPtr(base::in_place);
    result->set_f_int16(std::move(f_int16));
    return result;
  }

  template <typename U>
  static NewUnionPtr From(const U& u) {
    return mojo::TypeConverter<NewUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NewUnion>::Convert(*this);
  }

  NewUnion();
  ~NewUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = NewUnionPtr>
  NewUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, NewUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, NewUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.NewUnion.f_int8
  bool is_f_int8() const { return tag_ == Tag::F_INT8; }

  
// @generated_from: mojo.test.NewUnion.f_int8
  int8_t get_f_int8() const {
    DCHECK(tag_ == Tag::F_INT8);
    return data_.f_int8;
  }

  
// @generated_from: mojo.test.NewUnion.f_int8
  void set_f_int8(
      int8_t f_int8);
  
// @generated_from: mojo.test.NewUnion.f_int16
  bool is_f_int16() const { return tag_ == Tag::F_INT16; }

  
// @generated_from: mojo.test.NewUnion.f_int16
  int16_t get_f_int16() const {
    DCHECK(tag_ == Tag::F_INT16);
    return data_.f_int16;
  }

  
// @generated_from: mojo.test.NewUnion.f_int16
  void set_f_int16(
      int16_t f_int16);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NewUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<NewUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int8_t f_int8;
    int16_t f_int16;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.ImportedUnionUnion
class  ImportedUnionUnion {
 public:
  using DataView = ImportedUnionUnionDataView;
  using Data_ = internal::ImportedUnionUnion_Data;
  using Tag = Data_::ImportedUnionUnion_Tag;

  static ImportedUnionUnionPtr New() {
    return ImportedUnionUnionPtr(base::in_place);
  }
  // Construct an instance holding |point_or_shape|.
  static ImportedUnionUnionPtr
  NewPointOrShape(
      ::imported::PointOrShapePtr point_or_shape) {
    auto result = ImportedUnionUnionPtr(base::in_place);
    result->set_point_or_shape(std::move(point_or_shape));
    return result;
  }

  template <typename U>
  static ImportedUnionUnionPtr From(const U& u) {
    return mojo::TypeConverter<ImportedUnionUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ImportedUnionUnion>::Convert(*this);
  }

  ImportedUnionUnion();
  ~ImportedUnionUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = ImportedUnionUnionPtr>
  ImportedUnionUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, ImportedUnionUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, ImportedUnionUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.ImportedUnionUnion.point_or_shape
  bool is_point_or_shape() const { return tag_ == Tag::POINT_OR_SHAPE; }

  
// @generated_from: mojo.test.ImportedUnionUnion.point_or_shape
  ::imported::PointOrShapePtr& get_point_or_shape() const {
    DCHECK(tag_ == Tag::POINT_OR_SHAPE);
    return *(data_.point_or_shape);
  }

  
// @generated_from: mojo.test.ImportedUnionUnion.point_or_shape
  void set_point_or_shape(
      ::imported::PointOrShapePtr point_or_shape);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ImportedUnionUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<ImportedUnionUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    ::imported::PointOrShapePtr* point_or_shape;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.UnionWithStringForFirstField
class  UnionWithStringForFirstField {
 public:
  using DataView = UnionWithStringForFirstFieldDataView;
  using Data_ = internal::UnionWithStringForFirstField_Data;
  using Tag = Data_::UnionWithStringForFirstField_Tag;

  static UnionWithStringForFirstFieldPtr New() {
    return UnionWithStringForFirstFieldPtr(base::in_place);
  }
  // Construct an instance holding |s|.
  static UnionWithStringForFirstFieldPtr
  NewS(
      const std::string& s) {
    auto result = UnionWithStringForFirstFieldPtr(base::in_place);
    result->set_s(std::move(s));
    return result;
  }
  // Construct an instance holding |i|.
  static UnionWithStringForFirstFieldPtr
  NewI(
      int32_t i) {
    auto result = UnionWithStringForFirstFieldPtr(base::in_place);
    result->set_i(std::move(i));
    return result;
  }

  template <typename U>
  static UnionWithStringForFirstFieldPtr From(const U& u) {
    return mojo::TypeConverter<UnionWithStringForFirstFieldPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionWithStringForFirstField>::Convert(*this);
  }

  UnionWithStringForFirstField();
  ~UnionWithStringForFirstField();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = UnionWithStringForFirstFieldPtr>
  UnionWithStringForFirstFieldPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, UnionWithStringForFirstField>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, UnionWithStringForFirstField>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.UnionWithStringForFirstField.s
  bool is_s() const { return tag_ == Tag::S; }

  
// @generated_from: mojo.test.UnionWithStringForFirstField.s
  std::string& get_s() const {
    DCHECK(tag_ == Tag::S);
    return *(data_.s);
  }

  
// @generated_from: mojo.test.UnionWithStringForFirstField.s
  void set_s(
      const std::string& s);
  
// @generated_from: mojo.test.UnionWithStringForFirstField.i
  bool is_i() const { return tag_ == Tag::I; }

  
// @generated_from: mojo.test.UnionWithStringForFirstField.i
  int32_t get_i() const {
    DCHECK(tag_ == Tag::I);
    return data_.i;
  }

  
// @generated_from: mojo.test.UnionWithStringForFirstField.i
  void set_i(
      int32_t i);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        UnionWithStringForFirstField::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<UnionWithStringForFirstField::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    std::string* s;
    int32_t i;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





// @generated_from: mojo.test.WrapperStruct
class  WrapperStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WrapperStruct, T>::value>;
  using DataView = WrapperStructDataView;
  using Data_ = internal::WrapperStruct_Data;

  template <typename... Args>
  static WrapperStructPtr New(Args&&... args) {
    return WrapperStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WrapperStructPtr From(const U& u) {
    return mojo::TypeConverter<WrapperStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WrapperStruct>::Convert(*this);
  }


  WrapperStruct();

  WrapperStruct(
      ObjectUnionPtr object_union,
      PodUnionPtr pod_union,
      HandleUnionPtr handle_union);

  ~WrapperStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WrapperStructPtr>
  WrapperStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WrapperStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WrapperStruct_UnserializedMessageContext<
            UserType, WrapperStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WrapperStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WrapperStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WrapperStruct_UnserializedMessageContext<
            UserType, WrapperStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WrapperStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.WrapperStruct.object_union
  ObjectUnionPtr object_union;
  
// @generated_from: mojo.test.WrapperStruct.pod_union
  PodUnionPtr pod_union;
  
// @generated_from: mojo.test.WrapperStruct.handle_union
  HandleUnionPtr handle_union;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(WrapperStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.SmallStruct
class  SmallStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SmallStruct, T>::value>;
  using DataView = SmallStructDataView;
  using Data_ = internal::SmallStruct_Data;

  template <typename... Args>
  static SmallStructPtr New(Args&&... args) {
    return SmallStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SmallStructPtr From(const U& u) {
    return mojo::TypeConverter<SmallStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallStruct>::Convert(*this);
  }


  SmallStruct();

  SmallStruct(
      DummyStructPtr dummy_struct,
      PodUnionPtr pod_union,
      base::Optional<std::vector<PodUnionPtr>> pod_union_array,
      base::Optional<std::vector<PodUnionPtr>> nullable_pod_union_array,
      base::Optional<std::vector<DummyStructPtr>> s_array,
      base::Optional<base::flat_map<std::string, PodUnionPtr>> pod_union_map,
      base::Optional<base::flat_map<std::string, PodUnionPtr>> nullable_pod_union_map);

  ~SmallStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SmallStructPtr>
  SmallStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SmallStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SmallStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SmallStruct_UnserializedMessageContext<
            UserType, SmallStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SmallStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SmallStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SmallStruct_UnserializedMessageContext<
            UserType, SmallStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SmallStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SmallStruct.dummy_struct
  DummyStructPtr dummy_struct;
  
// @generated_from: mojo.test.SmallStruct.pod_union
  PodUnionPtr pod_union;
  
// @generated_from: mojo.test.SmallStruct.pod_union_array
  base::Optional<std::vector<PodUnionPtr>> pod_union_array;
  
// @generated_from: mojo.test.SmallStruct.nullable_pod_union_array
  base::Optional<std::vector<PodUnionPtr>> nullable_pod_union_array;
  
// @generated_from: mojo.test.SmallStruct.s_array
  base::Optional<std::vector<DummyStructPtr>> s_array;
  
// @generated_from: mojo.test.SmallStruct.pod_union_map
  base::Optional<base::flat_map<std::string, PodUnionPtr>> pod_union_map;
  
// @generated_from: mojo.test.SmallStruct.nullable_pod_union_map
  base::Optional<base::flat_map<std::string, PodUnionPtr>> nullable_pod_union_map;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SmallStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.SmallStructNonNullableUnion
class  SmallStructNonNullableUnion {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SmallStructNonNullableUnion, T>::value>;
  using DataView = SmallStructNonNullableUnionDataView;
  using Data_ = internal::SmallStructNonNullableUnion_Data;

  template <typename... Args>
  static SmallStructNonNullableUnionPtr New(Args&&... args) {
    return SmallStructNonNullableUnionPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SmallStructNonNullableUnionPtr From(const U& u) {
    return mojo::TypeConverter<SmallStructNonNullableUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallStructNonNullableUnion>::Convert(*this);
  }


  SmallStructNonNullableUnion();

  explicit SmallStructNonNullableUnion(
      PodUnionPtr pod_union);

  ~SmallStructNonNullableUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SmallStructNonNullableUnionPtr>
  SmallStructNonNullableUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SmallStructNonNullableUnion::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SmallStructNonNullableUnion::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SmallStructNonNullableUnion_UnserializedMessageContext<
            UserType, SmallStructNonNullableUnion::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SmallStructNonNullableUnion::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SmallStructNonNullableUnion::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SmallStructNonNullableUnion_UnserializedMessageContext<
            UserType, SmallStructNonNullableUnion::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SmallStructNonNullableUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SmallStructNonNullableUnion.pod_union
  PodUnionPtr pod_union;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SmallStructNonNullableUnion);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.SmallObjStruct
class  SmallObjStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SmallObjStruct, T>::value>;
  using DataView = SmallObjStructDataView;
  using Data_ = internal::SmallObjStruct_Data;

  template <typename... Args>
  static SmallObjStructPtr New(Args&&... args) {
    return SmallObjStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SmallObjStructPtr From(const U& u) {
    return mojo::TypeConverter<SmallObjStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallObjStruct>::Convert(*this);
  }


  SmallObjStruct();

  SmallObjStruct(
      ObjectUnionPtr obj_union,
      int8_t f_int8);

  ~SmallObjStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SmallObjStructPtr>
  SmallObjStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SmallObjStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SmallObjStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SmallObjStruct_UnserializedMessageContext<
            UserType, SmallObjStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SmallObjStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SmallObjStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SmallObjStruct_UnserializedMessageContext<
            UserType, SmallObjStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SmallObjStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SmallObjStruct.obj_union
  ObjectUnionPtr obj_union;
  
// @generated_from: mojo.test.SmallObjStruct.f_int8
  int8_t f_int8;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SmallObjStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.TryNonNullStruct
class  TryNonNullStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<TryNonNullStruct, T>::value>;
  using DataView = TryNonNullStructDataView;
  using Data_ = internal::TryNonNullStruct_Data;

  template <typename... Args>
  static TryNonNullStructPtr New(Args&&... args) {
    return TryNonNullStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static TryNonNullStructPtr From(const U& u) {
    return mojo::TypeConverter<TryNonNullStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TryNonNullStruct>::Convert(*this);
  }


  TryNonNullStruct();

  TryNonNullStruct(
      DummyStructPtr nullable,
      DummyStructPtr non_nullable);

  ~TryNonNullStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = TryNonNullStructPtr>
  TryNonNullStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        TryNonNullStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        TryNonNullStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::TryNonNullStruct_UnserializedMessageContext<
            UserType, TryNonNullStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<TryNonNullStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return TryNonNullStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::TryNonNullStruct_UnserializedMessageContext<
            UserType, TryNonNullStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<TryNonNullStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.TryNonNullStruct.nullable
  DummyStructPtr nullable;
  
// @generated_from: mojo.test.TryNonNullStruct.non_nullable
  DummyStructPtr non_nullable;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(TryNonNullStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.ImportedUnionStruct
class  ImportedUnionStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ImportedUnionStruct, T>::value>;
  using DataView = ImportedUnionStructDataView;
  using Data_ = internal::ImportedUnionStruct_Data;

  template <typename... Args>
  static ImportedUnionStructPtr New(Args&&... args) {
    return ImportedUnionStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ImportedUnionStructPtr From(const U& u) {
    return mojo::TypeConverter<ImportedUnionStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ImportedUnionStruct>::Convert(*this);
  }


  ImportedUnionStruct();

  explicit ImportedUnionStruct(
      ::imported::PointOrShapePtr point_or_shape);

  ~ImportedUnionStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ImportedUnionStructPtr>
  ImportedUnionStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ImportedUnionStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ImportedUnionStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ImportedUnionStruct_UnserializedMessageContext<
            UserType, ImportedUnionStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ImportedUnionStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ImportedUnionStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ImportedUnionStruct_UnserializedMessageContext<
            UserType, ImportedUnionStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ImportedUnionStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ImportedUnionStruct.point_or_shape
  ::imported::PointOrShapePtr point_or_shape;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ImportedUnionStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename UnionPtrType>
PodUnionPtr PodUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_INT8:
      rv->set_f_int8(mojo::Clone(data_.f_int8));
      break;
    case Tag::F_INT8_OTHER:
      rv->set_f_int8_other(mojo::Clone(data_.f_int8_other));
      break;
    case Tag::F_UINT8:
      rv->set_f_uint8(mojo::Clone(data_.f_uint8));
      break;
    case Tag::F_INT16:
      rv->set_f_int16(mojo::Clone(data_.f_int16));
      break;
    case Tag::F_UINT16:
      rv->set_f_uint16(mojo::Clone(data_.f_uint16));
      break;
    case Tag::F_INT32:
      rv->set_f_int32(mojo::Clone(data_.f_int32));
      break;
    case Tag::F_UINT32:
      rv->set_f_uint32(mojo::Clone(data_.f_uint32));
      break;
    case Tag::F_INT64:
      rv->set_f_int64(mojo::Clone(data_.f_int64));
      break;
    case Tag::F_UINT64:
      rv->set_f_uint64(mojo::Clone(data_.f_uint64));
      break;
    case Tag::F_FLOAT:
      rv->set_f_float(mojo::Clone(data_.f_float));
      break;
    case Tag::F_DOUBLE:
      rv->set_f_double(mojo::Clone(data_.f_double));
      break;
    case Tag::F_BOOL:
      rv->set_f_bool(mojo::Clone(data_.f_bool));
      break;
    case Tag::F_ENUM:
      rv->set_f_enum(mojo::Clone(data_.f_enum));
      break;
    case Tag::F_EXTENSIBLE_ENUM:
      rv->set_f_extensible_enum(mojo::Clone(data_.f_extensible_enum));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, PodUnion>::value>::type*>
bool PodUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_INT8:
      return mojo::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_INT8_OTHER:
      return mojo::Equals(data_.f_int8_other, other.data_.f_int8_other);
    case Tag::F_UINT8:
      return mojo::Equals(data_.f_uint8, other.data_.f_uint8);
    case Tag::F_INT16:
      return mojo::Equals(data_.f_int16, other.data_.f_int16);
    case Tag::F_UINT16:
      return mojo::Equals(data_.f_uint16, other.data_.f_uint16);
    case Tag::F_INT32:
      return mojo::Equals(data_.f_int32, other.data_.f_int32);
    case Tag::F_UINT32:
      return mojo::Equals(data_.f_uint32, other.data_.f_uint32);
    case Tag::F_INT64:
      return mojo::Equals(data_.f_int64, other.data_.f_int64);
    case Tag::F_UINT64:
      return mojo::Equals(data_.f_uint64, other.data_.f_uint64);
    case Tag::F_FLOAT:
      return mojo::Equals(data_.f_float, other.data_.f_float);
    case Tag::F_DOUBLE:
      return mojo::Equals(data_.f_double, other.data_.f_double);
    case Tag::F_BOOL:
      return mojo::Equals(data_.f_bool, other.data_.f_bool);
    case Tag::F_ENUM:
      return mojo::Equals(data_.f_enum, other.data_.f_enum);
    case Tag::F_EXTENSIBLE_ENUM:
      return mojo::Equals(data_.f_extensible_enum, other.data_.f_extensible_enum);
  }

  return false;
}
template <typename UnionPtrType>
ObjectUnionPtr ObjectUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_INT8:
      rv->set_f_int8(mojo::Clone(data_.f_int8));
      break;
    case Tag::F_STRING:
      rv->set_f_string(mojo::Clone(*data_.f_string));
      break;
    case Tag::F_DUMMY:
      rv->set_f_dummy(mojo::Clone(*data_.f_dummy));
      break;
    case Tag::F_NULLABLE:
      rv->set_f_nullable(mojo::Clone(*data_.f_nullable));
      break;
    case Tag::F_ARRAY_INT8:
      rv->set_f_array_int8(mojo::Clone(*data_.f_array_int8));
      break;
    case Tag::F_MAP_INT8:
      rv->set_f_map_int8(mojo::Clone(*data_.f_map_int8));
      break;
    case Tag::F_POD_UNION:
      rv->set_f_pod_union(mojo::Clone(*data_.f_pod_union));
      break;
    case Tag::F_SMALL_STRUCTS:
      rv->set_f_small_structs(mojo::Clone(*data_.f_small_structs));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, ObjectUnion>::value>::type*>
bool ObjectUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_INT8:
      return mojo::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_STRING:
      return mojo::Equals(*(data_.f_string), *(other.data_.f_string));
    case Tag::F_DUMMY:
      return mojo::Equals(*(data_.f_dummy), *(other.data_.f_dummy));
    case Tag::F_NULLABLE:
      return mojo::Equals(*(data_.f_nullable), *(other.data_.f_nullable));
    case Tag::F_ARRAY_INT8:
      return mojo::Equals(*(data_.f_array_int8), *(other.data_.f_array_int8));
    case Tag::F_MAP_INT8:
      return mojo::Equals(*(data_.f_map_int8), *(other.data_.f_map_int8));
    case Tag::F_POD_UNION:
      return mojo::Equals(*(data_.f_pod_union), *(other.data_.f_pod_union));
    case Tag::F_SMALL_STRUCTS:
      return mojo::Equals(*(data_.f_small_structs), *(other.data_.f_small_structs));
  }

  return false;
}
template <typename UnionPtrType>
HandleUnionPtr HandleUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_HANDLE:
      rv->set_f_handle(mojo::Clone(*data_.f_handle));
      break;
    case Tag::F_MESSAGE_PIPE:
      rv->set_f_message_pipe(mojo::Clone(*data_.f_message_pipe));
      break;
    case Tag::F_DATA_PIPE_CONSUMER:
      rv->set_f_data_pipe_consumer(mojo::Clone(*data_.f_data_pipe_consumer));
      break;
    case Tag::F_DATA_PIPE_PRODUCER:
      rv->set_f_data_pipe_producer(mojo::Clone(*data_.f_data_pipe_producer));
      break;
    case Tag::F_SHARED_BUFFER:
      rv->set_f_shared_buffer(mojo::Clone(*data_.f_shared_buffer));
      break;
    case Tag::F_PLATFORM:
      rv->set_f_platform(mojo::Clone(*data_.f_platform));
      break;
    case Tag::F_SMALL_CACHE:
      rv->set_f_small_cache(mojo::Clone(*data_.f_small_cache));
      break;
    case Tag::F_SMALL_CACHE_RECEIVER:
      rv->set_f_small_cache_receiver(mojo::Clone(*data_.f_small_cache_receiver));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, HandleUnion>::value>::type*>
bool HandleUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_HANDLE:
      return mojo::Equals(*(data_.f_handle), *(other.data_.f_handle));
    case Tag::F_MESSAGE_PIPE:
      return mojo::Equals(*(data_.f_message_pipe), *(other.data_.f_message_pipe));
    case Tag::F_DATA_PIPE_CONSUMER:
      return mojo::Equals(*(data_.f_data_pipe_consumer), *(other.data_.f_data_pipe_consumer));
    case Tag::F_DATA_PIPE_PRODUCER:
      return mojo::Equals(*(data_.f_data_pipe_producer), *(other.data_.f_data_pipe_producer));
    case Tag::F_SHARED_BUFFER:
      return mojo::Equals(*(data_.f_shared_buffer), *(other.data_.f_shared_buffer));
    case Tag::F_PLATFORM:
      return mojo::Equals(*(data_.f_platform), *(other.data_.f_platform));
    case Tag::F_SMALL_CACHE:
      return mojo::Equals(*(data_.f_small_cache), *(other.data_.f_small_cache));
    case Tag::F_SMALL_CACHE_RECEIVER:
      return mojo::Equals(*(data_.f_small_cache_receiver), *(other.data_.f_small_cache_receiver));
  }

  return false;
}
template <typename UnionPtrType>
OldUnionPtr OldUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_INT8:
      rv->set_f_int8(mojo::Clone(data_.f_int8));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, OldUnion>::value>::type*>
bool OldUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_INT8:
      return mojo::Equals(data_.f_int8, other.data_.f_int8);
  }

  return false;
}
template <typename UnionPtrType>
NewUnionPtr NewUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_INT8:
      rv->set_f_int8(mojo::Clone(data_.f_int8));
      break;
    case Tag::F_INT16:
      rv->set_f_int16(mojo::Clone(data_.f_int16));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, NewUnion>::value>::type*>
bool NewUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_INT8:
      return mojo::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_INT16:
      return mojo::Equals(data_.f_int16, other.data_.f_int16);
  }

  return false;
}
template <typename UnionPtrType>
ImportedUnionUnionPtr ImportedUnionUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::POINT_OR_SHAPE:
      rv->set_point_or_shape(mojo::Clone(*data_.point_or_shape));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, ImportedUnionUnion>::value>::type*>
bool ImportedUnionUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::POINT_OR_SHAPE:
      return mojo::Equals(*(data_.point_or_shape), *(other.data_.point_or_shape));
  }

  return false;
}
template <typename UnionPtrType>
UnionWithStringForFirstFieldPtr UnionWithStringForFirstField::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::S:
      rv->set_s(mojo::Clone(*data_.s));
      break;
    case Tag::I:
      rv->set_i(mojo::Clone(data_.i));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, UnionWithStringForFirstField>::value>::type*>
bool UnionWithStringForFirstField::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::S:
      return mojo::Equals(*(data_.s), *(other.data_.s));
    case Tag::I:
      return mojo::Equals(data_.i, other.data_.i);
  }

  return false;
}
template <typename StructPtrType>
WrapperStructPtr WrapperStruct::Clone() const {
  return New(
      mojo::Clone(object_union),
      mojo::Clone(pod_union),
      mojo::Clone(handle_union)
  );
}

template <typename T, WrapperStruct::EnableIfSame<T>*>
bool WrapperStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->object_union, other_struct.object_union))
    return false;
  if (!mojo::Equals(this->pod_union, other_struct.pod_union))
    return false;
  if (!mojo::Equals(this->handle_union, other_struct.handle_union))
    return false;
  return true;
}

template <typename T, WrapperStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.object_union < rhs.object_union)
    return true;
  if (rhs.object_union < lhs.object_union)
    return false;
  if (lhs.pod_union < rhs.pod_union)
    return true;
  if (rhs.pod_union < lhs.pod_union)
    return false;
  if (lhs.handle_union < rhs.handle_union)
    return true;
  if (rhs.handle_union < lhs.handle_union)
    return false;
  return false;
}
template <typename StructPtrType>
DummyStructPtr DummyStruct::Clone() const {
  return New(
      mojo::Clone(f_int8)
  );
}

template <typename T, DummyStruct::EnableIfSame<T>*>
bool DummyStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int8, other_struct.f_int8))
    return false;
  return true;
}

template <typename T, DummyStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int8 < rhs.f_int8)
    return true;
  if (rhs.f_int8 < lhs.f_int8)
    return false;
  return false;
}
template <typename StructPtrType>
SmallStructPtr SmallStruct::Clone() const {
  return New(
      mojo::Clone(dummy_struct),
      mojo::Clone(pod_union),
      mojo::Clone(pod_union_array),
      mojo::Clone(nullable_pod_union_array),
      mojo::Clone(s_array),
      mojo::Clone(pod_union_map),
      mojo::Clone(nullable_pod_union_map)
  );
}

template <typename T, SmallStruct::EnableIfSame<T>*>
bool SmallStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->dummy_struct, other_struct.dummy_struct))
    return false;
  if (!mojo::Equals(this->pod_union, other_struct.pod_union))
    return false;
  if (!mojo::Equals(this->pod_union_array, other_struct.pod_union_array))
    return false;
  if (!mojo::Equals(this->nullable_pod_union_array, other_struct.nullable_pod_union_array))
    return false;
  if (!mojo::Equals(this->s_array, other_struct.s_array))
    return false;
  if (!mojo::Equals(this->pod_union_map, other_struct.pod_union_map))
    return false;
  if (!mojo::Equals(this->nullable_pod_union_map, other_struct.nullable_pod_union_map))
    return false;
  return true;
}

template <typename T, SmallStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.dummy_struct < rhs.dummy_struct)
    return true;
  if (rhs.dummy_struct < lhs.dummy_struct)
    return false;
  if (lhs.pod_union < rhs.pod_union)
    return true;
  if (rhs.pod_union < lhs.pod_union)
    return false;
  if (lhs.pod_union_array < rhs.pod_union_array)
    return true;
  if (rhs.pod_union_array < lhs.pod_union_array)
    return false;
  if (lhs.nullable_pod_union_array < rhs.nullable_pod_union_array)
    return true;
  if (rhs.nullable_pod_union_array < lhs.nullable_pod_union_array)
    return false;
  if (lhs.s_array < rhs.s_array)
    return true;
  if (rhs.s_array < lhs.s_array)
    return false;
  if (lhs.pod_union_map < rhs.pod_union_map)
    return true;
  if (rhs.pod_union_map < lhs.pod_union_map)
    return false;
  if (lhs.nullable_pod_union_map < rhs.nullable_pod_union_map)
    return true;
  if (rhs.nullable_pod_union_map < lhs.nullable_pod_union_map)
    return false;
  return false;
}
template <typename StructPtrType>
SmallStructNonNullableUnionPtr SmallStructNonNullableUnion::Clone() const {
  return New(
      mojo::Clone(pod_union)
  );
}

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>*>
bool SmallStructNonNullableUnion::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->pod_union, other_struct.pod_union))
    return false;
  return true;
}

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.pod_union < rhs.pod_union)
    return true;
  if (rhs.pod_union < lhs.pod_union)
    return false;
  return false;
}
template <typename StructPtrType>
SmallObjStructPtr SmallObjStruct::Clone() const {
  return New(
      mojo::Clone(obj_union),
      mojo::Clone(f_int8)
  );
}

template <typename T, SmallObjStruct::EnableIfSame<T>*>
bool SmallObjStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->obj_union, other_struct.obj_union))
    return false;
  if (!mojo::Equals(this->f_int8, other_struct.f_int8))
    return false;
  return true;
}

template <typename T, SmallObjStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.obj_union < rhs.obj_union)
    return true;
  if (rhs.obj_union < lhs.obj_union)
    return false;
  if (lhs.f_int8 < rhs.f_int8)
    return true;
  if (rhs.f_int8 < lhs.f_int8)
    return false;
  return false;
}
template <typename StructPtrType>
TryNonNullStructPtr TryNonNullStruct::Clone() const {
  return New(
      mojo::Clone(nullable),
      mojo::Clone(non_nullable)
  );
}

template <typename T, TryNonNullStruct::EnableIfSame<T>*>
bool TryNonNullStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->nullable, other_struct.nullable))
    return false;
  if (!mojo::Equals(this->non_nullable, other_struct.non_nullable))
    return false;
  return true;
}

template <typename T, TryNonNullStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.nullable < rhs.nullable)
    return true;
  if (rhs.nullable < lhs.nullable)
    return false;
  if (lhs.non_nullable < rhs.non_nullable)
    return true;
  if (rhs.non_nullable < lhs.non_nullable)
    return false;
  return false;
}
template <typename StructPtrType>
ImportedUnionStructPtr ImportedUnionStruct::Clone() const {
  return New(
      mojo::Clone(point_or_shape)
  );
}

template <typename T, ImportedUnionStruct::EnableIfSame<T>*>
bool ImportedUnionStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->point_or_shape, other_struct.point_or_shape))
    return false;
  return true;
}

template <typename T, ImportedUnionStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.point_or_shape < rhs.point_or_shape)
    return true;
  if (rhs.point_or_shape < lhs.point_or_shape)
    return false;
  return false;
}


}  // namespace test
}  // namespace mojo

namespace mojo {


template <>
struct  StructTraits<::mojo::test::WrapperStruct::DataView,
                                         ::mojo::test::WrapperStructPtr> {
  static bool IsNull(const ::mojo::test::WrapperStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::WrapperStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::WrapperStruct::object_union)& object_union(
      const ::mojo::test::WrapperStructPtr& input) {
    return input->object_union;
  }

  static const decltype(::mojo::test::WrapperStruct::pod_union)& pod_union(
      const ::mojo::test::WrapperStructPtr& input) {
    return input->pod_union;
  }

  static  decltype(::mojo::test::WrapperStruct::handle_union)& handle_union(
       ::mojo::test::WrapperStructPtr& input) {
    return input->handle_union;
  }

  static bool Read(::mojo::test::WrapperStruct::DataView input, ::mojo::test::WrapperStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::DummyStruct::DataView,
                                         ::mojo::test::DummyStructPtr> {
  static bool IsNull(const ::mojo::test::DummyStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::DummyStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::DummyStruct::f_int8) f_int8(
      const ::mojo::test::DummyStructPtr& input) {
    return input->f_int8;
  }

  static bool Read(::mojo::test::DummyStruct::DataView input, ::mojo::test::DummyStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::SmallStruct::DataView,
                                         ::mojo::test::SmallStructPtr> {
  static bool IsNull(const ::mojo::test::SmallStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::SmallStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::SmallStruct::dummy_struct)& dummy_struct(
      const ::mojo::test::SmallStructPtr& input) {
    return input->dummy_struct;
  }

  static const decltype(::mojo::test::SmallStruct::pod_union)& pod_union(
      const ::mojo::test::SmallStructPtr& input) {
    return input->pod_union;
  }

  static const decltype(::mojo::test::SmallStruct::pod_union_array)& pod_union_array(
      const ::mojo::test::SmallStructPtr& input) {
    return input->pod_union_array;
  }

  static const decltype(::mojo::test::SmallStruct::nullable_pod_union_array)& nullable_pod_union_array(
      const ::mojo::test::SmallStructPtr& input) {
    return input->nullable_pod_union_array;
  }

  static const decltype(::mojo::test::SmallStruct::s_array)& s_array(
      const ::mojo::test::SmallStructPtr& input) {
    return input->s_array;
  }

  static const decltype(::mojo::test::SmallStruct::pod_union_map)& pod_union_map(
      const ::mojo::test::SmallStructPtr& input) {
    return input->pod_union_map;
  }

  static const decltype(::mojo::test::SmallStruct::nullable_pod_union_map)& nullable_pod_union_map(
      const ::mojo::test::SmallStructPtr& input) {
    return input->nullable_pod_union_map;
  }

  static bool Read(::mojo::test::SmallStruct::DataView input, ::mojo::test::SmallStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::SmallStructNonNullableUnion::DataView,
                                         ::mojo::test::SmallStructNonNullableUnionPtr> {
  static bool IsNull(const ::mojo::test::SmallStructNonNullableUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::SmallStructNonNullableUnionPtr* output) { output->reset(); }

  static const decltype(::mojo::test::SmallStructNonNullableUnion::pod_union)& pod_union(
      const ::mojo::test::SmallStructNonNullableUnionPtr& input) {
    return input->pod_union;
  }

  static bool Read(::mojo::test::SmallStructNonNullableUnion::DataView input, ::mojo::test::SmallStructNonNullableUnionPtr* output);
};


template <>
struct  StructTraits<::mojo::test::SmallObjStruct::DataView,
                                         ::mojo::test::SmallObjStructPtr> {
  static bool IsNull(const ::mojo::test::SmallObjStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::SmallObjStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::SmallObjStruct::obj_union)& obj_union(
      const ::mojo::test::SmallObjStructPtr& input) {
    return input->obj_union;
  }

  static decltype(::mojo::test::SmallObjStruct::f_int8) f_int8(
      const ::mojo::test::SmallObjStructPtr& input) {
    return input->f_int8;
  }

  static bool Read(::mojo::test::SmallObjStruct::DataView input, ::mojo::test::SmallObjStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::TryNonNullStruct::DataView,
                                         ::mojo::test::TryNonNullStructPtr> {
  static bool IsNull(const ::mojo::test::TryNonNullStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::TryNonNullStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::TryNonNullStruct::nullable)& nullable(
      const ::mojo::test::TryNonNullStructPtr& input) {
    return input->nullable;
  }

  static const decltype(::mojo::test::TryNonNullStruct::non_nullable)& non_nullable(
      const ::mojo::test::TryNonNullStructPtr& input) {
    return input->non_nullable;
  }

  static bool Read(::mojo::test::TryNonNullStruct::DataView input, ::mojo::test::TryNonNullStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::ImportedUnionStruct::DataView,
                                         ::mojo::test::ImportedUnionStructPtr> {
  static bool IsNull(const ::mojo::test::ImportedUnionStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::ImportedUnionStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::ImportedUnionStruct::point_or_shape)& point_or_shape(
      const ::mojo::test::ImportedUnionStructPtr& input) {
    return input->point_or_shape;
  }

  static bool Read(::mojo::test::ImportedUnionStruct::DataView input, ::mojo::test::ImportedUnionStructPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::PodUnion::DataView,
                                        ::mojo::test::PodUnionPtr> {
  static bool IsNull(const ::mojo::test::PodUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::PodUnionPtr* output) { output->reset(); }

  static ::mojo::test::PodUnion::Tag GetTag(const ::mojo::test::PodUnionPtr& input) {
    return input->which();
  }

  static  int8_t f_int8(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_int8();
  }

  static  int8_t f_int8_other(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_int8_other();
  }

  static  uint8_t f_uint8(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_uint8();
  }

  static  int16_t f_int16(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_int16();
  }

  static  uint16_t f_uint16(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_uint16();
  }

  static  int32_t f_int32(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_int32();
  }

  static  uint32_t f_uint32(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_uint32();
  }

  static  int64_t f_int64(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_int64();
  }

  static  uint64_t f_uint64(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_uint64();
  }

  static  float f_float(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_float();
  }

  static  double f_double(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_double();
  }

  static  bool f_bool(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_bool();
  }

  static  ::mojo::test::AnEnum f_enum(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_enum();
  }

  static  ::mojo::test::AnExtensibleEnum f_extensible_enum(const ::mojo::test::PodUnionPtr& input) {
    return input->get_f_extensible_enum();
  }

  static bool Read(::mojo::test::PodUnion::DataView input, ::mojo::test::PodUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::ObjectUnion::DataView,
                                        ::mojo::test::ObjectUnionPtr> {
  static bool IsNull(const ::mojo::test::ObjectUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::ObjectUnionPtr* output) { output->reset(); }

  static ::mojo::test::ObjectUnion::Tag GetTag(const ::mojo::test::ObjectUnionPtr& input) {
    return input->which();
  }

  static  int8_t f_int8(const ::mojo::test::ObjectUnionPtr& input) {
    return input->get_f_int8();
  }

  static const std::string& f_string(const ::mojo::test::ObjectUnionPtr& input) {
    return input->get_f_string();
  }

  static const ::mojo::test::DummyStructPtr& f_dummy(const ::mojo::test::ObjectUnionPtr& input) {
    return input->get_f_dummy();
  }

  static const ::mojo::test::DummyStructPtr& f_nullable(const ::mojo::test::ObjectUnionPtr& input) {
    return input->get_f_nullable();
  }

  static const std::vector<int8_t>& f_array_int8(const ::mojo::test::ObjectUnionPtr& input) {
    return input->get_f_array_int8();
  }

  static const base::flat_map<std::string, int8_t>& f_map_int8(const ::mojo::test::ObjectUnionPtr& input) {
    return input->get_f_map_int8();
  }

  static const ::mojo::test::PodUnionPtr& f_pod_union(const ::mojo::test::ObjectUnionPtr& input) {
    return input->get_f_pod_union();
  }

  static const std::vector<::mojo::test::SmallStructPtr>& f_small_structs(const ::mojo::test::ObjectUnionPtr& input) {
    return input->get_f_small_structs();
  }

  static bool Read(::mojo::test::ObjectUnion::DataView input, ::mojo::test::ObjectUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::HandleUnion::DataView,
                                        ::mojo::test::HandleUnionPtr> {
  static bool IsNull(const ::mojo::test::HandleUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::HandleUnionPtr* output) { output->reset(); }

  static ::mojo::test::HandleUnion::Tag GetTag(const ::mojo::test::HandleUnionPtr& input) {
    return input->which();
  }

  static  ::mojo::ScopedHandle& f_handle( ::mojo::test::HandleUnionPtr& input) {
    return input->get_f_handle();
  }

  static  ::mojo::ScopedMessagePipeHandle& f_message_pipe( ::mojo::test::HandleUnionPtr& input) {
    return input->get_f_message_pipe();
  }

  static  ::mojo::ScopedDataPipeConsumerHandle& f_data_pipe_consumer( ::mojo::test::HandleUnionPtr& input) {
    return input->get_f_data_pipe_consumer();
  }

  static  ::mojo::ScopedDataPipeProducerHandle& f_data_pipe_producer( ::mojo::test::HandleUnionPtr& input) {
    return input->get_f_data_pipe_producer();
  }

  static  ::mojo::ScopedSharedBufferHandle& f_shared_buffer( ::mojo::test::HandleUnionPtr& input) {
    return input->get_f_shared_buffer();
  }

  static  ::mojo::PlatformHandle& f_platform( ::mojo::test::HandleUnionPtr& input) {
    return input->get_f_platform();
  }

  static  ::mojo::PendingRemote<::mojo::test::SmallCache>& f_small_cache( ::mojo::test::HandleUnionPtr& input) {
    return input->get_f_small_cache();
  }

  static  ::mojo::PendingReceiver<::mojo::test::SmallCache>& f_small_cache_receiver( ::mojo::test::HandleUnionPtr& input) {
    return input->get_f_small_cache_receiver();
  }

  static bool Read(::mojo::test::HandleUnion::DataView input, ::mojo::test::HandleUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::OldUnion::DataView,
                                        ::mojo::test::OldUnionPtr> {
  static bool IsNull(const ::mojo::test::OldUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::OldUnionPtr* output) { output->reset(); }

  static ::mojo::test::OldUnion::Tag GetTag(const ::mojo::test::OldUnionPtr& input) {
    return input->which();
  }

  static  int8_t f_int8(const ::mojo::test::OldUnionPtr& input) {
    return input->get_f_int8();
  }

  static bool Read(::mojo::test::OldUnion::DataView input, ::mojo::test::OldUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::NewUnion::DataView,
                                        ::mojo::test::NewUnionPtr> {
  static bool IsNull(const ::mojo::test::NewUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::NewUnionPtr* output) { output->reset(); }

  static ::mojo::test::NewUnion::Tag GetTag(const ::mojo::test::NewUnionPtr& input) {
    return input->which();
  }

  static  int8_t f_int8(const ::mojo::test::NewUnionPtr& input) {
    return input->get_f_int8();
  }

  static  int16_t f_int16(const ::mojo::test::NewUnionPtr& input) {
    return input->get_f_int16();
  }

  static bool Read(::mojo::test::NewUnion::DataView input, ::mojo::test::NewUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::ImportedUnionUnion::DataView,
                                        ::mojo::test::ImportedUnionUnionPtr> {
  static bool IsNull(const ::mojo::test::ImportedUnionUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::ImportedUnionUnionPtr* output) { output->reset(); }

  static ::mojo::test::ImportedUnionUnion::Tag GetTag(const ::mojo::test::ImportedUnionUnionPtr& input) {
    return input->which();
  }

  static const ::imported::PointOrShapePtr& point_or_shape(const ::mojo::test::ImportedUnionUnionPtr& input) {
    return input->get_point_or_shape();
  }

  static bool Read(::mojo::test::ImportedUnionUnion::DataView input, ::mojo::test::ImportedUnionUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::UnionWithStringForFirstField::DataView,
                                        ::mojo::test::UnionWithStringForFirstFieldPtr> {
  static bool IsNull(const ::mojo::test::UnionWithStringForFirstFieldPtr& input) { return !input; }
  static void SetToNull(::mojo::test::UnionWithStringForFirstFieldPtr* output) { output->reset(); }

  static ::mojo::test::UnionWithStringForFirstField::Tag GetTag(const ::mojo::test::UnionWithStringForFirstFieldPtr& input) {
    return input->which();
  }

  static const std::string& s(const ::mojo::test::UnionWithStringForFirstFieldPtr& input) {
    return input->get_s();
  }

  static  int32_t i(const ::mojo::test::UnionWithStringForFirstFieldPtr& input) {
    return input->get_i();
  }

  static bool Read(::mojo::test::UnionWithStringForFirstField::DataView input, ::mojo::test::UnionWithStringForFirstFieldPtr* output);
};

}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_H_

/* Metadata comment
eyJtZXRhIjogW3siZW5kIjogMTk0MCwgImJlZ2luIjogMTkzMCwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbENhY2hlIn19LCB7ImVuZCI6
IDI2NTcsICJiZWdpbiI6IDI2NDYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuU21hbGxDYWNoZS5TZXRJbnRWYWx1ZSJ9fSwgeyJlbmQiOiAyODMx
LCAiYmVnaW4iOiAyODIwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LlNtYWxsQ2FjaGUuR2V0SW50VmFsdWUifX0sIHsiZW5kIjogMzEwNSwgImJl
Z2luIjogMzA5MSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5VbmlvbkludGVyZmFjZSJ9fSwgeyJlbmQiOiAzODY0LCAiYmVnaW4iOiAzODYwLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuaW9u
SW50ZXJmYWNlLkVjaG8ifX0sIHsiZW5kIjogNDIwMywgImJlZ2luIjogNDE5MiwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbENhY2hlLlNl
dEludFZhbHVlIn19LCB7ImVuZCI6IDQzMDQsICJiZWdpbiI6IDQyOTMsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxDYWNoZS5HZXRJbnRW
YWx1ZSJ9fSwgeyJlbmQiOiA0NzAyLCAiYmVnaW4iOiA0Njk4LCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuaW9uSW50ZXJmYWNlLkVjaG8ifX0s
IHsiZW5kIjogNzkzOCwgImJlZ2luIjogNzkyNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EdW1teVN0cnVjdCJ9fSwgeyJlbmQiOiAxMTUzNiwg
ImJlZ2luIjogMTE1MzAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuRHVtbXlTdHJ1Y3QuZl9pbnQ4In19LCB7ImVuZCI6IDEyNTU3LCAiYmVnaW4i
OiAxMjU0OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5Qb2RVbmlvbiJ9fSwgeyJlbmQiOiAxNzE2MCwgImJlZ2luIjogMTcxNTEsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9p
bnQ4In19LCB7ImVuZCI6IDE3MjcwLCAiYmVnaW4iOiAxNzI2MCwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDgifX0sIHsi
ZW5kIjogMTc0MTAsICJiZWdpbiI6IDE3NDAwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlBvZFVuaW9uLmZfaW50OCJ9fSwgeyJlbmQiOiAxNzUx
MSwgImJlZ2luIjogMTc0OTYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQ4X290aGVyIn19LCB7ImVuZCI6IDE3NjM5LCAi
YmVnaW4iOiAxNzYyMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDhfb3RoZXIifX0sIHsiZW5kIjogMTc4MDMsICJiZWdp
biI6IDE3Nzg3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlBvZFVuaW9uLmZfaW50OF9vdGhlciJ9fSwgeyJlbmQiOiAxNzkwMCwgImJlZ2luIjog
MTc4OTAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuUG9kVW5pb24uZl91aW50OCJ9fSwgeyJlbmQiOiAxODAxNCwgImJlZ2luIjogMTgwMDMsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5p
b24uZl91aW50OCJ9fSwgeyJlbmQiOiAxODE1OCwgImJlZ2luIjogMTgxNDcsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl91aW50
OCJ9fSwgeyJlbmQiOiAxODI1MSwgImJlZ2luIjogMTgyNDEsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQxNiJ9fSwgeyJl
bmQiOiAxODM2NSwgImJlZ2luIjogMTgzNTQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQxNiJ9fSwgeyJlbmQiOiAxODUw
OSwgImJlZ2luIjogMTg0OTgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQxNiJ9fSwgeyJlbmQiOiAxODYwNCwgImJlZ2lu
IjogMTg1OTMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuUG9kVW5pb24uZl91aW50MTYifX0sIHsiZW5kIjogMTg3MjIsICJiZWdpbiI6IDE4NzEw
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlBv
ZFVuaW9uLmZfdWludDE2In19LCB7ImVuZCI6IDE4ODcwLCAiYmVnaW4iOiAxODg1OCwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5m
X3VpbnQxNiJ9fSwgeyJlbmQiOiAxODk2NSwgImJlZ2luIjogMTg5NTUsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQzMiJ9
fSwgeyJlbmQiOiAxOTA3OSwgImJlZ2luIjogMTkwNjgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQzMiJ9fSwgeyJlbmQi
OiAxOTIyMywgImJlZ2luIjogMTkyMTIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQzMiJ9fSwgeyJlbmQiOiAxOTMxOCwg
ImJlZ2luIjogMTkzMDcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuUG9kVW5pb24uZl91aW50MzIifX0sIHsiZW5kIjogMTk0MzYsICJiZWdpbiI6
IDE5NDI0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0LlBvZFVuaW9uLmZfdWludDMyIn19LCB7ImVuZCI6IDE5NTg0LCAiYmVnaW4iOiAxOTU3Miwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RV
bmlvbi5mX3VpbnQzMiJ9fSwgeyJlbmQiOiAxOTY3OSwgImJlZ2luIjogMTk2NjksICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9p
bnQ2NCJ9fSwgeyJlbmQiOiAxOTc5MywgImJlZ2luIjogMTk3ODIsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQ2NCJ9fSwg
eyJlbmQiOiAxOTkzNywgImJlZ2luIjogMTk5MjYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQ2NCJ9fSwgeyJlbmQiOiAy
MDAzMiwgImJlZ2luIjogMjAwMjEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl91aW50NjQifX0sIHsiZW5kIjogMjAxNTAsICJi
ZWdpbiI6IDIwMTM4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0LlBvZFVuaW9uLmZfdWludDY0In19LCB7ImVuZCI6IDIwMjk4LCAiYmVnaW4iOiAy
MDI4NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9k
ZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9j
aHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVz
dC5Qb2RVbmlvbi5mX3VpbnQ2NCJ9fSwgeyJlbmQiOiAyMDM5MywgImJlZ2luIjogMjAzODMsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5p
b24uZl9mbG9hdCJ9fSwgeyJlbmQiOiAyMDUwNSwgImJlZ2luIjogMjA0OTQsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9mbG9h
dCJ9fSwgeyJlbmQiOiAyMDY0OSwgImJlZ2luIjogMjA2MzgsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9mbG9hdCJ9fSwgeyJl
bmQiOiAyMDc0MiwgImJlZ2luIjogMjA3MzEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9kb3VibGUifX0sIHsiZW5kIjogMjA4
NTgsICJiZWdpbiI6IDIwODQ2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0LlBvZFVuaW9uLmZfZG91YmxlIn19LCB7ImVuZCI6IDIxMDA2LCAiYmVn
aW4iOiAyMDk5NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5Qb2RVbmlvbi5mX2RvdWJsZSJ9fSwgeyJlbmQiOiAyMTA5NywgImJlZ2luIjogMjEw
ODgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
UG9kVW5pb24uZl9ib29sIn19LCB7ImVuZCI6IDIxMjA1LCAiYmVnaW4iOiAyMTE5NSwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5m
X2Jvb2wifX0sIHsiZW5kIjogMjEzNDUsICJiZWdpbiI6IDIxMzM1LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlBvZFVuaW9uLmZfYm9vbCJ9fSwg
eyJlbmQiOiAyMTQzMiwgImJlZ2luIjogMjE0MjMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9lbnVtIn19LCB7ImVuZCI6IDIx
NTQyLCAiYmVnaW4iOiAyMTUzMiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2VudW0ifX0sIHsiZW5kIjogMjE2ODIsICJiZWdp
biI6IDIxNjcyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlBvZFVuaW9uLmZfZW51bSJ9fSwgeyJlbmQiOiAyMTc5MywgImJlZ2luIjogMjE3NzMs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9k
VW5pb24uZl9leHRlbnNpYmxlX2VudW0ifX0sIHsiZW5kIjogMjE5NDYsICJiZWdpbiI6IDIxOTI1
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlBv
ZFVuaW9uLmZfZXh0ZW5zaWJsZV9lbnVtIn19LCB7ImVuZCI6IDIyMTMwLCAiYmVnaW4iOiAyMjEw
OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Q
b2RVbmlvbi5mX2V4dGVuc2libGVfZW51bSJ9fSwgeyJlbmQiOiAyMzI3MSwgImJlZ2luIjogMjMy
NjAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
T2JqZWN0VW5pb24ifX0sIHsiZW5kIjogMjY3MzgsICJiZWdpbiI6IDI2NzI5LCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZf
aW50OCJ9fSwgeyJlbmQiOiAyNjg1MSwgImJlZ2luIjogMjY4NDEsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9pbnQ4In19
LCB7ImVuZCI6IDI2OTk0LCAiYmVnaW4iOiAyNjk4NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX2ludDgifX0sIHsiZW5k
IjogMjcwOTAsICJiZWdpbiI6IDI3MDc5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfc3RyaW5nIn19LCB7ImVuZCI6IDI3
MjE1LCAiYmVnaW4iOiAyNzIwMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX3N0cmluZyJ9fSwgeyJlbmQiOiAyNzM2OSwg
ImJlZ2luIjogMjczNTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9zdHJpbmcifX0sIHsiZW5kIjogMjc0NzcsICJiZWdp
biI6IDI3NDY3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0Lk9iamVjdFVuaW9uLmZfZHVtbXkifX0sIHsiZW5kIjogMjc2MDIsICJiZWdpbiI6IDI3
NTkxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
Lk9iamVjdFVuaW9uLmZfZHVtbXkifX0sIHsiZW5kIjogMjc3NTIsICJiZWdpbiI6IDI3NzQxLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVj
dFVuaW9uLmZfZHVtbXkifX0sIHsiZW5kIjogMjc4NjEsICJiZWdpbiI6IDI3ODQ4LCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9u
LmZfbnVsbGFibGUifX0sIHsiZW5kIjogMjc5OTUsICJiZWdpbiI6IDI3OTgxLCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZf
bnVsbGFibGUifX0sIHsiZW5kIjogMjgxNTcsICJiZWdpbiI6IDI4MTQzLCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfbnVs
bGFibGUifX0sIHsiZW5kIjogMjgyNzMsICJiZWdpbiI6IDI4MjU4LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfYXJyYXlf
aW50OCJ9fSwgeyJlbmQiOiAyODQxOCwgImJlZ2luIjogMjg0MDIsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9hcnJheV9p
bnQ4In19LCB7ImVuZCI6IDI4NTg4LCAiYmVnaW4iOiAyODU3MiwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX2FycmF5X2lu
dDgifX0sIHsiZW5kIjogMjg3MDcsICJiZWdpbiI6IDI4Njk0LCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfbWFwX2ludDgi
fX0sIHsiZW5kIjogMjg4NjIsICJiZWdpbiI6IDI4ODQ4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfbWFwX2ludDgifX0s
IHsiZW5kIjogMjkwMjQsICJiZWdpbiI6IDI5MDEwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfbWFwX2ludDgifX0sIHsi
ZW5kIjogMjkxNjYsICJiZWdpbiI6IDI5MTUyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfcG9kX3VuaW9uIn19LCB7ImVu
ZCI6IDI5MzAwLCAiYmVnaW4iOiAyOTI4NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX3BvZF91bmlvbiJ9fSwgeyJlbmQi
OiAyOTQ2NiwgImJlZ2luIjogMjk0NTEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9wb2RfdW5pb24ifX0sIHsiZW5kIjog
Mjk1ODYsICJiZWdpbiI6IDI5NTY4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfc21hbGxfc3RydWN0cyJ9fSwgeyJlbmQi
OiAyOTc0OCwgImJlZ2luIjogMjk3MjksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9zbWFsbF9zdHJ1Y3RzIn19LCB7ImVu
ZCI6IDI5OTMwLCAiYmVnaW4iOiAyOTkxMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX3NtYWxsX3N0cnVjdHMifX0sIHsi
ZW5kIjogMzEwNTIsICJiZWdpbiI6IDMxMDQxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uIn19LCB7ImVuZCI6IDM0ODI3LCAi
YmVnaW4iOiAzNDgxNiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5IYW5kbGVVbmlvbi5mX2hhbmRsZSJ9fSwgeyJlbmQiOiAzNDk2MSwgImJlZ2lu
IjogMzQ5NDksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuSGFuZGxlVW5pb24uZl9oYW5kbGUifX0sIHsiZW5kIjogMzUxMTUsICJiZWdpbiI6IDM1
MTAzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkhhbmRsZVVuaW9uLmZfaGFuZGxlIn19LCB7ImVuZCI6IDM1MjM5LCAiYmVnaW4iOiAzNTIyMiwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5k
bGVVbmlvbi5mX21lc3NhZ2VfcGlwZSJ9fSwgeyJlbmQiOiAzNTQwMiwgImJlZ2luIjogMzUzODQs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSGFu
ZGxlVW5pb24uZl9tZXNzYWdlX3BpcGUifX0sIHsiZW5kIjogMzU1ODAsICJiZWdpbiI6IDM1NTYy
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lkhh
bmRsZVVuaW9uLmZfbWVzc2FnZV9waXBlIn19LCB7ImVuZCI6IDM1NzMzLCAiYmVnaW4iOiAzNTcx
MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5I
YW5kbGVVbmlvbi5mX2RhdGFfcGlwZV9jb25zdW1lciJ9fSwgeyJlbmQiOiAzNTkxOSwgImJlZ2lu
IjogMzU4OTUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuSGFuZGxlVW5pb24uZl9kYXRhX3BpcGVfY29uc3VtZXIifX0sIHsiZW5kIjogMzYxMjEs
ICJiZWdpbiI6IDM2MDk3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZfZGF0YV9waXBlX2NvbnN1bWVyIn19LCB7ImVuZCI6
IDM2Mjg1LCAiYmVnaW4iOiAzNjI2MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5mX2RhdGFfcGlwZV9wcm9kdWNlciJ9fSwg
eyJlbmQiOiAzNjQ3MSwgImJlZ2luIjogMzY0NDcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSGFuZGxlVW5pb24uZl9kYXRhX3BpcGVfcHJvZHVj
ZXIifX0sIHsiZW5kIjogMzY2NzMsICJiZWdpbiI6IDM2NjQ5LCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZfZGF0YV9waXBl
X3Byb2R1Y2VyIn19LCB7ImVuZCI6IDM2ODI3LCAiYmVnaW4iOiAzNjgwOSwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5mX3No
YXJlZF9idWZmZXIifX0sIHsiZW5kIjogMzY5OTQsICJiZWdpbiI6IDM2OTc1LCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZf
c2hhcmVkX2J1ZmZlciJ9fSwgeyJlbmQiOiAzNzE3NiwgImJlZ2luIjogMzcxNTcsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSGFuZGxlVW5pb24u
Zl9zaGFyZWRfYnVmZmVyIn19LCB7ImVuZCI6IDM3MzExLCAiYmVnaW4iOiAzNzI5OCwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlv
bi5mX3BsYXRmb3JtIn19LCB7ImVuZCI6IDM3NDUzLCAiYmVnaW4iOiAzNzQzOSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5m
X3BsYXRmb3JtIn19LCB7ImVuZCI6IDM3NjE1LCAiYmVnaW4iOiAzNzYwMSwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5mX3Bs
YXRmb3JtIn19LCB7ImVuZCI6IDM3NzQxLCAiYmVnaW4iOiAzNzcyNSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5mX3NtYWxs
X2NhY2hlIn19LCB7ImVuZCI6IDM3OTAzLCAiYmVnaW4iOiAzNzg4NiwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5mX3NtYWxs
X2NhY2hlIn19LCB7ImVuZCI6IDM4MDc3LCAiYmVnaW4iOiAzODA2MCwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5mX3NtYWxs
X2NhY2hlIn19LCB7ImVuZCI6IDM4MjM1LCAiYmVnaW4iOiAzODIxMCwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5mX3NtYWxs
X2NhY2hlX3JlY2VpdmVyIn19LCB7ImVuZCI6IDM4NDI2LCAiYmVnaW4iOiAzODQwMCwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlv
bi5mX3NtYWxsX2NhY2hlX3JlY2VpdmVyIn19LCB7ImVuZCI6IDM4NjM2LCAiYmVnaW4iOiAzODYx
MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5I
YW5kbGVVbmlvbi5mX3NtYWxsX2NhY2hlX3JlY2VpdmVyIn19LCB7ImVuZCI6IDM5OTE5LCAiYmVn
aW4iOiAzOTkxMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5PbGRVbmlvbiJ9fSwgeyJlbmQiOiA0MTU3NSwgImJlZ2luIjogNDE1NjYsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2xkVW5pb24u
Zl9pbnQ4In19LCB7ImVuZCI6IDQxNjg1LCAiYmVnaW4iOiA0MTY3NSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5PbGRVbmlvbi5mX2ludDgifX0s
IHsiZW5kIjogNDE4MjUsICJiZWdpbiI6IDQxODE1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9sZFVuaW9uLmZfaW50OCJ9fSwgeyJlbmQiOiA0
MjY0NSwgImJlZ2luIjogNDI2MzcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuTmV3VW5pb24ifX0sIHsiZW5kIjogNDQ1MjEsICJiZWdpbiI6IDQ0
NTEyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
Lk5ld1VuaW9uLmZfaW50OCJ9fSwgeyJlbmQiOiA0NDYzMSwgImJlZ2luIjogNDQ2MjEsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTmV3VW5pb24u
Zl9pbnQ4In19LCB7ImVuZCI6IDQ0NzcxLCAiYmVnaW4iOiA0NDc2MSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5OZXdVbmlvbi5mX2ludDgifX0s
IHsiZW5kIjogNDQ4NjIsICJiZWdpbiI6IDQ0ODUyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5ld1VuaW9uLmZfaW50MTYifX0sIHsiZW5kIjog
NDQ5NzYsICJiZWdpbiI6IDQ0OTY1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0Lk5ld1VuaW9uLmZfaW50MTYifX0sIHsiZW5kIjogNDUxMjAsICJi
ZWdpbiI6IDQ1MTA5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0Lk5ld1VuaW9uLmZfaW50MTYifX0sIHsiZW5kIjogNDU5ODMsICJiZWdpbiI6IDQ1
OTY1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkltcG9ydGVkVW5pb25VbmlvbiJ9fSwgeyJlbmQiOiA0Nzg4NSwgImJlZ2luIjogNDc4NjgsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW1wb3J0
ZWRVbmlvblVuaW9uLnBvaW50X29yX3NoYXBlIn19LCB7ImVuZCI6IDQ4MDUxLCAiYmVnaW4iOiA0
ODAzMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9k
ZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9j
aHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVz
dC5JbXBvcnRlZFVuaW9uVW5pb24ucG9pbnRfb3Jfc2hhcGUifX0sIHsiZW5kIjogNDgyMzYsICJi
ZWdpbiI6IDQ4MjE4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0LkltcG9ydGVkVW5pb25Vbmlvbi5wb2ludF9vcl9zaGFwZSJ9fSwgeyJlbmQiOiA0
OTE3NSwgImJlZ2luIjogNDkxNDcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuVW5pb25XaXRoU3RyaW5nRm9yRmlyc3RGaWVsZCJ9fSwgeyJlbmQi
OiA1MTM4MCwgImJlZ2luIjogNTEzNzYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuVW5pb25XaXRoU3RyaW5nRm9yRmlyc3RGaWVsZC5zIn19LCB7
ImVuZCI6IDUxNTAxLCAiYmVnaW4iOiA1MTQ5NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5VbmlvbldpdGhTdHJpbmdGb3JGaXJzdEZpZWxkLnMi
fX0sIHsiZW5kIjogNTE2NDQsICJiZWdpbiI6IDUxNjM5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuaW9uV2l0aFN0cmluZ0ZvckZpcnN0Rmll
bGQucyJ9fSwgeyJlbmQiOiA1MTc1MCwgImJlZ2luIjogNTE3NDYsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5pb25XaXRoU3RyaW5nRm9yRmly
c3RGaWVsZC5pIn19LCB7ImVuZCI6IDUxODY2LCAiYmVnaW4iOiA1MTg2MSwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5VbmlvbldpdGhTdHJpbmdG
b3JGaXJzdEZpZWxkLmkifX0sIHsiZW5kIjogNTIwMDYsICJiZWdpbiI6IDUyMDAxLCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuaW9uV2l0aFN0
cmluZ0ZvckZpcnN0RmllbGQuaSJ9fSwgeyJlbmQiOiA1Mjg5MCwgImJlZ2luIjogNTI4NzcsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuV3JhcHBl
clN0cnVjdCJ9fSwgeyJlbmQiOiA1NjM5NCwgImJlZ2luIjogNTYzODIsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuV3JhcHBlclN0cnVjdC5vYmpl
Y3RfdW5pb24ifX0sIHsiZW5kIjogNTY0NzYsICJiZWdpbiI6IDU2NDY3LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LldyYXBwZXJTdHJ1Y3QucG9k
X3VuaW9uIn19LCB7ImVuZCI6IDU2NTY3LCAiYmVnaW4iOiA1NjU1NSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5XcmFwcGVyU3RydWN0LmhhbmRs
ZV91bmlvbiJ9fSwgeyJlbmQiOiA1NzY0MSwgImJlZ2luIjogNTc2MzAsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxTdHJ1Y3QifX0sIHsi
ZW5kIjogNjE2MjAsICJiZWdpbiI6IDYxNjA4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNtYWxsU3RydWN0LmR1bW15X3N0cnVjdCJ9fSwgeyJl
bmQiOiA2MTcwMCwgImJlZ2luIjogNjE2OTEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxTdHJ1Y3QucG9kX3VuaW9uIn19LCB7ImVuZCI6
IDYxODIxLCAiYmVnaW4iOiA2MTgwNiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5TbWFsbFN0cnVjdC5wb2RfdW5pb25fYXJyYXkifX0sIHsiZW5k
IjogNjE5NjAsICJiZWdpbiI6IDYxOTM2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0LlNtYWxsU3RydWN0Lm51bGxhYmxlX3BvZF91bmlvbl9hcnJh
eSJ9fSwgeyJlbmQiOiA2MjA2OCwgImJlZ2luIjogNjIwNjEsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxTdHJ1Y3Quc19hcnJheSJ9fSwg
eyJlbmQiOiA2MjIwMSwgImJlZ2luIjogNjIxODgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxTdHJ1Y3QucG9kX3VuaW9uX21hcCJ9fSwg
eyJlbmQiOiA2MjM1MiwgImJlZ2luIjogNjIzMzAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxTdHJ1Y3QubnVsbGFibGVfcG9kX3VuaW9u
X21hcCJ9fSwgeyJlbmQiOiA2MzQ0NywgImJlZ2luIjogNjM0MjAsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxTdHJ1Y3ROb25OdWxsYWJs
ZVVuaW9uIn19LCB7ImVuZCI6IDY3NDY0LCAiYmVnaW4iOiA2NzQ1NSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbFN0cnVjdE5vbk51bGxh
YmxlVW5pb24ucG9kX3VuaW9uIn19LCB7ImVuZCI6IDY4NjEzLCAiYmVnaW4iOiA2ODU5OSwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbE9i
alN0cnVjdCJ9fSwgeyJlbmQiOiA3MjI4OSwgImJlZ2luIjogNzIyODAsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxPYmpTdHJ1Y3Qub2Jq
X3VuaW9uIn19LCB7ImVuZCI6IDcyMzYxLCAiYmVnaW4iOiA3MjM1NSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbE9ialN0cnVjdC5mX2lu
dDgifX0sIHsiZW5kIjogNzM0NDksICJiZWdpbiI6IDczNDMzLCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlRyeU5vbk51bGxTdHJ1Y3QifX0sIHsi
ZW5kIjogNzcxODYsICJiZWdpbiI6IDc3MTc4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlRyeU5vbk51bGxTdHJ1Y3QubnVsbGFibGUifX0sIHsi
ZW5kIjogNzcyODAsICJiZWdpbiI6IDc3MjY4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlRyeU5vbk51bGxTdHJ1Y3Qubm9uX251bGxhYmxlIn19
LCB7ImVuZCI6IDc4Mzg0LCAiYmVnaW4iOiA3ODM2NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbXBvcnRlZFVuaW9uU3RydWN0In19LCB7ImVu
ZCI6IDgyMjQ4LCAiYmVnaW4iOiA4MjIzNCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5JbXBvcnRlZFVuaW9uU3RydWN0LnBvaW50X29yX3NoYXBl
In19XSwgInR5cGUiOiAia3l0aGUwIn0=
*/