// mojo/public/interfaces/bindings/tests/test_unions.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_SHARED_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <ostream>
#include <type_traits>
#include <utility>

#include "base/compiler_specific.h"
#include "base/containers/flat_map.h"
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
#include "mojo/public/interfaces/bindings/tests/test_unions.mojom-shared-internal.h"
#include "mojo/public/interfaces/bindings/tests/sample_import.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"



#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif


namespace mojo {
namespace test {
class WrapperStructDataView;

class DummyStructDataView;

class SmallStructDataView;

class SmallStructNonNullableUnionDataView;

class SmallObjStructDataView;

class TryNonNullStructDataView;

class ImportedUnionStructDataView;

class PodUnionDataView;
class ObjectUnionDataView;
class HandleUnionDataView;
class OldUnionDataView;
class NewUnionDataView;
class ImportedUnionUnionDataView;
class UnionWithStringForFirstFieldDataView;


}  // namespace test
}  // namespace mojo

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::mojo::test::WrapperStructDataView> {
  using Data = ::mojo::test::internal::WrapperStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojo::test::DummyStructDataView> {
  using Data = ::mojo::test::internal::DummyStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojo::test::SmallStructDataView> {
  using Data = ::mojo::test::internal::SmallStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojo::test::SmallStructNonNullableUnionDataView> {
  using Data = ::mojo::test::internal::SmallStructNonNullableUnion_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojo::test::SmallObjStructDataView> {
  using Data = ::mojo::test::internal::SmallObjStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojo::test::TryNonNullStructDataView> {
  using Data = ::mojo::test::internal::TryNonNullStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojo::test::ImportedUnionStructDataView> {
  using Data = ::mojo::test::internal::ImportedUnionStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojo::test::PodUnionDataView> {
  using Data = ::mojo::test::internal::PodUnion_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::mojo::test::ObjectUnionDataView> {
  using Data = ::mojo::test::internal::ObjectUnion_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::mojo::test::HandleUnionDataView> {
  using Data = ::mojo::test::internal::HandleUnion_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::mojo::test::OldUnionDataView> {
  using Data = ::mojo::test::internal::OldUnion_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::mojo::test::NewUnionDataView> {
  using Data = ::mojo::test::internal::NewUnion_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::mojo::test::ImportedUnionUnionDataView> {
  using Data = ::mojo::test::internal::ImportedUnionUnion_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::mojo::test::UnionWithStringForFirstFieldDataView> {
  using Data = ::mojo::test::internal::UnionWithStringForFirstField_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace mojo {
namespace test {


// @generated_from: mojo.test.AnEnum
enum class AnEnum : int32_t {
  
// @generated_from: mojo.test.AnEnum.FIRST
  FIRST = 0,
  
// @generated_from: mojo.test.AnEnum.SECOND
  SECOND = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, AnEnum value);
inline bool IsKnownEnumValue(AnEnum value) {
  return internal::AnEnum_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


// @generated_from: mojo.test.AnExtensibleEnum
enum class AnExtensibleEnum : int32_t {
  
// @generated_from: mojo.test.AnExtensibleEnum.FIRST
  FIRST = 0,
  
// @generated_from: mojo.test.AnExtensibleEnum.SECOND
  SECOND = 1,
  
// @generated_from: mojo.test.AnExtensibleEnum.THIRD
  THIRD = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, AnExtensibleEnum value);
inline bool IsKnownEnumValue(AnExtensibleEnum value) {
  return internal::AnExtensibleEnum_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class SmallCacheInterfaceBase {};

using SmallCachePtrDataView =
    mojo::InterfacePtrDataView<SmallCacheInterfaceBase>;
using SmallCacheRequestDataView =
    mojo::InterfaceRequestDataView<SmallCacheInterfaceBase>;
using SmallCacheAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<SmallCacheInterfaceBase>;
using SmallCacheAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<SmallCacheInterfaceBase>;
class UnionInterfaceInterfaceBase {};

using UnionInterfacePtrDataView =
    mojo::InterfacePtrDataView<UnionInterfaceInterfaceBase>;
using UnionInterfaceRequestDataView =
    mojo::InterfaceRequestDataView<UnionInterfaceInterfaceBase>;
using UnionInterfaceAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<UnionInterfaceInterfaceBase>;
using UnionInterfaceAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<UnionInterfaceInterfaceBase>;


class WrapperStructDataView {
 public:
  WrapperStructDataView() {}

  WrapperStructDataView(
      internal::WrapperStruct_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetObjectUnionDataView(
      ObjectUnionDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadObjectUnion(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo::test::ObjectUnionDataView, UserType>(),
    "Attempting to read the optional `object_union` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadObjectUnion` instead "
    "of `ReadObjectUnion if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = !data_->object_union.is_null() ? &data_->object_union : nullptr;
    return mojo::internal::Deserialize<::mojo::test::ObjectUnionDataView>(
        pointer, output, message_);
  }
  inline void GetPodUnionDataView(
      PodUnionDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPodUnion(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo::test::PodUnionDataView, UserType>(),
    "Attempting to read the optional `pod_union` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPodUnion` instead "
    "of `ReadPodUnion if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = !data_->pod_union.is_null() ? &data_->pod_union : nullptr;
    return mojo::internal::Deserialize<::mojo::test::PodUnionDataView>(
        pointer, output, message_);
  }
  inline void GetHandleUnionDataView(
      HandleUnionDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadHandleUnion(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo::test::HandleUnionDataView, UserType>(),
    "Attempting to read the optional `handle_union` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadHandleUnion` instead "
    "of `ReadHandleUnion if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = !data_->handle_union.is_null() ? &data_->handle_union : nullptr;
    return mojo::internal::Deserialize<::mojo::test::HandleUnionDataView>(
        pointer, output, message_);
  }
 private:
  internal::WrapperStruct_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DummyStructDataView {
 public:
  DummyStructDataView() {}

  DummyStructDataView(
      internal::DummyStruct_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int8_t f_int8() const {
    return data_->f_int8;
  }
 private:
  internal::DummyStruct_Data* data_ = nullptr;
};



class SmallStructDataView {
 public:
  SmallStructDataView() {}

  SmallStructDataView(
      internal::SmallStruct_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetDummyStructDataView(
      DummyStructDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadDummyStruct(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo::test::DummyStructDataView, UserType>(),
    "Attempting to read the optional `dummy_struct` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDummyStruct` instead "
    "of `ReadDummyStruct if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->dummy_struct.Get();
    return mojo::internal::Deserialize<::mojo::test::DummyStructDataView>(
        pointer, output, message_);
  }
  inline void GetPodUnionDataView(
      PodUnionDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPodUnion(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo::test::PodUnionDataView, UserType>(),
    "Attempting to read the optional `pod_union` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPodUnion` instead "
    "of `ReadPodUnion if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = !data_->pod_union.is_null() ? &data_->pod_union : nullptr;
    return mojo::internal::Deserialize<::mojo::test::PodUnionDataView>(
        pointer, output, message_);
  }
  inline void GetPodUnionArrayDataView(
      mojo::ArrayDataView<PodUnionDataView>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPodUnionArray(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::mojo::test::PodUnionDataView>, UserType>(),
    "Attempting to read the optional `pod_union_array` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPodUnionArray` instead "
    "of `ReadPodUnionArray if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->pod_union_array.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo::test::PodUnionDataView>>(
        pointer, output, message_);
  }
  inline void GetNullablePodUnionArrayDataView(
      mojo::ArrayDataView<PodUnionDataView>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadNullablePodUnionArray(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::mojo::test::PodUnionDataView>, UserType>(),
    "Attempting to read the optional `nullable_pod_union_array` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadNullablePodUnionArray` instead "
    "of `ReadNullablePodUnionArray if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->nullable_pod_union_array.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo::test::PodUnionDataView>>(
        pointer, output, message_);
  }
  inline void GetSArrayDataView(
      mojo::ArrayDataView<DummyStructDataView>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadSArray(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::mojo::test::DummyStructDataView>, UserType>(),
    "Attempting to read the optional `s_array` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSArray` instead "
    "of `ReadSArray if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->s_array.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo::test::DummyStructDataView>>(
        pointer, output, message_);
  }
  inline void GetPodUnionMapDataView(
      mojo::MapDataView<mojo::StringDataView, PodUnionDataView>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPodUnionMap(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::MapDataView<mojo::StringDataView, ::mojo::test::PodUnionDataView>, UserType>(),
    "Attempting to read the optional `pod_union_map` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPodUnionMap` instead "
    "of `ReadPodUnionMap if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->pod_union_map.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, ::mojo::test::PodUnionDataView>>(
        pointer, output, message_);
  }
  inline void GetNullablePodUnionMapDataView(
      mojo::MapDataView<mojo::StringDataView, PodUnionDataView>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadNullablePodUnionMap(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::MapDataView<mojo::StringDataView, ::mojo::test::PodUnionDataView>, UserType>(),
    "Attempting to read the optional `nullable_pod_union_map` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadNullablePodUnionMap` instead "
    "of `ReadNullablePodUnionMap if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->nullable_pod_union_map.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, ::mojo::test::PodUnionDataView>>(
        pointer, output, message_);
  }
 private:
  internal::SmallStruct_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SmallStructNonNullableUnionDataView {
 public:
  SmallStructNonNullableUnionDataView() {}

  SmallStructNonNullableUnionDataView(
      internal::SmallStructNonNullableUnion_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetPodUnionDataView(
      PodUnionDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPodUnion(UserType* output) {
    
    auto* pointer = !data_->pod_union.is_null() ? &data_->pod_union : nullptr;
    return mojo::internal::Deserialize<::mojo::test::PodUnionDataView>(
        pointer, output, message_);
  }
 private:
  internal::SmallStructNonNullableUnion_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SmallObjStructDataView {
 public:
  SmallObjStructDataView() {}

  SmallObjStructDataView(
      internal::SmallObjStruct_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetObjUnionDataView(
      ObjectUnionDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadObjUnion(UserType* output) {
    
    auto* pointer = !data_->obj_union.is_null() ? &data_->obj_union : nullptr;
    return mojo::internal::Deserialize<::mojo::test::ObjectUnionDataView>(
        pointer, output, message_);
  }
  int8_t f_int8() const {
    return data_->f_int8;
  }
 private:
  internal::SmallObjStruct_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class TryNonNullStructDataView {
 public:
  TryNonNullStructDataView() {}

  TryNonNullStructDataView(
      internal::TryNonNullStruct_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNullableDataView(
      DummyStructDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadNullable(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo::test::DummyStructDataView, UserType>(),
    "Attempting to read the optional `nullable` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadNullable` instead "
    "of `ReadNullable if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->nullable.Get();
    return mojo::internal::Deserialize<::mojo::test::DummyStructDataView>(
        pointer, output, message_);
  }
  inline void GetNonNullableDataView(
      DummyStructDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadNonNullable(UserType* output) {
    
    auto* pointer = data_->non_nullable.Get();
    return mojo::internal::Deserialize<::mojo::test::DummyStructDataView>(
        pointer, output, message_);
  }
 private:
  internal::TryNonNullStruct_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ImportedUnionStructDataView {
 public:
  ImportedUnionStructDataView() {}

  ImportedUnionStructDataView(
      internal::ImportedUnionStruct_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetPointOrShapeDataView(
      ::imported::PointOrShapeDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPointOrShape(UserType* output) {
    
    auto* pointer = !data_->point_or_shape.is_null() ? &data_->point_or_shape : nullptr;
    return mojo::internal::Deserialize<::imported::PointOrShapeDataView>(
        pointer, output, message_);
  }
 private:
  internal::ImportedUnionStruct_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PodUnionDataView {
 public:
  using Tag = internal::PodUnion_Data::PodUnion_Tag;

  PodUnionDataView() {}

  PodUnionDataView(
      internal::PodUnion_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_f_int8() const { return data_->tag == Tag::F_INT8; }
  int8_t f_int8() const {
    DCHECK(is_f_int8());
    return data_->data.f_f_int8;
  }
  bool is_f_int8_other() const { return data_->tag == Tag::F_INT8_OTHER; }
  int8_t f_int8_other() const {
    DCHECK(is_f_int8_other());
    return data_->data.f_f_int8_other;
  }
  bool is_f_uint8() const { return data_->tag == Tag::F_UINT8; }
  uint8_t f_uint8() const {
    DCHECK(is_f_uint8());
    return data_->data.f_f_uint8;
  }
  bool is_f_int16() const { return data_->tag == Tag::F_INT16; }
  int16_t f_int16() const {
    DCHECK(is_f_int16());
    return data_->data.f_f_int16;
  }
  bool is_f_uint16() const { return data_->tag == Tag::F_UINT16; }
  uint16_t f_uint16() const {
    DCHECK(is_f_uint16());
    return data_->data.f_f_uint16;
  }
  bool is_f_int32() const { return data_->tag == Tag::F_INT32; }
  int32_t f_int32() const {
    DCHECK(is_f_int32());
    return data_->data.f_f_int32;
  }
  bool is_f_uint32() const { return data_->tag == Tag::F_UINT32; }
  uint32_t f_uint32() const {
    DCHECK(is_f_uint32());
    return data_->data.f_f_uint32;
  }
  bool is_f_int64() const { return data_->tag == Tag::F_INT64; }
  int64_t f_int64() const {
    DCHECK(is_f_int64());
    return data_->data.f_f_int64;
  }
  bool is_f_uint64() const { return data_->tag == Tag::F_UINT64; }
  uint64_t f_uint64() const {
    DCHECK(is_f_uint64());
    return data_->data.f_f_uint64;
  }
  bool is_f_float() const { return data_->tag == Tag::F_FLOAT; }
  float f_float() const {
    DCHECK(is_f_float());
    return data_->data.f_f_float;
  }
  bool is_f_double() const { return data_->tag == Tag::F_DOUBLE; }
  double f_double() const {
    DCHECK(is_f_double());
    return data_->data.f_f_double;
  }
  bool is_f_bool() const { return data_->tag == Tag::F_BOOL; }
  bool f_bool() const {
    DCHECK(is_f_bool());
    return data_->data.f_f_bool;
  }
  bool is_f_enum() const { return data_->tag == Tag::F_ENUM; }
  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFEnum(UserType* output) const {
    DCHECK(is_f_enum());
    return mojo::internal::Deserialize<::mojo::test::AnEnum>(
        data_->data.f_f_enum, output);
  }
  AnEnum f_enum() const {
    DCHECK(is_f_enum());
    // TODO(dcheng): This seems incorrect, as it bypasses enum traits.
    return ::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::mojo::test::AnEnum>(data_->data.f_f_enum));
  }
  bool is_f_extensible_enum() const { return data_->tag == Tag::F_EXTENSIBLE_ENUM; }
  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFExtensibleEnum(UserType* output) const {
    DCHECK(is_f_extensible_enum());
    return mojo::internal::Deserialize<::mojo::test::AnExtensibleEnum>(
        data_->data.f_f_extensible_enum, output);
  }
  AnExtensibleEnum f_extensible_enum() const {
    DCHECK(is_f_extensible_enum());
    // TODO(dcheng): This seems incorrect, as it bypasses enum traits.
    return ::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::mojo::test::AnExtensibleEnum>(data_->data.f_f_extensible_enum));
  }

 private:
  internal::PodUnion_Data* data_ = nullptr;
};



class ObjectUnionDataView {
 public:
  using Tag = internal::ObjectUnion_Data::ObjectUnion_Tag;

  ObjectUnionDataView() {}

  ObjectUnionDataView(
      internal::ObjectUnion_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_f_int8() const { return data_->tag == Tag::F_INT8; }
  int8_t f_int8() const {
    DCHECK(is_f_int8());
    return data_->data.f_f_int8;
  }
  bool is_f_string() const { return data_->tag == Tag::F_STRING; }
  inline void GetFStringDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFString(UserType* output) {
    
    DCHECK(is_f_string());
    return mojo::internal::Deserialize<mojo::StringDataView>(
        data_->data.f_f_string.Get(), output, message_);
  }
  bool is_f_dummy() const { return data_->tag == Tag::F_DUMMY; }
  inline void GetFDummyDataView(
      DummyStructDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFDummy(UserType* output) {
    
    DCHECK(is_f_dummy());
    return mojo::internal::Deserialize<::mojo::test::DummyStructDataView>(
        data_->data.f_f_dummy.Get(), output, message_);
  }
  bool is_f_nullable() const { return data_->tag == Tag::F_NULLABLE; }
  inline void GetFNullableDataView(
      DummyStructDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFNullable(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo::test::DummyStructDataView, UserType>(),
    "Attempting to read the optional `f_nullable` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFNullable` instead "
    "of `ReadFNullable if you're fine with null values being "
    "silently ignored in this case.");
    DCHECK(is_f_nullable());
    return mojo::internal::Deserialize<::mojo::test::DummyStructDataView>(
        data_->data.f_f_nullable.Get(), output, message_);
  }
  bool is_f_array_int8() const { return data_->tag == Tag::F_ARRAY_INT8; }
  inline void GetFArrayInt8DataView(
      mojo::ArrayDataView<int8_t>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFArrayInt8(UserType* output) {
    
    DCHECK(is_f_array_int8());
    return mojo::internal::Deserialize<mojo::ArrayDataView<int8_t>>(
        data_->data.f_f_array_int8.Get(), output, message_);
  }
  bool is_f_map_int8() const { return data_->tag == Tag::F_MAP_INT8; }
  inline void GetFMapInt8DataView(
      mojo::MapDataView<mojo::StringDataView, int8_t>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFMapInt8(UserType* output) {
    
    DCHECK(is_f_map_int8());
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, int8_t>>(
        data_->data.f_f_map_int8.Get(), output, message_);
  }
  bool is_f_pod_union() const { return data_->tag == Tag::F_POD_UNION; }
  inline void GetFPodUnionDataView(
      PodUnionDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFPodUnion(UserType* output) {
    
    DCHECK(is_f_pod_union());
    return mojo::internal::Deserialize<::mojo::test::PodUnionDataView>(
        data_->data.f_f_pod_union.Get(), output, message_);
  }
  bool is_f_small_structs() const { return data_->tag == Tag::F_SMALL_STRUCTS; }
  inline void GetFSmallStructsDataView(
      mojo::ArrayDataView<SmallStructDataView>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFSmallStructs(UserType* output) {
    
    DCHECK(is_f_small_structs());
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo::test::SmallStructDataView>>(
        data_->data.f_f_small_structs.Get(), output, message_);
  }

 private:
  internal::ObjectUnion_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HandleUnionDataView {
 public:
  using Tag = internal::HandleUnion_Data::HandleUnion_Tag;

  HandleUnionDataView() {}

  HandleUnionDataView(
      internal::HandleUnion_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_f_handle() const { return data_->tag == Tag::F_HANDLE; }
  mojo::ScopedHandle TakeFHandle() {
    DCHECK(is_f_handle());
    mojo::ScopedHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedHandle>(
            &data_->data.f_f_handle, &result, message_);
    DCHECK(ret);
    return result;
  }
  bool is_f_message_pipe() const { return data_->tag == Tag::F_MESSAGE_PIPE; }
  mojo::ScopedMessagePipeHandle TakeFMessagePipe() {
    DCHECK(is_f_message_pipe());
    mojo::ScopedMessagePipeHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedMessagePipeHandle>(
            &data_->data.f_f_message_pipe, &result, message_);
    DCHECK(ret);
    return result;
  }
  bool is_f_data_pipe_consumer() const { return data_->tag == Tag::F_DATA_PIPE_CONSUMER; }
  mojo::ScopedDataPipeConsumerHandle TakeFDataPipeConsumer() {
    DCHECK(is_f_data_pipe_consumer());
    mojo::ScopedDataPipeConsumerHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedDataPipeConsumerHandle>(
            &data_->data.f_f_data_pipe_consumer, &result, message_);
    DCHECK(ret);
    return result;
  }
  bool is_f_data_pipe_producer() const { return data_->tag == Tag::F_DATA_PIPE_PRODUCER; }
  mojo::ScopedDataPipeProducerHandle TakeFDataPipeProducer() {
    DCHECK(is_f_data_pipe_producer());
    mojo::ScopedDataPipeProducerHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedDataPipeProducerHandle>(
            &data_->data.f_f_data_pipe_producer, &result, message_);
    DCHECK(ret);
    return result;
  }
  bool is_f_shared_buffer() const { return data_->tag == Tag::F_SHARED_BUFFER; }
  mojo::ScopedSharedBufferHandle TakeFSharedBuffer() {
    DCHECK(is_f_shared_buffer());
    mojo::ScopedSharedBufferHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedSharedBufferHandle>(
            &data_->data.f_f_shared_buffer, &result, message_);
    DCHECK(ret);
    return result;
  }
  bool is_f_platform() const { return data_->tag == Tag::F_PLATFORM; }
  mojo::PlatformHandle TakeFPlatform() {
    DCHECK(is_f_platform());
    mojo::PlatformHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::PlatformHandle>(
            &data_->data.f_f_platform, &result, message_);
    DCHECK(ret);
    return result;
  }
  bool is_f_small_cache() const { return data_->tag == Tag::F_SMALL_CACHE; }
  template <typename UserType>
  UserType TakeFSmallCache() {
    DCHECK(is_f_small_cache());
    UserType result;
    bool ret =
        mojo::internal::Deserialize<mojo::InterfacePtrDataView<::mojo::test::SmallCacheInterfaceBase>>(
            &data_->data.f_f_small_cache, &result, message_);
    DCHECK(ret);
    return result;
  }
  bool is_f_small_cache_receiver() const { return data_->tag == Tag::F_SMALL_CACHE_RECEIVER; }
  template <typename UserType>
  UserType TakeFSmallCacheReceiver() {
    DCHECK(is_f_small_cache_receiver());
    UserType result;
    bool ret =
        mojo::internal::Deserialize<mojo::InterfaceRequestDataView<::mojo::test::SmallCacheInterfaceBase>>(
            &data_->data.f_f_small_cache_receiver, &result, message_);
    DCHECK(ret);
    return result;
  }

 private:
  internal::HandleUnion_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class OldUnionDataView {
 public:
  using Tag = internal::OldUnion_Data::OldUnion_Tag;

  OldUnionDataView() {}

  OldUnionDataView(
      internal::OldUnion_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_f_int8() const { return data_->tag == Tag::F_INT8; }
  int8_t f_int8() const {
    DCHECK(is_f_int8());
    return data_->data.f_f_int8;
  }

 private:
  internal::OldUnion_Data* data_ = nullptr;
};



class NewUnionDataView {
 public:
  using Tag = internal::NewUnion_Data::NewUnion_Tag;

  NewUnionDataView() {}

  NewUnionDataView(
      internal::NewUnion_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_f_int8() const { return data_->tag == Tag::F_INT8; }
  int8_t f_int8() const {
    DCHECK(is_f_int8());
    return data_->data.f_f_int8;
  }
  bool is_f_int16() const { return data_->tag == Tag::F_INT16; }
  int16_t f_int16() const {
    DCHECK(is_f_int16());
    return data_->data.f_f_int16;
  }

 private:
  internal::NewUnion_Data* data_ = nullptr;
};



class ImportedUnionUnionDataView {
 public:
  using Tag = internal::ImportedUnionUnion_Data::ImportedUnionUnion_Tag;

  ImportedUnionUnionDataView() {}

  ImportedUnionUnionDataView(
      internal::ImportedUnionUnion_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_point_or_shape() const { return data_->tag == Tag::POINT_OR_SHAPE; }
  inline void GetPointOrShapeDataView(
      ::imported::PointOrShapeDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPointOrShape(UserType* output) {
    
    DCHECK(is_point_or_shape());
    return mojo::internal::Deserialize<::imported::PointOrShapeDataView>(
        data_->data.f_point_or_shape.Get(), output, message_);
  }

 private:
  internal::ImportedUnionUnion_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class UnionWithStringForFirstFieldDataView {
 public:
  using Tag = internal::UnionWithStringForFirstField_Data::UnionWithStringForFirstField_Tag;

  UnionWithStringForFirstFieldDataView() {}

  UnionWithStringForFirstFieldDataView(
      internal::UnionWithStringForFirstField_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_s() const { return data_->tag == Tag::S; }
  inline void GetSDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadS(UserType* output) {
    
    DCHECK(is_s());
    return mojo::internal::Deserialize<mojo::StringDataView>(
        data_->data.f_s.Get(), output, message_);
  }
  bool is_i() const { return data_->tag == Tag::I; }
  int32_t i() const {
    DCHECK(is_i());
    return data_->data.f_i;
  }

 private:
  internal::UnionWithStringForFirstField_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace test
}  // namespace mojo

namespace std {

template <>
struct hash<::mojo::test::AnEnum>
    : public mojo::internal::EnumHashImpl<::mojo::test::AnEnum> {};

template <>
struct hash<::mojo::test::AnExtensibleEnum>
    : public mojo::internal::EnumHashImpl<::mojo::test::AnExtensibleEnum> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::AnEnum, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::mojo::test::AnEnum, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::mojo::test::AnEnum>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::AnExtensibleEnum, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::mojo::test::AnExtensibleEnum, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::mojo::test::AnExtensibleEnum>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::WrapperStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojo::test::WrapperStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojo::test::internal::WrapperStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::object_union(input)) in_object_union = Traits::object_union(input);
    mojo::internal::MessageFragment<decltype(fragment->object_union)>
        object_union_fragment(fragment.message());
    object_union_fragment.Claim(&fragment->object_union);
    mojo::internal::Serialize<::mojo::test::ObjectUnionDataView>(
        in_object_union, object_union_fragment, true);
    decltype(Traits::pod_union(input)) in_pod_union = Traits::pod_union(input);
    mojo::internal::MessageFragment<decltype(fragment->pod_union)>
        pod_union_fragment(fragment.message());
    pod_union_fragment.Claim(&fragment->pod_union);
    mojo::internal::Serialize<::mojo::test::PodUnionDataView>(
        in_pod_union, pod_union_fragment, true);
    decltype(Traits::handle_union(input)) in_handle_union = Traits::handle_union(input);
    mojo::internal::MessageFragment<decltype(fragment->handle_union)>
        handle_union_fragment(fragment.message());
    handle_union_fragment.Claim(&fragment->handle_union);
    mojo::internal::Serialize<::mojo::test::HandleUnionDataView>(
        in_handle_union, handle_union_fragment, true);
  }

  static bool Deserialize(::mojo::test::internal::WrapperStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::WrapperStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::DummyStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojo::test::DummyStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojo::test::internal::DummyStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->f_int8 = Traits::f_int8(input);
  }

  static bool Deserialize(::mojo::test::internal::DummyStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::DummyStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::SmallStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojo::test::SmallStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojo::test::internal::SmallStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::dummy_struct(input)) in_dummy_struct = Traits::dummy_struct(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->dummy_struct)::BaseType> dummy_struct_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo::test::DummyStructDataView>(
        in_dummy_struct, dummy_struct_fragment);
    fragment->dummy_struct.Set(
        dummy_struct_fragment.is_null() ? nullptr : dummy_struct_fragment.data());
    decltype(Traits::pod_union(input)) in_pod_union = Traits::pod_union(input);
    mojo::internal::MessageFragment<decltype(fragment->pod_union)>
        pod_union_fragment(fragment.message());
    pod_union_fragment.Claim(&fragment->pod_union);
    mojo::internal::Serialize<::mojo::test::PodUnionDataView>(
        in_pod_union, pod_union_fragment, true);
    decltype(Traits::pod_union_array(input)) in_pod_union_array = Traits::pod_union_array(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pod_union_array)::BaseType>
        pod_union_array_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams pod_union_array_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojo::test::PodUnionDataView>>(
        in_pod_union_array, pod_union_array_fragment, &pod_union_array_validate_params);
    fragment->pod_union_array.Set(
        pod_union_array_fragment.is_null() ? nullptr : pod_union_array_fragment.data());
    decltype(Traits::nullable_pod_union_array(input)) in_nullable_pod_union_array = Traits::nullable_pod_union_array(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->nullable_pod_union_array)::BaseType>
        nullable_pod_union_array_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams nullable_pod_union_array_validate_params(
        0, true, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojo::test::PodUnionDataView>>(
        in_nullable_pod_union_array, nullable_pod_union_array_fragment, &nullable_pod_union_array_validate_params);
    fragment->nullable_pod_union_array.Set(
        nullable_pod_union_array_fragment.is_null() ? nullptr : nullable_pod_union_array_fragment.data());
    decltype(Traits::s_array(input)) in_s_array = Traits::s_array(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->s_array)::BaseType>
        s_array_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams s_array_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojo::test::DummyStructDataView>>(
        in_s_array, s_array_fragment, &s_array_validate_params);
    fragment->s_array.Set(
        s_array_fragment.is_null() ? nullptr : s_array_fragment.data());
    decltype(Traits::pod_union_map(input)) in_pod_union_map = Traits::pod_union_map(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pod_union_map)::BaseType>
        pod_union_map_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams pod_union_map_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::mojo::test::PodUnionDataView>>(
        in_pod_union_map, pod_union_map_fragment, &pod_union_map_validate_params);
    fragment->pod_union_map.Set(
        pod_union_map_fragment.is_null() ? nullptr : pod_union_map_fragment.data());
    decltype(Traits::nullable_pod_union_map(input)) in_nullable_pod_union_map = Traits::nullable_pod_union_map(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->nullable_pod_union_map)::BaseType>
        nullable_pod_union_map_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams nullable_pod_union_map_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, true, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::mojo::test::PodUnionDataView>>(
        in_nullable_pod_union_map, nullable_pod_union_map_fragment, &nullable_pod_union_map_validate_params);
    fragment->nullable_pod_union_map.Set(
        nullable_pod_union_map_fragment.is_null() ? nullptr : nullable_pod_union_map_fragment.data());
  }

  static bool Deserialize(::mojo::test::internal::SmallStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::SmallStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::SmallStructNonNullableUnionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojo::test::SmallStructNonNullableUnionDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojo::test::internal::SmallStructNonNullableUnion_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::pod_union(input)) in_pod_union = Traits::pod_union(input);
    mojo::internal::MessageFragment<decltype(fragment->pod_union)>
        pod_union_fragment(fragment.message());
    pod_union_fragment.Claim(&fragment->pod_union);
    mojo::internal::Serialize<::mojo::test::PodUnionDataView>(
        in_pod_union, pod_union_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->pod_union.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null pod_union in SmallStructNonNullableUnion struct");
  }

  static bool Deserialize(::mojo::test::internal::SmallStructNonNullableUnion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::SmallStructNonNullableUnionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::SmallObjStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojo::test::SmallObjStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojo::test::internal::SmallObjStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::obj_union(input)) in_obj_union = Traits::obj_union(input);
    mojo::internal::MessageFragment<decltype(fragment->obj_union)>
        obj_union_fragment(fragment.message());
    obj_union_fragment.Claim(&fragment->obj_union);
    mojo::internal::Serialize<::mojo::test::ObjectUnionDataView>(
        in_obj_union, obj_union_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->obj_union.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null obj_union in SmallObjStruct struct");
    fragment->f_int8 = Traits::f_int8(input);
  }

  static bool Deserialize(::mojo::test::internal::SmallObjStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::SmallObjStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::TryNonNullStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojo::test::TryNonNullStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojo::test::internal::TryNonNullStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::nullable(input)) in_nullable = Traits::nullable(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->nullable)::BaseType> nullable_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo::test::DummyStructDataView>(
        in_nullable, nullable_fragment);
    fragment->nullable.Set(
        nullable_fragment.is_null() ? nullptr : nullable_fragment.data());
    decltype(Traits::non_nullable(input)) in_non_nullable = Traits::non_nullable(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->non_nullable)::BaseType> non_nullable_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo::test::DummyStructDataView>(
        in_non_nullable, non_nullable_fragment);
    fragment->non_nullable.Set(
        non_nullable_fragment.is_null() ? nullptr : non_nullable_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->non_nullable.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null non_nullable in TryNonNullStruct struct");
  }

  static bool Deserialize(::mojo::test::internal::TryNonNullStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::TryNonNullStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::ImportedUnionStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojo::test::ImportedUnionStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojo::test::internal::ImportedUnionStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::point_or_shape(input)) in_point_or_shape = Traits::point_or_shape(input);
    mojo::internal::MessageFragment<decltype(fragment->point_or_shape)>
        point_or_shape_fragment(fragment.message());
    point_or_shape_fragment.Claim(&fragment->point_or_shape);
    mojo::internal::Serialize<::imported::PointOrShapeDataView>(
        in_point_or_shape, point_or_shape_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->point_or_shape.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null point_or_shape in ImportedUnionStruct struct");
  }

  static bool Deserialize(::mojo::test::internal::ImportedUnionStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::ImportedUnionStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::PodUnionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::mojo::test::PodUnionDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::mojo::test::internal::PodUnion_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::mojo::test::PodUnionDataView::Tag::F_INT8: {
        decltype(Traits::f_int8(input))
            in_f_int8 = Traits::f_int8(input);
        fragment->data.f_f_int8 = in_f_int8;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_INT8_OTHER: {
        decltype(Traits::f_int8_other(input))
            in_f_int8_other = Traits::f_int8_other(input);
        fragment->data.f_f_int8_other = in_f_int8_other;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_UINT8: {
        decltype(Traits::f_uint8(input))
            in_f_uint8 = Traits::f_uint8(input);
        fragment->data.f_f_uint8 = in_f_uint8;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_INT16: {
        decltype(Traits::f_int16(input))
            in_f_int16 = Traits::f_int16(input);
        fragment->data.f_f_int16 = in_f_int16;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_UINT16: {
        decltype(Traits::f_uint16(input))
            in_f_uint16 = Traits::f_uint16(input);
        fragment->data.f_f_uint16 = in_f_uint16;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_INT32: {
        decltype(Traits::f_int32(input))
            in_f_int32 = Traits::f_int32(input);
        fragment->data.f_f_int32 = in_f_int32;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_UINT32: {
        decltype(Traits::f_uint32(input))
            in_f_uint32 = Traits::f_uint32(input);
        fragment->data.f_f_uint32 = in_f_uint32;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_INT64: {
        decltype(Traits::f_int64(input))
            in_f_int64 = Traits::f_int64(input);
        fragment->data.f_f_int64 = in_f_int64;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_UINT64: {
        decltype(Traits::f_uint64(input))
            in_f_uint64 = Traits::f_uint64(input);
        fragment->data.f_f_uint64 = in_f_uint64;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_FLOAT: {
        decltype(Traits::f_float(input))
            in_f_float = Traits::f_float(input);
        fragment->data.f_f_float = in_f_float;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_DOUBLE: {
        decltype(Traits::f_double(input))
            in_f_double = Traits::f_double(input);
        fragment->data.f_f_double = in_f_double;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_BOOL: {
        decltype(Traits::f_bool(input))
            in_f_bool = Traits::f_bool(input);
        fragment->data.f_f_bool = in_f_bool;
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_ENUM: {
        decltype(Traits::f_enum(input))
            in_f_enum = Traits::f_enum(input);
        mojo::internal::Serialize<::mojo::test::AnEnum>(
            in_f_enum, &fragment->data.f_f_enum);
        break;
      }
      case ::mojo::test::PodUnionDataView::Tag::F_EXTENSIBLE_ENUM: {
        decltype(Traits::f_extensible_enum(input))
            in_f_extensible_enum = Traits::f_extensible_enum(input);
        mojo::internal::Serialize<::mojo::test::AnExtensibleEnum>(
            in_f_extensible_enum, &fragment->data.f_f_extensible_enum);
        break;
      }
    }
  }

  static bool Deserialize(::mojo::test::internal::PodUnion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::PodUnionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::ObjectUnionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::mojo::test::ObjectUnionDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::mojo::test::internal::ObjectUnion_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::mojo::test::ObjectUnionDataView::Tag::F_INT8: {
        decltype(Traits::f_int8(input))
            in_f_int8 = Traits::f_int8(input);
        fragment->data.f_f_int8 = in_f_int8;
        break;
      }
      case ::mojo::test::ObjectUnionDataView::Tag::F_STRING: {
        decltype(Traits::f_string(input))
            in_f_string = Traits::f_string(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_f_string)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(
            in_f_string, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null f_string in ObjectUnion union");
        fragment->data.f_f_string.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::mojo::test::ObjectUnionDataView::Tag::F_DUMMY: {
        decltype(Traits::f_dummy(input))
            in_f_dummy = Traits::f_dummy(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_f_dummy)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo::test::DummyStructDataView>(
            in_f_dummy, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null f_dummy in ObjectUnion union");
        fragment->data.f_f_dummy.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::mojo::test::ObjectUnionDataView::Tag::F_NULLABLE: {
        decltype(Traits::f_nullable(input))
            in_f_nullable = Traits::f_nullable(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_f_nullable)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo::test::DummyStructDataView>(
            in_f_nullable, value_fragment);
        fragment->data.f_f_nullable.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::mojo::test::ObjectUnionDataView::Tag::F_ARRAY_INT8: {
        decltype(Traits::f_array_int8(input))
            in_f_array_int8 = Traits::f_array_int8(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_f_array_int8)::BaseType>
            value_fragment(fragment.message());
        const ContainerValidateParams f_array_int8_validate_params(
            0, false, nullptr);
        mojo::internal::Serialize<mojo::ArrayDataView<int8_t>>(
            in_f_array_int8, value_fragment, &f_array_int8_validate_params);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null f_array_int8 in ObjectUnion union");
        fragment->data.f_f_array_int8.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::mojo::test::ObjectUnionDataView::Tag::F_MAP_INT8: {
        decltype(Traits::f_map_int8(input))
            in_f_map_int8 = Traits::f_map_int8(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_f_map_int8)::BaseType>
            value_fragment(fragment.message());
        const ContainerValidateParams f_map_int8_validate_params(
            new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
        mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, int8_t>>(
            in_f_map_int8, value_fragment, &f_map_int8_validate_params);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null f_map_int8 in ObjectUnion union");
        fragment->data.f_f_map_int8.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::mojo::test::ObjectUnionDataView::Tag::F_POD_UNION: {
        decltype(Traits::f_pod_union(input))
            in_f_pod_union = Traits::f_pod_union(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_f_pod_union)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo::test::PodUnionDataView>(
            in_f_pod_union, value_fragment, false);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null f_pod_union in ObjectUnion union");
        fragment->data.f_f_pod_union.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::mojo::test::ObjectUnionDataView::Tag::F_SMALL_STRUCTS: {
        decltype(Traits::f_small_structs(input))
            in_f_small_structs = Traits::f_small_structs(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_f_small_structs)::BaseType>
            value_fragment(fragment.message());
        const ContainerValidateParams f_small_structs_validate_params(
            0, false, nullptr);
        mojo::internal::Serialize<mojo::ArrayDataView<::mojo::test::SmallStructDataView>>(
            in_f_small_structs, value_fragment, &f_small_structs_validate_params);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null f_small_structs in ObjectUnion union");
        fragment->data.f_f_small_structs.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::mojo::test::internal::ObjectUnion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::ObjectUnionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::HandleUnionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::mojo::test::HandleUnionDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::mojo::test::internal::HandleUnion_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::mojo::test::HandleUnionDataView::Tag::F_HANDLE: {
        decltype(Traits::f_handle(input))
            in_f_handle = Traits::f_handle(input);
        mojo::internal::Serialize<mojo::ScopedHandle>(
            in_f_handle, &fragment->data.f_f_handle, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_f_handle),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid f_handle in HandleUnion union");
        break;
      }
      case ::mojo::test::HandleUnionDataView::Tag::F_MESSAGE_PIPE: {
        decltype(Traits::f_message_pipe(input))
            in_f_message_pipe = Traits::f_message_pipe(input);
        mojo::internal::Serialize<mojo::ScopedMessagePipeHandle>(
            in_f_message_pipe, &fragment->data.f_f_message_pipe, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_f_message_pipe),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid f_message_pipe in HandleUnion union");
        break;
      }
      case ::mojo::test::HandleUnionDataView::Tag::F_DATA_PIPE_CONSUMER: {
        decltype(Traits::f_data_pipe_consumer(input))
            in_f_data_pipe_consumer = Traits::f_data_pipe_consumer(input);
        mojo::internal::Serialize<mojo::ScopedDataPipeConsumerHandle>(
            in_f_data_pipe_consumer, &fragment->data.f_f_data_pipe_consumer, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_f_data_pipe_consumer),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid f_data_pipe_consumer in HandleUnion union");
        break;
      }
      case ::mojo::test::HandleUnionDataView::Tag::F_DATA_PIPE_PRODUCER: {
        decltype(Traits::f_data_pipe_producer(input))
            in_f_data_pipe_producer = Traits::f_data_pipe_producer(input);
        mojo::internal::Serialize<mojo::ScopedDataPipeProducerHandle>(
            in_f_data_pipe_producer, &fragment->data.f_f_data_pipe_producer, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_f_data_pipe_producer),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid f_data_pipe_producer in HandleUnion union");
        break;
      }
      case ::mojo::test::HandleUnionDataView::Tag::F_SHARED_BUFFER: {
        decltype(Traits::f_shared_buffer(input))
            in_f_shared_buffer = Traits::f_shared_buffer(input);
        mojo::internal::Serialize<mojo::ScopedSharedBufferHandle>(
            in_f_shared_buffer, &fragment->data.f_f_shared_buffer, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_f_shared_buffer),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid f_shared_buffer in HandleUnion union");
        break;
      }
      case ::mojo::test::HandleUnionDataView::Tag::F_PLATFORM: {
        decltype(Traits::f_platform(input))
            in_f_platform = Traits::f_platform(input);
        mojo::internal::Serialize<mojo::PlatformHandle>(
            in_f_platform, &fragment->data.f_f_platform, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_f_platform),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid f_platform in HandleUnion union");
        break;
      }
      case ::mojo::test::HandleUnionDataView::Tag::F_SMALL_CACHE: {
        decltype(Traits::f_small_cache(input))
            in_f_small_cache = Traits::f_small_cache(input);
        mojo::internal::Serialize<mojo::InterfacePtrDataView<::mojo::test::SmallCacheInterfaceBase>>(
            in_f_small_cache, &fragment->data.f_f_small_cache, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_f_small_cache),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid f_small_cache in HandleUnion union");
        break;
      }
      case ::mojo::test::HandleUnionDataView::Tag::F_SMALL_CACHE_RECEIVER: {
        decltype(Traits::f_small_cache_receiver(input))
            in_f_small_cache_receiver = Traits::f_small_cache_receiver(input);
        mojo::internal::Serialize<mojo::InterfaceRequestDataView<::mojo::test::SmallCacheInterfaceBase>>(
            in_f_small_cache_receiver, &fragment->data.f_f_small_cache_receiver, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_f_small_cache_receiver),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid f_small_cache_receiver in HandleUnion union");
        break;
      }
    }
  }

  static bool Deserialize(::mojo::test::internal::HandleUnion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::HandleUnionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::OldUnionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::mojo::test::OldUnionDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::mojo::test::internal::OldUnion_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::mojo::test::OldUnionDataView::Tag::F_INT8: {
        decltype(Traits::f_int8(input))
            in_f_int8 = Traits::f_int8(input);
        fragment->data.f_f_int8 = in_f_int8;
        break;
      }
    }
  }

  static bool Deserialize(::mojo::test::internal::OldUnion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::OldUnionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::NewUnionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::mojo::test::NewUnionDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::mojo::test::internal::NewUnion_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::mojo::test::NewUnionDataView::Tag::F_INT8: {
        decltype(Traits::f_int8(input))
            in_f_int8 = Traits::f_int8(input);
        fragment->data.f_f_int8 = in_f_int8;
        break;
      }
      case ::mojo::test::NewUnionDataView::Tag::F_INT16: {
        decltype(Traits::f_int16(input))
            in_f_int16 = Traits::f_int16(input);
        fragment->data.f_f_int16 = in_f_int16;
        break;
      }
    }
  }

  static bool Deserialize(::mojo::test::internal::NewUnion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::NewUnionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::ImportedUnionUnionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::mojo::test::ImportedUnionUnionDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::mojo::test::internal::ImportedUnionUnion_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::mojo::test::ImportedUnionUnionDataView::Tag::POINT_OR_SHAPE: {
        decltype(Traits::point_or_shape(input))
            in_point_or_shape = Traits::point_or_shape(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_point_or_shape)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::imported::PointOrShapeDataView>(
            in_point_or_shape, value_fragment, false);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null point_or_shape in ImportedUnionUnion union");
        fragment->data.f_point_or_shape.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::mojo::test::internal::ImportedUnionUnion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::ImportedUnionUnionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojo::test::UnionWithStringForFirstFieldDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::mojo::test::UnionWithStringForFirstFieldDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::mojo::test::internal::UnionWithStringForFirstField_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::mojo::test::UnionWithStringForFirstFieldDataView::Tag::S: {
        decltype(Traits::s(input))
            in_s = Traits::s(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_s)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(
            in_s, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null s in UnionWithStringForFirstField union");
        fragment->data.f_s.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::mojo::test::UnionWithStringForFirstFieldDataView::Tag::I: {
        decltype(Traits::i(input))
            in_i = Traits::i(input);
        fragment->data.f_i = in_i;
        break;
      }
    }
  }

  static bool Deserialize(::mojo::test::internal::UnionWithStringForFirstField_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::mojo::test::UnionWithStringForFirstFieldDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace mojo {
namespace test {

inline void WrapperStructDataView::GetObjectUnionDataView(
    ObjectUnionDataView* output) {
  auto pointer = &data_->object_union;
  *output = ObjectUnionDataView(pointer, message_);
}
inline void WrapperStructDataView::GetPodUnionDataView(
    PodUnionDataView* output) {
  auto pointer = &data_->pod_union;
  *output = PodUnionDataView(pointer, message_);
}
inline void WrapperStructDataView::GetHandleUnionDataView(
    HandleUnionDataView* output) {
  auto pointer = &data_->handle_union;
  *output = HandleUnionDataView(pointer, message_);
}




inline void SmallStructDataView::GetDummyStructDataView(
    DummyStructDataView* output) {
  auto pointer = data_->dummy_struct.Get();
  *output = DummyStructDataView(pointer, message_);
}
inline void SmallStructDataView::GetPodUnionDataView(
    PodUnionDataView* output) {
  auto pointer = &data_->pod_union;
  *output = PodUnionDataView(pointer, message_);
}
inline void SmallStructDataView::GetPodUnionArrayDataView(
    mojo::ArrayDataView<PodUnionDataView>* output) {
  auto pointer = data_->pod_union_array.Get();
  *output = mojo::ArrayDataView<PodUnionDataView>(pointer, message_);
}
inline void SmallStructDataView::GetNullablePodUnionArrayDataView(
    mojo::ArrayDataView<PodUnionDataView>* output) {
  auto pointer = data_->nullable_pod_union_array.Get();
  *output = mojo::ArrayDataView<PodUnionDataView>(pointer, message_);
}
inline void SmallStructDataView::GetSArrayDataView(
    mojo::ArrayDataView<DummyStructDataView>* output) {
  auto pointer = data_->s_array.Get();
  *output = mojo::ArrayDataView<DummyStructDataView>(pointer, message_);
}
inline void SmallStructDataView::GetPodUnionMapDataView(
    mojo::MapDataView<mojo::StringDataView, PodUnionDataView>* output) {
  auto pointer = data_->pod_union_map.Get();
  *output = mojo::MapDataView<mojo::StringDataView, PodUnionDataView>(pointer, message_);
}
inline void SmallStructDataView::GetNullablePodUnionMapDataView(
    mojo::MapDataView<mojo::StringDataView, PodUnionDataView>* output) {
  auto pointer = data_->nullable_pod_union_map.Get();
  *output = mojo::MapDataView<mojo::StringDataView, PodUnionDataView>(pointer, message_);
}


inline void SmallStructNonNullableUnionDataView::GetPodUnionDataView(
    PodUnionDataView* output) {
  auto pointer = &data_->pod_union;
  *output = PodUnionDataView(pointer, message_);
}


inline void SmallObjStructDataView::GetObjUnionDataView(
    ObjectUnionDataView* output) {
  auto pointer = &data_->obj_union;
  *output = ObjectUnionDataView(pointer, message_);
}


inline void TryNonNullStructDataView::GetNullableDataView(
    DummyStructDataView* output) {
  auto pointer = data_->nullable.Get();
  *output = DummyStructDataView(pointer, message_);
}
inline void TryNonNullStructDataView::GetNonNullableDataView(
    DummyStructDataView* output) {
  auto pointer = data_->non_nullable.Get();
  *output = DummyStructDataView(pointer, message_);
}


inline void ImportedUnionStructDataView::GetPointOrShapeDataView(
    ::imported::PointOrShapeDataView* output) {
  auto pointer = &data_->point_or_shape;
  *output = ::imported::PointOrShapeDataView(pointer, message_);
}



inline void ObjectUnionDataView::GetFStringDataView(
    mojo::StringDataView* output) {
  DCHECK(is_f_string());
  *output = mojo::StringDataView(data_->data.f_f_string.Get(), message_);
}
inline void ObjectUnionDataView::GetFDummyDataView(
    DummyStructDataView* output) {
  DCHECK(is_f_dummy());
  *output = DummyStructDataView(data_->data.f_f_dummy.Get(), message_);
}
inline void ObjectUnionDataView::GetFNullableDataView(
    DummyStructDataView* output) {
  DCHECK(is_f_nullable());
  *output = DummyStructDataView(data_->data.f_f_nullable.Get(), message_);
}
inline void ObjectUnionDataView::GetFArrayInt8DataView(
    mojo::ArrayDataView<int8_t>* output) {
  DCHECK(is_f_array_int8());
  *output = mojo::ArrayDataView<int8_t>(data_->data.f_f_array_int8.Get(), message_);
}
inline void ObjectUnionDataView::GetFMapInt8DataView(
    mojo::MapDataView<mojo::StringDataView, int8_t>* output) {
  DCHECK(is_f_map_int8());
  *output = mojo::MapDataView<mojo::StringDataView, int8_t>(data_->data.f_f_map_int8.Get(), message_);
}
inline void ObjectUnionDataView::GetFPodUnionDataView(
    PodUnionDataView* output) {
  DCHECK(is_f_pod_union());
  *output = PodUnionDataView(data_->data.f_f_pod_union.Get(), message_);
}
inline void ObjectUnionDataView::GetFSmallStructsDataView(
    mojo::ArrayDataView<SmallStructDataView>* output) {
  DCHECK(is_f_small_structs());
  *output = mojo::ArrayDataView<SmallStructDataView>(data_->data.f_f_small_structs.Get(), message_);
}




inline void ImportedUnionUnionDataView::GetPointOrShapeDataView(
    ::imported::PointOrShapeDataView* output) {
  DCHECK(is_point_or_shape());
  *output = ::imported::PointOrShapeDataView(data_->data.f_point_or_shape.Get(), message_);
}

inline void UnionWithStringForFirstFieldDataView::GetSDataView(
    mojo::StringDataView* output) {
  DCHECK(is_s());
  *output = mojo::StringDataView(data_->data.f_s.Get(), message_);
}


}  // namespace test
}  // namespace mojo

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::mojo::test::AnEnum> {
 static void WriteIntoTracedValue(perfetto::TracedValue context, ::mojo::test::AnEnum value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::mojo::test::AnExtensibleEnum> {
 static void WriteIntoTracedValue(perfetto::TracedValue context, ::mojo::test::AnExtensibleEnum value);
};

} // namespace perfetto

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_SHARED_H_

/* Metadata comment
eyJtZXRhIjogW3siZW5kIjogNTY2NCwgImJlZ2luIjogNTY1OCwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5BbkVudW0ifX0sIHsiZW5kIjogNTcz
MCwgImJlZ2luIjogNTcyNSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5BbkVudW0uRklSU1QifX0sIHsiZW5kIjogNTc5MSwgImJlZ2luIjogNTc4
NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5B
bkVudW0uU0VDT05EIn19LCB7ImVuZCI6IDYwOTksICJiZWdpbiI6IDYwODMsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQW5FeHRlbnNpYmxlRW51
bSJ9fSwgeyJlbmQiOiA2MTc1LCAiYmVnaW4iOiA2MTcwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkFuRXh0ZW5zaWJsZUVudW0uRklSU1QifX0s
IHsiZW5kIjogNjI0NiwgImJlZ2luIjogNjI0MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5BbkV4dGVuc2libGVFbnVtLlNFQ09ORCJ9fSwgeyJl
bmQiOiA2MzE1LCAiYmVnaW4iOiA2MzEwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0LkFuRXh0ZW5zaWJsZUVudW0uVEhJUkQifX1dLCAidHlwZSI6
ICJreXRoZTAifQ==
*/