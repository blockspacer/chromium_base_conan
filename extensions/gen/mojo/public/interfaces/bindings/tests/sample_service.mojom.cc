// mojo/public/interfaces/bindings/tests/sample_service.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "mojo/public/interfaces/bindings/tests/sample_service.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/common/task_annotator.h"
#include "base/trace_event/trace_event.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "mojo/public/interfaces/bindings/tests/sample_service.mojom-params-data.h"
#include "mojo/public/interfaces/bindings/tests/sample_service.mojom-shared-message-ids.h"

#include "mojo/public/interfaces/bindings/tests/sample_service.mojom-import-headers.h"


#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_SAMPLE_SERVICE_MOJOM_JUMBO_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_SAMPLE_SERVICE_MOJOM_JUMBO_H_
#endif
namespace sample {
const char Foo::kFooby[] = "Fooby";
Bar::Bar()
    : alpha(0xffU),
      beta(),
      gamma(),
      type(Bar_Type::VERTICAL) {}

Bar::Bar(
    uint8_t alpha_in,
    uint8_t beta_in,
    uint8_t gamma_in,
    Bar::Type type_in)
    : alpha(std::move(alpha_in)),
      beta(std::move(beta_in)),
      gamma(std::move(gamma_in)),
      type(std::move(type_in)) {}

Bar::~Bar() = default;
size_t Bar::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->alpha);
  seed = mojo::internal::Hash(seed, this->beta);
  seed = mojo::internal::Hash(seed, this->gamma);
  seed = mojo::internal::Hash(seed, this->type);
  return seed;
}

void Bar::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "alpha"), this->alpha,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint8_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "beta"), this->beta,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint8_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "gamma"), this->gamma,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint8_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "type"), this->type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type Bar::Type>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Bar::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Foo::Foo()
    : name(Foo::kFooby),
      x(),
      y(),
      a(true),
      b(),
      c(),
      bar(),
      extra_bars(),
      data(),
      source(),
      input_streams(),
      output_streams(),
      array_of_array_of_bools(),
      multi_array_of_strings(),
      array_of_bools() {}

Foo::Foo(
    const std::string& name_in,
    int32_t x_in,
    int32_t y_in,
    bool a_in,
    bool b_in,
    bool c_in,
    BarPtr bar_in,
    base::Optional<std::vector<BarPtr>> extra_bars_in,
    base::Optional<std::vector<uint8_t>> data_in,
    ::mojo::ScopedMessagePipeHandle source_in,
    base::Optional<std::vector<::mojo::ScopedDataPipeConsumerHandle>> input_streams_in,
    base::Optional<std::vector<::mojo::ScopedDataPipeProducerHandle>> output_streams_in,
    base::Optional<std::vector<std::vector<bool>>> array_of_array_of_bools_in,
    base::Optional<std::vector<std::vector<std::vector<std::string>>>> multi_array_of_strings_in,
    base::Optional<std::vector<bool>> array_of_bools_in)
    : name(std::move(name_in)),
      x(std::move(x_in)),
      y(std::move(y_in)),
      a(std::move(a_in)),
      b(std::move(b_in)),
      c(std::move(c_in)),
      bar(std::move(bar_in)),
      extra_bars(std::move(extra_bars_in)),
      data(std::move(data_in)),
      source(std::move(source_in)),
      input_streams(std::move(input_streams_in)),
      output_streams(std::move(output_streams_in)),
      array_of_array_of_bools(std::move(array_of_array_of_bools_in)),
      multi_array_of_strings(std::move(multi_array_of_strings_in)),
      array_of_bools(std::move(array_of_bools_in)) {}

Foo::~Foo() = default;

void Foo::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "x"), this->x,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "y"), this->y,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a"), this->a,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "b"), this->b,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "c"), this->c,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "bar"), this->bar,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type BarPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "extra_bars"), this->extra_bars,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type base::Optional<std::vector<BarPtr>>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::Optional<std::vector<uint8_t>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source"), this->source,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::ScopedMessagePipeHandle>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "input_streams"), this->input_streams,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type base::Optional<std::vector<::mojo::ScopedDataPipeConsumerHandle>>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "output_streams"), this->output_streams,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type base::Optional<std::vector<::mojo::ScopedDataPipeProducerHandle>>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "array_of_array_of_bools"), this->array_of_array_of_bools,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::Optional<std::vector<std::vector<bool>>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "multi_array_of_strings"), this->multi_array_of_strings,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::Optional<std::vector<std::vector<std::vector<std::string>>>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "array_of_bools"), this->array_of_bools,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::Optional<std::vector<bool>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Foo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DefaultsTest::DefaultsTest()
    : a0(-12),
      a1(kTwelve),
      a2(1234),
      a3(34567U),
      a4(123456),
      a5(3456789012U),
      a6(-111111111111),
      a7(9999999999999999999ULL),
      a8(0x12345),
      a9(-0x12345),
      a10(+1234),
      a11(true),
      a12(false),
      a13(123.25f),
      a14(1234567890.123),
      a15(1E10),
      a16(-1.2E+20),
      a17(+1.23E-20),
      a18(),
      a19(),
      a20(Bar_Type::BOTH),
      a21(),
      a22(::imported::Thing::New()),
      a23(0xFFFFFFFFFFFFFFFFULL),
      a24(0x123456789),
      a25(-0x123456789),
      a26(std::numeric_limits<double>::infinity()),
      a27(-std::numeric_limits<double>::infinity()),
      a28(std::numeric_limits<double>::quiet_NaN()),
      a29(std::numeric_limits<float>::infinity()),
      a30(-std::numeric_limits<float>::infinity()),
      a31(std::numeric_limits<float>::quiet_NaN()) {}

DefaultsTest::DefaultsTest(
    int8_t a0_in,
    uint8_t a1_in,
    int16_t a2_in,
    uint16_t a3_in,
    int32_t a4_in,
    uint32_t a5_in,
    int64_t a6_in,
    uint64_t a7_in,
    int32_t a8_in,
    int32_t a9_in,
    int32_t a10_in,
    bool a11_in,
    bool a12_in,
    float a13_in,
    double a14_in,
    double a15_in,
    double a16_in,
    double a17_in,
    std::vector<uint8_t> a18_in,
    const std::string& a19_in,
    Bar::Type a20_in,
    ::imported::PointPtr a21_in,
    ::imported::ThingPtr a22_in,
    uint64_t a23_in,
    int64_t a24_in,
    int64_t a25_in,
    double a26_in,
    double a27_in,
    double a28_in,
    float a29_in,
    float a30_in,
    float a31_in)
    : a0(std::move(a0_in)),
      a1(std::move(a1_in)),
      a2(std::move(a2_in)),
      a3(std::move(a3_in)),
      a4(std::move(a4_in)),
      a5(std::move(a5_in)),
      a6(std::move(a6_in)),
      a7(std::move(a7_in)),
      a8(std::move(a8_in)),
      a9(std::move(a9_in)),
      a10(std::move(a10_in)),
      a11(std::move(a11_in)),
      a12(std::move(a12_in)),
      a13(std::move(a13_in)),
      a14(std::move(a14_in)),
      a15(std::move(a15_in)),
      a16(std::move(a16_in)),
      a17(std::move(a17_in)),
      a18(std::move(a18_in)),
      a19(std::move(a19_in)),
      a20(std::move(a20_in)),
      a21(std::move(a21_in)),
      a22(std::move(a22_in)),
      a23(std::move(a23_in)),
      a24(std::move(a24_in)),
      a25(std::move(a25_in)),
      a26(std::move(a26_in)),
      a27(std::move(a27_in)),
      a28(std::move(a28_in)),
      a29(std::move(a29_in)),
      a30(std::move(a30_in)),
      a31(std::move(a31_in)) {}

DefaultsTest::~DefaultsTest() = default;

void DefaultsTest::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a0"), this->a0,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int8_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a1"), this->a1,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint8_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a2"), this->a2,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int16_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a3"), this->a3,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint16_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a4"), this->a4,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a5"), this->a5,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a6"), this->a6,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a7"), this->a7,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a8"), this->a8,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a9"), this->a9,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a10"), this->a10,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a11"), this->a11,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a12"), this->a12,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a13"), this->a13,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a14"), this->a14,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a15"), this->a15,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a16"), this->a16,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a17"), this->a17,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a18"), this->a18,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<uint8_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a19"), this->a19,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a20"), this->a20,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type Bar::Type>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a21"), this->a21,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::imported::PointPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a22"), this->a22,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::imported::ThingPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a23"), this->a23,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a24"), this->a24,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a25"), this->a25,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a26"), this->a26,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a27"), this->a27,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a28"), this->a28,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a29"), this->a29,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a30"), this->a30,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "a31"), this->a31,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DefaultsTest::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StructWithHoleV1::StructWithHoleV1()
    : v1(1),
      v2(2) {}

StructWithHoleV1::StructWithHoleV1(
    int32_t v1_in,
    int64_t v2_in)
    : v1(std::move(v1_in)),
      v2(std::move(v2_in)) {}

StructWithHoleV1::~StructWithHoleV1() = default;
size_t StructWithHoleV1::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->v1);
  seed = mojo::internal::Hash(seed, this->v2);
  return seed;
}

void StructWithHoleV1::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "v1"), this->v1,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "v2"), this->v2,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StructWithHoleV1::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StructWithHoleV2::StructWithHoleV2()
    : v1(1),
      v2(2),
      v3(3) {}

StructWithHoleV2::StructWithHoleV2(
    int32_t v1_in,
    int64_t v2_in,
    int32_t v3_in)
    : v1(std::move(v1_in)),
      v2(std::move(v2_in)),
      v3(std::move(v3_in)) {}

StructWithHoleV2::~StructWithHoleV2() = default;
size_t StructWithHoleV2::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->v1);
  seed = mojo::internal::Hash(seed, this->v2);
  seed = mojo::internal::Hash(seed, this->v3);
  return seed;
}

void StructWithHoleV2::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "v1"), this->v1,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "v2"), this->v2,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "v3"), this->v3,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StructWithHoleV2::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char DefaultsSender::Name_[] = "sample.DefaultsSender";

DefaultsSenderProxy::DefaultsSenderProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class DefaultsSenderProxy_SendBar_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit DefaultsSenderProxy_SendBar_Message(
      uint32_t message_flags
      , BarPtr param_bar
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kDefaultsSender_SendBar_Name,
          message_flags)
      , param_bar_(std::move(param_bar)){}
  ~DefaultsSenderProxy_SendBar_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      BarPtr param_bar) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<DefaultsSenderProxy_SendBar_Message>(
          kFlags
          , std::move(param_bar)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kDefaultsSender_SendBar_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::sample::internal::DefaultsSender_SendBar_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bar)::BaseType> bar_fragment(
          params.message());
  mojo::internal::Serialize<::sample::BarDataView>(
      param_bar, bar_fragment);
  params->bar.Set(
      bar_fragment.is_null() ? nullptr : bar_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bar.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bar in DefaultsSender.SendBar request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      DefaultsSender* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->SendBar(
        std::move(param_bar_));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::sample::internal::DefaultsSender_SendBar_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bar)::BaseType> bar_fragment(
          params.message());
  mojo::internal::Serialize<::sample::BarDataView>(
      param_bar_, bar_fragment);
  params->bar.Set(
      bar_fragment.is_null() ? nullptr : bar_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bar.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bar in DefaultsSender.SendBar request");
  }
  BarPtr param_bar_;

  DISALLOW_COPY_AND_ASSIGN(DefaultsSenderProxy_SendBar_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
DefaultsSenderProxy_SendBar_Message::kMessageTag = {};

void DefaultsSenderProxy::SendBar(
    BarPtr in_bar) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "sample::DefaultsSender::SendBar", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bar"), in_bar, 
                        "<value of type BarPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = DefaultsSenderProxy_SendBar_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_bar));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DefaultsSender::Name_);
  message.set_method_name("SendBar");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class DefaultsSenderProxy_SendFoo_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit DefaultsSenderProxy_SendFoo_Message(
      uint32_t message_flags
      , FooPtr param_foo
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kDefaultsSender_SendFoo_Name,
          message_flags)
      , param_foo_(std::move(param_foo)){}
  ~DefaultsSenderProxy_SendFoo_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      FooPtr param_foo) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<DefaultsSenderProxy_SendFoo_Message>(
          kFlags
          , std::move(param_foo)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kDefaultsSender_SendFoo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::sample::internal::DefaultsSender_SendFoo_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->foo)::BaseType> foo_fragment(
          params.message());
  mojo::internal::Serialize<::sample::FooDataView>(
      param_foo, foo_fragment);
  params->foo.Set(
      foo_fragment.is_null() ? nullptr : foo_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->foo.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null foo in DefaultsSender.SendFoo request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      DefaultsSender* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->SendFoo(
        std::move(param_foo_));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::sample::internal::DefaultsSender_SendFoo_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->foo)::BaseType> foo_fragment(
          params.message());
  mojo::internal::Serialize<::sample::FooDataView>(
      param_foo_, foo_fragment);
  params->foo.Set(
      foo_fragment.is_null() ? nullptr : foo_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->foo.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null foo in DefaultsSender.SendFoo request");
  }
  FooPtr param_foo_;

  DISALLOW_COPY_AND_ASSIGN(DefaultsSenderProxy_SendFoo_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
DefaultsSenderProxy_SendFoo_Message::kMessageTag = {};

void DefaultsSenderProxy::SendFoo(
    FooPtr in_foo) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "sample::DefaultsSender::SendFoo", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("foo"), in_foo, 
                        "<value of type FooPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = DefaultsSenderProxy_SendFoo_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_foo));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DefaultsSender::Name_);
  message.set_method_name("SendFoo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class DefaultsSenderProxy_SendDefaultsTest_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit DefaultsSenderProxy_SendDefaultsTest_Message(
      uint32_t message_flags
      , DefaultsTestPtr param_defaults
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kDefaultsSender_SendDefaultsTest_Name,
          message_flags)
      , param_defaults_(std::move(param_defaults)){}
  ~DefaultsSenderProxy_SendDefaultsTest_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      DefaultsTestPtr param_defaults) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<DefaultsSenderProxy_SendDefaultsTest_Message>(
          kFlags
          , std::move(param_defaults)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kDefaultsSender_SendDefaultsTest_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::sample::internal::DefaultsSender_SendDefaultsTest_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->defaults)::BaseType> defaults_fragment(
          params.message());
  mojo::internal::Serialize<::sample::DefaultsTestDataView>(
      param_defaults, defaults_fragment);
  params->defaults.Set(
      defaults_fragment.is_null() ? nullptr : defaults_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->defaults.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null defaults in DefaultsSender.SendDefaultsTest request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      DefaultsSender* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->SendDefaultsTest(
        std::move(param_defaults_));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::sample::internal::DefaultsSender_SendDefaultsTest_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->defaults)::BaseType> defaults_fragment(
          params.message());
  mojo::internal::Serialize<::sample::DefaultsTestDataView>(
      param_defaults_, defaults_fragment);
  params->defaults.Set(
      defaults_fragment.is_null() ? nullptr : defaults_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->defaults.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null defaults in DefaultsSender.SendDefaultsTest request");
  }
  DefaultsTestPtr param_defaults_;

  DISALLOW_COPY_AND_ASSIGN(DefaultsSenderProxy_SendDefaultsTest_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
DefaultsSenderProxy_SendDefaultsTest_Message::kMessageTag = {};

void DefaultsSenderProxy::SendDefaultsTest(
    DefaultsTestPtr in_defaults) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "sample::DefaultsSender::SendDefaultsTest", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("defaults"), in_defaults, 
                        "<value of type DefaultsTestPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = DefaultsSenderProxy_SendDefaultsTest_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_defaults));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DefaultsSender::Name_);
  message.set_method_name("SendDefaultsTest");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool DefaultsSenderStubDispatch::Accept(
    DefaultsSender* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kDefaultsSender_SendBar_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)sample::DefaultsSender::SendBar",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)sample::DefaultsSender::SendBar");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            DefaultsSenderProxy_SendBar_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::DefaultsSender_SendBar_Params_Data* params =
          reinterpret_cast<internal::DefaultsSender_SendBar_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      BarPtr p_bar{};
      DefaultsSender_SendBar_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBar(&p_bar))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DefaultsSender::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendBar(
std::move(p_bar));
      return true;
    }
    case internal::kDefaultsSender_SendFoo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)sample::DefaultsSender::SendFoo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)sample::DefaultsSender::SendFoo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            DefaultsSenderProxy_SendFoo_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::DefaultsSender_SendFoo_Params_Data* params =
          reinterpret_cast<internal::DefaultsSender_SendFoo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      FooPtr p_foo{};
      DefaultsSender_SendFoo_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFoo(&p_foo))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DefaultsSender::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendFoo(
std::move(p_foo));
      return true;
    }
    case internal::kDefaultsSender_SendDefaultsTest_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)sample::DefaultsSender::SendDefaultsTest",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)sample::DefaultsSender::SendDefaultsTest");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            DefaultsSenderProxy_SendDefaultsTest_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::DefaultsSender_SendDefaultsTest_Params_Data* params =
          reinterpret_cast<internal::DefaultsSender_SendDefaultsTest_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      DefaultsTestPtr p_defaults{};
      DefaultsSender_SendDefaultsTest_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDefaults(&p_defaults))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DefaultsSender::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendDefaultsTest(
std::move(p_defaults));
      return true;
    }
  }
  return false;
}

// static
bool DefaultsSenderStubDispatch::AcceptWithResponder(
    DefaultsSender* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kDefaultsSender_SendBar_Name: {
      break;
    }
    case internal::kDefaultsSender_SendFoo_Name: {
      break;
    }
    case internal::kDefaultsSender_SendDefaultsTest_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kDefaultsSenderValidationInfo[] = {
    {&internal::DefaultsSender_SendBar_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DefaultsSender_SendFoo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DefaultsSender_SendDefaultsTest_Params_Data::Validate,
     nullptr /* no response */},
};

bool DefaultsSenderRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::sample::DefaultsSender::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kDefaultsSenderValidationInfo);
}

const char Service::Name_[] = "sample.Service";
constexpr uint8_t Service::kFavoriteBaz;

class Service_Frobinate_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Service_Frobinate_ForwardToCallback(
      Service::FrobinateCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Service::FrobinateCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Service_Frobinate_ForwardToCallback);
};

ServiceProxy::ServiceProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class ServiceProxy_Frobinate_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ServiceProxy_Frobinate_Message(
      uint32_t message_flags
      , FooPtr param_foo
      , Service::BazOptions param_baz
      , ::mojo::PendingRemote<Port> param_port
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kService_Frobinate_Name,
          message_flags)
      , param_foo_(std::move(param_foo))
      , param_baz_(std::move(param_baz))
      , param_port_(std::move(param_port)){}
  ~ServiceProxy_Frobinate_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      FooPtr param_foo, Service::BazOptions param_baz, ::mojo::PendingRemote<Port> param_port) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ServiceProxy_Frobinate_Message>(
          kFlags
          , std::move(param_foo)
          , std::move(param_baz)
          , std::move(param_port)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kService_Frobinate_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::sample::internal::Service_Frobinate_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->foo)::BaseType> foo_fragment(
          params.message());
  mojo::internal::Serialize<::sample::FooDataView>(
      param_foo, foo_fragment);
  params->foo.Set(
      foo_fragment.is_null() ? nullptr : foo_fragment.data());
  mojo::internal::Serialize<::sample::Service_BazOptions>(
      param_baz, &params->baz);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::sample::PortInterfaceBase>>(
      param_port, &params->port, &params.message());
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      Service* impl, Service::FrobinateCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->Frobinate(
        std::move(param_foo_),
        std::move(param_baz_),
        std::move(param_port_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::sample::internal::Service_Frobinate_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->foo)::BaseType> foo_fragment(
          params.message());
  mojo::internal::Serialize<::sample::FooDataView>(
      param_foo_, foo_fragment);
  params->foo.Set(
      foo_fragment.is_null() ? nullptr : foo_fragment.data());
  mojo::internal::Serialize<::sample::Service_BazOptions>(
      param_baz_, &params->baz);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::sample::PortInterfaceBase>>(
      param_port_, &params->port, &params.message());
  }
  FooPtr param_foo_;
  Service::BazOptions param_baz_;
  ::mojo::PendingRemote<Port> param_port_;

  DISALLOW_COPY_AND_ASSIGN(ServiceProxy_Frobinate_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ServiceProxy_Frobinate_Message::kMessageTag = {};

void ServiceProxy::Frobinate(
    FooPtr in_foo, Service::BazOptions in_baz, ::mojo::PendingRemote<Port> in_port, FrobinateCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "sample::Service::Frobinate", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("foo"), in_foo, 
                        "<value of type FooPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("baz"), in_baz, 
                        "<value of type Service::BazOptions>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("port"), in_port, 
                        "<value of type ::mojo::PendingRemote<Port>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = ServiceProxy_Frobinate_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_foo), std::move(in_baz), std::move(in_port));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Service::Name_);
  message.set_method_name("Frobinate");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Service_Frobinate_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class ServiceProxy_GetPort_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ServiceProxy_GetPort_Message(
      uint32_t message_flags
      , ::mojo::PendingReceiver<Port> param_receiver
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kService_GetPort_Name,
          message_flags)
      , param_receiver_(std::move(param_receiver)){}
  ~ServiceProxy_GetPort_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      ::mojo::PendingReceiver<Port> param_receiver) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ServiceProxy_GetPort_Message>(
          kFlags
          , std::move(param_receiver)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kService_GetPort_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::sample::internal::Service_GetPort_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::sample::PortInterfaceBase>>(
      param_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in Service.GetPort request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      Service* impl) {
    if (message->receiver_connection_group()) {
      param_receiver_.set_connection_group(
          *message->receiver_connection_group());
    }

    impl->GetPort(
        std::move(param_receiver_));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::sample::internal::Service_GetPort_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::sample::PortInterfaceBase>>(
      param_receiver_, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in Service.GetPort request");
  }
  ::mojo::PendingReceiver<Port> param_receiver_;

  DISALLOW_COPY_AND_ASSIGN(ServiceProxy_GetPort_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ServiceProxy_GetPort_Message::kMessageTag = {};

void ServiceProxy::GetPort(
    ::mojo::PendingReceiver<Port> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "sample::Service::GetPort", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver, 
                        "<value of type ::mojo::PendingReceiver<Port>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = ServiceProxy_GetPort_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_receiver));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Service::Name_);
  message.set_method_name("GetPort");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class Service_Frobinate_ProxyToResponder {
 public:
  static Service::FrobinateCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<Service_Frobinate_ProxyToResponder> proxy(
        new Service_Frobinate_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&Service_Frobinate_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Service_Frobinate_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Service_Frobinate_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Service::FrobinateCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Service_Frobinate_ProxyToResponder);
};
class Service_Frobinate_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit Service_Frobinate_Response_Message(
      uint32_t message_flags
      , int32_t param_result
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kService_Frobinate_Name,
          message_flags)
      , param_result_(std::move(param_result)){}
  ~Service_Frobinate_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      int32_t param_result) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<Service_Frobinate_Response_Message>(
          kFlags
          , std::move(param_result)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kService_Frobinate_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::sample::internal::Service_Frobinate_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = param_result;
    return message;
  }


  void Dispatch(mojo::Message* message,
                Service::FrobinateCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_result_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::sample::internal::Service_Frobinate_ResponseParams_Data> params(
            message);
    params.Allocate();
  params->result = param_result_;
  }
  int32_t param_result_;

  DISALLOW_COPY_AND_ASSIGN(Service_Frobinate_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
Service_Frobinate_Response_Message::kMessageTag = {};

bool Service_Frobinate_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "sample::Service::FrobinateCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<Service_Frobinate_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::Service_Frobinate_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Service_Frobinate_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  Service_Frobinate_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Service::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void Service_Frobinate_ProxyToResponder::Run(
    int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)sample::Service::FrobinateCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result, 
                        "<value of type int32_t>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = Service_Frobinate_Response_Message::Build(kSerialize, is_sync_, std::move(in_result));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)sample::Service::FrobinateCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Service::Name_);
  message.set_method_name("Frobinate");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool ServiceStubDispatch::Accept(
    Service* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kService_Frobinate_Name: {
      break;
    }
    case internal::kService_GetPort_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)sample::Service::GetPort",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)sample::Service::GetPort");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            ServiceProxy_GetPort_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::Service_GetPort_Params_Data* params =
          reinterpret_cast<internal::Service_GetPort_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<Port> p_receiver{};
      Service_GetPort_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Service::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetPort(
std::move(p_receiver));
      return true;
    }
  }
  return false;
}

// static
bool ServiceStubDispatch::AcceptWithResponder(
    Service* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kService_Frobinate_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)sample::Service::Frobinate",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)sample::Service::Frobinate");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            ServiceProxy_Frobinate_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          Service::FrobinateCallback callback =
              Service_Frobinate_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::Service_Frobinate_Params_Data* params =
          reinterpret_cast<
              internal::Service_Frobinate_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      FooPtr p_foo{};
      Service::BazOptions p_baz{};
      ::mojo::PendingRemote<Port> p_port{};
      Service_Frobinate_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFoo(&p_foo))
        success = false;
      if (success && !input_data_view.ReadBaz(&p_baz))
        success = false;
      if (success) {
        p_port =
            input_data_view.TakePort<decltype(p_port)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Service::Name_, 0, false);
        return false;
      }
      Service::FrobinateCallback callback =
          Service_Frobinate_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Frobinate(
std::move(p_foo), 
std::move(p_baz), 
std::move(p_port), std::move(callback));
      return true;
    }
    case internal::kService_GetPort_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kServiceValidationInfo[] = {
    {&internal::Service_Frobinate_Params_Data::Validate,
     &internal::Service_Frobinate_ResponseParams_Data::Validate},
    {&internal::Service_GetPort_Params_Data::Validate,
     nullptr /* no response */},
};

bool ServiceRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::sample::Service::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kServiceValidationInfo);
}

bool ServiceResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::sample::Service::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kServiceValidationInfo);
}
const char Port::Name_[] = "sample.Port";

PortProxy::PortProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class PortProxy_PostMessageToPort_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PortProxy_PostMessageToPort_Message(
      uint32_t message_flags
      , const std::string& param_message_text
      , ::mojo::PendingRemote<Port> param_port
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPort_PostMessageToPort_Name,
          message_flags)
      , param_message_text_(std::move(param_message_text))
      , param_port_(std::move(param_port)){}
  ~PortProxy_PostMessageToPort_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      const std::string& param_message_text, ::mojo::PendingRemote<Port> param_port) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PortProxy_PostMessageToPort_Message>(
          kFlags
          , std::move(param_message_text)
          , std::move(param_port)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPort_PostMessageToPort_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::sample::internal::Port_PostMessageToPort_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->message_text)::BaseType> message_text_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_message_text, message_text_fragment);
  params->message_text.Set(
      message_text_fragment.is_null() ? nullptr : message_text_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message_text.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message_text in Port.PostMessageToPort request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::sample::PortInterfaceBase>>(
      param_port, &params->port, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->port),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid port in Port.PostMessageToPort request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      Port* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->PostMessageToPort(
        std::move(param_message_text_),
        std::move(param_port_));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::sample::internal::Port_PostMessageToPort_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->message_text)::BaseType> message_text_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_message_text_, message_text_fragment);
  params->message_text.Set(
      message_text_fragment.is_null() ? nullptr : message_text_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message_text.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message_text in Port.PostMessageToPort request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::sample::PortInterfaceBase>>(
      param_port_, &params->port, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->port),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid port in Port.PostMessageToPort request");
  }
  std::string param_message_text_;
  ::mojo::PendingRemote<Port> param_port_;

  DISALLOW_COPY_AND_ASSIGN(PortProxy_PostMessageToPort_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PortProxy_PostMessageToPort_Message::kMessageTag = {};

void PortProxy::PostMessageToPort(
    const std::string& in_message_text, ::mojo::PendingRemote<Port> in_port) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "sample::Port::PostMessageToPort", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message_text"), in_message_text, 
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("port"), in_port, 
                        "<value of type ::mojo::PendingRemote<Port>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = PortProxy_PostMessageToPort_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_message_text), std::move(in_port));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Port::Name_);
  message.set_method_name("PostMessageToPort");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PortStubDispatch::Accept(
    Port* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPort_PostMessageToPort_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)sample::Port::PostMessageToPort",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)sample::Port::PostMessageToPort");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            PortProxy_PostMessageToPort_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::Port_PostMessageToPort_Params_Data* params =
          reinterpret_cast<internal::Port_PostMessageToPort_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_message_text{};
      ::mojo::PendingRemote<Port> p_port{};
      Port_PostMessageToPort_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadMessageText(&p_message_text))
        success = false;
      if (success) {
        p_port =
            input_data_view.TakePort<decltype(p_port)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Port::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PostMessageToPort(
std::move(p_message_text), 
std::move(p_port));
      return true;
    }
  }
  return false;
}

// static
bool PortStubDispatch::AcceptWithResponder(
    Port* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPort_PostMessageToPort_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPortValidationInfo[] = {
    {&internal::Port_PostMessageToPort_Params_Data::Validate,
     nullptr /* no response */},
};

bool PortRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::sample::Port::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPortValidationInfo);
}

}  // namespace sample

namespace mojo {


// static
bool StructTraits<::sample::Bar::DataView, ::sample::BarPtr>::Read(
    ::sample::Bar::DataView input,
    ::sample::BarPtr* output) {
  bool success = true;
  ::sample::BarPtr result(::sample::Bar::New());
  
      if (success)
        result->alpha = input.alpha();
      if (success)
        result->beta = input.beta();
      if (success)
        result->gamma = input.gamma();
      if (success && !input.ReadType(&result->type))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::sample::Foo::DataView, ::sample::FooPtr>::Read(
    ::sample::Foo::DataView input,
    ::sample::FooPtr* output) {
  bool success = true;
  ::sample::FooPtr result(::sample::Foo::New());
  
      if (success)
        result->x = input.x();
      if (success)
        result->y = input.y();
      if (success)
        result->a = input.a();
      if (success)
        result->b = input.b();
      if (success)
        result->c = input.c();
      if (success && !input.ReadBar(&result->bar))
        success = false;
      if (success && !input.ReadData(&result->data))
        success = false;
      if (success && !input.ReadExtraBars(&result->extra_bars))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success)
        result->source = input.TakeSource();
      if (success && !input.ReadInputStreams(&result->input_streams))
        success = false;
      if (success && !input.ReadOutputStreams(&result->output_streams))
        success = false;
      if (success && !input.ReadArrayOfArrayOfBools(&result->array_of_array_of_bools))
        success = false;
      if (success && !input.ReadMultiArrayOfStrings(&result->multi_array_of_strings))
        success = false;
      if (success && !input.ReadArrayOfBools(&result->array_of_bools))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::sample::DefaultsTest::DataView, ::sample::DefaultsTestPtr>::Read(
    ::sample::DefaultsTest::DataView input,
    ::sample::DefaultsTestPtr* output) {
  bool success = true;
  ::sample::DefaultsTestPtr result(::sample::DefaultsTest::New());
  
      if (success)
        result->a0 = input.a0();
      if (success)
        result->a1 = input.a1();
      if (success)
        result->a2 = input.a2();
      if (success)
        result->a3 = input.a3();
      if (success)
        result->a4 = input.a4();
      if (success)
        result->a5 = input.a5();
      if (success)
        result->a6 = input.a6();
      if (success)
        result->a7 = input.a7();
      if (success)
        result->a8 = input.a8();
      if (success)
        result->a9 = input.a9();
      if (success)
        result->a10 = input.a10();
      if (success)
        result->a11 = input.a11();
      if (success)
        result->a12 = input.a12();
      if (success)
        result->a13 = input.a13();
      if (success)
        result->a14 = input.a14();
      if (success)
        result->a15 = input.a15();
      if (success)
        result->a16 = input.a16();
      if (success)
        result->a17 = input.a17();
      if (success && !input.ReadA18(&result->a18))
        success = false;
      if (success && !input.ReadA19(&result->a19))
        success = false;
      if (success && !input.ReadA20(&result->a20))
        success = false;
      if (success && !input.ReadA21(&result->a21))
        success = false;
      if (success && !input.ReadA22(&result->a22))
        success = false;
      if (success)
        result->a23 = input.a23();
      if (success)
        result->a24 = input.a24();
      if (success)
        result->a25 = input.a25();
      if (success)
        result->a26 = input.a26();
      if (success)
        result->a27 = input.a27();
      if (success)
        result->a28 = input.a28();
      if (success)
        result->a29 = input.a29();
      if (success)
        result->a30 = input.a30();
      if (success)
        result->a31 = input.a31();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::sample::StructWithHoleV1::DataView, ::sample::StructWithHoleV1Ptr>::Read(
    ::sample::StructWithHoleV1::DataView input,
    ::sample::StructWithHoleV1Ptr* output) {
  bool success = true;
  ::sample::StructWithHoleV1Ptr result(::sample::StructWithHoleV1::New());
  
      if (success)
        result->v1 = input.v1();
      if (success)
        result->v2 = input.v2();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::sample::StructWithHoleV2::DataView, ::sample::StructWithHoleV2Ptr>::Read(
    ::sample::StructWithHoleV2::DataView input,
    ::sample::StructWithHoleV2Ptr* output) {
  bool success = true;
  ::sample::StructWithHoleV2Ptr result(::sample::StructWithHoleV2::New());
  
      if (success)
        result->v1 = input.v1();
      if (success)
        result->v2 = input.v2();
      if (success)
        result->v3 = input.v3();
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif