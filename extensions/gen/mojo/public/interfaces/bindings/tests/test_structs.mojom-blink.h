// mojo/public/interfaces/bindings/tests/test_structs.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_BLINK_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
#include "mojo/public/interfaces/bindings/tests/test_structs.mojom-shared.h"
#include "mojo/public/interfaces/bindings/tests/test_structs.mojom-blink-forward.h"
#include "mojo/public/interfaces/bindings/tests/rect.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"

#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif


namespace WTF {
struct mojo_test_internal_ScopedConstants_EType_DataHashFn {
  static unsigned GetHash(const ::mojo::test::ScopedConstants_EType& value) {
    using utype = std::underlying_type<::mojo::test::ScopedConstants_EType>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::mojo::test::ScopedConstants_EType& left, const ::mojo::test::ScopedConstants_EType& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::mojo::test::ScopedConstants_EType>
    : public GenericHashTraits<::mojo::test::ScopedConstants_EType> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool hasIsEmptyValueFunction = true;
  static bool IsEmptyValue(const ::mojo::test::ScopedConstants_EType& value) {
    return value == static_cast<::mojo::test::ScopedConstants_EType>(-1000000);
  }
  static void ConstructDeletedValue(::mojo::test::ScopedConstants_EType& slot, bool) {
    slot = static_cast<::mojo::test::ScopedConstants_EType>(-1000001);
  }
  static bool IsDeletedValue(const ::mojo::test::ScopedConstants_EType& value) {
    return value == static_cast<::mojo::test::ScopedConstants_EType>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct mojo_test_internal_EnumNestedStruct_StructEnum_DataHashFn {
  static unsigned GetHash(const ::mojo::test::EnumNestedStruct_StructEnum& value) {
    using utype = std::underlying_type<::mojo::test::EnumNestedStruct_StructEnum>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::mojo::test::EnumNestedStruct_StructEnum& left, const ::mojo::test::EnumNestedStruct_StructEnum& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::mojo::test::EnumNestedStruct_StructEnum>
    : public GenericHashTraits<::mojo::test::EnumNestedStruct_StructEnum> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool hasIsEmptyValueFunction = true;
  static bool IsEmptyValue(const ::mojo::test::EnumNestedStruct_StructEnum& value) {
    return value == static_cast<::mojo::test::EnumNestedStruct_StructEnum>(-1000000);
  }
  static void ConstructDeletedValue(::mojo::test::EnumNestedStruct_StructEnum& slot, bool) {
    slot = static_cast<::mojo::test::EnumNestedStruct_StructEnum>(-1000001);
  }
  static bool IsDeletedValue(const ::mojo::test::EnumNestedStruct_StructEnum& value) {
    return value == static_cast<::mojo::test::EnumNestedStruct_StructEnum>(-1000001);
  }
};
}  // namespace WTF


namespace mojo {
namespace test {
namespace blink {

class SomeInterfaceProxy;

template <typename ImplRefTraits>
class SomeInterfaceStub;

class SomeInterfaceRequestValidator;
class SomeInterfaceResponseValidator;


// @generated_from: mojo.test.SomeInterface
class  SomeInterface
    : public SomeInterfaceInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = SomeInterfaceInterfaceBase;
  using Proxy_ = SomeInterfaceProxy;

  template <typename ImplRefTraits>
  using Stub_ = SomeInterfaceStub<ImplRefTraits>;

  using RequestValidator_ = SomeInterfaceRequestValidator;
  using ResponseValidator_ = SomeInterfaceResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSomeMethodMinVersion = 0,
  };
  virtual ~SomeInterface() {}


  using SomeMethodCallback = base::OnceCallback<void(RectPairPtr)>;
  
// @generated_from: mojo.test.SomeInterface.SomeMethod
  virtual void SomeMethod(RectPairPtr pair, SomeMethodCallback callback) = 0;
};



// @generated_from: mojo.test.SomeInterface
class  SomeInterfaceProxy
    : public SomeInterface {
 public:
  using InterfaceType = SomeInterface;

  explicit SomeInterfaceProxy(mojo::MessageReceiverWithResponder* receiver);
  
// @generated_from: mojo.test.SomeInterface.SomeMethod
  void SomeMethod(RectPairPtr pair, SomeMethodCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  SomeInterfaceStubDispatch {
 public:
  static bool Accept(SomeInterface* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SomeInterface* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SomeInterface>>
class SomeInterfaceStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SomeInterfaceStub() {}
  ~SomeInterfaceStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SomeInterfaceStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SomeInterfaceStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  SomeInterfaceRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  SomeInterfaceResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};







// @generated_from: mojo.test.EmptyStruct
class  EmptyStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EmptyStruct, T>::value>;
  using DataView = EmptyStructDataView;
  using Data_ = internal::EmptyStruct_Data;

  template <typename... Args>
  static EmptyStructPtr New(Args&&... args) {
    return EmptyStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EmptyStructPtr From(const U& u) {
    return mojo::TypeConverter<EmptyStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EmptyStruct>::Convert(*this);
  }


  EmptyStruct();

  ~EmptyStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EmptyStructPtr>
  EmptyStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EmptyStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EmptyStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EmptyStruct_UnserializedMessageContext<
            UserType, EmptyStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EmptyStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return EmptyStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EmptyStruct_UnserializedMessageContext<
            UserType, EmptyStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EmptyStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }


  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

















// @generated_from: mojo.test.MultiVersionStructV0
class  MultiVersionStructV0 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV0, T>::value>;
  using DataView = MultiVersionStructV0DataView;
  using Data_ = internal::MultiVersionStructV0_Data;

  template <typename... Args>
  static MultiVersionStructV0Ptr New(Args&&... args) {
    return MultiVersionStructV0Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV0Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV0Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV0>::Convert(*this);
  }


  MultiVersionStructV0();

  explicit MultiVersionStructV0(
      int32_t f_int32);

  ~MultiVersionStructV0();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV0Ptr>
  MultiVersionStructV0Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MultiVersionStructV0::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV0::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV0_UnserializedMessageContext<
            UserType, MultiVersionStructV0::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV0::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV0::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV0_UnserializedMessageContext<
            UserType, MultiVersionStructV0::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV0::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV0.f_int32
  int32_t f_int32;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}









// @generated_from: mojo.test.ReorderedStruct
class  ReorderedStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ReorderedStruct, T>::value>;
  using DataView = ReorderedStructDataView;
  using Data_ = internal::ReorderedStruct_Data;

  template <typename... Args>
  static ReorderedStructPtr New(Args&&... args) {
    return ReorderedStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ReorderedStructPtr From(const U& u) {
    return mojo::TypeConverter<ReorderedStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ReorderedStruct>::Convert(*this);
  }


  ReorderedStruct();

  explicit ReorderedStruct(
      int32_t c);

  ReorderedStruct(
      int32_t a,
      int32_t c);

  ReorderedStruct(
      int32_t a,
      int32_t b,
      int32_t c);

  ~ReorderedStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ReorderedStructPtr>
  ReorderedStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ReorderedStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ReorderedStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ReorderedStruct_UnserializedMessageContext<
            UserType, ReorderedStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ReorderedStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ReorderedStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ReorderedStruct_UnserializedMessageContext<
            UserType, ReorderedStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ReorderedStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ReorderedStruct.a
  int32_t a;
  
// @generated_from: mojo.test.ReorderedStruct.b
  int32_t b;
  
// @generated_from: mojo.test.ReorderedStruct.c
  int32_t c;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.ContainsOther
class  ContainsOther {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ContainsOther, T>::value>;
  using DataView = ContainsOtherDataView;
  using Data_ = internal::ContainsOther_Data;

  template <typename... Args>
  static ContainsOtherPtr New(Args&&... args) {
    return ContainsOtherPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ContainsOtherPtr From(const U& u) {
    return mojo::TypeConverter<ContainsOtherPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsOther>::Convert(*this);
  }


  ContainsOther();

  explicit ContainsOther(
      int32_t other);

  ~ContainsOther();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ContainsOtherPtr>
  ContainsOtherPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ContainsOther::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ContainsOther::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ContainsOther_UnserializedMessageContext<
            UserType, ContainsOther::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ContainsOther::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ContainsOther::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ContainsOther_UnserializedMessageContext<
            UserType, ContainsOther::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ContainsOther::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ContainsOther.other
  int32_t other;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.SingleBoolStruct
class  SingleBoolStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SingleBoolStruct, T>::value>;
  using DataView = SingleBoolStructDataView;
  using Data_ = internal::SingleBoolStruct_Data;

  template <typename... Args>
  static SingleBoolStructPtr New(Args&&... args) {
    return SingleBoolStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SingleBoolStructPtr From(const U& u) {
    return mojo::TypeConverter<SingleBoolStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SingleBoolStruct>::Convert(*this);
  }


  SingleBoolStruct();

  explicit SingleBoolStruct(
      bool value);

  ~SingleBoolStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SingleBoolStructPtr>
  SingleBoolStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SingleBoolStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SingleBoolStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SingleBoolStruct_UnserializedMessageContext<
            UserType, SingleBoolStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SingleBoolStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return SingleBoolStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SingleBoolStruct_UnserializedMessageContext<
            UserType, SingleBoolStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SingleBoolStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SingleBoolStruct.value
  bool value;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







// @generated_from: mojo.test.EnumNestedStruct
class  EnumNestedStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EnumNestedStruct, T>::value>;
  using DataView = EnumNestedStructDataView;
  using Data_ = internal::EnumNestedStruct_Data;
// @generated_from: mojo.test.EnumNestedStruct.StructEnum
  using StructEnum = EnumNestedStruct_StructEnum;

  template <typename... Args>
  static EnumNestedStructPtr New(Args&&... args) {
    return EnumNestedStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EnumNestedStructPtr From(const U& u) {
    return mojo::TypeConverter<EnumNestedStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EnumNestedStruct>::Convert(*this);
  }


  EnumNestedStruct();

  explicit EnumNestedStruct(
      EnumNestedStruct::StructEnum local_enum_state_);

  ~EnumNestedStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EnumNestedStructPtr>
  EnumNestedStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EnumNestedStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EnumNestedStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EnumNestedStruct_UnserializedMessageContext<
            UserType, EnumNestedStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EnumNestedStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return EnumNestedStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EnumNestedStruct_UnserializedMessageContext<
            UserType, EnumNestedStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EnumNestedStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.EnumNestedStruct.local_enum_state_
  EnumNestedStruct::StructEnum local_enum_state_;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







// @generated_from: mojo.test.NamedRegion
class  NamedRegion {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NamedRegion, T>::value>;
  using DataView = NamedRegionDataView;
  using Data_ = internal::NamedRegion_Data;

  template <typename... Args>
  static NamedRegionPtr New(Args&&... args) {
    return NamedRegionPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NamedRegionPtr From(const U& u) {
    return mojo::TypeConverter<NamedRegionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NamedRegion>::Convert(*this);
  }


  NamedRegion();

  NamedRegion(
      const WTF::String& name,
      base::Optional<WTF::Vector<::mojo::test::blink::RectPtr>> rects);

  ~NamedRegion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NamedRegionPtr>
  NamedRegionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        NamedRegion::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NamedRegion::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NamedRegion_UnserializedMessageContext<
            UserType, NamedRegion::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NamedRegion::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NamedRegion::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NamedRegion_UnserializedMessageContext<
            UserType, NamedRegion::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NamedRegion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.NamedRegion.name
  WTF::String name;
  
// @generated_from: mojo.test.NamedRegion.rects
  base::Optional<WTF::Vector<::mojo::test::blink::RectPtr>> rects;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(NamedRegion);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.RectPair
class  RectPair {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<RectPair, T>::value>;
  using DataView = RectPairDataView;
  using Data_ = internal::RectPair_Data;

  template <typename... Args>
  static RectPairPtr New(Args&&... args) {
    return RectPairPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static RectPairPtr From(const U& u) {
    return mojo::TypeConverter<RectPairPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RectPair>::Convert(*this);
  }


  RectPair();

  RectPair(
      ::mojo::test::blink::RectPtr first,
      ::mojo::test::blink::RectPtr second);

  ~RectPair();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = RectPairPtr>
  RectPairPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, RectPair::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, RectPair::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        RectPair::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        RectPair::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::RectPair_UnserializedMessageContext<
            UserType, RectPair::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<RectPair::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return RectPair::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::RectPair_UnserializedMessageContext<
            UserType, RectPair::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<RectPair::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.RectPair.first
  ::mojo::test::blink::RectPtr first;
  
// @generated_from: mojo.test.RectPair.second
  ::mojo::test::blink::RectPtr second;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(RectPair);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RectPair::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, RectPair::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, RectPair::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, RectPair::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







// @generated_from: mojo.test.NoDefaultFieldValues
class  NoDefaultFieldValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NoDefaultFieldValues, T>::value>;
  using DataView = NoDefaultFieldValuesDataView;
  using Data_ = internal::NoDefaultFieldValues_Data;

  template <typename... Args>
  static NoDefaultFieldValuesPtr New(Args&&... args) {
    return NoDefaultFieldValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NoDefaultFieldValuesPtr From(const U& u) {
    return mojo::TypeConverter<NoDefaultFieldValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NoDefaultFieldValues>::Convert(*this);
  }


  NoDefaultFieldValues();

  NoDefaultFieldValues(
      bool f0,
      int8_t f1,
      uint8_t f2,
      int16_t f3,
      uint16_t f4,
      int32_t f5,
      uint32_t f6,
      int64_t f7,
      uint64_t f8,
      float f9,
      double f10,
      const WTF::String& f11,
      const WTF::String& f12,
      ::mojo::ScopedMessagePipeHandle f13,
      ::mojo::ScopedDataPipeConsumerHandle f14,
      ::mojo::ScopedDataPipeProducerHandle f15,
      ::mojo::ScopedMessagePipeHandle f16,
      ::mojo::ScopedDataPipeConsumerHandle f17,
      ::mojo::ScopedDataPipeProducerHandle f18,
      ::mojo::ScopedHandle f19,
      ::mojo::ScopedHandle f20,
      ::mojo::ScopedSharedBufferHandle f21,
      ::mojo::ScopedSharedBufferHandle f22,
      WTF::Vector<WTF::String> f23,
      WTF::Vector<WTF::String> f24,
      base::Optional<WTF::Vector<WTF::String>> f25,
      base::Optional<WTF::Vector<WTF::String>> f26,
      EmptyStructPtr f27,
      EmptyStructPtr f28,
      ::mojo::PlatformHandle f29,
      ::mojo::PlatformHandle f30);

  ~NoDefaultFieldValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NoDefaultFieldValuesPtr>
  NoDefaultFieldValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NoDefaultFieldValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NoDefaultFieldValues_UnserializedMessageContext<
            UserType, NoDefaultFieldValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NoDefaultFieldValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NoDefaultFieldValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NoDefaultFieldValues_UnserializedMessageContext<
            UserType, NoDefaultFieldValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NoDefaultFieldValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.NoDefaultFieldValues.f0
  bool f0;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f1
  int8_t f1;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f2
  uint8_t f2;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f3
  int16_t f3;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f4
  uint16_t f4;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f5
  int32_t f5;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f6
  uint32_t f6;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f7
  int64_t f7;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f8
  uint64_t f8;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f9
  float f9;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f10
  double f10;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f11
  WTF::String f11;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f12
  WTF::String f12;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f13
  ::mojo::ScopedMessagePipeHandle f13;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f14
  ::mojo::ScopedDataPipeConsumerHandle f14;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f15
  ::mojo::ScopedDataPipeProducerHandle f15;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f16
  ::mojo::ScopedMessagePipeHandle f16;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f17
  ::mojo::ScopedDataPipeConsumerHandle f17;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f18
  ::mojo::ScopedDataPipeProducerHandle f18;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f19
  ::mojo::ScopedHandle f19;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f20
  ::mojo::ScopedHandle f20;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f21
  ::mojo::ScopedSharedBufferHandle f21;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f22
  ::mojo::ScopedSharedBufferHandle f22;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f23
  WTF::Vector<WTF::String> f23;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f24
  WTF::Vector<WTF::String> f24;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f25
  base::Optional<WTF::Vector<WTF::String>> f25;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f26
  base::Optional<WTF::Vector<WTF::String>> f26;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f27
  EmptyStructPtr f27;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f28
  EmptyStructPtr f28;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f29
  ::mojo::PlatformHandle f29;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f30
  ::mojo::PlatformHandle f30;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(NoDefaultFieldValues);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.DefaultFieldValues
class  DefaultFieldValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DefaultFieldValues, T>::value>;
  using DataView = DefaultFieldValuesDataView;
  using Data_ = internal::DefaultFieldValues_Data;
  
// @generated_from: mojo.test.DefaultFieldValues.kFoo
  static const char kFoo[];

  template <typename... Args>
  static DefaultFieldValuesPtr New(Args&&... args) {
    return DefaultFieldValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DefaultFieldValuesPtr From(const U& u) {
    return mojo::TypeConverter<DefaultFieldValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DefaultFieldValues>::Convert(*this);
  }


  DefaultFieldValues();

  DefaultFieldValues(
      bool f0,
      int8_t f1,
      uint8_t f2,
      int16_t f3,
      uint16_t f4,
      int32_t f5,
      uint32_t f6,
      int64_t f7,
      uint64_t f8,
      float f9,
      float f10,
      double f11,
      double f12,
      const WTF::String& f13,
      const WTF::String& f14,
      ::mojo::test::blink::RectPtr f15,
      ::mojo::test::blink::RectPtr f16);

  ~DefaultFieldValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DefaultFieldValuesPtr>
  DefaultFieldValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DefaultFieldValues::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DefaultFieldValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DefaultFieldValues_UnserializedMessageContext<
            UserType, DefaultFieldValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DefaultFieldValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return DefaultFieldValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DefaultFieldValues_UnserializedMessageContext<
            UserType, DefaultFieldValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DefaultFieldValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.DefaultFieldValues.f0
  bool f0;
  
// @generated_from: mojo.test.DefaultFieldValues.f1
  int8_t f1;
  
// @generated_from: mojo.test.DefaultFieldValues.f2
  uint8_t f2;
  
// @generated_from: mojo.test.DefaultFieldValues.f3
  int16_t f3;
  
// @generated_from: mojo.test.DefaultFieldValues.f4
  uint16_t f4;
  
// @generated_from: mojo.test.DefaultFieldValues.f5
  int32_t f5;
  
// @generated_from: mojo.test.DefaultFieldValues.f6
  uint32_t f6;
  
// @generated_from: mojo.test.DefaultFieldValues.f7
  int64_t f7;
  
// @generated_from: mojo.test.DefaultFieldValues.f8
  uint64_t f8;
  
// @generated_from: mojo.test.DefaultFieldValues.f9
  float f9;
  
// @generated_from: mojo.test.DefaultFieldValues.f10
  float f10;
  
// @generated_from: mojo.test.DefaultFieldValues.f11
  double f11;
  
// @generated_from: mojo.test.DefaultFieldValues.f12
  double f12;
  
// @generated_from: mojo.test.DefaultFieldValues.f13
  WTF::String f13;
  
// @generated_from: mojo.test.DefaultFieldValues.f14
  WTF::String f14;
  
// @generated_from: mojo.test.DefaultFieldValues.f15
  ::mojo::test::blink::RectPtr f15;
  
// @generated_from: mojo.test.DefaultFieldValues.f16
  ::mojo::test::blink::RectPtr f16;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(DefaultFieldValues);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.ScopedConstants
class  ScopedConstants {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ScopedConstants, T>::value>;
  using DataView = ScopedConstantsDataView;
  using Data_ = internal::ScopedConstants_Data;
// @generated_from: mojo.test.ScopedConstants.EType
  using EType = ScopedConstants_EType;
  
// @generated_from: mojo.test.ScopedConstants.TEN
  static constexpr int32_t TEN = 10;
  
// @generated_from: mojo.test.ScopedConstants.ALSO_TEN
  static constexpr int32_t ALSO_TEN = 10;

  template <typename... Args>
  static ScopedConstantsPtr New(Args&&... args) {
    return ScopedConstantsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ScopedConstantsPtr From(const U& u) {
    return mojo::TypeConverter<ScopedConstantsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ScopedConstants>::Convert(*this);
  }


  ScopedConstants();

  ScopedConstants(
      ScopedConstants::EType f0,
      ScopedConstants::EType f1,
      ScopedConstants::EType f2,
      ScopedConstants::EType f3,
      ScopedConstants::EType f4,
      int32_t f5,
      int32_t f6);

  ~ScopedConstants();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ScopedConstantsPtr>
  ScopedConstantsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ScopedConstants::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ScopedConstants::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ScopedConstants_UnserializedMessageContext<
            UserType, ScopedConstants::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ScopedConstants::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ScopedConstants::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ScopedConstants_UnserializedMessageContext<
            UserType, ScopedConstants::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ScopedConstants::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ScopedConstants.f0
  ScopedConstants::EType f0;
  
// @generated_from: mojo.test.ScopedConstants.f1
  ScopedConstants::EType f1;
  
// @generated_from: mojo.test.ScopedConstants.f2
  ScopedConstants::EType f2;
  
// @generated_from: mojo.test.ScopedConstants.f3
  ScopedConstants::EType f3;
  
// @generated_from: mojo.test.ScopedConstants.f4
  ScopedConstants::EType f4;
  
// @generated_from: mojo.test.ScopedConstants.f5
  int32_t f5;
  
// @generated_from: mojo.test.ScopedConstants.f6
  int32_t f6;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MapKeyTypes
class  MapKeyTypes {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MapKeyTypes, T>::value>;
  using DataView = MapKeyTypesDataView;
  using Data_ = internal::MapKeyTypes_Data;

  template <typename... Args>
  static MapKeyTypesPtr New(Args&&... args) {
    return MapKeyTypesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MapKeyTypesPtr From(const U& u) {
    return mojo::TypeConverter<MapKeyTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MapKeyTypes>::Convert(*this);
  }


  MapKeyTypes();

  MapKeyTypes(
      const WTF::HashMap<int8_t, int8_t>& f1,
      const WTF::HashMap<uint8_t, uint8_t>& f2,
      const WTF::HashMap<int16_t, int16_t>& f3,
      const WTF::HashMap<uint16_t, uint16_t>& f4,
      const WTF::HashMap<int32_t, int32_t>& f5,
      const WTF::HashMap<uint32_t, uint32_t>& f6,
      const WTF::HashMap<int64_t, int64_t>& f7,
      const WTF::HashMap<uint64_t, uint64_t>& f8,
      const WTF::HashMap<float, float>& f9,
      const WTF::HashMap<double, double>& f10,
      const WTF::HashMap<WTF::String, WTF::String>& f11);

  ~MapKeyTypes();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MapKeyTypesPtr>
  MapKeyTypesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MapKeyTypes::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MapKeyTypes::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MapKeyTypes_UnserializedMessageContext<
            UserType, MapKeyTypes::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MapKeyTypes::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MapKeyTypes::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MapKeyTypes_UnserializedMessageContext<
            UserType, MapKeyTypes::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MapKeyTypes::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MapKeyTypes.f1
  WTF::HashMap<int8_t, int8_t> f1;
  
// @generated_from: mojo.test.MapKeyTypes.f2
  WTF::HashMap<uint8_t, uint8_t> f2;
  
// @generated_from: mojo.test.MapKeyTypes.f3
  WTF::HashMap<int16_t, int16_t> f3;
  
// @generated_from: mojo.test.MapKeyTypes.f4
  WTF::HashMap<uint16_t, uint16_t> f4;
  
// @generated_from: mojo.test.MapKeyTypes.f5
  WTF::HashMap<int32_t, int32_t> f5;
  
// @generated_from: mojo.test.MapKeyTypes.f6
  WTF::HashMap<uint32_t, uint32_t> f6;
  
// @generated_from: mojo.test.MapKeyTypes.f7
  WTF::HashMap<int64_t, int64_t> f7;
  
// @generated_from: mojo.test.MapKeyTypes.f8
  WTF::HashMap<uint64_t, uint64_t> f8;
  
// @generated_from: mojo.test.MapKeyTypes.f9
  WTF::HashMap<float, float> f9;
  
// @generated_from: mojo.test.MapKeyTypes.f10
  WTF::HashMap<double, double> f10;
  
// @generated_from: mojo.test.MapKeyTypes.f11
  WTF::HashMap<WTF::String, WTF::String> f11;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MapValueTypes
class  MapValueTypes {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MapValueTypes, T>::value>;
  using DataView = MapValueTypesDataView;
  using Data_ = internal::MapValueTypes_Data;

  template <typename... Args>
  static MapValueTypesPtr New(Args&&... args) {
    return MapValueTypesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MapValueTypesPtr From(const U& u) {
    return mojo::TypeConverter<MapValueTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MapValueTypes>::Convert(*this);
  }


  MapValueTypes();

  MapValueTypes(
      const WTF::HashMap<WTF::String, WTF::Vector<WTF::String>>& f0,
      const WTF::HashMap<WTF::String, base::Optional<WTF::Vector<WTF::String>>>& f1,
      const WTF::HashMap<WTF::String, WTF::Vector<WTF::String>>& f2,
      const WTF::HashMap<WTF::String, WTF::Vector<WTF::String>>& f3,
      const WTF::HashMap<WTF::String, WTF::Vector<base::Optional<WTF::Vector<WTF::String>>>>& f4,
      const WTF::HashMap<WTF::String, WTF::Vector<WTF::Vector<WTF::String>>>& f5,
      WTF::HashMap<WTF::String, ::mojo::test::blink::RectPtr> f6,
      const WTF::HashMap<WTF::String, WTF::HashMap<WTF::String, WTF::String>>& f7,
      const WTF::HashMap<WTF::String, WTF::Vector<WTF::HashMap<WTF::String, WTF::String>>>& f8,
      WTF::HashMap<WTF::String, ::mojo::ScopedHandle> f9,
      WTF::HashMap<WTF::String, WTF::Vector<::mojo::ScopedHandle>> f10,
      WTF::HashMap<WTF::String, WTF::HashMap<WTF::String, ::mojo::ScopedHandle>> f11);

  ~MapValueTypes();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MapValueTypesPtr>
  MapValueTypesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MapValueTypes::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MapValueTypes_UnserializedMessageContext<
            UserType, MapValueTypes::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MapValueTypes::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MapValueTypes::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MapValueTypes_UnserializedMessageContext<
            UserType, MapValueTypes::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MapValueTypes::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MapValueTypes.f0
  WTF::HashMap<WTF::String, WTF::Vector<WTF::String>> f0;
  
// @generated_from: mojo.test.MapValueTypes.f1
  WTF::HashMap<WTF::String, base::Optional<WTF::Vector<WTF::String>>> f1;
  
// @generated_from: mojo.test.MapValueTypes.f2
  WTF::HashMap<WTF::String, WTF::Vector<WTF::String>> f2;
  
// @generated_from: mojo.test.MapValueTypes.f3
  WTF::HashMap<WTF::String, WTF::Vector<WTF::String>> f3;
  
// @generated_from: mojo.test.MapValueTypes.f4
  WTF::HashMap<WTF::String, WTF::Vector<base::Optional<WTF::Vector<WTF::String>>>> f4;
  
// @generated_from: mojo.test.MapValueTypes.f5
  WTF::HashMap<WTF::String, WTF::Vector<WTF::Vector<WTF::String>>> f5;
  
// @generated_from: mojo.test.MapValueTypes.f6
  WTF::HashMap<WTF::String, ::mojo::test::blink::RectPtr> f6;
  
// @generated_from: mojo.test.MapValueTypes.f7
  WTF::HashMap<WTF::String, WTF::HashMap<WTF::String, WTF::String>> f7;
  
// @generated_from: mojo.test.MapValueTypes.f8
  WTF::HashMap<WTF::String, WTF::Vector<WTF::HashMap<WTF::String, WTF::String>>> f8;
  
// @generated_from: mojo.test.MapValueTypes.f9
  WTF::HashMap<WTF::String, ::mojo::ScopedHandle> f9;
  
// @generated_from: mojo.test.MapValueTypes.f10
  WTF::HashMap<WTF::String, WTF::Vector<::mojo::ScopedHandle>> f10;
  
// @generated_from: mojo.test.MapValueTypes.f11
  WTF::HashMap<WTF::String, WTF::HashMap<WTF::String, ::mojo::ScopedHandle>> f11;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MapValueTypes);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.ArrayValueTypes
class  ArrayValueTypes {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ArrayValueTypes, T>::value>;
  using DataView = ArrayValueTypesDataView;
  using Data_ = internal::ArrayValueTypes_Data;

  template <typename... Args>
  static ArrayValueTypesPtr New(Args&&... args) {
    return ArrayValueTypesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ArrayValueTypesPtr From(const U& u) {
    return mojo::TypeConverter<ArrayValueTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ArrayValueTypes>::Convert(*this);
  }


  ArrayValueTypes();

  ArrayValueTypes(
      WTF::Vector<int8_t> f0,
      WTF::Vector<int16_t> f1,
      WTF::Vector<int32_t> f2,
      WTF::Vector<int64_t> f3,
      WTF::Vector<float> f4,
      WTF::Vector<double> f5,
      WTF::Vector<::mojo::PendingRemote<SomeInterface>> f6,
      WTF::Vector<::mojo::PendingReceiver<SomeInterface>> f7);

  ~ArrayValueTypes();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ArrayValueTypesPtr>
  ArrayValueTypesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ArrayValueTypes::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ArrayValueTypes_UnserializedMessageContext<
            UserType, ArrayValueTypes::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ArrayValueTypes::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ArrayValueTypes::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ArrayValueTypes_UnserializedMessageContext<
            UserType, ArrayValueTypes::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ArrayValueTypes::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ArrayValueTypes.f0
  WTF::Vector<int8_t> f0;
  
// @generated_from: mojo.test.ArrayValueTypes.f1
  WTF::Vector<int16_t> f1;
  
// @generated_from: mojo.test.ArrayValueTypes.f2
  WTF::Vector<int32_t> f2;
  
// @generated_from: mojo.test.ArrayValueTypes.f3
  WTF::Vector<int64_t> f3;
  
// @generated_from: mojo.test.ArrayValueTypes.f4
  WTF::Vector<float> f4;
  
// @generated_from: mojo.test.ArrayValueTypes.f5
  WTF::Vector<double> f5;
  
// @generated_from: mojo.test.ArrayValueTypes.f6
  WTF::Vector<::mojo::PendingRemote<SomeInterface>> f6;
  
// @generated_from: mojo.test.ArrayValueTypes.f7
  WTF::Vector<::mojo::PendingReceiver<SomeInterface>> f7;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ArrayValueTypes);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.FloatNumberValues
class  FloatNumberValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FloatNumberValues, T>::value>;
  using DataView = FloatNumberValuesDataView;
  using Data_ = internal::FloatNumberValues_Data;
  
// @generated_from: mojo.test.FloatNumberValues.V0
  static constexpr double V0 = std::numeric_limits<double>::infinity();
  
// @generated_from: mojo.test.FloatNumberValues.V1
  static constexpr double V1 = -std::numeric_limits<double>::infinity();
  
// @generated_from: mojo.test.FloatNumberValues.V2
  static constexpr double V2 = std::numeric_limits<double>::quiet_NaN();
  
// @generated_from: mojo.test.FloatNumberValues.V3
  static constexpr float V3 = std::numeric_limits<float>::infinity();
  
// @generated_from: mojo.test.FloatNumberValues.V4
  static constexpr float V4 = -std::numeric_limits<float>::infinity();
  
// @generated_from: mojo.test.FloatNumberValues.V5
  static constexpr float V5 = std::numeric_limits<float>::quiet_NaN();
  
// @generated_from: mojo.test.FloatNumberValues.V6
  static constexpr float V6 = 0;
  
// @generated_from: mojo.test.FloatNumberValues.V7
  static constexpr double V7 = 1234567890.123;
  
// @generated_from: mojo.test.FloatNumberValues.V8
  static constexpr double V8 = 1.2E+20;
  
// @generated_from: mojo.test.FloatNumberValues.V9
  static constexpr double V9 = -1.2E+20;

  template <typename... Args>
  static FloatNumberValuesPtr New(Args&&... args) {
    return FloatNumberValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FloatNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<FloatNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FloatNumberValues>::Convert(*this);
  }


  FloatNumberValues();

  FloatNumberValues(
      double f0,
      double f1,
      double f2,
      float f3,
      float f4,
      float f5,
      float f6,
      double f7,
      double f8,
      double f9);

  ~FloatNumberValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FloatNumberValuesPtr>
  FloatNumberValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FloatNumberValues::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FloatNumberValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FloatNumberValues_UnserializedMessageContext<
            UserType, FloatNumberValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FloatNumberValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return FloatNumberValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FloatNumberValues_UnserializedMessageContext<
            UserType, FloatNumberValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FloatNumberValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.FloatNumberValues.f0
  double f0;
  
// @generated_from: mojo.test.FloatNumberValues.f1
  double f1;
  
// @generated_from: mojo.test.FloatNumberValues.f2
  double f2;
  
// @generated_from: mojo.test.FloatNumberValues.f3
  float f3;
  
// @generated_from: mojo.test.FloatNumberValues.f4
  float f4;
  
// @generated_from: mojo.test.FloatNumberValues.f5
  float f5;
  
// @generated_from: mojo.test.FloatNumberValues.f6
  float f6;
  
// @generated_from: mojo.test.FloatNumberValues.f7
  double f7;
  
// @generated_from: mojo.test.FloatNumberValues.f8
  double f8;
  
// @generated_from: mojo.test.FloatNumberValues.f9
  double f9;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.IntegerNumberValues
class  IntegerNumberValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<IntegerNumberValues, T>::value>;
  using DataView = IntegerNumberValuesDataView;
  using Data_ = internal::IntegerNumberValues_Data;
  
// @generated_from: mojo.test.IntegerNumberValues.V0
  static constexpr int8_t V0 = -128;
  
// @generated_from: mojo.test.IntegerNumberValues.V1
  static constexpr int8_t V1 = -1;
  
// @generated_from: mojo.test.IntegerNumberValues.V2
  static constexpr int8_t V2 = 0;
  
// @generated_from: mojo.test.IntegerNumberValues.V3
  static constexpr int8_t V3 = 42;
  
// @generated_from: mojo.test.IntegerNumberValues.V4
  static constexpr int8_t V4 = 127;
  
// @generated_from: mojo.test.IntegerNumberValues.V5
  static constexpr int16_t V5 = -32768;
  
// @generated_from: mojo.test.IntegerNumberValues.V6
  static constexpr int16_t V6 = -1;
  
// @generated_from: mojo.test.IntegerNumberValues.V7
  static constexpr int16_t V7 = 0;
  
// @generated_from: mojo.test.IntegerNumberValues.V8
  static constexpr int16_t V8 = 12345;
  
// @generated_from: mojo.test.IntegerNumberValues.V9
  static constexpr int16_t V9 = 32767;
  
// @generated_from: mojo.test.IntegerNumberValues.V10
  static constexpr int32_t V10 = -2147483648;
  
// @generated_from: mojo.test.IntegerNumberValues.V11
  static constexpr int32_t V11 = -1;
  
// @generated_from: mojo.test.IntegerNumberValues.V12
  static constexpr int32_t V12 = 0;
  
// @generated_from: mojo.test.IntegerNumberValues.V13
  static constexpr int32_t V13 = 1234567890;
  
// @generated_from: mojo.test.IntegerNumberValues.V14
  static constexpr int32_t V14 = 2147483647;
  
// @generated_from: mojo.test.IntegerNumberValues.V15
  static constexpr int64_t V15 = -9007199254740991;
  
// @generated_from: mojo.test.IntegerNumberValues.V16
  static constexpr int64_t V16 = -1;
  
// @generated_from: mojo.test.IntegerNumberValues.V17
  static constexpr int64_t V17 = 0;
  
// @generated_from: mojo.test.IntegerNumberValues.V18
  static constexpr int64_t V18 = 1234567890123456;
  
// @generated_from: mojo.test.IntegerNumberValues.V19
  static constexpr int64_t V19 = 9007199254740991;

  template <typename... Args>
  static IntegerNumberValuesPtr New(Args&&... args) {
    return IntegerNumberValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static IntegerNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<IntegerNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IntegerNumberValues>::Convert(*this);
  }


  IntegerNumberValues();

  IntegerNumberValues(
      int8_t f0,
      int8_t f1,
      int8_t f2,
      int8_t f3,
      int8_t f4,
      int16_t f5,
      int16_t f6,
      int16_t f7,
      int16_t f8,
      int16_t f9,
      int32_t f10,
      int32_t f11,
      int32_t f12,
      int32_t f13,
      int32_t f14,
      int64_t f15,
      int64_t f16,
      int64_t f17,
      int64_t f18,
      int64_t f19);

  ~IntegerNumberValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = IntegerNumberValuesPtr>
  IntegerNumberValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        IntegerNumberValues::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        IntegerNumberValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::IntegerNumberValues_UnserializedMessageContext<
            UserType, IntegerNumberValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<IntegerNumberValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return IntegerNumberValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::IntegerNumberValues_UnserializedMessageContext<
            UserType, IntegerNumberValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<IntegerNumberValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.IntegerNumberValues.f0
  int8_t f0;
  
// @generated_from: mojo.test.IntegerNumberValues.f1
  int8_t f1;
  
// @generated_from: mojo.test.IntegerNumberValues.f2
  int8_t f2;
  
// @generated_from: mojo.test.IntegerNumberValues.f3
  int8_t f3;
  
// @generated_from: mojo.test.IntegerNumberValues.f4
  int8_t f4;
  
// @generated_from: mojo.test.IntegerNumberValues.f5
  int16_t f5;
  
// @generated_from: mojo.test.IntegerNumberValues.f6
  int16_t f6;
  
// @generated_from: mojo.test.IntegerNumberValues.f7
  int16_t f7;
  
// @generated_from: mojo.test.IntegerNumberValues.f8
  int16_t f8;
  
// @generated_from: mojo.test.IntegerNumberValues.f9
  int16_t f9;
  
// @generated_from: mojo.test.IntegerNumberValues.f10
  int32_t f10;
  
// @generated_from: mojo.test.IntegerNumberValues.f11
  int32_t f11;
  
// @generated_from: mojo.test.IntegerNumberValues.f12
  int32_t f12;
  
// @generated_from: mojo.test.IntegerNumberValues.f13
  int32_t f13;
  
// @generated_from: mojo.test.IntegerNumberValues.f14
  int32_t f14;
  
// @generated_from: mojo.test.IntegerNumberValues.f15
  int64_t f15;
  
// @generated_from: mojo.test.IntegerNumberValues.f16
  int64_t f16;
  
// @generated_from: mojo.test.IntegerNumberValues.f17
  int64_t f17;
  
// @generated_from: mojo.test.IntegerNumberValues.f18
  int64_t f18;
  
// @generated_from: mojo.test.IntegerNumberValues.f19
  int64_t f19;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.UnsignedNumberValues
class  UnsignedNumberValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<UnsignedNumberValues, T>::value>;
  using DataView = UnsignedNumberValuesDataView;
  using Data_ = internal::UnsignedNumberValues_Data;
  
// @generated_from: mojo.test.UnsignedNumberValues.V0
  static constexpr uint8_t V0 = 0U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V1
  static constexpr uint8_t V1 = 42U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V2
  static constexpr uint8_t V2 = 0xFFU;
  
// @generated_from: mojo.test.UnsignedNumberValues.V3
  static constexpr uint16_t V3 = 0U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V4
  static constexpr uint16_t V4 = 12345U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V5
  static constexpr uint16_t V5 = 0xFFFFU;
  
// @generated_from: mojo.test.UnsignedNumberValues.V6
  static constexpr uint32_t V6 = 0U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V7
  static constexpr uint32_t V7 = 1234567890U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V8
  static constexpr uint32_t V8 = 0xFFFFFFFFU;
  
// @generated_from: mojo.test.UnsignedNumberValues.V9
  static constexpr uint64_t V9 = 0ULL;
  
// @generated_from: mojo.test.UnsignedNumberValues.V10
  static constexpr uint64_t V10 = 1234567890123456ULL;
  
// @generated_from: mojo.test.UnsignedNumberValues.V11
  static constexpr uint64_t V11 = 9007199254740991ULL;

  template <typename... Args>
  static UnsignedNumberValuesPtr New(Args&&... args) {
    return UnsignedNumberValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static UnsignedNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<UnsignedNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnsignedNumberValues>::Convert(*this);
  }


  UnsignedNumberValues();

  UnsignedNumberValues(
      uint8_t f0,
      uint8_t f1,
      uint8_t f2,
      uint16_t f3,
      uint16_t f4,
      uint16_t f5,
      uint32_t f6,
      uint32_t f7,
      uint32_t f8,
      uint64_t f9,
      uint64_t f10,
      uint64_t f11);

  ~UnsignedNumberValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = UnsignedNumberValuesPtr>
  UnsignedNumberValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        UnsignedNumberValues::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        UnsignedNumberValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::UnsignedNumberValues_UnserializedMessageContext<
            UserType, UnsignedNumberValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<UnsignedNumberValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return UnsignedNumberValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::UnsignedNumberValues_UnserializedMessageContext<
            UserType, UnsignedNumberValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<UnsignedNumberValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.UnsignedNumberValues.f0
  uint8_t f0;
  
// @generated_from: mojo.test.UnsignedNumberValues.f1
  uint8_t f1;
  
// @generated_from: mojo.test.UnsignedNumberValues.f2
  uint8_t f2;
  
// @generated_from: mojo.test.UnsignedNumberValues.f3
  uint16_t f3;
  
// @generated_from: mojo.test.UnsignedNumberValues.f4
  uint16_t f4;
  
// @generated_from: mojo.test.UnsignedNumberValues.f5
  uint16_t f5;
  
// @generated_from: mojo.test.UnsignedNumberValues.f6
  uint32_t f6;
  
// @generated_from: mojo.test.UnsignedNumberValues.f7
  uint32_t f7;
  
// @generated_from: mojo.test.UnsignedNumberValues.f8
  uint32_t f8;
  
// @generated_from: mojo.test.UnsignedNumberValues.f9
  uint64_t f9;
  
// @generated_from: mojo.test.UnsignedNumberValues.f10
  uint64_t f10;
  
// @generated_from: mojo.test.UnsignedNumberValues.f11
  uint64_t f11;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.BitArrayValues
class  BitArrayValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BitArrayValues, T>::value>;
  using DataView = BitArrayValuesDataView;
  using Data_ = internal::BitArrayValues_Data;

  template <typename... Args>
  static BitArrayValuesPtr New(Args&&... args) {
    return BitArrayValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BitArrayValuesPtr From(const U& u) {
    return mojo::TypeConverter<BitArrayValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BitArrayValues>::Convert(*this);
  }


  BitArrayValues();

  BitArrayValues(
      WTF::Vector<bool> f0,
      WTF::Vector<bool> f1,
      WTF::Vector<bool> f2,
      WTF::Vector<bool> f3,
      WTF::Vector<WTF::Vector<bool>> f4,
      WTF::Vector<base::Optional<WTF::Vector<bool>>> f5,
      WTF::Vector<base::Optional<WTF::Vector<bool>>> f6);

  ~BitArrayValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BitArrayValuesPtr>
  BitArrayValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BitArrayValues::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BitArrayValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BitArrayValues_UnserializedMessageContext<
            UserType, BitArrayValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BitArrayValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return BitArrayValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BitArrayValues_UnserializedMessageContext<
            UserType, BitArrayValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BitArrayValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.BitArrayValues.f0
  WTF::Vector<bool> f0;
  
// @generated_from: mojo.test.BitArrayValues.f1
  WTF::Vector<bool> f1;
  
// @generated_from: mojo.test.BitArrayValues.f2
  WTF::Vector<bool> f2;
  
// @generated_from: mojo.test.BitArrayValues.f3
  WTF::Vector<bool> f3;
  
// @generated_from: mojo.test.BitArrayValues.f4
  WTF::Vector<WTF::Vector<bool>> f4;
  
// @generated_from: mojo.test.BitArrayValues.f5
  WTF::Vector<base::Optional<WTF::Vector<bool>>> f5;
  
// @generated_from: mojo.test.BitArrayValues.f6
  WTF::Vector<base::Optional<WTF::Vector<bool>>> f6;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MultiVersionStruct
class  MultiVersionStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStruct, T>::value>;
  using DataView = MultiVersionStructDataView;
  using Data_ = internal::MultiVersionStruct_Data;

  template <typename... Args>
  static MultiVersionStructPtr New(Args&&... args) {
    return MultiVersionStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructPtr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStruct>::Convert(*this);
  }


  MultiVersionStruct();

  explicit MultiVersionStruct(
      int32_t f_int32);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string,
      base::Optional<WTF::Vector<int8_t>> f_array);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string,
      base::Optional<WTF::Vector<int8_t>> f_array,
      ::mojo::ScopedMessagePipeHandle f_message_pipe,
      bool f_bool);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string,
      base::Optional<WTF::Vector<int8_t>> f_array,
      ::mojo::ScopedMessagePipeHandle f_message_pipe,
      bool f_bool,
      int16_t f_int16);

  ~MultiVersionStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructPtr>
  MultiVersionStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStruct_UnserializedMessageContext<
            UserType, MultiVersionStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStruct_UnserializedMessageContext<
            UserType, MultiVersionStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStruct.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStruct.f_rect
  ::mojo::test::blink::RectPtr f_rect;
  
// @generated_from: mojo.test.MultiVersionStruct.f_string
  WTF::String f_string;
  
// @generated_from: mojo.test.MultiVersionStruct.f_array
  base::Optional<WTF::Vector<int8_t>> f_array;
  
// @generated_from: mojo.test.MultiVersionStruct.f_message_pipe
  ::mojo::ScopedMessagePipeHandle f_message_pipe;
  
// @generated_from: mojo.test.MultiVersionStruct.f_bool
  bool f_bool;
  
// @generated_from: mojo.test.MultiVersionStruct.f_int16
  int16_t f_int16;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.MultiVersionStructV1
class  MultiVersionStructV1 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV1, T>::value>;
  using DataView = MultiVersionStructV1DataView;
  using Data_ = internal::MultiVersionStructV1_Data;

  template <typename... Args>
  static MultiVersionStructV1Ptr New(Args&&... args) {
    return MultiVersionStructV1Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV1Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV1Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV1>::Convert(*this);
  }


  MultiVersionStructV1();

  explicit MultiVersionStructV1(
      int32_t f_int32);

  MultiVersionStructV1(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect);

  ~MultiVersionStructV1();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV1Ptr>
  MultiVersionStructV1Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MultiVersionStructV1::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV1::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV1_UnserializedMessageContext<
            UserType, MultiVersionStructV1::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV1::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV1::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV1_UnserializedMessageContext<
            UserType, MultiVersionStructV1::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV1::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV1.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStructV1.f_rect
  ::mojo::test::blink::RectPtr f_rect;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStructV1);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MultiVersionStructV3
class  MultiVersionStructV3 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV3, T>::value>;
  using DataView = MultiVersionStructV3DataView;
  using Data_ = internal::MultiVersionStructV3_Data;

  template <typename... Args>
  static MultiVersionStructV3Ptr New(Args&&... args) {
    return MultiVersionStructV3Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV3Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV3Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV3>::Convert(*this);
  }


  MultiVersionStructV3();

  explicit MultiVersionStructV3(
      int32_t f_int32);

  MultiVersionStructV3(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect);

  MultiVersionStructV3(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string);

  ~MultiVersionStructV3();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV3Ptr>
  MultiVersionStructV3Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MultiVersionStructV3::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV3::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV3_UnserializedMessageContext<
            UserType, MultiVersionStructV3::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV3::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV3::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV3_UnserializedMessageContext<
            UserType, MultiVersionStructV3::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV3::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV3.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStructV3.f_rect
  ::mojo::test::blink::RectPtr f_rect;
  
// @generated_from: mojo.test.MultiVersionStructV3.f_string
  WTF::String f_string;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStructV3);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MultiVersionStructV5
class  MultiVersionStructV5 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV5, T>::value>;
  using DataView = MultiVersionStructV5DataView;
  using Data_ = internal::MultiVersionStructV5_Data;

  template <typename... Args>
  static MultiVersionStructV5Ptr New(Args&&... args) {
    return MultiVersionStructV5Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV5Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV5Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV5>::Convert(*this);
  }


  MultiVersionStructV5();

  explicit MultiVersionStructV5(
      int32_t f_int32);

  MultiVersionStructV5(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect);

  MultiVersionStructV5(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string);

  MultiVersionStructV5(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string,
      base::Optional<WTF::Vector<int8_t>> f_array);

  ~MultiVersionStructV5();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV5Ptr>
  MultiVersionStructV5Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MultiVersionStructV5::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV5::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV5_UnserializedMessageContext<
            UserType, MultiVersionStructV5::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV5::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV5::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV5_UnserializedMessageContext<
            UserType, MultiVersionStructV5::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV5::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV5.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStructV5.f_rect
  ::mojo::test::blink::RectPtr f_rect;
  
// @generated_from: mojo.test.MultiVersionStructV5.f_string
  WTF::String f_string;
  
// @generated_from: mojo.test.MultiVersionStructV5.f_array
  base::Optional<WTF::Vector<int8_t>> f_array;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStructV5);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MultiVersionStructV7
class  MultiVersionStructV7 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV7, T>::value>;
  using DataView = MultiVersionStructV7DataView;
  using Data_ = internal::MultiVersionStructV7_Data;

  template <typename... Args>
  static MultiVersionStructV7Ptr New(Args&&... args) {
    return MultiVersionStructV7Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV7Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV7Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV7>::Convert(*this);
  }


  MultiVersionStructV7();

  explicit MultiVersionStructV7(
      int32_t f_int32);

  MultiVersionStructV7(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect);

  MultiVersionStructV7(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string);

  MultiVersionStructV7(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string,
      base::Optional<WTF::Vector<int8_t>> f_array);

  MultiVersionStructV7(
      int32_t f_int32,
      ::mojo::test::blink::RectPtr f_rect,
      const WTF::String& f_string,
      base::Optional<WTF::Vector<int8_t>> f_array,
      ::mojo::ScopedMessagePipeHandle f_message_pipe,
      bool f_bool);

  ~MultiVersionStructV7();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV7Ptr>
  MultiVersionStructV7Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV7::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV7_UnserializedMessageContext<
            UserType, MultiVersionStructV7::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV7::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV7::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV7_UnserializedMessageContext<
            UserType, MultiVersionStructV7::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV7::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV7.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_rect
  ::mojo::test::blink::RectPtr f_rect;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_string
  WTF::String f_string;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_array
  base::Optional<WTF::Vector<int8_t>> f_array;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_message_pipe
  ::mojo::ScopedMessagePipeHandle f_message_pipe;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_bool
  bool f_bool;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStructV7);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.ContainsInterface
class  ContainsInterface {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ContainsInterface, T>::value>;
  using DataView = ContainsInterfaceDataView;
  using Data_ = internal::ContainsInterface_Data;

  template <typename... Args>
  static ContainsInterfacePtr New(Args&&... args) {
    return ContainsInterfacePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ContainsInterfacePtr From(const U& u) {
    return mojo::TypeConverter<ContainsInterfacePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsInterface>::Convert(*this);
  }


  ContainsInterface();

  explicit ContainsInterface(
      ::mojo::PendingRemote<SomeInterface> some_interface);

  ~ContainsInterface();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ContainsInterfacePtr>
  ContainsInterfacePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ContainsInterface::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ContainsInterface_UnserializedMessageContext<
            UserType, ContainsInterface::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ContainsInterface::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ContainsInterface::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ContainsInterface_UnserializedMessageContext<
            UserType, ContainsInterface::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ContainsInterface::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ContainsInterface.some_interface
  ::mojo::PendingRemote<SomeInterface> some_interface;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ContainsInterface);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.ContainsInterfaceRequest
class  ContainsInterfaceRequest {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ContainsInterfaceRequest, T>::value>;
  using DataView = ContainsInterfaceRequestDataView;
  using Data_ = internal::ContainsInterfaceRequest_Data;

  template <typename... Args>
  static ContainsInterfaceRequestPtr New(Args&&... args) {
    return ContainsInterfaceRequestPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ContainsInterfaceRequestPtr From(const U& u) {
    return mojo::TypeConverter<ContainsInterfaceRequestPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsInterfaceRequest>::Convert(*this);
  }


  ContainsInterfaceRequest();

  explicit ContainsInterfaceRequest(
      ::mojo::PendingReceiver<SomeInterface> request);

  ~ContainsInterfaceRequest();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ContainsInterfaceRequestPtr>
  ContainsInterfaceRequestPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ContainsInterfaceRequest::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ContainsInterfaceRequest_UnserializedMessageContext<
            UserType, ContainsInterfaceRequest::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ContainsInterfaceRequest::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ContainsInterfaceRequest::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ContainsInterfaceRequest_UnserializedMessageContext<
            UserType, ContainsInterfaceRequest::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ContainsInterfaceRequest::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ContainsInterfaceRequest.request
  ::mojo::PendingReceiver<SomeInterface> request;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ContainsInterfaceRequest);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.ContainsHashable
class  ContainsHashable {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ContainsHashable, T>::value>;
  using DataView = ContainsHashableDataView;
  using Data_ = internal::ContainsHashable_Data;

  template <typename... Args>
  static ContainsHashablePtr New(Args&&... args) {
    return ContainsHashablePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ContainsHashablePtr From(const U& u) {
    return mojo::TypeConverter<ContainsHashablePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsHashable>::Convert(*this);
  }


  ContainsHashable();

  explicit ContainsHashable(
      const ::mojo::test::RectBlink& rect);

  ~ContainsHashable();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ContainsHashablePtr>
  ContainsHashablePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ContainsHashable::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ContainsHashable::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ContainsHashable_UnserializedMessageContext<
            UserType, ContainsHashable::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ContainsHashable::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ContainsHashable::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ContainsHashable_UnserializedMessageContext<
            UserType, ContainsHashable::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ContainsHashable::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ContainsHashable.rect
  ::mojo::test::RectBlink rect;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.SimpleNestedStruct
class  SimpleNestedStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SimpleNestedStruct, T>::value>;
  using DataView = SimpleNestedStructDataView;
  using Data_ = internal::SimpleNestedStruct_Data;

  template <typename... Args>
  static SimpleNestedStructPtr New(Args&&... args) {
    return SimpleNestedStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SimpleNestedStructPtr From(const U& u) {
    return mojo::TypeConverter<SimpleNestedStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SimpleNestedStruct>::Convert(*this);
  }


  SimpleNestedStruct();

  explicit SimpleNestedStruct(
      ContainsOtherPtr nested);

  ~SimpleNestedStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SimpleNestedStructPtr>
  SimpleNestedStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SimpleNestedStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SimpleNestedStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SimpleNestedStruct_UnserializedMessageContext<
            UserType, SimpleNestedStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SimpleNestedStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return SimpleNestedStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SimpleNestedStruct_UnserializedMessageContext<
            UserType, SimpleNestedStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SimpleNestedStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SimpleNestedStruct.nested
  ContainsOtherPtr nested;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SimpleNestedStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}


template <typename StructPtrType>
NamedRegionPtr NamedRegion::Clone() const {
  return New(
      mojo::Clone(name),
      mojo::Clone(rects)
  );
}

template <typename T, NamedRegion::EnableIfSame<T>*>
bool NamedRegion::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->rects, other_struct.rects))
    return false;
  return true;
}

template <typename T, NamedRegion::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.rects < rhs.rects)
    return true;
  if (rhs.rects < lhs.rects)
    return false;
  return false;
}
template <typename StructPtrType>
RectPairPtr RectPair::Clone() const {
  return New(
      mojo::Clone(first),
      mojo::Clone(second)
  );
}

template <typename T, RectPair::EnableIfSame<T>*>
bool RectPair::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->first, other_struct.first))
    return false;
  if (!mojo::Equals(this->second, other_struct.second))
    return false;
  return true;
}

template <typename T, RectPair::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.first < rhs.first)
    return true;
  if (rhs.first < lhs.first)
    return false;
  if (lhs.second < rhs.second)
    return true;
  if (rhs.second < lhs.second)
    return false;
  return false;
}
template <typename StructPtrType>
EmptyStructPtr EmptyStruct::Clone() const {
  return New(
  );
}

template <typename T, EmptyStruct::EnableIfSame<T>*>
bool EmptyStruct::Equals(const T& other_struct) const {
  return true;
}

template <typename T, EmptyStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  return false;
}
template <typename StructPtrType>
NoDefaultFieldValuesPtr NoDefaultFieldValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11),
      mojo::Clone(f12),
      mojo::Clone(f13),
      mojo::Clone(f14),
      mojo::Clone(f15),
      mojo::Clone(f16),
      mojo::Clone(f17),
      mojo::Clone(f18),
      mojo::Clone(f19),
      mojo::Clone(f20),
      mojo::Clone(f21),
      mojo::Clone(f22),
      mojo::Clone(f23),
      mojo::Clone(f24),
      mojo::Clone(f25),
      mojo::Clone(f26),
      mojo::Clone(f27),
      mojo::Clone(f28),
      mojo::Clone(f29),
      mojo::Clone(f30)
  );
}

template <typename T, NoDefaultFieldValues::EnableIfSame<T>*>
bool NoDefaultFieldValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  if (!mojo::Equals(this->f12, other_struct.f12))
    return false;
  if (!mojo::Equals(this->f13, other_struct.f13))
    return false;
  if (!mojo::Equals(this->f14, other_struct.f14))
    return false;
  if (!mojo::Equals(this->f15, other_struct.f15))
    return false;
  if (!mojo::Equals(this->f16, other_struct.f16))
    return false;
  if (!mojo::Equals(this->f17, other_struct.f17))
    return false;
  if (!mojo::Equals(this->f18, other_struct.f18))
    return false;
  if (!mojo::Equals(this->f19, other_struct.f19))
    return false;
  if (!mojo::Equals(this->f20, other_struct.f20))
    return false;
  if (!mojo::Equals(this->f21, other_struct.f21))
    return false;
  if (!mojo::Equals(this->f22, other_struct.f22))
    return false;
  if (!mojo::Equals(this->f23, other_struct.f23))
    return false;
  if (!mojo::Equals(this->f24, other_struct.f24))
    return false;
  if (!mojo::Equals(this->f25, other_struct.f25))
    return false;
  if (!mojo::Equals(this->f26, other_struct.f26))
    return false;
  if (!mojo::Equals(this->f27, other_struct.f27))
    return false;
  if (!mojo::Equals(this->f28, other_struct.f28))
    return false;
  if (!mojo::Equals(this->f29, other_struct.f29))
    return false;
  if (!mojo::Equals(this->f30, other_struct.f30))
    return false;
  return true;
}

template <typename T, NoDefaultFieldValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  if (lhs.f12 < rhs.f12)
    return true;
  if (rhs.f12 < lhs.f12)
    return false;
  if (lhs.f13 < rhs.f13)
    return true;
  if (rhs.f13 < lhs.f13)
    return false;
  if (lhs.f14 < rhs.f14)
    return true;
  if (rhs.f14 < lhs.f14)
    return false;
  if (lhs.f15 < rhs.f15)
    return true;
  if (rhs.f15 < lhs.f15)
    return false;
  if (lhs.f16 < rhs.f16)
    return true;
  if (rhs.f16 < lhs.f16)
    return false;
  if (lhs.f17 < rhs.f17)
    return true;
  if (rhs.f17 < lhs.f17)
    return false;
  if (lhs.f18 < rhs.f18)
    return true;
  if (rhs.f18 < lhs.f18)
    return false;
  if (lhs.f19 < rhs.f19)
    return true;
  if (rhs.f19 < lhs.f19)
    return false;
  if (lhs.f20 < rhs.f20)
    return true;
  if (rhs.f20 < lhs.f20)
    return false;
  if (lhs.f21 < rhs.f21)
    return true;
  if (rhs.f21 < lhs.f21)
    return false;
  if (lhs.f22 < rhs.f22)
    return true;
  if (rhs.f22 < lhs.f22)
    return false;
  if (lhs.f23 < rhs.f23)
    return true;
  if (rhs.f23 < lhs.f23)
    return false;
  if (lhs.f24 < rhs.f24)
    return true;
  if (rhs.f24 < lhs.f24)
    return false;
  if (lhs.f25 < rhs.f25)
    return true;
  if (rhs.f25 < lhs.f25)
    return false;
  if (lhs.f26 < rhs.f26)
    return true;
  if (rhs.f26 < lhs.f26)
    return false;
  if (lhs.f27 < rhs.f27)
    return true;
  if (rhs.f27 < lhs.f27)
    return false;
  if (lhs.f28 < rhs.f28)
    return true;
  if (rhs.f28 < lhs.f28)
    return false;
  if (lhs.f29 < rhs.f29)
    return true;
  if (rhs.f29 < lhs.f29)
    return false;
  if (lhs.f30 < rhs.f30)
    return true;
  if (rhs.f30 < lhs.f30)
    return false;
  return false;
}
template <typename StructPtrType>
DefaultFieldValuesPtr DefaultFieldValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11),
      mojo::Clone(f12),
      mojo::Clone(f13),
      mojo::Clone(f14),
      mojo::Clone(f15),
      mojo::Clone(f16)
  );
}

template <typename T, DefaultFieldValues::EnableIfSame<T>*>
bool DefaultFieldValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  if (!mojo::Equals(this->f12, other_struct.f12))
    return false;
  if (!mojo::Equals(this->f13, other_struct.f13))
    return false;
  if (!mojo::Equals(this->f14, other_struct.f14))
    return false;
  if (!mojo::Equals(this->f15, other_struct.f15))
    return false;
  if (!mojo::Equals(this->f16, other_struct.f16))
    return false;
  return true;
}

template <typename T, DefaultFieldValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  if (lhs.f12 < rhs.f12)
    return true;
  if (rhs.f12 < lhs.f12)
    return false;
  if (lhs.f13 < rhs.f13)
    return true;
  if (rhs.f13 < lhs.f13)
    return false;
  if (lhs.f14 < rhs.f14)
    return true;
  if (rhs.f14 < lhs.f14)
    return false;
  if (lhs.f15 < rhs.f15)
    return true;
  if (rhs.f15 < lhs.f15)
    return false;
  if (lhs.f16 < rhs.f16)
    return true;
  if (rhs.f16 < lhs.f16)
    return false;
  return false;
}
template <typename StructPtrType>
ScopedConstantsPtr ScopedConstants::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6)
  );
}

template <typename T, ScopedConstants::EnableIfSame<T>*>
bool ScopedConstants::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  return true;
}

template <typename T, ScopedConstants::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  return false;
}
template <typename StructPtrType>
MapKeyTypesPtr MapKeyTypes::Clone() const {
  return New(
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11)
  );
}

template <typename T, MapKeyTypes::EnableIfSame<T>*>
bool MapKeyTypes::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  return true;
}

template <typename T, MapKeyTypes::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  return false;
}
template <typename StructPtrType>
MapValueTypesPtr MapValueTypes::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11)
  );
}

template <typename T, MapValueTypes::EnableIfSame<T>*>
bool MapValueTypes::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  return true;
}

template <typename T, MapValueTypes::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  return false;
}
template <typename StructPtrType>
ArrayValueTypesPtr ArrayValueTypes::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7)
  );
}

template <typename T, ArrayValueTypes::EnableIfSame<T>*>
bool ArrayValueTypes::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  return true;
}

template <typename T, ArrayValueTypes::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  return false;
}
template <typename StructPtrType>
FloatNumberValuesPtr FloatNumberValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9)
  );
}

template <typename T, FloatNumberValues::EnableIfSame<T>*>
bool FloatNumberValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  return true;
}

template <typename T, FloatNumberValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  return false;
}
template <typename StructPtrType>
IntegerNumberValuesPtr IntegerNumberValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11),
      mojo::Clone(f12),
      mojo::Clone(f13),
      mojo::Clone(f14),
      mojo::Clone(f15),
      mojo::Clone(f16),
      mojo::Clone(f17),
      mojo::Clone(f18),
      mojo::Clone(f19)
  );
}

template <typename T, IntegerNumberValues::EnableIfSame<T>*>
bool IntegerNumberValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  if (!mojo::Equals(this->f12, other_struct.f12))
    return false;
  if (!mojo::Equals(this->f13, other_struct.f13))
    return false;
  if (!mojo::Equals(this->f14, other_struct.f14))
    return false;
  if (!mojo::Equals(this->f15, other_struct.f15))
    return false;
  if (!mojo::Equals(this->f16, other_struct.f16))
    return false;
  if (!mojo::Equals(this->f17, other_struct.f17))
    return false;
  if (!mojo::Equals(this->f18, other_struct.f18))
    return false;
  if (!mojo::Equals(this->f19, other_struct.f19))
    return false;
  return true;
}

template <typename T, IntegerNumberValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  if (lhs.f12 < rhs.f12)
    return true;
  if (rhs.f12 < lhs.f12)
    return false;
  if (lhs.f13 < rhs.f13)
    return true;
  if (rhs.f13 < lhs.f13)
    return false;
  if (lhs.f14 < rhs.f14)
    return true;
  if (rhs.f14 < lhs.f14)
    return false;
  if (lhs.f15 < rhs.f15)
    return true;
  if (rhs.f15 < lhs.f15)
    return false;
  if (lhs.f16 < rhs.f16)
    return true;
  if (rhs.f16 < lhs.f16)
    return false;
  if (lhs.f17 < rhs.f17)
    return true;
  if (rhs.f17 < lhs.f17)
    return false;
  if (lhs.f18 < rhs.f18)
    return true;
  if (rhs.f18 < lhs.f18)
    return false;
  if (lhs.f19 < rhs.f19)
    return true;
  if (rhs.f19 < lhs.f19)
    return false;
  return false;
}
template <typename StructPtrType>
UnsignedNumberValuesPtr UnsignedNumberValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11)
  );
}

template <typename T, UnsignedNumberValues::EnableIfSame<T>*>
bool UnsignedNumberValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  return true;
}

template <typename T, UnsignedNumberValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  return false;
}
template <typename StructPtrType>
BitArrayValuesPtr BitArrayValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6)
  );
}

template <typename T, BitArrayValues::EnableIfSame<T>*>
bool BitArrayValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  return true;
}

template <typename T, BitArrayValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructPtr MultiVersionStruct::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect),
      mojo::Clone(f_string),
      mojo::Clone(f_array),
      mojo::Clone(f_message_pipe),
      mojo::Clone(f_bool),
      mojo::Clone(f_int16)
  );
}

template <typename T, MultiVersionStruct::EnableIfSame<T>*>
bool MultiVersionStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  if (!mojo::Equals(this->f_string, other_struct.f_string))
    return false;
  if (!mojo::Equals(this->f_array, other_struct.f_array))
    return false;
  if (!mojo::Equals(this->f_message_pipe, other_struct.f_message_pipe))
    return false;
  if (!mojo::Equals(this->f_bool, other_struct.f_bool))
    return false;
  if (!mojo::Equals(this->f_int16, other_struct.f_int16))
    return false;
  return true;
}

template <typename T, MultiVersionStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  if (lhs.f_string < rhs.f_string)
    return true;
  if (rhs.f_string < lhs.f_string)
    return false;
  if (lhs.f_array < rhs.f_array)
    return true;
  if (rhs.f_array < lhs.f_array)
    return false;
  if (lhs.f_message_pipe < rhs.f_message_pipe)
    return true;
  if (rhs.f_message_pipe < lhs.f_message_pipe)
    return false;
  if (lhs.f_bool < rhs.f_bool)
    return true;
  if (rhs.f_bool < lhs.f_bool)
    return false;
  if (lhs.f_int16 < rhs.f_int16)
    return true;
  if (rhs.f_int16 < lhs.f_int16)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV0Ptr MultiVersionStructV0::Clone() const {
  return New(
      mojo::Clone(f_int32)
  );
}

template <typename T, MultiVersionStructV0::EnableIfSame<T>*>
bool MultiVersionStructV0::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  return true;
}

template <typename T, MultiVersionStructV0::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV1Ptr MultiVersionStructV1::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect)
  );
}

template <typename T, MultiVersionStructV1::EnableIfSame<T>*>
bool MultiVersionStructV1::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  return true;
}

template <typename T, MultiVersionStructV1::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV3Ptr MultiVersionStructV3::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect),
      mojo::Clone(f_string)
  );
}

template <typename T, MultiVersionStructV3::EnableIfSame<T>*>
bool MultiVersionStructV3::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  if (!mojo::Equals(this->f_string, other_struct.f_string))
    return false;
  return true;
}

template <typename T, MultiVersionStructV3::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  if (lhs.f_string < rhs.f_string)
    return true;
  if (rhs.f_string < lhs.f_string)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV5Ptr MultiVersionStructV5::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect),
      mojo::Clone(f_string),
      mojo::Clone(f_array)
  );
}

template <typename T, MultiVersionStructV5::EnableIfSame<T>*>
bool MultiVersionStructV5::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  if (!mojo::Equals(this->f_string, other_struct.f_string))
    return false;
  if (!mojo::Equals(this->f_array, other_struct.f_array))
    return false;
  return true;
}

template <typename T, MultiVersionStructV5::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  if (lhs.f_string < rhs.f_string)
    return true;
  if (rhs.f_string < lhs.f_string)
    return false;
  if (lhs.f_array < rhs.f_array)
    return true;
  if (rhs.f_array < lhs.f_array)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV7Ptr MultiVersionStructV7::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect),
      mojo::Clone(f_string),
      mojo::Clone(f_array),
      mojo::Clone(f_message_pipe),
      mojo::Clone(f_bool)
  );
}

template <typename T, MultiVersionStructV7::EnableIfSame<T>*>
bool MultiVersionStructV7::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  if (!mojo::Equals(this->f_string, other_struct.f_string))
    return false;
  if (!mojo::Equals(this->f_array, other_struct.f_array))
    return false;
  if (!mojo::Equals(this->f_message_pipe, other_struct.f_message_pipe))
    return false;
  if (!mojo::Equals(this->f_bool, other_struct.f_bool))
    return false;
  return true;
}

template <typename T, MultiVersionStructV7::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  if (lhs.f_string < rhs.f_string)
    return true;
  if (rhs.f_string < lhs.f_string)
    return false;
  if (lhs.f_array < rhs.f_array)
    return true;
  if (rhs.f_array < lhs.f_array)
    return false;
  if (lhs.f_message_pipe < rhs.f_message_pipe)
    return true;
  if (rhs.f_message_pipe < lhs.f_message_pipe)
    return false;
  if (lhs.f_bool < rhs.f_bool)
    return true;
  if (rhs.f_bool < lhs.f_bool)
    return false;
  return false;
}
template <typename StructPtrType>
ReorderedStructPtr ReorderedStruct::Clone() const {
  return New(
      mojo::Clone(a),
      mojo::Clone(b),
      mojo::Clone(c)
  );
}

template <typename T, ReorderedStruct::EnableIfSame<T>*>
bool ReorderedStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->a, other_struct.a))
    return false;
  if (!mojo::Equals(this->b, other_struct.b))
    return false;
  if (!mojo::Equals(this->c, other_struct.c))
    return false;
  return true;
}

template <typename T, ReorderedStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.a < rhs.a)
    return true;
  if (rhs.a < lhs.a)
    return false;
  if (lhs.b < rhs.b)
    return true;
  if (rhs.b < lhs.b)
    return false;
  if (lhs.c < rhs.c)
    return true;
  if (rhs.c < lhs.c)
    return false;
  return false;
}
template <typename StructPtrType>
ContainsInterfacePtr ContainsInterface::Clone() const {
  return New(
      mojo::Clone(some_interface)
  );
}

template <typename T, ContainsInterface::EnableIfSame<T>*>
bool ContainsInterface::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->some_interface, other_struct.some_interface))
    return false;
  return true;
}

template <typename T, ContainsInterface::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.some_interface < rhs.some_interface)
    return true;
  if (rhs.some_interface < lhs.some_interface)
    return false;
  return false;
}
template <typename StructPtrType>
ContainsOtherPtr ContainsOther::Clone() const {
  return New(
      mojo::Clone(other)
  );
}

template <typename T, ContainsOther::EnableIfSame<T>*>
bool ContainsOther::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->other, other_struct.other))
    return false;
  return true;
}

template <typename T, ContainsOther::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.other < rhs.other)
    return true;
  if (rhs.other < lhs.other)
    return false;
  return false;
}
template <typename StructPtrType>
ContainsInterfaceRequestPtr ContainsInterfaceRequest::Clone() const {
  return New(
      mojo::Clone(request)
  );
}

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>*>
bool ContainsInterfaceRequest::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->request, other_struct.request))
    return false;
  return true;
}

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.request < rhs.request)
    return true;
  if (rhs.request < lhs.request)
    return false;
  return false;
}
template <typename StructPtrType>
SingleBoolStructPtr SingleBoolStruct::Clone() const {
  return New(
      mojo::Clone(value)
  );
}

template <typename T, SingleBoolStruct::EnableIfSame<T>*>
bool SingleBoolStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, SingleBoolStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
ContainsHashablePtr ContainsHashable::Clone() const {
  return New(
      mojo::Clone(rect)
  );
}

template <typename T, ContainsHashable::EnableIfSame<T>*>
bool ContainsHashable::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->rect, other_struct.rect))
    return false;
  return true;
}

template <typename T, ContainsHashable::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.rect < rhs.rect)
    return true;
  if (rhs.rect < lhs.rect)
    return false;
  return false;
}
template <typename StructPtrType>
SimpleNestedStructPtr SimpleNestedStruct::Clone() const {
  return New(
      mojo::Clone(nested)
  );
}

template <typename T, SimpleNestedStruct::EnableIfSame<T>*>
bool SimpleNestedStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->nested, other_struct.nested))
    return false;
  return true;
}

template <typename T, SimpleNestedStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.nested < rhs.nested)
    return true;
  if (rhs.nested < lhs.nested)
    return false;
  return false;
}
template <typename StructPtrType>
EnumNestedStructPtr EnumNestedStruct::Clone() const {
  return New(
      mojo::Clone(local_enum_state_)
  );
}

template <typename T, EnumNestedStruct::EnableIfSame<T>*>
bool EnumNestedStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->local_enum_state_, other_struct.local_enum_state_))
    return false;
  return true;
}

template <typename T, EnumNestedStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.local_enum_state_ < rhs.local_enum_state_)
    return true;
  if (rhs.local_enum_state_ < lhs.local_enum_state_)
    return false;
  return false;
}


}  // namespace blink
}  // namespace test
}  // namespace mojo

namespace mojo {


template <>
struct  StructTraits<::mojo::test::blink::NamedRegion::DataView,
                                         ::mojo::test::blink::NamedRegionPtr> {
  static bool IsNull(const ::mojo::test::blink::NamedRegionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::NamedRegionPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::NamedRegion::name)& name(
      const ::mojo::test::blink::NamedRegionPtr& input) {
    return input->name;
  }

  static const decltype(::mojo::test::blink::NamedRegion::rects)& rects(
      const ::mojo::test::blink::NamedRegionPtr& input) {
    return input->rects;
  }

  static bool Read(::mojo::test::blink::NamedRegion::DataView input, ::mojo::test::blink::NamedRegionPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::RectPair::DataView,
                                         ::mojo::test::blink::RectPairPtr> {
  static bool IsNull(const ::mojo::test::blink::RectPairPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::RectPairPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::RectPair::first)& first(
      const ::mojo::test::blink::RectPairPtr& input) {
    return input->first;
  }

  static const decltype(::mojo::test::blink::RectPair::second)& second(
      const ::mojo::test::blink::RectPairPtr& input) {
    return input->second;
  }

  static bool Read(::mojo::test::blink::RectPair::DataView input, ::mojo::test::blink::RectPairPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::EmptyStruct::DataView,
                                         ::mojo::test::blink::EmptyStructPtr> {
  static bool IsNull(const ::mojo::test::blink::EmptyStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::EmptyStructPtr* output) { output->reset(); }

  static bool Read(::mojo::test::blink::EmptyStruct::DataView input, ::mojo::test::blink::EmptyStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::NoDefaultFieldValues::DataView,
                                         ::mojo::test::blink::NoDefaultFieldValuesPtr> {
  static bool IsNull(const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::NoDefaultFieldValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f0) f0(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f1) f1(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f2) f2(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f3) f3(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f4) f4(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f5) f5(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f6) f6(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f7) f7(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f8) f8(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f9) f9(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f9;
  }

  static decltype(::mojo::test::blink::NoDefaultFieldValues::f10) f10(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f10;
  }

  static const decltype(::mojo::test::blink::NoDefaultFieldValues::f11)& f11(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f11;
  }

  static const decltype(::mojo::test::blink::NoDefaultFieldValues::f12)& f12(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f12;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f13)& f13(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f13;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f14)& f14(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f14;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f15)& f15(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f15;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f16)& f16(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f16;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f17)& f17(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f17;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f18)& f18(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f18;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f19)& f19(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f19;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f20)& f20(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f20;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f21)& f21(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f21;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f22)& f22(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f22;
  }

  static const decltype(::mojo::test::blink::NoDefaultFieldValues::f23)& f23(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f23;
  }

  static const decltype(::mojo::test::blink::NoDefaultFieldValues::f24)& f24(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f24;
  }

  static const decltype(::mojo::test::blink::NoDefaultFieldValues::f25)& f25(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f25;
  }

  static const decltype(::mojo::test::blink::NoDefaultFieldValues::f26)& f26(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f26;
  }

  static const decltype(::mojo::test::blink::NoDefaultFieldValues::f27)& f27(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f27;
  }

  static const decltype(::mojo::test::blink::NoDefaultFieldValues::f28)& f28(
      const ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f28;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f29)& f29(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f29;
  }

  static  decltype(::mojo::test::blink::NoDefaultFieldValues::f30)& f30(
       ::mojo::test::blink::NoDefaultFieldValuesPtr& input) {
    return input->f30;
  }

  static bool Read(::mojo::test::blink::NoDefaultFieldValues::DataView input, ::mojo::test::blink::NoDefaultFieldValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::DefaultFieldValues::DataView,
                                         ::mojo::test::blink::DefaultFieldValuesPtr> {
  static bool IsNull(const ::mojo::test::blink::DefaultFieldValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::DefaultFieldValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::DefaultFieldValues::f0) f0(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f1) f1(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f2) f2(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f3) f3(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f4) f4(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f5) f5(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f6) f6(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f7) f7(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f8) f8(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f9) f9(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f9;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f10) f10(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f10;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f11) f11(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f11;
  }

  static decltype(::mojo::test::blink::DefaultFieldValues::f12) f12(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f12;
  }

  static const decltype(::mojo::test::blink::DefaultFieldValues::f13)& f13(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f13;
  }

  static const decltype(::mojo::test::blink::DefaultFieldValues::f14)& f14(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f14;
  }

  static const decltype(::mojo::test::blink::DefaultFieldValues::f15)& f15(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f15;
  }

  static const decltype(::mojo::test::blink::DefaultFieldValues::f16)& f16(
      const ::mojo::test::blink::DefaultFieldValuesPtr& input) {
    return input->f16;
  }

  static bool Read(::mojo::test::blink::DefaultFieldValues::DataView input, ::mojo::test::blink::DefaultFieldValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::ScopedConstants::DataView,
                                         ::mojo::test::blink::ScopedConstantsPtr> {
  static bool IsNull(const ::mojo::test::blink::ScopedConstantsPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ScopedConstantsPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::ScopedConstants::f0) f0(
      const ::mojo::test::blink::ScopedConstantsPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::blink::ScopedConstants::f1) f1(
      const ::mojo::test::blink::ScopedConstantsPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::blink::ScopedConstants::f2) f2(
      const ::mojo::test::blink::ScopedConstantsPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::blink::ScopedConstants::f3) f3(
      const ::mojo::test::blink::ScopedConstantsPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::blink::ScopedConstants::f4) f4(
      const ::mojo::test::blink::ScopedConstantsPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::blink::ScopedConstants::f5) f5(
      const ::mojo::test::blink::ScopedConstantsPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::blink::ScopedConstants::f6) f6(
      const ::mojo::test::blink::ScopedConstantsPtr& input) {
    return input->f6;
  }

  static bool Read(::mojo::test::blink::ScopedConstants::DataView input, ::mojo::test::blink::ScopedConstantsPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::MapKeyTypes::DataView,
                                         ::mojo::test::blink::MapKeyTypesPtr> {
  static bool IsNull(const ::mojo::test::blink::MapKeyTypesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::MapKeyTypesPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::MapKeyTypes::f1)& f1(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f1;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f2)& f2(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f2;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f3)& f3(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f3;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f4)& f4(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f4;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f5)& f5(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f5;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f6)& f6(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f6;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f7)& f7(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f7;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f8)& f8(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f8;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f9)& f9(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f9;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f10)& f10(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f10;
  }

  static const decltype(::mojo::test::blink::MapKeyTypes::f11)& f11(
      const ::mojo::test::blink::MapKeyTypesPtr& input) {
    return input->f11;
  }

  static bool Read(::mojo::test::blink::MapKeyTypes::DataView input, ::mojo::test::blink::MapKeyTypesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::MapValueTypes::DataView,
                                         ::mojo::test::blink::MapValueTypesPtr> {
  static bool IsNull(const ::mojo::test::blink::MapValueTypesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::MapValueTypesPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::MapValueTypes::f0)& f0(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f0;
  }

  static const decltype(::mojo::test::blink::MapValueTypes::f1)& f1(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f1;
  }

  static const decltype(::mojo::test::blink::MapValueTypes::f2)& f2(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f2;
  }

  static const decltype(::mojo::test::blink::MapValueTypes::f3)& f3(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f3;
  }

  static const decltype(::mojo::test::blink::MapValueTypes::f4)& f4(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f4;
  }

  static const decltype(::mojo::test::blink::MapValueTypes::f5)& f5(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f5;
  }

  static const decltype(::mojo::test::blink::MapValueTypes::f6)& f6(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f6;
  }

  static const decltype(::mojo::test::blink::MapValueTypes::f7)& f7(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f7;
  }

  static const decltype(::mojo::test::blink::MapValueTypes::f8)& f8(
      const ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f8;
  }

  static  decltype(::mojo::test::blink::MapValueTypes::f9)& f9(
       ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f9;
  }

  static  decltype(::mojo::test::blink::MapValueTypes::f10)& f10(
       ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f10;
  }

  static  decltype(::mojo::test::blink::MapValueTypes::f11)& f11(
       ::mojo::test::blink::MapValueTypesPtr& input) {
    return input->f11;
  }

  static bool Read(::mojo::test::blink::MapValueTypes::DataView input, ::mojo::test::blink::MapValueTypesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::ArrayValueTypes::DataView,
                                         ::mojo::test::blink::ArrayValueTypesPtr> {
  static bool IsNull(const ::mojo::test::blink::ArrayValueTypesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ArrayValueTypesPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::ArrayValueTypes::f0)& f0(
      const ::mojo::test::blink::ArrayValueTypesPtr& input) {
    return input->f0;
  }

  static const decltype(::mojo::test::blink::ArrayValueTypes::f1)& f1(
      const ::mojo::test::blink::ArrayValueTypesPtr& input) {
    return input->f1;
  }

  static const decltype(::mojo::test::blink::ArrayValueTypes::f2)& f2(
      const ::mojo::test::blink::ArrayValueTypesPtr& input) {
    return input->f2;
  }

  static const decltype(::mojo::test::blink::ArrayValueTypes::f3)& f3(
      const ::mojo::test::blink::ArrayValueTypesPtr& input) {
    return input->f3;
  }

  static const decltype(::mojo::test::blink::ArrayValueTypes::f4)& f4(
      const ::mojo::test::blink::ArrayValueTypesPtr& input) {
    return input->f4;
  }

  static const decltype(::mojo::test::blink::ArrayValueTypes::f5)& f5(
      const ::mojo::test::blink::ArrayValueTypesPtr& input) {
    return input->f5;
  }

  static  decltype(::mojo::test::blink::ArrayValueTypes::f6)& f6(
       ::mojo::test::blink::ArrayValueTypesPtr& input) {
    return input->f6;
  }

  static  decltype(::mojo::test::blink::ArrayValueTypes::f7)& f7(
       ::mojo::test::blink::ArrayValueTypesPtr& input) {
    return input->f7;
  }

  static bool Read(::mojo::test::blink::ArrayValueTypes::DataView input, ::mojo::test::blink::ArrayValueTypesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::FloatNumberValues::DataView,
                                         ::mojo::test::blink::FloatNumberValuesPtr> {
  static bool IsNull(const ::mojo::test::blink::FloatNumberValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::FloatNumberValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::FloatNumberValues::f0) f0(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f1) f1(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f2) f2(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f3) f3(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f4) f4(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f5) f5(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f6) f6(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f7) f7(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f8) f8(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::blink::FloatNumberValues::f9) f9(
      const ::mojo::test::blink::FloatNumberValuesPtr& input) {
    return input->f9;
  }

  static bool Read(::mojo::test::blink::FloatNumberValues::DataView input, ::mojo::test::blink::FloatNumberValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::IntegerNumberValues::DataView,
                                         ::mojo::test::blink::IntegerNumberValuesPtr> {
  static bool IsNull(const ::mojo::test::blink::IntegerNumberValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::IntegerNumberValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::IntegerNumberValues::f0) f0(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f1) f1(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f2) f2(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f3) f3(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f4) f4(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f5) f5(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f6) f6(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f7) f7(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f8) f8(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f9) f9(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f9;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f10) f10(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f10;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f11) f11(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f11;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f12) f12(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f12;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f13) f13(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f13;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f14) f14(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f14;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f15) f15(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f15;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f16) f16(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f16;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f17) f17(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f17;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f18) f18(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f18;
  }

  static decltype(::mojo::test::blink::IntegerNumberValues::f19) f19(
      const ::mojo::test::blink::IntegerNumberValuesPtr& input) {
    return input->f19;
  }

  static bool Read(::mojo::test::blink::IntegerNumberValues::DataView input, ::mojo::test::blink::IntegerNumberValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::UnsignedNumberValues::DataView,
                                         ::mojo::test::blink::UnsignedNumberValuesPtr> {
  static bool IsNull(const ::mojo::test::blink::UnsignedNumberValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::UnsignedNumberValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f0) f0(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f1) f1(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f2) f2(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f3) f3(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f4) f4(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f5) f5(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f6) f6(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f7) f7(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f8) f8(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f9) f9(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f9;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f10) f10(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f10;
  }

  static decltype(::mojo::test::blink::UnsignedNumberValues::f11) f11(
      const ::mojo::test::blink::UnsignedNumberValuesPtr& input) {
    return input->f11;
  }

  static bool Read(::mojo::test::blink::UnsignedNumberValues::DataView input, ::mojo::test::blink::UnsignedNumberValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::BitArrayValues::DataView,
                                         ::mojo::test::blink::BitArrayValuesPtr> {
  static bool IsNull(const ::mojo::test::blink::BitArrayValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::BitArrayValuesPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::BitArrayValues::f0)& f0(
      const ::mojo::test::blink::BitArrayValuesPtr& input) {
    return input->f0;
  }

  static const decltype(::mojo::test::blink::BitArrayValues::f1)& f1(
      const ::mojo::test::blink::BitArrayValuesPtr& input) {
    return input->f1;
  }

  static const decltype(::mojo::test::blink::BitArrayValues::f2)& f2(
      const ::mojo::test::blink::BitArrayValuesPtr& input) {
    return input->f2;
  }

  static const decltype(::mojo::test::blink::BitArrayValues::f3)& f3(
      const ::mojo::test::blink::BitArrayValuesPtr& input) {
    return input->f3;
  }

  static const decltype(::mojo::test::blink::BitArrayValues::f4)& f4(
      const ::mojo::test::blink::BitArrayValuesPtr& input) {
    return input->f4;
  }

  static const decltype(::mojo::test::blink::BitArrayValues::f5)& f5(
      const ::mojo::test::blink::BitArrayValuesPtr& input) {
    return input->f5;
  }

  static const decltype(::mojo::test::blink::BitArrayValues::f6)& f6(
      const ::mojo::test::blink::BitArrayValuesPtr& input) {
    return input->f6;
  }

  static bool Read(::mojo::test::blink::BitArrayValues::DataView input, ::mojo::test::blink::BitArrayValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::MultiVersionStruct::DataView,
                                         ::mojo::test::blink::MultiVersionStructPtr> {
  static bool IsNull(const ::mojo::test::blink::MultiVersionStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::MultiVersionStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::MultiVersionStruct::f_int32) f_int32(
      const ::mojo::test::blink::MultiVersionStructPtr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::blink::MultiVersionStruct::f_rect)& f_rect(
      const ::mojo::test::blink::MultiVersionStructPtr& input) {
    return input->f_rect;
  }

  static const decltype(::mojo::test::blink::MultiVersionStruct::f_string)& f_string(
      const ::mojo::test::blink::MultiVersionStructPtr& input) {
    return input->f_string;
  }

  static const decltype(::mojo::test::blink::MultiVersionStruct::f_array)& f_array(
      const ::mojo::test::blink::MultiVersionStructPtr& input) {
    return input->f_array;
  }

  static  decltype(::mojo::test::blink::MultiVersionStruct::f_message_pipe)& f_message_pipe(
       ::mojo::test::blink::MultiVersionStructPtr& input) {
    return input->f_message_pipe;
  }

  static decltype(::mojo::test::blink::MultiVersionStruct::f_bool) f_bool(
      const ::mojo::test::blink::MultiVersionStructPtr& input) {
    return input->f_bool;
  }

  static decltype(::mojo::test::blink::MultiVersionStruct::f_int16) f_int16(
      const ::mojo::test::blink::MultiVersionStructPtr& input) {
    return input->f_int16;
  }

  static bool Read(::mojo::test::blink::MultiVersionStruct::DataView input, ::mojo::test::blink::MultiVersionStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::MultiVersionStructV0::DataView,
                                         ::mojo::test::blink::MultiVersionStructV0Ptr> {
  static bool IsNull(const ::mojo::test::blink::MultiVersionStructV0Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::MultiVersionStructV0Ptr* output) { output->reset(); }

  static decltype(::mojo::test::blink::MultiVersionStructV0::f_int32) f_int32(
      const ::mojo::test::blink::MultiVersionStructV0Ptr& input) {
    return input->f_int32;
  }

  static bool Read(::mojo::test::blink::MultiVersionStructV0::DataView input, ::mojo::test::blink::MultiVersionStructV0Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::MultiVersionStructV1::DataView,
                                         ::mojo::test::blink::MultiVersionStructV1Ptr> {
  static bool IsNull(const ::mojo::test::blink::MultiVersionStructV1Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::MultiVersionStructV1Ptr* output) { output->reset(); }

  static decltype(::mojo::test::blink::MultiVersionStructV1::f_int32) f_int32(
      const ::mojo::test::blink::MultiVersionStructV1Ptr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV1::f_rect)& f_rect(
      const ::mojo::test::blink::MultiVersionStructV1Ptr& input) {
    return input->f_rect;
  }

  static bool Read(::mojo::test::blink::MultiVersionStructV1::DataView input, ::mojo::test::blink::MultiVersionStructV1Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::MultiVersionStructV3::DataView,
                                         ::mojo::test::blink::MultiVersionStructV3Ptr> {
  static bool IsNull(const ::mojo::test::blink::MultiVersionStructV3Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::MultiVersionStructV3Ptr* output) { output->reset(); }

  static decltype(::mojo::test::blink::MultiVersionStructV3::f_int32) f_int32(
      const ::mojo::test::blink::MultiVersionStructV3Ptr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV3::f_rect)& f_rect(
      const ::mojo::test::blink::MultiVersionStructV3Ptr& input) {
    return input->f_rect;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV3::f_string)& f_string(
      const ::mojo::test::blink::MultiVersionStructV3Ptr& input) {
    return input->f_string;
  }

  static bool Read(::mojo::test::blink::MultiVersionStructV3::DataView input, ::mojo::test::blink::MultiVersionStructV3Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::MultiVersionStructV5::DataView,
                                         ::mojo::test::blink::MultiVersionStructV5Ptr> {
  static bool IsNull(const ::mojo::test::blink::MultiVersionStructV5Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::MultiVersionStructV5Ptr* output) { output->reset(); }

  static decltype(::mojo::test::blink::MultiVersionStructV5::f_int32) f_int32(
      const ::mojo::test::blink::MultiVersionStructV5Ptr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV5::f_rect)& f_rect(
      const ::mojo::test::blink::MultiVersionStructV5Ptr& input) {
    return input->f_rect;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV5::f_string)& f_string(
      const ::mojo::test::blink::MultiVersionStructV5Ptr& input) {
    return input->f_string;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV5::f_array)& f_array(
      const ::mojo::test::blink::MultiVersionStructV5Ptr& input) {
    return input->f_array;
  }

  static bool Read(::mojo::test::blink::MultiVersionStructV5::DataView input, ::mojo::test::blink::MultiVersionStructV5Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::MultiVersionStructV7::DataView,
                                         ::mojo::test::blink::MultiVersionStructV7Ptr> {
  static bool IsNull(const ::mojo::test::blink::MultiVersionStructV7Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::MultiVersionStructV7Ptr* output) { output->reset(); }

  static decltype(::mojo::test::blink::MultiVersionStructV7::f_int32) f_int32(
      const ::mojo::test::blink::MultiVersionStructV7Ptr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV7::f_rect)& f_rect(
      const ::mojo::test::blink::MultiVersionStructV7Ptr& input) {
    return input->f_rect;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV7::f_string)& f_string(
      const ::mojo::test::blink::MultiVersionStructV7Ptr& input) {
    return input->f_string;
  }

  static const decltype(::mojo::test::blink::MultiVersionStructV7::f_array)& f_array(
      const ::mojo::test::blink::MultiVersionStructV7Ptr& input) {
    return input->f_array;
  }

  static  decltype(::mojo::test::blink::MultiVersionStructV7::f_message_pipe)& f_message_pipe(
       ::mojo::test::blink::MultiVersionStructV7Ptr& input) {
    return input->f_message_pipe;
  }

  static decltype(::mojo::test::blink::MultiVersionStructV7::f_bool) f_bool(
      const ::mojo::test::blink::MultiVersionStructV7Ptr& input) {
    return input->f_bool;
  }

  static bool Read(::mojo::test::blink::MultiVersionStructV7::DataView input, ::mojo::test::blink::MultiVersionStructV7Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::ReorderedStruct::DataView,
                                         ::mojo::test::blink::ReorderedStructPtr> {
  static bool IsNull(const ::mojo::test::blink::ReorderedStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ReorderedStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::ReorderedStruct::a) a(
      const ::mojo::test::blink::ReorderedStructPtr& input) {
    return input->a;
  }

  static decltype(::mojo::test::blink::ReorderedStruct::b) b(
      const ::mojo::test::blink::ReorderedStructPtr& input) {
    return input->b;
  }

  static decltype(::mojo::test::blink::ReorderedStruct::c) c(
      const ::mojo::test::blink::ReorderedStructPtr& input) {
    return input->c;
  }

  static bool Read(::mojo::test::blink::ReorderedStruct::DataView input, ::mojo::test::blink::ReorderedStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::ContainsInterface::DataView,
                                         ::mojo::test::blink::ContainsInterfacePtr> {
  static bool IsNull(const ::mojo::test::blink::ContainsInterfacePtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ContainsInterfacePtr* output) { output->reset(); }

  static  decltype(::mojo::test::blink::ContainsInterface::some_interface)& some_interface(
       ::mojo::test::blink::ContainsInterfacePtr& input) {
    return input->some_interface;
  }

  static bool Read(::mojo::test::blink::ContainsInterface::DataView input, ::mojo::test::blink::ContainsInterfacePtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::ContainsOther::DataView,
                                         ::mojo::test::blink::ContainsOtherPtr> {
  static bool IsNull(const ::mojo::test::blink::ContainsOtherPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ContainsOtherPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::ContainsOther::other) other(
      const ::mojo::test::blink::ContainsOtherPtr& input) {
    return input->other;
  }

  static bool Read(::mojo::test::blink::ContainsOther::DataView input, ::mojo::test::blink::ContainsOtherPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::ContainsInterfaceRequest::DataView,
                                         ::mojo::test::blink::ContainsInterfaceRequestPtr> {
  static bool IsNull(const ::mojo::test::blink::ContainsInterfaceRequestPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ContainsInterfaceRequestPtr* output) { output->reset(); }

  static  decltype(::mojo::test::blink::ContainsInterfaceRequest::request)& request(
       ::mojo::test::blink::ContainsInterfaceRequestPtr& input) {
    return input->request;
  }

  static bool Read(::mojo::test::blink::ContainsInterfaceRequest::DataView input, ::mojo::test::blink::ContainsInterfaceRequestPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::SingleBoolStruct::DataView,
                                         ::mojo::test::blink::SingleBoolStructPtr> {
  static bool IsNull(const ::mojo::test::blink::SingleBoolStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::SingleBoolStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::SingleBoolStruct::value) value(
      const ::mojo::test::blink::SingleBoolStructPtr& input) {
    return input->value;
  }

  static bool Read(::mojo::test::blink::SingleBoolStruct::DataView input, ::mojo::test::blink::SingleBoolStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::ContainsHashable::DataView,
                                         ::mojo::test::blink::ContainsHashablePtr> {
  static bool IsNull(const ::mojo::test::blink::ContainsHashablePtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ContainsHashablePtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::ContainsHashable::rect)& rect(
      const ::mojo::test::blink::ContainsHashablePtr& input) {
    return input->rect;
  }

  static bool Read(::mojo::test::blink::ContainsHashable::DataView input, ::mojo::test::blink::ContainsHashablePtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::SimpleNestedStruct::DataView,
                                         ::mojo::test::blink::SimpleNestedStructPtr> {
  static bool IsNull(const ::mojo::test::blink::SimpleNestedStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::SimpleNestedStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::SimpleNestedStruct::nested)& nested(
      const ::mojo::test::blink::SimpleNestedStructPtr& input) {
    return input->nested;
  }

  static bool Read(::mojo::test::blink::SimpleNestedStruct::DataView input, ::mojo::test::blink::SimpleNestedStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::EnumNestedStruct::DataView,
                                         ::mojo::test::blink::EnumNestedStructPtr> {
  static bool IsNull(const ::mojo::test::blink::EnumNestedStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::EnumNestedStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::EnumNestedStruct::local_enum_state_) local_enum_state_(
      const ::mojo::test::blink::EnumNestedStructPtr& input) {
    return input->local_enum_state_;
  }

  static bool Read(::mojo::test::blink::EnumNestedStruct::DataView input, ::mojo::test::blink::EnumNestedStructPtr* output);
};

}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_BLINK_H_

/* Metadata comment
eyJtZXRhIjogW3siZW5kIjogNTIyMiwgImJlZ2luIjogNTIwOSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Tb21lSW50ZXJmYWNlIn19LCB7ImVu
ZCI6IDU5OTcsICJiZWdpbiI6IDU5ODcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuU29tZUludGVyZmFjZS5Tb21lTWV0aG9kIn19LCB7ImVuZCI6
IDYzNTYsICJiZWdpbiI6IDYzNDYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuU29tZUludGVyZmFjZS5Tb21lTWV0aG9kIn19LCB7ImVuZCI6IDgw
ODAsICJiZWdpbiI6IDgwNjksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuRW1wdHlTdHJ1Y3QifX0sIHsiZW5kIjogMTI2MTQsICJiZWdpbiI6IDEy
NTk0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
Lk11bHRpVmVyc2lvblN0cnVjdFYwIn19LCB7ImVuZCI6IDE2NDQyLCAiYmVnaW4iOiAxNjQzNSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0
aVZlcnNpb25TdHJ1Y3RWMC5mX2ludDMyIn19LCB7ImVuZCI6IDE3NTEyLCAiYmVnaW4iOiAxNzQ5
NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5S
ZW9yZGVyZWRTdHJ1Y3QifX0sIHsiZW5kIjogMjEzMjQsICJiZWdpbiI6IDIxMzIzLCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlJlb3JkZXJlZFN0
cnVjdC5hIn19LCB7ImVuZCI6IDIxMzg4LCAiYmVnaW4iOiAyMTM4NywgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5SZW9yZGVyZWRTdHJ1Y3QuYiJ9
fSwgeyJlbmQiOiAyMTQ1MiwgImJlZ2luIjogMjE0NTEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUmVvcmRlcmVkU3RydWN0LmMifX0sIHsiZW5k
IjogMjI0OTUsICJiZWdpbiI6IDIyNDgyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0LkNvbnRhaW5zT3RoZXIifX0sIHsiZW5kIjogMjYxNDIsICJi
ZWdpbiI6IDI2MTM3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0LkNvbnRhaW5zT3RoZXIub3RoZXIifX0sIHsiZW5kIjogMjcxODMsICJiZWdpbiI6
IDI3MTY3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0LlNpbmdsZUJvb2xTdHJ1Y3QifX0sIHsiZW5kIjogMzA4OTksICJiZWdpbiI6IDMwODk0LCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNpbmds
ZUJvb2xTdHJ1Y3QudmFsdWUifX0sIHsiZW5kIjogMzE5NTMsICJiZWdpbiI6IDMxOTM3LCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkVudW1OZXN0
ZWRTdHJ1Y3QifX0sIHsiZW5kIjogMzIyNDIsICJiZWdpbiI6IDMyMjMyLCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkVudW1OZXN0ZWRTdHJ1Y3Qu
U3RydWN0RW51bSJ9fSwgeyJlbmQiOiAzNTg2MSwgImJlZ2luIjogMzU4NDQsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRW51bU5lc3RlZFN0cnVj
dC5sb2NhbF9lbnVtX3N0YXRlXyJ9fSwgeyJlbmQiOiAzNjkwNSwgImJlZ2luIjogMzY4OTQsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTmFtZWRS
ZWdpb24ifX0sIHsiZW5kIjogNDA1NDIsICJiZWdpbiI6IDQwNTM4LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5hbWVkUmVnaW9uLm5hbWUifX0s
IHsiZW5kIjogNDA2NjAsICJiZWdpbiI6IDQwNjU1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5hbWVkUmVnaW9uLnJlY3RzIn19LCB7ImVuZCI6
IDQxNzE3LCAiYmVnaW4iOiA0MTcwOSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5SZWN0UGFpciJ9fSwgeyJlbmQiOiA0NTI4MSwgImJlZ2luIjog
NDUyNzYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuUmVjdFBhaXIuZmlyc3QifX0sIHsiZW5kIjogNDUzNjksICJiZWdpbiI6IDQ1MzYzLCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlJlY3RQYWly
LnNlY29uZCJ9fSwgeyJlbmQiOiA0NjQzNywgImJlZ2luIjogNDY0MTcsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1
ZXMifX0sIHsiZW5kIjogNTA5NjEsICJiZWdpbiI6IDUwOTU5LCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYw
In19LCB7ImVuZCI6IDUxMDMxLCAiYmVnaW4iOiA1MTAyOSwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMSJ9
fSwgeyJlbmQiOiA1MTEwMiwgImJlZ2luIjogNTExMDAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjIifX0s
IHsiZW5kIjogNTExNzMsICJiZWdpbiI6IDUxMTcxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYzIn19LCB7
ImVuZCI6IDUxMjQ1LCAiYmVnaW4iOiA1MTI0MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mNCJ9fSwgeyJl
bmQiOiA1MTMxNiwgImJlZ2luIjogNTEzMTQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjUifX0sIHsiZW5k
IjogNTEzODgsICJiZWdpbiI6IDUxMzg2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmY2In19LCB7ImVuZCI6
IDUxNDU5LCAiYmVnaW4iOiA1MTQ1NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mNyJ9fSwgeyJlbmQiOiA1
MTUzMSwgImJlZ2luIjogNTE1MjksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjgifX0sIHsiZW5kIjogNTE2
MDAsICJiZWdpbiI6IDUxNTk4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmY5In19LCB7ImVuZCI6IDUxNjcy
LCAiYmVnaW4iOiA1MTY2OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMTAifX0sIHsiZW5kIjogNTE3NDks
ICJiZWdpbiI6IDUxNzQ2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYxMSJ9fSwgeyJlbmQiOiA1MTgyNiwg
ImJlZ2luIjogNTE4MjMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjEyIn19LCB7ImVuZCI6IDUxOTIzLCAi
YmVnaW4iOiA1MTkyMCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMTMifX0sIHsiZW5kIjogNTIwMjUsICJi
ZWdpbiI6IDUyMDIyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYxNCJ9fSwgeyJlbmQiOiA1MjEyNywgImJl
Z2luIjogNTIxMjQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjE1In19LCB7ImVuZCI6IDUyMjI0LCAiYmVn
aW4iOiA1MjIyMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMTYifX0sIHsiZW5kIjogNTIzMjYsICJiZWdp
biI6IDUyMzIzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYxNyJ9fSwgeyJlbmQiOiA1MjQyOCwgImJlZ2lu
IjogNTI0MjUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjE4In19LCB7ImVuZCI6IDUyNTE0LCAiYmVnaW4i
OiA1MjUxMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMTkifX0sIHsiZW5kIjogNTI2MDAsICJiZWdpbiI6
IDUyNTk3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYyMCJ9fSwgeyJlbmQiOiA1MjY5OCwgImJlZ2luIjog
NTI2OTUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjIxIn19LCB7ImVuZCI6IDUyNzk2LCAiYmVnaW4iOiA1
Mjc5MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9k
ZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9j
aHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVz
dC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMjIifX0sIHsiZW5kIjogNTI4ODYsICJiZWdpbiI6IDUy
ODgzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYyMyJ9fSwgeyJlbmQiOiA1Mjk3NiwgImJlZ2luIjogNTI5
NzMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
Tm9EZWZhdWx0RmllbGRWYWx1ZXMuZjI0In19LCB7ImVuZCI6IDUzMDgyLCAiYmVnaW4iOiA1MzA3
OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5O
b0RlZmF1bHRGaWVsZFZhbHVlcy5mMjUifX0sIHsiZW5kIjogNTMxODgsICJiZWdpbiI6IDUzMTg1
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5v
RGVmYXVsdEZpZWxkVmFsdWVzLmYyNiJ9fSwgeyJlbmQiOiA1MzI2OCwgImJlZ2luIjogNTMyNjUs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9E
ZWZhdWx0RmllbGRWYWx1ZXMuZjI3In19LCB7ImVuZCI6IDUzMzQ4LCAiYmVnaW4iOiA1MzM0NSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Ob0Rl
ZmF1bHRGaWVsZFZhbHVlcy5mMjgifX0sIHsiZW5kIjogNTM0MzYsICJiZWdpbiI6IDUzNDMzLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVm
YXVsdEZpZWxkVmFsdWVzLmYyOSJ9fSwgeyJlbmQiOiA1MzUyNCwgImJlZ2luIjogNTM1MjEsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZh
dWx0RmllbGRWYWx1ZXMuZjMwIn19LCB7ImVuZCI6IDU0NjQ2LCAiYmVnaW4iOiA1NDYyOCwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0
RmllbGRWYWx1ZXMifX0sIHsiZW5kIjogNTQ5NDYsICJiZWdpbiI6IDU0OTQyLCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRGaWVsZFZh
bHVlcy5rRm9vIn19LCB7ImVuZCI6IDU4ODAwLCAiYmVnaW4iOiA1ODc5OCwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1
ZXMuZjAifX0sIHsiZW5kIjogNTg4NjgsICJiZWdpbiI6IDU4ODY2LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRGaWVsZFZhbHVlcy5m
MSJ9fSwgeyJlbmQiOiA1ODkzNywgImJlZ2luIjogNTg5MzUsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRGVmYXVsdEZpZWxkVmFsdWVzLmYyIn19
LCB7ImVuZCI6IDU5MDA2LCAiYmVnaW4iOiA1OTAwNCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1ZXMuZjMifX0sIHsi
ZW5kIjogNTkwNzYsICJiZWdpbiI6IDU5MDc0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRGaWVsZFZhbHVlcy5mNCJ9fSwgeyJlbmQi
OiA1OTE0NSwgImJlZ2luIjogNTkxNDMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuRGVmYXVsdEZpZWxkVmFsdWVzLmY1In19LCB7ImVuZCI6IDU5
MjE1LCAiYmVnaW4iOiA1OTIxMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1ZXMuZjYifX0sIHsiZW5kIjogNTkyODQs
ICJiZWdpbiI6IDU5MjgyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LkRlZmF1bHRGaWVsZFZhbHVlcy5mNyJ9fSwgeyJlbmQiOiA1OTM1NCwgImJl
Z2luIjogNTkzNTIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuRGVmYXVsdEZpZWxkVmFsdWVzLmY4In19LCB7ImVuZCI6IDU5NDIxLCAiYmVnaW4i
OiA1OTQxOSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5EZWZhdWx0RmllbGRWYWx1ZXMuZjkifX0sIHsiZW5kIjogNTk0OTAsICJiZWdpbiI6IDU5
NDg3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkRlZmF1bHRGaWVsZFZhbHVlcy5mMTAifX0sIHsiZW5kIjogNTk1NjAsICJiZWdpbiI6IDU5NTU3
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRl
ZmF1bHRGaWVsZFZhbHVlcy5mMTEifX0sIHsiZW5kIjogNTk2MzAsICJiZWdpbiI6IDU5NjI3LCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1
bHRGaWVsZFZhbHVlcy5mMTIifX0sIHsiZW5kIjogNTk3MDUsICJiZWdpbiI6IDU5NzAyLCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRG
aWVsZFZhbHVlcy5mMTMifX0sIHsiZW5kIjogNTk3ODAsICJiZWdpbiI6IDU5Nzc3LCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRGaWVs
ZFZhbHVlcy5mMTQifX0sIHsiZW5kIjogNTk4NzIsICJiZWdpbiI6IDU5ODY5LCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRGaWVsZFZh
bHVlcy5mMTUifX0sIHsiZW5kIjogNTk5NjQsICJiZWdpbiI6IDU5OTYxLCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRGaWVsZFZhbHVl
cy5mMTYifX0sIHsiZW5kIjogNjEwNzAsICJiZWdpbiI6IDYxMDU1LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNjb3BlZENvbnN0YW50cyJ9fSwg
eyJlbmQiOiA2MTM0NSwgImJlZ2luIjogNjEzNDAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU2NvcGVkQ29uc3RhbnRzLkVUeXBlIn19LCB7ImVu
ZCI6IDYxNDU0LCAiYmVnaW4iOiA2MTQ1MSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5TY29wZWRDb25zdGFudHMuVEVOIn19LCB7ImVuZCI6IDYx
NTU0LCAiYmVnaW4iOiA2MTU0NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5TY29wZWRDb25zdGFudHMuQUxTT19URU4ifX0sIHsiZW5kIjogNjUy
MjgsICJiZWdpbiI6IDY1MjI2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0LlNjb3BlZENvbnN0YW50cy5mMCJ9fSwgeyJlbmQiOiA2NTMwOSwgImJl
Z2luIjogNjUzMDcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuU2NvcGVkQ29uc3RhbnRzLmYxIn19LCB7ImVuZCI6IDY1MzkwLCAiYmVnaW4iOiA2
NTM4OCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9k
ZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9j
aHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVz
dC5TY29wZWRDb25zdGFudHMuZjIifX0sIHsiZW5kIjogNjU0NzEsICJiZWdpbiI6IDY1NDY5LCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNjb3Bl
ZENvbnN0YW50cy5mMyJ9fSwgeyJlbmQiOiA2NTU1MiwgImJlZ2luIjogNjU1NTAsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU2NvcGVkQ29uc3Rh
bnRzLmY0In19LCB7ImVuZCI6IDY1NjE4LCAiYmVnaW4iOiA2NTYxNiwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TY29wZWRDb25zdGFudHMuZjUi
fX0sIHsiZW5kIjogNjU2ODQsICJiZWdpbiI6IDY1NjgyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNjb3BlZENvbnN0YW50cy5mNiJ9fSwgeyJl
bmQiOiA2NjcyMiwgImJlZ2luIjogNjY3MTEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwS2V5VHlwZXMifX0sIHsiZW5kIjogNzA4MDYsICJi
ZWdpbiI6IDcwODA0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0Lk1hcEtleVR5cGVzLmYxIn19LCB7ImVuZCI6IDcwODkxLCAiYmVnaW4iOiA3MDg4
OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5N
YXBLZXlUeXBlcy5mMiJ9fSwgeyJlbmQiOiA3MDk3NiwgImJlZ2luIjogNzA5NzQsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwS2V5VHlwZXMu
ZjMifX0sIHsiZW5kIjogNzEwNjMsICJiZWdpbiI6IDcxMDYxLCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk1hcEtleVR5cGVzLmY0In19LCB7ImVu
ZCI6IDcxMTQ4LCAiYmVnaW4iOiA3MTE0NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBLZXlUeXBlcy5mNSJ9fSwgeyJlbmQiOiA3MTIzNSwg
ImJlZ2luIjogNzEyMzMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuTWFwS2V5VHlwZXMuZjYifX0sIHsiZW5kIjogNzEzMjAsICJiZWdpbiI6IDcx
MzE4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
Lk1hcEtleVR5cGVzLmY3In19LCB7ImVuZCI6IDcxNDA3LCAiYmVnaW4iOiA3MTQwNSwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBLZXlUeXBl
cy5mOCJ9fSwgeyJlbmQiOiA3MTQ4OCwgImJlZ2luIjogNzE0ODYsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwS2V5VHlwZXMuZjkifX0sIHsi
ZW5kIjogNzE1NzMsICJiZWdpbiI6IDcxNTcwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk1hcEtleVR5cGVzLmYxMCJ9fSwgeyJlbmQiOiA3MTY2
OCwgImJlZ2luIjogNzE2NjUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuTWFwS2V5VHlwZXMuZjExIn19LCB7ImVuZCI6IDcyNjk0LCAiYmVnaW4i
OiA3MjY4MSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5NYXBWYWx1ZVR5cGVzIn19LCB7ImVuZCI6IDc3MDQ5LCAiYmVnaW4iOiA3NzA0NywgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBWYWx1
ZVR5cGVzLmYwIn19LCB7ImVuZCI6IDc3MTczLCAiYmVnaW4iOiA3NzE3MSwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBWYWx1ZVR5cGVzLmYx
In19LCB7ImVuZCI6IDc3MjgxLCAiYmVnaW4iOiA3NzI3OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBWYWx1ZVR5cGVzLmYyIn19LCB7ImVu
ZCI6IDc3Mzg5LCAiYmVnaW4iOiA3NzM4NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBWYWx1ZVR5cGVzLmYzIn19LCB7ImVuZCI6IDc3NTI2
LCAiYmVnaW4iOiA3NzUyNCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5NYXBWYWx1ZVR5cGVzLmY0In19LCB7ImVuZCI6IDc3NjQ3LCAiYmVnaW4i
OiA3NzY0NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5NYXBWYWx1ZVR5cGVzLmY1In19LCB7ImVuZCI6IDc3NzU5LCAiYmVnaW4iOiA3Nzc1Nywg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBW
YWx1ZVR5cGVzLmY2In19LCB7ImVuZCI6IDc3ODgxLCAiYmVnaW4iOiA3Nzg3OSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBWYWx1ZVR5cGVz
LmY3In19LCB7ImVuZCI6IDc4MDE2LCAiYmVnaW4iOiA3ODAxNCwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBWYWx1ZVR5cGVzLmY4In19LCB7
ImVuZCI6IDc4MTIwLCAiYmVnaW4iOiA3ODExOCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBWYWx1ZVR5cGVzLmY5In19LCB7ImVuZCI6IDc4
MjM5LCAiYmVnaW4iOiA3ODIzNiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5NYXBWYWx1ZVR5cGVzLmYxMCJ9fSwgeyJlbmQiOiA3ODM3MiwgImJl
Z2luIjogNzgzNjksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5mMTEifX0sIHsiZW5kIjogNzk0NTMsICJiZWdpbiI6IDc5
NDM4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkFycmF5VmFsdWVUeXBlcyJ9fSwgeyJlbmQiOiA4MzE5NSwgImJlZ2luIjogODMxOTMsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQXJyYXlWYWx1
ZVR5cGVzLmYwIn19LCB7ImVuZCI6IDgzMjc0LCAiYmVnaW4iOiA4MzI3MiwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5BcnJheVZhbHVlVHlwZXMu
ZjEifX0sIHsiZW5kIjogODMzNTMsICJiZWdpbiI6IDgzMzUxLCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkFycmF5VmFsdWVUeXBlcy5mMiJ9fSwg
eyJlbmQiOiA4MzQzMiwgImJlZ2luIjogODM0MzAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQXJyYXlWYWx1ZVR5cGVzLmYzIn19LCB7ImVuZCI6
IDgzNTA5LCAiYmVnaW4iOiA4MzUwNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5BcnJheVZhbHVlVHlwZXMuZjQifX0sIHsiZW5kIjogODM1ODcs
ICJiZWdpbiI6IDgzNTg1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LkFycmF5VmFsdWVUeXBlcy5mNSJ9fSwgeyJlbmQiOiA4MzY5NSwgImJlZ2lu
IjogODM2OTMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuQXJyYXlWYWx1ZVR5cGVzLmY2In19LCB7ImVuZCI6IDgzODA1LCAiYmVnaW4iOiA4Mzgw
MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5B
cnJheVZhbHVlVHlwZXMuZjcifX0sIHsiZW5kIjogODQ5MDAsICJiZWdpbiI6IDg0ODgzLCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkZsb2F0TnVt
YmVyVmFsdWVzIn19LCB7ImVuZCI6IDg1MTk4LCAiYmVnaW4iOiA4NTE5NiwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9hdE51bWJlclZhbHVl
cy5WMCJ9fSwgeyJlbmQiOiA4NTMyNCwgImJlZ2luIjogODUzMjIsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuVjEi
fX0sIHsiZW5kIjogODU0NTEsICJiZWdpbiI6IDg1NDQ5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLlYyIn19LCB7
ImVuZCI6IDg1NTc3LCAiYmVnaW4iOiA4NTU3NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5WMyJ9fSwgeyJlbmQi
OiA4NTcwMSwgImJlZ2luIjogODU2OTksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuVjQifX0sIHsiZW5kIjogODU4
MjYsICJiZWdpbiI6IDg1ODI0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLlY1In19LCB7ImVuZCI6IDg1OTUxLCAi
YmVnaW4iOiA4NTk0OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5WNiJ9fSwgeyJlbmQiOiA4NjAzOSwgImJlZ2lu
IjogODYwMzcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuVjcifX0sIHsiZW5kIjogODYxNDAsICJiZWdpbiI6IDg2
MTM4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkZsb2F0TnVtYmVyVmFsdWVzLlY4In19LCB7ImVuZCI6IDg2MjM0LCAiYmVnaW4iOiA4NjIzMiwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9h
dE51bWJlclZhbHVlcy5WOSJ9fSwgeyJlbmQiOiA4OTkwNywgImJlZ2luIjogODk5MDUsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1i
ZXJWYWx1ZXMuZjAifX0sIHsiZW5kIjogODk5NzQsICJiZWdpbiI6IDg5OTcyLCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFs
dWVzLmYxIn19LCB7ImVuZCI6IDkwMDQxLCAiYmVnaW4iOiA5MDAzOSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5m
MiJ9fSwgeyJlbmQiOiA5MDEwNywgImJlZ2luIjogOTAxMDUsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuZjMifX0s
IHsiZW5kIjogOTAxNzMsICJiZWdpbiI6IDkwMTcxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLmY0In19LCB7ImVu
ZCI6IDkwMjM5LCAiYmVnaW4iOiA5MDIzNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5mNSJ9fSwgeyJlbmQiOiA5
MDMwNSwgImJlZ2luIjogOTAzMDMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuZjYifX0sIHsiZW5kIjogOTAzNzIs
ICJiZWdpbiI6IDkwMzcwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLmY3In19LCB7ImVuZCI6IDkwNDM5LCAiYmVn
aW4iOiA5MDQzNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5mOCJ9fSwgeyJlbmQiOiA5MDUwNiwgImJlZ2luIjog
OTA1MDQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuRmxvYXROdW1iZXJWYWx1ZXMuZjkifX0sIHsiZW5kIjogOTE1NjgsICJiZWdpbiI6IDkxNTQ5
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lklu
dGVnZXJOdW1iZXJWYWx1ZXMifX0sIHsiZW5kIjogOTE4NzQsICJiZWdpbiI6IDkxODcyLCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJO
dW1iZXJWYWx1ZXMuVjAifX0sIHsiZW5kIjogOTE5NjcsICJiZWdpbiI6IDkxOTY1LCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1i
ZXJWYWx1ZXMuVjEifX0sIHsiZW5kIjogOTIwNTgsICJiZWdpbiI6IDkyMDU2LCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJW
YWx1ZXMuVjIifX0sIHsiZW5kIjogOTIxNDgsICJiZWdpbiI6IDkyMTQ2LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1
ZXMuVjMifX0sIHsiZW5kIjogOTIyMzksICJiZWdpbiI6IDkyMjM3LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMu
VjQifX0sIHsiZW5kIjogOTIzMzIsICJiZWdpbiI6IDkyMzMwLCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjUi
fX0sIHsiZW5kIjogOTI0MjgsICJiZWdpbiI6IDkyNDI2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjYifX0s
IHsiZW5kIjogOTI1MjAsICJiZWdpbiI6IDkyNTE4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjcifX0sIHsi
ZW5kIjogOTI2MTEsICJiZWdpbiI6IDkyNjA5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjgifX0sIHsiZW5k
IjogOTI3MDYsICJiZWdpbiI6IDkyNzA0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjkifX0sIHsiZW5kIjog
OTI4MDMsICJiZWdpbiI6IDkyODAwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjEwIn19LCB7ImVuZCI6IDky
OTA2LCAiYmVnaW4iOiA5MjkwMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlYxMSJ9fSwgeyJlbmQiOiA5MzAw
MCwgImJlZ2luIjogOTI5OTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5WMTIifX0sIHsiZW5kIjogOTMwOTMs
ICJiZWdpbiI6IDkzMDkwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjEzIn19LCB7ImVuZCI6IDkzMTk1LCAi
YmVnaW4iOiA5MzE5MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlYxNCJ9fSwgeyJlbmQiOiA5MzI5NywgImJl
Z2luIjogOTMyOTQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5WMTUifX0sIHsiZW5kIjogOTM0MDYsICJiZWdp
biI6IDkzNDAzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjE2In19LCB7ImVuZCI6IDkzNTAwLCAiYmVnaW4i
OiA5MzQ5NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlYxNyJ9fSwgeyJlbmQiOiA5MzU5MywgImJlZ2luIjog
OTM1OTAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuSW50ZWdlck51bWJlclZhbHVlcy5WMTgifX0sIHsiZW5kIjogOTM3MDEsICJiZWdpbiI6IDkz
Njk4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkludGVnZXJOdW1iZXJWYWx1ZXMuVjE5In19LCB7ImVuZCI6IDk3NjI1LCAiYmVnaW4iOiA5NzYy
MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5J
bnRlZ2VyTnVtYmVyVmFsdWVzLmYwIn19LCB7ImVuZCI6IDk3Njk0LCAiYmVnaW4iOiA5NzY5Miwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRl
Z2VyTnVtYmVyVmFsdWVzLmYxIn19LCB7ImVuZCI6IDk3NzYzLCAiYmVnaW4iOiA5Nzc2MSwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2Vy
TnVtYmVyVmFsdWVzLmYyIn19LCB7ImVuZCI6IDk3ODMyLCAiYmVnaW4iOiA5NzgzMCwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVt
YmVyVmFsdWVzLmYzIn19LCB7ImVuZCI6IDk3OTAxLCAiYmVnaW4iOiA5Nzg5OSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVy
VmFsdWVzLmY0In19LCB7ImVuZCI6IDk3OTcxLCAiYmVnaW4iOiA5Nzk2OSwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFs
dWVzLmY1In19LCB7ImVuZCI6IDk4MDQxLCAiYmVnaW4iOiA5ODAzOSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVz
LmY2In19LCB7ImVuZCI6IDk4MTExLCAiYmVnaW4iOiA5ODEwOSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmY3
In19LCB7ImVuZCI6IDk4MTgxLCAiYmVnaW4iOiA5ODE3OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmY4In19
LCB7ImVuZCI6IDk4MjUxLCAiYmVnaW4iOiA5ODI0OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmY5In19LCB7
ImVuZCI6IDk4MzIzLCAiYmVnaW4iOiA5ODMyMCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmYxMCJ9fSwgeyJl
bmQiOiA5ODM5NSwgImJlZ2luIjogOTgzOTIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mMTEifX0sIHsiZW5k
IjogOTg0NjcsICJiZWdpbiI6IDk4NDY0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuZjEyIn19LCB7ImVuZCI6
IDk4NTM5LCAiYmVnaW4iOiA5ODUzNiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmYxMyJ9fSwgeyJlbmQiOiA5
ODYxMSwgImJlZ2luIjogOTg2MDgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mMTQifX0sIHsiZW5kIjogOTg2
ODMsICJiZWdpbiI6IDk4NjgwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuZjE1In19LCB7ImVuZCI6IDk4NzU1
LCAiYmVnaW4iOiA5ODc1MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmYxNiJ9fSwgeyJlbmQiOiA5ODgyNywg
ImJlZ2luIjogOTg4MjQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mMTcifX0sIHsiZW5kIjogOTg4OTksICJi
ZWdpbiI6IDk4ODk2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuZjE4In19LCB7ImVuZCI6IDk4OTcxLCAiYmVn
aW4iOiA5ODk2OCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmYxOSJ9fSwgeyJlbmQiOiAxMDAwNDMsICJiZWdp
biI6IDEwMDAyMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcyJ9fSwgeyJlbmQiOiAxMDAzNTQsICJiZWdpbiI6
IDEwMDM1MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WMCJ9fSwgeyJlbmQiOiAxMDA0NDcsICJiZWdpbiI6
IDEwMDQ0NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WMSJ9fSwgeyJlbmQiOiAxMDA1NDEsICJiZWdpbiI6
IDEwMDUzOSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WMiJ9fSwgeyJlbmQiOiAxMDA2MzgsICJiZWdpbiI6
IDEwMDYzNiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WMyJ9fSwgeyJlbmQiOiAxMDA3MzIsICJiZWdpbiI6
IDEwMDczMCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WNCJ9fSwgeyJlbmQiOiAxMDA4MzAsICJiZWdpbiI6
IDEwMDgyOCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WNSJ9fSwgeyJlbmQiOiAxMDA5MjksICJiZWdpbiI6
IDEwMDkyNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WNiJ9fSwgeyJlbmQiOiAxMDEwMjMsICJiZWdpbiI6
IDEwMTAyMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WNyJ9fSwgeyJlbmQiOiAxMDExMjYsICJiZWdpbiI6
IDEwMTEyNCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WOCJ9fSwgeyJlbmQiOiAxMDEyMjksICJiZWdpbiI6
IDEwMTIyNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WOSJ9fSwgeyJlbmQiOiAxMDEzMjcsICJiZWdpbiI6
IDEwMTMyNCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5WMTAifX0sIHsiZW5kIjogMTAxNDQwLCAiYmVnaW4i
OiAxMDE0MzcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMuVjExIn19LCB7ImVuZCI6IDEwNTI1MiwgImJlZ2lu
IjogMTA1MjUwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmYwIn19LCB7ImVuZCI6IDEwNTMyMywgImJlZ2lu
IjogMTA1MzIxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmYxIn19LCB7ImVuZCI6IDEwNTM5NCwgImJlZ2lu
IjogMTA1MzkyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmYyIn19LCB7ImVuZCI6IDEwNTQ2NiwgImJlZ2lu
IjogMTA1NDY0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmYzIn19LCB7ImVuZCI6IDEwNTUzOCwgImJlZ2lu
IjogMTA1NTM2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmY0In19LCB7ImVuZCI6IDEwNTYxMCwgImJlZ2lu
IjogMTA1NjA4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmY1In19LCB7ImVuZCI6IDEwNTY4MiwgImJlZ2lu
IjogMTA1NjgwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmY2In19LCB7ImVuZCI6IDEwNTc1NCwgImJlZ2lu
IjogMTA1NzUyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmY3In19LCB7ImVuZCI6IDEwNTgyNiwgImJlZ2lu
IjogMTA1ODI0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmY4In19LCB7ImVuZCI6IDEwNTg5OCwgImJlZ2lu
IjogMTA1ODk2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmY5In19LCB7ImVuZCI6IDEwNTk3MiwgImJlZ2lu
IjogMTA1OTY5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzLmYxMCJ9fSwgeyJlbmQiOiAxMDYwNDYsICJiZWdp
biI6IDEwNjA0MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5mMTEifX0sIHsiZW5kIjogMTA3MTEwLCAiYmVn
aW4iOiAxMDcwOTYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuQml0QXJyYXlWYWx1ZXMifX0sIHsiZW5kIjogMTEwOTg5LCAiYmVnaW4iOiAxMTA5
ODcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
Qml0QXJyYXlWYWx1ZXMuZjAifX0sIHsiZW5kIjogMTExMDY0LCAiYmVnaW4iOiAxMTEwNjIsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQml0QXJy
YXlWYWx1ZXMuZjEifX0sIHsiZW5kIjogMTExMTM5LCAiYmVnaW4iOiAxMTExMzcsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQml0QXJyYXlWYWx1
ZXMuZjIifX0sIHsiZW5kIjogMTExMjE0LCAiYmVnaW4iOiAxMTEyMTIsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQml0QXJyYXlWYWx1ZXMuZjMi
fX0sIHsiZW5kIjogMTExMzAyLCAiYmVnaW4iOiAxMTEzMDAsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQml0QXJyYXlWYWx1ZXMuZjQifX0sIHsi
ZW5kIjogMTExNDA2LCAiYmVnaW4iOiAxMTE0MDQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQml0QXJyYXlWYWx1ZXMuZjUifX0sIHsiZW5kIjog
MTExNTEwLCAiYmVnaW4iOiAxMTE1MDgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuQml0QXJyYXlWYWx1ZXMuZjYifX0sIHsiZW5kIjogMTEyNTU4
LCAiYmVnaW4iOiAxMTI1NDAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0In19LCB7ImVuZCI6IDExNzAxMCwgImJl
Z2luIjogMTE3MDAzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdC5mX2ludDMyIn19LCB7ImVuZCI6IDExNzEwOCwg
ImJlZ2luIjogMTE3MTAyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdC5mX3JlY3QifX0sIHsiZW5kIjogMTE3MTkz
LCAiYmVnaW4iOiAxMTcxODUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0LmZfc3RyaW5nIn19LCB7ImVuZCI6IDEx
NzMwMCwgImJlZ2luIjogMTE3MjkzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdC5mX2FycmF5In19LCB7ImVuZCI6
IDExNzQxNywgImJlZ2luIjogMTE3NDAzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdC5mX21lc3NhZ2VfcGlwZSJ9
fSwgeyJlbmQiOiAxMTc0OTEsICJiZWdpbiI6IDExNzQ4NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25TdHJ1Y3QuZl9ib29s
In19LCB7ImVuZCI6IDExNzU3MCwgImJlZ2luIjogMTE3NTYzLCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdC5mX2lu
dDE2In19LCB7ImVuZCI6IDExODY4NywgImJlZ2luIjogMTE4NjY3LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdFYx
In19LCB7ImVuZCI6IDEyMjU3MywgImJlZ2luIjogMTIyNTY2LCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdFYxLmZf
aW50MzIifX0sIHsiZW5kIjogMTIyNjczLCAiYmVnaW4iOiAxMjI2NjcsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0
VjEuZl9yZWN0In19LCB7ImVuZCI6IDEyMzc5OSwgImJlZ2luIjogMTIzNzc5LCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0
cnVjdFYzIn19LCB7ImVuZCI6IDEyNzgxMiwgImJlZ2luIjogMTI3ODA1LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVj
dFYzLmZfaW50MzIifX0sIHsiZW5kIjogMTI3OTEyLCAiYmVnaW4iOiAxMjc5MDYsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9u
U3RydWN0VjMuZl9yZWN0In19LCB7ImVuZCI6IDEyNzk5OSwgImJlZ2luIjogMTI3OTkxLCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVy
c2lvblN0cnVjdFYzLmZfc3RyaW5nIn19LCB7ImVuZCI6IDEyOTEyNSwgImJlZ2luIjogMTI5MTA1
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11
bHRpVmVyc2lvblN0cnVjdFY1In19LCB7ImVuZCI6IDEzMzMxNiwgImJlZ2luIjogMTMzMzA5LCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRp
VmVyc2lvblN0cnVjdFY1LmZfaW50MzIifX0sIHsiZW5kIjogMTMzNDE2LCAiYmVnaW4iOiAxMzM0
MTAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
TXVsdGlWZXJzaW9uU3RydWN0VjUuZl9yZWN0In19LCB7ImVuZCI6IDEzMzUwMywgImJlZ2luIjog
MTMzNDk1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0Lk11bHRpVmVyc2lvblN0cnVjdFY1LmZfc3RyaW5nIn19LCB7ImVuZCI6IDEzMzYxMiwgImJl
Z2luIjogMTMzNjA1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdFY1LmZfYXJyYXkifX0sIHsiZW5kIjogMTM0NzM4
LCAiYmVnaW4iOiAxMzQ3MTgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjcifX0sIHsiZW5kIjogMTM4OTc0LCAi
YmVnaW4iOiAxMzg5NjcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjcuZl9pbnQzMiJ9fSwgeyJlbmQiOiAxMzkw
NzQsICJiZWdpbiI6IDEzOTA2OCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25TdHJ1Y3RWNy5mX3JlY3QifX0sIHsiZW5kIjog
MTM5MTYxLCAiYmVnaW4iOiAxMzkxNTMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjcuZl9zdHJpbmcifX0sIHsi
ZW5kIjogMTM5MjcwLCAiYmVnaW4iOiAxMzkyNjMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjcuZl9hcnJheSJ9
fSwgeyJlbmQiOiAxMzkzODksICJiZWdpbiI6IDEzOTM3NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25TdHJ1Y3RWNy5mX21l
c3NhZ2VfcGlwZSJ9fSwgeyJlbmQiOiAxMzk0NjUsICJiZWdpbiI6IDEzOTQ1OSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25T
dHJ1Y3RWNy5mX2Jvb2wifX0sIHsiZW5kIjogMTQwNTg2LCAiYmVnaW4iOiAxNDA1NjksICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQ29udGFpbnNJ
bnRlcmZhY2UifX0sIHsiZW5kIjogMTQ0MTgxLCAiYmVnaW4iOiAxNDQxNjcsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQ29udGFpbnNJbnRlcmZh
Y2Uuc29tZV9pbnRlcmZhY2UifX0sIHsiZW5kIjogMTQ1MzAxLCAiYmVnaW4iOiAxNDUyNzcsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQ29udGFp
bnNJbnRlcmZhY2VSZXF1ZXN0In19LCB7ImVuZCI6IDE0OTA0NywgImJlZ2luIjogMTQ5MDQwLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkNvbnRh
aW5zSW50ZXJmYWNlUmVxdWVzdC5yZXF1ZXN0In19LCB7ImVuZCI6IDE1MDE4NiwgImJlZ2luIjog
MTUwMTcwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0LkNvbnRhaW5zSGFzaGFibGUifX0sIHsiZW5kIjogMTUzOTQ0LCAiYmVnaW4iOiAxNTM5NDAs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQ29u
dGFpbnNIYXNoYWJsZS5yZWN0In19LCB7ImVuZCI6IDE1NTAwMCwgImJlZ2luIjogMTU0OTgyLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNpbXBs
ZU5lc3RlZFN0cnVjdCJ9fSwgeyJlbmQiOiAxNTg3OTMsICJiZWdpbiI6IDE1ODc4NywgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TaW1wbGVOZXN0
ZWRTdHJ1Y3QubmVzdGVkIn19XSwgInR5cGUiOiAia3l0aGUwIn0=
*/