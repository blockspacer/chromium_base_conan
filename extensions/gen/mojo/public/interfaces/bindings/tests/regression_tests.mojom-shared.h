// mojo/public/interfaces/bindings/tests/regression_tests.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_REGRESSION_TESTS_MOJOM_SHARED_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_REGRESSION_TESTS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <ostream>
#include <type_traits>
#include <utility>

#include "base/compiler_specific.h"
#include "base/containers/flat_map.h"
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
#include "mojo/public/interfaces/bindings/tests/regression_tests.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"



#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif


namespace regression_tests {
class EdgeDataView;

class VertexDataView;

class EmptyStructDataView;

class ADataView;

class BDataView;

class HandlesNameCollisionStructDataView;

class HandlesHandleNameCollisionStructDataView;

class HandlesUnionNameCollisionStructDataView;

class HandlesNameCollisionUnionDataView;


}  // namespace regression_tests

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::regression_tests::EdgeDataView> {
  using Data = ::regression_tests::internal::Edge_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::regression_tests::VertexDataView> {
  using Data = ::regression_tests::internal::Vertex_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::regression_tests::EmptyStructDataView> {
  using Data = ::regression_tests::internal::EmptyStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::regression_tests::ADataView> {
  using Data = ::regression_tests::internal::A_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::regression_tests::BDataView> {
  using Data = ::regression_tests::internal::B_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::regression_tests::HandlesNameCollisionStructDataView> {
  using Data = ::regression_tests::internal::HandlesNameCollisionStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::regression_tests::HandlesHandleNameCollisionStructDataView> {
  using Data = ::regression_tests::internal::HandlesHandleNameCollisionStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::regression_tests::HandlesUnionNameCollisionStructDataView> {
  using Data = ::regression_tests::internal::HandlesUnionNameCollisionStruct_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::regression_tests::HandlesNameCollisionUnionDataView> {
  using Data = ::regression_tests::internal::HandlesNameCollisionUnion_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace regression_tests {


// @generated_from: regression_tests.EnumWithReference
enum class EnumWithReference : int32_t {
  
// @generated_from: regression_tests.EnumWithReference.k_STEREO_AND_KEYBOARD_MIC
  k_STEREO_AND_KEYBOARD_MIC = 30,
  
// @generated_from: regression_tests.EnumWithReference.k_MAX
  k_MAX = 30,
  kMinValue = 30,
  kMaxValue = 30,
};

 std::ostream& operator<<(std::ostream& os, EnumWithReference value);
inline bool IsKnownEnumValue(EnumWithReference value) {
  return internal::EnumWithReference_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


// @generated_from: regression_tests.EnumWithLowercase
enum class EnumWithLowercase : int32_t {
  
// @generated_from: regression_tests.EnumWithLowercase.PlanarF16
  PlanarF16 = 0,
  
// @generated_from: regression_tests.EnumWithLowercase.PlanarF32
  PlanarF32 = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, EnumWithLowercase value);
inline bool IsKnownEnumValue(EnumWithLowercase value) {
  return internal::EnumWithLowercase_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


// @generated_from: regression_tests.EnumWithNumbers
enum class EnumWithNumbers : int32_t {
  
// @generated_from: regression_tests.EnumWithNumbers.k_2_1
  k_2_1 = 4,
  kMinValue = 4,
  kMaxValue = 4,
};

 std::ostream& operator<<(std::ostream& os, EnumWithNumbers value);
inline bool IsKnownEnumValue(EnumWithNumbers value) {
  return internal::EnumWithNumbers_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


// @generated_from: regression_tests.EnumWithK
enum class EnumWithK : int32_t {
  
// @generated_from: regression_tests.EnumWithK.K
  K = 0,
  kMinValue = 0,
  kMaxValue = 0,
};

 std::ostream& operator<<(std::ostream& os, EnumWithK value);
inline bool IsKnownEnumValue(EnumWithK value) {
  return internal::EnumWithK_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class CheckMethodWithEmptyResponseInterfaceBase {};

using CheckMethodWithEmptyResponsePtrDataView =
    mojo::InterfacePtrDataView<CheckMethodWithEmptyResponseInterfaceBase>;
using CheckMethodWithEmptyResponseRequestDataView =
    mojo::InterfaceRequestDataView<CheckMethodWithEmptyResponseInterfaceBase>;
using CheckMethodWithEmptyResponseAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<CheckMethodWithEmptyResponseInterfaceBase>;
using CheckMethodWithEmptyResponseAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<CheckMethodWithEmptyResponseInterfaceBase>;
class CheckNameCollisionInterfaceBase {};

using CheckNameCollisionPtrDataView =
    mojo::InterfacePtrDataView<CheckNameCollisionInterfaceBase>;
using CheckNameCollisionRequestDataView =
    mojo::InterfaceRequestDataView<CheckNameCollisionInterfaceBase>;
using CheckNameCollisionAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<CheckNameCollisionInterfaceBase>;
using CheckNameCollisionAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<CheckNameCollisionInterfaceBase>;
class HandlesNameCollisionInterfaceInterfaceBase {};

using HandlesNameCollisionInterfacePtrDataView =
    mojo::InterfacePtrDataView<HandlesNameCollisionInterfaceInterfaceBase>;
using HandlesNameCollisionInterfaceRequestDataView =
    mojo::InterfaceRequestDataView<HandlesNameCollisionInterfaceInterfaceBase>;
using HandlesNameCollisionInterfaceAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<HandlesNameCollisionInterfaceInterfaceBase>;
using HandlesNameCollisionInterfaceAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<HandlesNameCollisionInterfaceInterfaceBase>;


class EdgeDataView {
 public:
  EdgeDataView() {}

  EdgeDataView(
      internal::Edge_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetVDataView(
      VertexDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadV(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::regression_tests::VertexDataView, UserType>(),
    "Attempting to read the optional `v` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadV` instead "
    "of `ReadV if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->v.Get();
    return mojo::internal::Deserialize<::regression_tests::VertexDataView>(
        pointer, output, message_);
  }
 private:
  internal::Edge_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VertexDataView {
 public:
  VertexDataView() {}

  VertexDataView(
      internal::Vertex_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetEDataView(
      EmptyStructDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadE(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::regression_tests::EmptyStructDataView, UserType>(),
    "Attempting to read the optional `e` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadE` instead "
    "of `ReadE if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->e.Get();
    return mojo::internal::Deserialize<::regression_tests::EmptyStructDataView>(
        pointer, output, message_);
  }
 private:
  internal::Vertex_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class EmptyStructDataView {
 public:
  EmptyStructDataView() {}

  EmptyStructDataView(
      internal::EmptyStruct_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
 private:
  internal::EmptyStruct_Data* data_ = nullptr;
};



class ADataView {
 public:
  ADataView() {}

  ADataView(
      internal::A_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetBDataView(
      BDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadB(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::regression_tests::BDataView, UserType>(),
    "Attempting to read the optional `b` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadB` instead "
    "of `ReadB if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->b.Get();
    return mojo::internal::Deserialize<::regression_tests::BDataView>(
        pointer, output, message_);
  }
 private:
  internal::A_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BDataView {
 public:
  BDataView() {}

  BDataView(
      internal::B_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetADataView(
      ADataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadA(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::regression_tests::ADataView, UserType>(),
    "Attempting to read the optional `a` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadA` instead "
    "of `ReadA if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->a.Get();
    return mojo::internal::Deserialize<::regression_tests::ADataView>(
        pointer, output, message_);
  }
 private:
  internal::B_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HandlesNameCollisionStructDataView {
 public:
  HandlesNameCollisionStructDataView() {}

  HandlesNameCollisionStructDataView(
      internal::HandlesNameCollisionStruct_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetHandlesDataView(
      EmptyStructDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadHandles(UserType* output) {
    
    auto* pointer = data_->handles.Get();
    return mojo::internal::Deserialize<::regression_tests::EmptyStructDataView>(
        pointer, output, message_);
  }
 private:
  internal::HandlesNameCollisionStruct_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HandlesHandleNameCollisionStructDataView {
 public:
  HandlesHandleNameCollisionStructDataView() {}

  HandlesHandleNameCollisionStructDataView(
      internal::HandlesHandleNameCollisionStruct_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  mojo::ScopedHandle TakeHandles() {
    mojo::ScopedHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedHandle>(
            &data_->handles, &result, message_);
    DCHECK(ret);
    return result;
  }
 private:
  internal::HandlesHandleNameCollisionStruct_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HandlesUnionNameCollisionStructDataView {
 public:
  HandlesUnionNameCollisionStructDataView() {}

  HandlesUnionNameCollisionStructDataView(
      internal::HandlesUnionNameCollisionStruct_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetHandlesDataView(
      HandlesNameCollisionUnionDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadHandles(UserType* output) {
    
    auto* pointer = !data_->handles.is_null() ? &data_->handles : nullptr;
    return mojo::internal::Deserialize<::regression_tests::HandlesNameCollisionUnionDataView>(
        pointer, output, message_);
  }
 private:
  internal::HandlesUnionNameCollisionStruct_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HandlesNameCollisionUnionDataView {
 public:
  using Tag = internal::HandlesNameCollisionUnion_Data::HandlesNameCollisionUnion_Tag;

  HandlesNameCollisionUnionDataView() {}

  HandlesNameCollisionUnionDataView(
      internal::HandlesNameCollisionUnion_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_handles() const { return data_->tag == Tag::HANDLES; }
  int32_t handles() const {
    DCHECK(is_handles());
    return data_->data.f_handles;
  }

 private:
  internal::HandlesNameCollisionUnion_Data* data_ = nullptr;
};



}  // namespace regression_tests

namespace std {

template <>
struct hash<::regression_tests::EnumWithReference>
    : public mojo::internal::EnumHashImpl<::regression_tests::EnumWithReference> {};

template <>
struct hash<::regression_tests::EnumWithLowercase>
    : public mojo::internal::EnumHashImpl<::regression_tests::EnumWithLowercase> {};

template <>
struct hash<::regression_tests::EnumWithNumbers>
    : public mojo::internal::EnumHashImpl<::regression_tests::EnumWithNumbers> {};

template <>
struct hash<::regression_tests::EnumWithK>
    : public mojo::internal::EnumHashImpl<::regression_tests::EnumWithK> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::EnumWithReference, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::regression_tests::EnumWithReference, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::regression_tests::EnumWithReference>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::EnumWithLowercase, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::regression_tests::EnumWithLowercase, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::regression_tests::EnumWithLowercase>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::EnumWithNumbers, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::regression_tests::EnumWithNumbers, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::regression_tests::EnumWithNumbers>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::EnumWithK, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::regression_tests::EnumWithK, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::regression_tests::EnumWithK>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::EdgeDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::regression_tests::EdgeDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::regression_tests::internal::Edge_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::v(input)) in_v = Traits::v(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->v)::BaseType> v_fragment(
            fragment.message());
    mojo::internal::Serialize<::regression_tests::VertexDataView>(
        in_v, v_fragment);
    fragment->v.Set(
        v_fragment.is_null() ? nullptr : v_fragment.data());
  }

  static bool Deserialize(::regression_tests::internal::Edge_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::EdgeDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::VertexDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::regression_tests::VertexDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::regression_tests::internal::Vertex_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::e(input)) in_e = Traits::e(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->e)::BaseType> e_fragment(
            fragment.message());
    mojo::internal::Serialize<::regression_tests::EmptyStructDataView>(
        in_e, e_fragment);
    fragment->e.Set(
        e_fragment.is_null() ? nullptr : e_fragment.data());
  }

  static bool Deserialize(::regression_tests::internal::Vertex_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::VertexDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::EmptyStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::regression_tests::EmptyStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::regression_tests::internal::EmptyStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
  }

  static bool Deserialize(::regression_tests::internal::EmptyStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::EmptyStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::ADataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::regression_tests::ADataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::regression_tests::internal::A_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::b(input)) in_b = Traits::b(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->b)::BaseType> b_fragment(
            fragment.message());
    mojo::internal::Serialize<::regression_tests::BDataView>(
        in_b, b_fragment);
    fragment->b.Set(
        b_fragment.is_null() ? nullptr : b_fragment.data());
  }

  static bool Deserialize(::regression_tests::internal::A_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::ADataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::BDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::regression_tests::BDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::regression_tests::internal::B_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::a(input)) in_a = Traits::a(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->a)::BaseType> a_fragment(
            fragment.message());
    mojo::internal::Serialize<::regression_tests::ADataView>(
        in_a, a_fragment);
    fragment->a.Set(
        a_fragment.is_null() ? nullptr : a_fragment.data());
  }

  static bool Deserialize(::regression_tests::internal::B_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::BDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::HandlesNameCollisionStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::regression_tests::HandlesNameCollisionStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::regression_tests::internal::HandlesNameCollisionStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::handles(input)) in_handles = Traits::handles(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->handles)::BaseType> handles_fragment(
            fragment.message());
    mojo::internal::Serialize<::regression_tests::EmptyStructDataView>(
        in_handles, handles_fragment);
    fragment->handles.Set(
        handles_fragment.is_null() ? nullptr : handles_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->handles.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null handles in HandlesNameCollisionStruct struct");
  }

  static bool Deserialize(::regression_tests::internal::HandlesNameCollisionStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::HandlesNameCollisionStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::HandlesHandleNameCollisionStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::regression_tests::HandlesHandleNameCollisionStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::regression_tests::internal::HandlesHandleNameCollisionStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::handles(input)) in_handles = Traits::handles(input);
    mojo::internal::Serialize<mojo::ScopedHandle>(
        in_handles, &fragment->handles, &fragment.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        !mojo::internal::IsHandleOrInterfaceValid(fragment->handles),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
        "invalid handles in HandlesHandleNameCollisionStruct struct");
  }

  static bool Deserialize(::regression_tests::internal::HandlesHandleNameCollisionStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::HandlesHandleNameCollisionStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::HandlesUnionNameCollisionStructDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::regression_tests::HandlesUnionNameCollisionStructDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::regression_tests::internal::HandlesUnionNameCollisionStruct_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::handles(input)) in_handles = Traits::handles(input);
    mojo::internal::MessageFragment<decltype(fragment->handles)>
        handles_fragment(fragment.message());
    handles_fragment.Claim(&fragment->handles);
    mojo::internal::Serialize<::regression_tests::HandlesNameCollisionUnionDataView>(
        in_handles, handles_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->handles.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null handles in HandlesUnionNameCollisionStruct struct");
  }

  static bool Deserialize(::regression_tests::internal::HandlesUnionNameCollisionStruct_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::HandlesUnionNameCollisionStructDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::regression_tests::HandlesNameCollisionUnionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::regression_tests::HandlesNameCollisionUnionDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::regression_tests::internal::HandlesNameCollisionUnion_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::regression_tests::HandlesNameCollisionUnionDataView::Tag::HANDLES: {
        decltype(Traits::handles(input))
            in_handles = Traits::handles(input);
        fragment->data.f_handles = in_handles;
        break;
      }
    }
  }

  static bool Deserialize(::regression_tests::internal::HandlesNameCollisionUnion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::regression_tests::HandlesNameCollisionUnionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace regression_tests {

inline void EdgeDataView::GetVDataView(
    VertexDataView* output) {
  auto pointer = data_->v.Get();
  *output = VertexDataView(pointer, message_);
}


inline void VertexDataView::GetEDataView(
    EmptyStructDataView* output) {
  auto pointer = data_->e.Get();
  *output = EmptyStructDataView(pointer, message_);
}




inline void ADataView::GetBDataView(
    BDataView* output) {
  auto pointer = data_->b.Get();
  *output = BDataView(pointer, message_);
}


inline void BDataView::GetADataView(
    ADataView* output) {
  auto pointer = data_->a.Get();
  *output = ADataView(pointer, message_);
}


inline void HandlesNameCollisionStructDataView::GetHandlesDataView(
    EmptyStructDataView* output) {
  auto pointer = data_->handles.Get();
  *output = EmptyStructDataView(pointer, message_);
}




inline void HandlesUnionNameCollisionStructDataView::GetHandlesDataView(
    HandlesNameCollisionUnionDataView* output) {
  auto pointer = &data_->handles;
  *output = HandlesNameCollisionUnionDataView(pointer, message_);
}




}  // namespace regression_tests

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::regression_tests::EnumWithReference> {
 static void WriteIntoTracedValue(perfetto::TracedValue context, ::regression_tests::EnumWithReference value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::regression_tests::EnumWithLowercase> {
 static void WriteIntoTracedValue(perfetto::TracedValue context, ::regression_tests::EnumWithLowercase value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::regression_tests::EnumWithNumbers> {
 static void WriteIntoTracedValue(perfetto::TracedValue context, ::regression_tests::EnumWithNumbers value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::regression_tests::EnumWithK> {
 static void WriteIntoTracedValue(perfetto::TracedValue context, ::regression_tests::EnumWithK value);
};

} // namespace perfetto

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_REGRESSION_TESTS_MOJOM_SHARED_H_

/* Metadata comment
eyJtZXRhIjogW3siZW5kIjogNDM1MiwgImJlZ2luIjogNDMzNSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogInJlZ3Jlc3Npb25fdGVzdHMuRW51bVdpdGhSZWZlcmVu
Y2UifX0sIHsiZW5kIjogNDQ3NiwgImJlZ2luIjogNDQ1MSwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogInJlZ3Jlc3Npb25fdGVzdHMuRW51bVdpdGhSZWZlcmVuY2Uu
a19TVEVSRU9fQU5EX0tFWUJPQVJEX01JQyJ9fSwgeyJlbmQiOiA0NTU0LCAiYmVnaW4iOiA0NTQ5
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAicmVncmVzc2lvbl90
ZXN0cy5FbnVtV2l0aFJlZmVyZW5jZS5rX01BWCJ9fSwgeyJlbmQiOiA0OTA3LCAiYmVnaW4iOiA0
ODkwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAicmVncmVzc2lv
bl90ZXN0cy5FbnVtV2l0aExvd2VyY2FzZSJ9fSwgeyJlbmQiOiA0OTk5LCAiYmVnaW4iOiA0OTkw
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAicmVncmVzc2lvbl90
ZXN0cy5FbnVtV2l0aExvd2VyY2FzZS5QbGFuYXJGMTYifX0sIHsiZW5kIjogNTA4NCwgImJlZ2lu
IjogNTA3NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogInJlZ3Jl
c3Npb25fdGVzdHMuRW51bVdpdGhMb3dlcmNhc2UuUGxhbmFyRjMyIn19LCB7ImVuZCI6IDU0MzAs
ICJiZWdpbiI6IDU0MTUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJyZWdyZXNzaW9uX3Rlc3RzLkVudW1XaXRoTnVtYmVycyJ9fSwgeyJlbmQiOiA1NTEyLCAiYmVn
aW4iOiA1NTA3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAicmVn
cmVzc2lvbl90ZXN0cy5FbnVtV2l0aE51bWJlcnMua18yXzEifX0sIHsiZW5kIjogNTg0MCwgImJl
Z2luIjogNTgzMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogInJl
Z3Jlc3Npb25fdGVzdHMuRW51bVdpdGhLIn19LCB7ImVuZCI6IDU5MDgsICJiZWdpbiI6IDU5MDcs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJyZWdyZXNzaW9uX3Rl
c3RzLkVudW1XaXRoSy5LIn19XSwgInR5cGUiOiAia3l0aGUwIn0=
*/