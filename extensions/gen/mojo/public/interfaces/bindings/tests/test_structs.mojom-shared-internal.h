// mojo/public/interfaces/bindings/tests/test_structs.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_SHARED_INTERNAL_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_SHARED_INTERNAL_H_

#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "mojo/public/interfaces/bindings/tests/rect.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"

#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif

namespace mojo {
namespace internal {
class ValidationContext;
}
}
namespace mojo {
namespace test {
namespace internal {
class NamedRegion_Data;
class RectPair_Data;
class EmptyStruct_Data;
using UnmappedNativeStruct_Data = mojo::native::internal::NativeStruct_Data;
class NoDefaultFieldValues_Data;
class DefaultFieldValues_Data;
class ScopedConstants_Data;
class MapKeyTypes_Data;
class MapValueTypes_Data;
class ArrayValueTypes_Data;
class FloatNumberValues_Data;
class IntegerNumberValues_Data;
class UnsignedNumberValues_Data;
class BitArrayValues_Data;
class MultiVersionStruct_Data;
class MultiVersionStructV0_Data;
class MultiVersionStructV1_Data;
class MultiVersionStructV3_Data;
class MultiVersionStructV5_Data;
class MultiVersionStructV7_Data;
class ReorderedStruct_Data;
class ContainsInterface_Data;
class ContainsOther_Data;
class ContainsInterfaceRequest_Data;
class SingleBoolStruct_Data;
class ContainsHashable_Data;
class SimpleNestedStruct_Data;
class EnumNestedStruct_Data;

struct ScopedConstants_EType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 10:
      case 11:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct EnumNestedStruct_StructEnum_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

#pragma pack(push, 1)
class  NamedRegion_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> name;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<::mojo::test::internal::Rect_Data>>> rects;

 private:
  friend class mojo::internal::MessageFragment<NamedRegion_Data>;

  NamedRegion_Data();
  ~NamedRegion_Data() = delete;
};
static_assert(sizeof(NamedRegion_Data) == 24,
              "Bad sizeof(NamedRegion_Data)");
// Used by NamedRegion::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct NamedRegion_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  NamedRegion_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~NamedRegion_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<NamedRegion_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    NamedRegion_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  RectPair_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> first;
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> second;

 private:
  friend class mojo::internal::MessageFragment<RectPair_Data>;

  RectPair_Data();
  ~RectPair_Data() = delete;
};
static_assert(sizeof(RectPair_Data) == 24,
              "Bad sizeof(RectPair_Data)");
// Used by RectPair::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct RectPair_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  RectPair_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~RectPair_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<RectPair_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    RectPair_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  EmptyStruct_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;

 private:
  friend class mojo::internal::MessageFragment<EmptyStruct_Data>;

  EmptyStruct_Data();
  ~EmptyStruct_Data() = delete;
};
static_assert(sizeof(EmptyStruct_Data) == 8,
              "Bad sizeof(EmptyStruct_Data)");
// Used by EmptyStruct::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct EmptyStruct_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  EmptyStruct_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~EmptyStruct_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<EmptyStruct_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    EmptyStruct_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  NoDefaultFieldValues_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  uint8_t f0 : 1;
  int8_t f1;
  uint8_t f2;
  uint8_t pad2_[1];
  int16_t f3;
  uint16_t f4;
  int32_t f5;
  uint32_t f6;
  int64_t f7;
  uint64_t f8;
  float f9;
  mojo::internal::Handle_Data f13;
  double f10;
  mojo::internal::Pointer<mojo::internal::String_Data> f11;
  mojo::internal::Pointer<mojo::internal::String_Data> f12;
  mojo::internal::Handle_Data f14;
  mojo::internal::Handle_Data f15;
  mojo::internal::Handle_Data f16;
  mojo::internal::Handle_Data f17;
  mojo::internal::Handle_Data f18;
  mojo::internal::Handle_Data f19;
  mojo::internal::Handle_Data f20;
  mojo::internal::Handle_Data f21;
  mojo::internal::Handle_Data f22;
  mojo::internal::Handle_Data f29;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>> f23;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>> f24;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>> f25;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>> f26;
  mojo::internal::Pointer<internal::EmptyStruct_Data> f27;
  mojo::internal::Pointer<internal::EmptyStruct_Data> f28;
  mojo::internal::Handle_Data f30;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<NoDefaultFieldValues_Data>;

  NoDefaultFieldValues_Data();
  ~NoDefaultFieldValues_Data() = delete;
};
static_assert(sizeof(NoDefaultFieldValues_Data) == 168,
              "Bad sizeof(NoDefaultFieldValues_Data)");
// Used by NoDefaultFieldValues::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct NoDefaultFieldValues_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  NoDefaultFieldValues_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~NoDefaultFieldValues_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<NoDefaultFieldValues_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    NoDefaultFieldValues_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  DefaultFieldValues_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  uint8_t f0 : 1;
  int8_t f1;
  uint8_t f2;
  uint8_t pad2_[1];
  int16_t f3;
  uint16_t f4;
  int32_t f5;
  uint32_t f6;
  int64_t f7;
  uint64_t f8;
  float f9;
  float f10;
  double f11;
  double f12;
  mojo::internal::Pointer<mojo::internal::String_Data> f13;
  mojo::internal::Pointer<mojo::internal::String_Data> f14;
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> f15;
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> f16;

 private:
  friend class mojo::internal::MessageFragment<DefaultFieldValues_Data>;

  DefaultFieldValues_Data();
  ~DefaultFieldValues_Data() = delete;
};
static_assert(sizeof(DefaultFieldValues_Data) == 96,
              "Bad sizeof(DefaultFieldValues_Data)");
// Used by DefaultFieldValues::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct DefaultFieldValues_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  DefaultFieldValues_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~DefaultFieldValues_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<DefaultFieldValues_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    DefaultFieldValues_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ScopedConstants_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t f0;
  int32_t f1;
  int32_t f2;
  int32_t f3;
  int32_t f4;
  int32_t f5;
  int32_t f6;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<ScopedConstants_Data>;

  ScopedConstants_Data();
  ~ScopedConstants_Data() = delete;
};
static_assert(sizeof(ScopedConstants_Data) == 40,
              "Bad sizeof(ScopedConstants_Data)");
// Used by ScopedConstants::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ScopedConstants_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ScopedConstants_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ScopedConstants_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ScopedConstants_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ScopedConstants_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  MapKeyTypes_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Map_Data<int8_t, int8_t>> f1;
  mojo::internal::Pointer<mojo::internal::Map_Data<uint8_t, uint8_t>> f2;
  mojo::internal::Pointer<mojo::internal::Map_Data<int16_t, int16_t>> f3;
  mojo::internal::Pointer<mojo::internal::Map_Data<uint16_t, uint16_t>> f4;
  mojo::internal::Pointer<mojo::internal::Map_Data<int32_t, int32_t>> f5;
  mojo::internal::Pointer<mojo::internal::Map_Data<uint32_t, uint32_t>> f6;
  mojo::internal::Pointer<mojo::internal::Map_Data<int64_t, int64_t>> f7;
  mojo::internal::Pointer<mojo::internal::Map_Data<uint64_t, uint64_t>> f8;
  mojo::internal::Pointer<mojo::internal::Map_Data<float, float>> f9;
  mojo::internal::Pointer<mojo::internal::Map_Data<double, double>> f10;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::String_Data>>> f11;

 private:
  friend class mojo::internal::MessageFragment<MapKeyTypes_Data>;

  MapKeyTypes_Data();
  ~MapKeyTypes_Data() = delete;
};
static_assert(sizeof(MapKeyTypes_Data) == 96,
              "Bad sizeof(MapKeyTypes_Data)");
// Used by MapKeyTypes::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MapKeyTypes_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MapKeyTypes_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MapKeyTypes_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MapKeyTypes_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MapKeyTypes_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  MapValueTypes_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>>>> f0;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>>>> f1;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>>>> f2;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>>>> f3;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>>>>>> f4;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>>>>>> f5;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<::mojo::test::internal::Rect_Data>>> f6;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::String_Data>>>>> f7;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::String_Data>>>>>>> f8;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Handle_Data>> f9;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Handle_Data>>>> f10;
  mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Handle_Data>>>> f11;

 private:
  friend class mojo::internal::MessageFragment<MapValueTypes_Data>;

  MapValueTypes_Data();
  ~MapValueTypes_Data() = delete;
};
static_assert(sizeof(MapValueTypes_Data) == 104,
              "Bad sizeof(MapValueTypes_Data)");
// Used by MapValueTypes::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MapValueTypes_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MapValueTypes_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MapValueTypes_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MapValueTypes_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MapValueTypes_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ArrayValueTypes_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<int8_t>> f0;
  mojo::internal::Pointer<mojo::internal::Array_Data<int16_t>> f1;
  mojo::internal::Pointer<mojo::internal::Array_Data<int32_t>> f2;
  mojo::internal::Pointer<mojo::internal::Array_Data<int64_t>> f3;
  mojo::internal::Pointer<mojo::internal::Array_Data<float>> f4;
  mojo::internal::Pointer<mojo::internal::Array_Data<double>> f5;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Interface_Data>> f6;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Handle_Data>> f7;

 private:
  friend class mojo::internal::MessageFragment<ArrayValueTypes_Data>;

  ArrayValueTypes_Data();
  ~ArrayValueTypes_Data() = delete;
};
static_assert(sizeof(ArrayValueTypes_Data) == 72,
              "Bad sizeof(ArrayValueTypes_Data)");
// Used by ArrayValueTypes::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ArrayValueTypes_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ArrayValueTypes_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ArrayValueTypes_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ArrayValueTypes_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ArrayValueTypes_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FloatNumberValues_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  double f0;
  double f1;
  double f2;
  float f3;
  float f4;
  float f5;
  float f6;
  double f7;
  double f8;
  double f9;

 private:
  friend class mojo::internal::MessageFragment<FloatNumberValues_Data>;

  FloatNumberValues_Data();
  ~FloatNumberValues_Data() = delete;
};
static_assert(sizeof(FloatNumberValues_Data) == 72,
              "Bad sizeof(FloatNumberValues_Data)");
// Used by FloatNumberValues::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FloatNumberValues_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FloatNumberValues_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FloatNumberValues_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FloatNumberValues_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FloatNumberValues_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  IntegerNumberValues_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int8_t f0;
  int8_t f1;
  int8_t f2;
  int8_t f3;
  int8_t f4;
  uint8_t pad4_[1];
  int16_t f5;
  int16_t f6;
  int16_t f7;
  int16_t f8;
  int16_t f9;
  int32_t f10;
  int32_t f11;
  int32_t f12;
  int32_t f13;
  int32_t f14;
  uint8_t pad14_[4];
  int64_t f15;
  int64_t f16;
  int64_t f17;
  int64_t f18;
  int64_t f19;

 private:
  friend class mojo::internal::MessageFragment<IntegerNumberValues_Data>;

  IntegerNumberValues_Data();
  ~IntegerNumberValues_Data() = delete;
};
static_assert(sizeof(IntegerNumberValues_Data) == 88,
              "Bad sizeof(IntegerNumberValues_Data)");
// Used by IntegerNumberValues::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct IntegerNumberValues_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  IntegerNumberValues_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~IntegerNumberValues_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<IntegerNumberValues_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    IntegerNumberValues_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  UnsignedNumberValues_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  uint8_t f0;
  uint8_t f1;
  uint8_t f2;
  uint8_t pad2_[1];
  uint16_t f3;
  uint16_t f4;
  uint16_t f5;
  uint8_t pad5_[2];
  uint32_t f6;
  uint32_t f7;
  uint32_t f8;
  uint64_t f9;
  uint64_t f10;
  uint64_t f11;

 private:
  friend class mojo::internal::MessageFragment<UnsignedNumberValues_Data>;

  UnsignedNumberValues_Data();
  ~UnsignedNumberValues_Data() = delete;
};
static_assert(sizeof(UnsignedNumberValues_Data) == 56,
              "Bad sizeof(UnsignedNumberValues_Data)");
// Used by UnsignedNumberValues::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct UnsignedNumberValues_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  UnsignedNumberValues_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~UnsignedNumberValues_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<UnsignedNumberValues_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    UnsignedNumberValues_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  BitArrayValues_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<bool>> f0;
  mojo::internal::Pointer<mojo::internal::Array_Data<bool>> f1;
  mojo::internal::Pointer<mojo::internal::Array_Data<bool>> f2;
  mojo::internal::Pointer<mojo::internal::Array_Data<bool>> f3;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::Array_Data<bool>>>> f4;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::Array_Data<bool>>>> f5;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::Array_Data<bool>>>> f6;

 private:
  friend class mojo::internal::MessageFragment<BitArrayValues_Data>;

  BitArrayValues_Data();
  ~BitArrayValues_Data() = delete;
};
static_assert(sizeof(BitArrayValues_Data) == 64,
              "Bad sizeof(BitArrayValues_Data)");
// Used by BitArrayValues::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct BitArrayValues_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  BitArrayValues_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~BitArrayValues_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<BitArrayValues_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    BitArrayValues_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  MultiVersionStruct_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t f_int32;
  mojo::internal::Handle_Data f_message_pipe;
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> f_rect;
  mojo::internal::Pointer<mojo::internal::String_Data> f_string;
  mojo::internal::Pointer<mojo::internal::Array_Data<int8_t>> f_array;
  uint8_t f_bool : 1;
  uint8_t pad5_[1];
  int16_t f_int16;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<MultiVersionStruct_Data>;

  MultiVersionStruct_Data();
  ~MultiVersionStruct_Data() = delete;
};
static_assert(sizeof(MultiVersionStruct_Data) == 48,
              "Bad sizeof(MultiVersionStruct_Data)");
// Used by MultiVersionStruct::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MultiVersionStruct_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MultiVersionStruct_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MultiVersionStruct_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MultiVersionStruct_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MultiVersionStruct_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  MultiVersionStructV0_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t f_int32;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<MultiVersionStructV0_Data>;

  MultiVersionStructV0_Data();
  ~MultiVersionStructV0_Data() = delete;
};
static_assert(sizeof(MultiVersionStructV0_Data) == 16,
              "Bad sizeof(MultiVersionStructV0_Data)");
// Used by MultiVersionStructV0::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MultiVersionStructV0_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MultiVersionStructV0_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MultiVersionStructV0_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MultiVersionStructV0_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MultiVersionStructV0_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  MultiVersionStructV1_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t f_int32;
  uint8_t pad0_[4];
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> f_rect;

 private:
  friend class mojo::internal::MessageFragment<MultiVersionStructV1_Data>;

  MultiVersionStructV1_Data();
  ~MultiVersionStructV1_Data() = delete;
};
static_assert(sizeof(MultiVersionStructV1_Data) == 24,
              "Bad sizeof(MultiVersionStructV1_Data)");
// Used by MultiVersionStructV1::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MultiVersionStructV1_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MultiVersionStructV1_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MultiVersionStructV1_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MultiVersionStructV1_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MultiVersionStructV1_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  MultiVersionStructV3_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t f_int32;
  uint8_t pad0_[4];
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> f_rect;
  mojo::internal::Pointer<mojo::internal::String_Data> f_string;

 private:
  friend class mojo::internal::MessageFragment<MultiVersionStructV3_Data>;

  MultiVersionStructV3_Data();
  ~MultiVersionStructV3_Data() = delete;
};
static_assert(sizeof(MultiVersionStructV3_Data) == 32,
              "Bad sizeof(MultiVersionStructV3_Data)");
// Used by MultiVersionStructV3::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MultiVersionStructV3_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MultiVersionStructV3_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MultiVersionStructV3_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MultiVersionStructV3_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MultiVersionStructV3_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  MultiVersionStructV5_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t f_int32;
  uint8_t pad0_[4];
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> f_rect;
  mojo::internal::Pointer<mojo::internal::String_Data> f_string;
  mojo::internal::Pointer<mojo::internal::Array_Data<int8_t>> f_array;

 private:
  friend class mojo::internal::MessageFragment<MultiVersionStructV5_Data>;

  MultiVersionStructV5_Data();
  ~MultiVersionStructV5_Data() = delete;
};
static_assert(sizeof(MultiVersionStructV5_Data) == 40,
              "Bad sizeof(MultiVersionStructV5_Data)");
// Used by MultiVersionStructV5::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MultiVersionStructV5_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MultiVersionStructV5_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MultiVersionStructV5_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MultiVersionStructV5_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MultiVersionStructV5_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  MultiVersionStructV7_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t f_int32;
  mojo::internal::Handle_Data f_message_pipe;
  mojo::internal::Pointer<::mojo::test::internal::Rect_Data> f_rect;
  mojo::internal::Pointer<mojo::internal::String_Data> f_string;
  mojo::internal::Pointer<mojo::internal::Array_Data<int8_t>> f_array;
  uint8_t f_bool : 1;
  uint8_t padfinal_[7];

 private:
  friend class mojo::internal::MessageFragment<MultiVersionStructV7_Data>;

  MultiVersionStructV7_Data();
  ~MultiVersionStructV7_Data() = delete;
};
static_assert(sizeof(MultiVersionStructV7_Data) == 48,
              "Bad sizeof(MultiVersionStructV7_Data)");
// Used by MultiVersionStructV7::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MultiVersionStructV7_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MultiVersionStructV7_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MultiVersionStructV7_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MultiVersionStructV7_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MultiVersionStructV7_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ReorderedStruct_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t c;
  int32_t a;
  int32_t b;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<ReorderedStruct_Data>;

  ReorderedStruct_Data();
  ~ReorderedStruct_Data() = delete;
};
static_assert(sizeof(ReorderedStruct_Data) == 24,
              "Bad sizeof(ReorderedStruct_Data)");
// Used by ReorderedStruct::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ReorderedStruct_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ReorderedStruct_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ReorderedStruct_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ReorderedStruct_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ReorderedStruct_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ContainsInterface_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Interface_Data some_interface;

 private:
  friend class mojo::internal::MessageFragment<ContainsInterface_Data>;

  ContainsInterface_Data();
  ~ContainsInterface_Data() = delete;
};
static_assert(sizeof(ContainsInterface_Data) == 16,
              "Bad sizeof(ContainsInterface_Data)");
// Used by ContainsInterface::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ContainsInterface_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ContainsInterface_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ContainsInterface_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ContainsInterface_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ContainsInterface_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ContainsOther_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t other;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<ContainsOther_Data>;

  ContainsOther_Data();
  ~ContainsOther_Data() = delete;
};
static_assert(sizeof(ContainsOther_Data) == 16,
              "Bad sizeof(ContainsOther_Data)");
// Used by ContainsOther::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ContainsOther_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ContainsOther_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ContainsOther_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ContainsOther_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ContainsOther_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ContainsInterfaceRequest_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Handle_Data request;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<ContainsInterfaceRequest_Data>;

  ContainsInterfaceRequest_Data();
  ~ContainsInterfaceRequest_Data() = delete;
};
static_assert(sizeof(ContainsInterfaceRequest_Data) == 16,
              "Bad sizeof(ContainsInterfaceRequest_Data)");
// Used by ContainsInterfaceRequest::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ContainsInterfaceRequest_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ContainsInterfaceRequest_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ContainsInterfaceRequest_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ContainsInterfaceRequest_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ContainsInterfaceRequest_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  SingleBoolStruct_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  uint8_t value : 1;
  uint8_t padfinal_[7];

 private:
  friend class mojo::internal::MessageFragment<SingleBoolStruct_Data>;

  SingleBoolStruct_Data();
  ~SingleBoolStruct_Data() = delete;
};
static_assert(sizeof(SingleBoolStruct_Data) == 16,
              "Bad sizeof(SingleBoolStruct_Data)");
// Used by SingleBoolStruct::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SingleBoolStruct_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SingleBoolStruct_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SingleBoolStruct_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SingleBoolStruct_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SingleBoolStruct_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ContainsHashable_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo::test::internal::TypemappedRect_Data> rect;

 private:
  friend class mojo::internal::MessageFragment<ContainsHashable_Data>;

  ContainsHashable_Data();
  ~ContainsHashable_Data() = delete;
};
static_assert(sizeof(ContainsHashable_Data) == 16,
              "Bad sizeof(ContainsHashable_Data)");
// Used by ContainsHashable::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ContainsHashable_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ContainsHashable_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ContainsHashable_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ContainsHashable_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ContainsHashable_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  SimpleNestedStruct_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::ContainsOther_Data> nested;

 private:
  friend class mojo::internal::MessageFragment<SimpleNestedStruct_Data>;

  SimpleNestedStruct_Data();
  ~SimpleNestedStruct_Data() = delete;
};
static_assert(sizeof(SimpleNestedStruct_Data) == 16,
              "Bad sizeof(SimpleNestedStruct_Data)");
// Used by SimpleNestedStruct::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SimpleNestedStruct_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SimpleNestedStruct_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SimpleNestedStruct_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SimpleNestedStruct_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SimpleNestedStruct_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  EnumNestedStruct_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t local_enum_state_;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<EnumNestedStruct_Data>;

  EnumNestedStruct_Data();
  ~EnumNestedStruct_Data() = delete;
};
static_assert(sizeof(EnumNestedStruct_Data) == 16,
              "Bad sizeof(EnumNestedStruct_Data)");
// Used by EnumNestedStruct::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct EnumNestedStruct_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  EnumNestedStruct_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~EnumNestedStruct_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<EnumNestedStruct_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    EnumNestedStruct_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

}  // namespace internal
}  // namespace test
}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_SHARED_INTERNAL_H_

/* Metadata comment
eyJtZXRhIjogW10sICJ0eXBlIjogImt5dGhlMCJ9
*/