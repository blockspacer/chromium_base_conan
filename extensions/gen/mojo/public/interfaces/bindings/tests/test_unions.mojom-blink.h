// mojo/public/interfaces/bindings/tests/test_unions.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_BLINK_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
#include "mojo/public/interfaces/bindings/tests/test_unions.mojom-shared.h"
#include "mojo/public/interfaces/bindings/tests/test_unions.mojom-blink-forward.h"
#include "mojo/public/interfaces/bindings/tests/sample_import.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"



#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif


namespace WTF {
struct mojo_test_internal_AnEnum_DataHashFn {
  static unsigned GetHash(const ::mojo::test::AnEnum& value) {
    using utype = std::underlying_type<::mojo::test::AnEnum>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::mojo::test::AnEnum& left, const ::mojo::test::AnEnum& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::mojo::test::AnEnum>
    : public GenericHashTraits<::mojo::test::AnEnum> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool hasIsEmptyValueFunction = true;
  static bool IsEmptyValue(const ::mojo::test::AnEnum& value) {
    return value == static_cast<::mojo::test::AnEnum>(-1000000);
  }
  static void ConstructDeletedValue(::mojo::test::AnEnum& slot, bool) {
    slot = static_cast<::mojo::test::AnEnum>(-1000001);
  }
  static bool IsDeletedValue(const ::mojo::test::AnEnum& value) {
    return value == static_cast<::mojo::test::AnEnum>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct mojo_test_internal_AnExtensibleEnum_DataHashFn {
  static unsigned GetHash(const ::mojo::test::AnExtensibleEnum& value) {
    using utype = std::underlying_type<::mojo::test::AnExtensibleEnum>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::mojo::test::AnExtensibleEnum& left, const ::mojo::test::AnExtensibleEnum& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::mojo::test::AnExtensibleEnum>
    : public GenericHashTraits<::mojo::test::AnExtensibleEnum> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool hasIsEmptyValueFunction = true;
  static bool IsEmptyValue(const ::mojo::test::AnExtensibleEnum& value) {
    return value == static_cast<::mojo::test::AnExtensibleEnum>(-1000000);
  }
  static void ConstructDeletedValue(::mojo::test::AnExtensibleEnum& slot, bool) {
    slot = static_cast<::mojo::test::AnExtensibleEnum>(-1000001);
  }
  static bool IsDeletedValue(const ::mojo::test::AnExtensibleEnum& value) {
    return value == static_cast<::mojo::test::AnExtensibleEnum>(-1000001);
  }
};
}  // namespace WTF


namespace mojo {
namespace test {
namespace blink {

class SmallCacheProxy;

template <typename ImplRefTraits>
class SmallCacheStub;

class SmallCacheRequestValidator;
class SmallCacheResponseValidator;


// @generated_from: mojo.test.SmallCache
class  SmallCache
    : public SmallCacheInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = SmallCacheInterfaceBase;
  using Proxy_ = SmallCacheProxy;

  template <typename ImplRefTraits>
  using Stub_ = SmallCacheStub<ImplRefTraits>;

  using RequestValidator_ = SmallCacheRequestValidator;
  using ResponseValidator_ = SmallCacheResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSetIntValueMinVersion = 0,
    kGetIntValueMinVersion = 0,
  };
  virtual ~SmallCache() {}

  
// @generated_from: mojo.test.SmallCache.SetIntValue
  virtual void SetIntValue(int64_t int_value) = 0;


  using GetIntValueCallback = base::OnceCallback<void(int64_t)>;
  
// @generated_from: mojo.test.SmallCache.GetIntValue
  virtual void GetIntValue(GetIntValueCallback callback) = 0;
};

class UnionInterfaceProxy;

template <typename ImplRefTraits>
class UnionInterfaceStub;

class UnionInterfaceRequestValidator;
class UnionInterfaceResponseValidator;


// @generated_from: mojo.test.UnionInterface
class  UnionInterface
    : public UnionInterfaceInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = UnionInterfaceInterfaceBase;
  using Proxy_ = UnionInterfaceProxy;

  template <typename ImplRefTraits>
  using Stub_ = UnionInterfaceStub<ImplRefTraits>;

  using RequestValidator_ = UnionInterfaceRequestValidator;
  using ResponseValidator_ = UnionInterfaceResponseValidator;
  enum MethodMinVersions : uint32_t {
    kEchoMinVersion = 0,
  };
  virtual ~UnionInterface() {}


  using EchoCallback = base::OnceCallback<void(PodUnionPtr)>;
  
// @generated_from: mojo.test.UnionInterface.Echo
  virtual void Echo(PodUnionPtr in_val, EchoCallback callback) = 0;
};



// @generated_from: mojo.test.SmallCache
class  SmallCacheProxy
    : public SmallCache {
 public:
  using InterfaceType = SmallCache;

  explicit SmallCacheProxy(mojo::MessageReceiverWithResponder* receiver);
  
// @generated_from: mojo.test.SmallCache.SetIntValue
  void SetIntValue(int64_t int_value) final;
  
// @generated_from: mojo.test.SmallCache.GetIntValue
  void GetIntValue(GetIntValueCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



// @generated_from: mojo.test.UnionInterface
class  UnionInterfaceProxy
    : public UnionInterface {
 public:
  using InterfaceType = UnionInterface;

  explicit UnionInterfaceProxy(mojo::MessageReceiverWithResponder* receiver);
  
// @generated_from: mojo.test.UnionInterface.Echo
  void Echo(PodUnionPtr in_val, EchoCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  SmallCacheStubDispatch {
 public:
  static bool Accept(SmallCache* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SmallCache* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SmallCache>>
class SmallCacheStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SmallCacheStub() {}
  ~SmallCacheStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SmallCacheStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SmallCacheStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  UnionInterfaceStubDispatch {
 public:
  static bool Accept(UnionInterface* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      UnionInterface* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<UnionInterface>>
class UnionInterfaceStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  UnionInterfaceStub() {}
  ~UnionInterfaceStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return UnionInterfaceStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return UnionInterfaceStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  SmallCacheRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  UnionInterfaceRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  SmallCacheResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  UnionInterfaceResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};






// @generated_from: mojo.test.DummyStruct
class  DummyStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DummyStruct, T>::value>;
  using DataView = DummyStructDataView;
  using Data_ = internal::DummyStruct_Data;

  template <typename... Args>
  static DummyStructPtr New(Args&&... args) {
    return DummyStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DummyStructPtr From(const U& u) {
    return mojo::TypeConverter<DummyStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DummyStruct>::Convert(*this);
  }


  DummyStruct();

  explicit DummyStruct(
      int8_t f_int8);

  ~DummyStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DummyStructPtr>
  DummyStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DummyStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DummyStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DummyStruct_UnserializedMessageContext<
            UserType, DummyStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DummyStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return DummyStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DummyStruct_UnserializedMessageContext<
            UserType, DummyStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DummyStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.DummyStruct.f_int8
  int8_t f_int8;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DummyStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}










// @generated_from: mojo.test.PodUnion
class  PodUnion {
 public:
  using DataView = PodUnionDataView;
  using Data_ = internal::PodUnion_Data;
  using Tag = Data_::PodUnion_Tag;

  static PodUnionPtr New() {
    return PodUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_int8|.
  static PodUnionPtr
  NewFInt8(
      int8_t f_int8) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int8(std::move(f_int8));
    return result;
  }
  // Construct an instance holding |f_int8_other|.
  static PodUnionPtr
  NewFInt8Other(
      int8_t f_int8_other) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int8_other(std::move(f_int8_other));
    return result;
  }
  // Construct an instance holding |f_uint8|.
  static PodUnionPtr
  NewFUint8(
      uint8_t f_uint8) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_uint8(std::move(f_uint8));
    return result;
  }
  // Construct an instance holding |f_int16|.
  static PodUnionPtr
  NewFInt16(
      int16_t f_int16) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int16(std::move(f_int16));
    return result;
  }
  // Construct an instance holding |f_uint16|.
  static PodUnionPtr
  NewFUint16(
      uint16_t f_uint16) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_uint16(std::move(f_uint16));
    return result;
  }
  // Construct an instance holding |f_int32|.
  static PodUnionPtr
  NewFInt32(
      int32_t f_int32) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int32(std::move(f_int32));
    return result;
  }
  // Construct an instance holding |f_uint32|.
  static PodUnionPtr
  NewFUint32(
      uint32_t f_uint32) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_uint32(std::move(f_uint32));
    return result;
  }
  // Construct an instance holding |f_int64|.
  static PodUnionPtr
  NewFInt64(
      int64_t f_int64) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_int64(std::move(f_int64));
    return result;
  }
  // Construct an instance holding |f_uint64|.
  static PodUnionPtr
  NewFUint64(
      uint64_t f_uint64) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_uint64(std::move(f_uint64));
    return result;
  }
  // Construct an instance holding |f_float|.
  static PodUnionPtr
  NewFFloat(
      float f_float) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_float(std::move(f_float));
    return result;
  }
  // Construct an instance holding |f_double|.
  static PodUnionPtr
  NewFDouble(
      double f_double) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_double(std::move(f_double));
    return result;
  }
  // Construct an instance holding |f_bool|.
  static PodUnionPtr
  NewFBool(
      bool f_bool) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_bool(std::move(f_bool));
    return result;
  }
  // Construct an instance holding |f_enum|.
  static PodUnionPtr
  NewFEnum(
      AnEnum f_enum) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_enum(std::move(f_enum));
    return result;
  }
  // Construct an instance holding |f_extensible_enum|.
  static PodUnionPtr
  NewFExtensibleEnum(
      AnExtensibleEnum f_extensible_enum) {
    auto result = PodUnionPtr(base::in_place);
    result->set_f_extensible_enum(std::move(f_extensible_enum));
    return result;
  }

  template <typename U>
  static PodUnionPtr From(const U& u) {
    return mojo::TypeConverter<PodUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PodUnion>::Convert(*this);
  }

  PodUnion();
  ~PodUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = PodUnionPtr>
  PodUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, PodUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, PodUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.PodUnion.f_int8
  bool is_f_int8() const { return tag_ == Tag::F_INT8; }

  
// @generated_from: mojo.test.PodUnion.f_int8
  int8_t get_f_int8() const {
    DCHECK(tag_ == Tag::F_INT8);
    return data_.f_int8;
  }

  
// @generated_from: mojo.test.PodUnion.f_int8
  void set_f_int8(
      int8_t f_int8);
  
// @generated_from: mojo.test.PodUnion.f_int8_other
  bool is_f_int8_other() const { return tag_ == Tag::F_INT8_OTHER; }

  
// @generated_from: mojo.test.PodUnion.f_int8_other
  int8_t get_f_int8_other() const {
    DCHECK(tag_ == Tag::F_INT8_OTHER);
    return data_.f_int8_other;
  }

  
// @generated_from: mojo.test.PodUnion.f_int8_other
  void set_f_int8_other(
      int8_t f_int8_other);
  
// @generated_from: mojo.test.PodUnion.f_uint8
  bool is_f_uint8() const { return tag_ == Tag::F_UINT8; }

  
// @generated_from: mojo.test.PodUnion.f_uint8
  uint8_t get_f_uint8() const {
    DCHECK(tag_ == Tag::F_UINT8);
    return data_.f_uint8;
  }

  
// @generated_from: mojo.test.PodUnion.f_uint8
  void set_f_uint8(
      uint8_t f_uint8);
  
// @generated_from: mojo.test.PodUnion.f_int16
  bool is_f_int16() const { return tag_ == Tag::F_INT16; }

  
// @generated_from: mojo.test.PodUnion.f_int16
  int16_t get_f_int16() const {
    DCHECK(tag_ == Tag::F_INT16);
    return data_.f_int16;
  }

  
// @generated_from: mojo.test.PodUnion.f_int16
  void set_f_int16(
      int16_t f_int16);
  
// @generated_from: mojo.test.PodUnion.f_uint16
  bool is_f_uint16() const { return tag_ == Tag::F_UINT16; }

  
// @generated_from: mojo.test.PodUnion.f_uint16
  uint16_t get_f_uint16() const {
    DCHECK(tag_ == Tag::F_UINT16);
    return data_.f_uint16;
  }

  
// @generated_from: mojo.test.PodUnion.f_uint16
  void set_f_uint16(
      uint16_t f_uint16);
  
// @generated_from: mojo.test.PodUnion.f_int32
  bool is_f_int32() const { return tag_ == Tag::F_INT32; }

  
// @generated_from: mojo.test.PodUnion.f_int32
  int32_t get_f_int32() const {
    DCHECK(tag_ == Tag::F_INT32);
    return data_.f_int32;
  }

  
// @generated_from: mojo.test.PodUnion.f_int32
  void set_f_int32(
      int32_t f_int32);
  
// @generated_from: mojo.test.PodUnion.f_uint32
  bool is_f_uint32() const { return tag_ == Tag::F_UINT32; }

  
// @generated_from: mojo.test.PodUnion.f_uint32
  uint32_t get_f_uint32() const {
    DCHECK(tag_ == Tag::F_UINT32);
    return data_.f_uint32;
  }

  
// @generated_from: mojo.test.PodUnion.f_uint32
  void set_f_uint32(
      uint32_t f_uint32);
  
// @generated_from: mojo.test.PodUnion.f_int64
  bool is_f_int64() const { return tag_ == Tag::F_INT64; }

  
// @generated_from: mojo.test.PodUnion.f_int64
  int64_t get_f_int64() const {
    DCHECK(tag_ == Tag::F_INT64);
    return data_.f_int64;
  }

  
// @generated_from: mojo.test.PodUnion.f_int64
  void set_f_int64(
      int64_t f_int64);
  
// @generated_from: mojo.test.PodUnion.f_uint64
  bool is_f_uint64() const { return tag_ == Tag::F_UINT64; }

  
// @generated_from: mojo.test.PodUnion.f_uint64
  uint64_t get_f_uint64() const {
    DCHECK(tag_ == Tag::F_UINT64);
    return data_.f_uint64;
  }

  
// @generated_from: mojo.test.PodUnion.f_uint64
  void set_f_uint64(
      uint64_t f_uint64);
  
// @generated_from: mojo.test.PodUnion.f_float
  bool is_f_float() const { return tag_ == Tag::F_FLOAT; }

  
// @generated_from: mojo.test.PodUnion.f_float
  float get_f_float() const {
    DCHECK(tag_ == Tag::F_FLOAT);
    return data_.f_float;
  }

  
// @generated_from: mojo.test.PodUnion.f_float
  void set_f_float(
      float f_float);
  
// @generated_from: mojo.test.PodUnion.f_double
  bool is_f_double() const { return tag_ == Tag::F_DOUBLE; }

  
// @generated_from: mojo.test.PodUnion.f_double
  double get_f_double() const {
    DCHECK(tag_ == Tag::F_DOUBLE);
    return data_.f_double;
  }

  
// @generated_from: mojo.test.PodUnion.f_double
  void set_f_double(
      double f_double);
  
// @generated_from: mojo.test.PodUnion.f_bool
  bool is_f_bool() const { return tag_ == Tag::F_BOOL; }

  
// @generated_from: mojo.test.PodUnion.f_bool
  bool get_f_bool() const {
    DCHECK(tag_ == Tag::F_BOOL);
    return data_.f_bool;
  }

  
// @generated_from: mojo.test.PodUnion.f_bool
  void set_f_bool(
      bool f_bool);
  
// @generated_from: mojo.test.PodUnion.f_enum
  bool is_f_enum() const { return tag_ == Tag::F_ENUM; }

  
// @generated_from: mojo.test.PodUnion.f_enum
  AnEnum get_f_enum() const {
    DCHECK(tag_ == Tag::F_ENUM);
    return data_.f_enum;
  }

  
// @generated_from: mojo.test.PodUnion.f_enum
  void set_f_enum(
      AnEnum f_enum);
  
// @generated_from: mojo.test.PodUnion.f_extensible_enum
  bool is_f_extensible_enum() const { return tag_ == Tag::F_EXTENSIBLE_ENUM; }

  
// @generated_from: mojo.test.PodUnion.f_extensible_enum
  AnExtensibleEnum get_f_extensible_enum() const {
    DCHECK(tag_ == Tag::F_EXTENSIBLE_ENUM);
    return data_.f_extensible_enum;
  }

  
// @generated_from: mojo.test.PodUnion.f_extensible_enum
  void set_f_extensible_enum(
      AnExtensibleEnum f_extensible_enum);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PodUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<PodUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int8_t f_int8;
    int8_t f_int8_other;
    uint8_t f_uint8;
    int16_t f_int16;
    uint16_t f_uint16;
    int32_t f_int32;
    uint32_t f_uint32;
    int64_t f_int64;
    uint64_t f_uint64;
    float f_float;
    double f_double;
    bool f_bool;
    AnEnum f_enum;
    AnExtensibleEnum f_extensible_enum;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.ObjectUnion
class  ObjectUnion {
 public:
  using DataView = ObjectUnionDataView;
  using Data_ = internal::ObjectUnion_Data;
  using Tag = Data_::ObjectUnion_Tag;

  static ObjectUnionPtr New() {
    return ObjectUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_int8|.
  static ObjectUnionPtr
  NewFInt8(
      int8_t f_int8) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_int8(std::move(f_int8));
    return result;
  }
  // Construct an instance holding |f_string|.
  static ObjectUnionPtr
  NewFString(
      const WTF::String& f_string) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_string(std::move(f_string));
    return result;
  }
  // Construct an instance holding |f_dummy|.
  static ObjectUnionPtr
  NewFDummy(
      DummyStructPtr f_dummy) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_dummy(std::move(f_dummy));
    return result;
  }
  // Construct an instance holding |f_nullable|.
  static ObjectUnionPtr
  NewFNullable(
      DummyStructPtr f_nullable) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_nullable(std::move(f_nullable));
    return result;
  }
  // Construct an instance holding |f_array_int8|.
  static ObjectUnionPtr
  NewFArrayInt8(
      WTF::Vector<int8_t> f_array_int8) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_array_int8(std::move(f_array_int8));
    return result;
  }
  // Construct an instance holding |f_map_int8|.
  static ObjectUnionPtr
  NewFMapInt8(
      const WTF::HashMap<WTF::String, int8_t>& f_map_int8) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_map_int8(std::move(f_map_int8));
    return result;
  }
  // Construct an instance holding |f_pod_union|.
  static ObjectUnionPtr
  NewFPodUnion(
      PodUnionPtr f_pod_union) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_pod_union(std::move(f_pod_union));
    return result;
  }
  // Construct an instance holding |f_small_structs|.
  static ObjectUnionPtr
  NewFSmallStructs(
      WTF::Vector<SmallStructPtr> f_small_structs) {
    auto result = ObjectUnionPtr(base::in_place);
    result->set_f_small_structs(std::move(f_small_structs));
    return result;
  }

  template <typename U>
  static ObjectUnionPtr From(const U& u) {
    return mojo::TypeConverter<ObjectUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ObjectUnion>::Convert(*this);
  }

  ObjectUnion();
  ~ObjectUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = ObjectUnionPtr>
  ObjectUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, ObjectUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, ObjectUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.ObjectUnion.f_int8
  bool is_f_int8() const { return tag_ == Tag::F_INT8; }

  
// @generated_from: mojo.test.ObjectUnion.f_int8
  int8_t get_f_int8() const {
    DCHECK(tag_ == Tag::F_INT8);
    return data_.f_int8;
  }

  
// @generated_from: mojo.test.ObjectUnion.f_int8
  void set_f_int8(
      int8_t f_int8);
  
// @generated_from: mojo.test.ObjectUnion.f_string
  bool is_f_string() const { return tag_ == Tag::F_STRING; }

  
// @generated_from: mojo.test.ObjectUnion.f_string
  WTF::String& get_f_string() const {
    DCHECK(tag_ == Tag::F_STRING);
    return *(data_.f_string);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_string
  void set_f_string(
      const WTF::String& f_string);
  
// @generated_from: mojo.test.ObjectUnion.f_dummy
  bool is_f_dummy() const { return tag_ == Tag::F_DUMMY; }

  
// @generated_from: mojo.test.ObjectUnion.f_dummy
  DummyStructPtr& get_f_dummy() const {
    DCHECK(tag_ == Tag::F_DUMMY);
    return *(data_.f_dummy);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_dummy
  void set_f_dummy(
      DummyStructPtr f_dummy);
  
// @generated_from: mojo.test.ObjectUnion.f_nullable
  bool is_f_nullable() const { return tag_ == Tag::F_NULLABLE; }

  
// @generated_from: mojo.test.ObjectUnion.f_nullable
  DummyStructPtr& get_f_nullable() const {
    DCHECK(tag_ == Tag::F_NULLABLE);
    return *(data_.f_nullable);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_nullable
  void set_f_nullable(
      DummyStructPtr f_nullable);
  
// @generated_from: mojo.test.ObjectUnion.f_array_int8
  bool is_f_array_int8() const { return tag_ == Tag::F_ARRAY_INT8; }

  
// @generated_from: mojo.test.ObjectUnion.f_array_int8
  WTF::Vector<int8_t>& get_f_array_int8() const {
    DCHECK(tag_ == Tag::F_ARRAY_INT8);
    return *(data_.f_array_int8);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_array_int8
  void set_f_array_int8(
      WTF::Vector<int8_t> f_array_int8);
  
// @generated_from: mojo.test.ObjectUnion.f_map_int8
  bool is_f_map_int8() const { return tag_ == Tag::F_MAP_INT8; }

  
// @generated_from: mojo.test.ObjectUnion.f_map_int8
  WTF::HashMap<WTF::String, int8_t>& get_f_map_int8() const {
    DCHECK(tag_ == Tag::F_MAP_INT8);
    return *(data_.f_map_int8);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_map_int8
  void set_f_map_int8(
      const WTF::HashMap<WTF::String, int8_t>& f_map_int8);
  
// @generated_from: mojo.test.ObjectUnion.f_pod_union
  bool is_f_pod_union() const { return tag_ == Tag::F_POD_UNION; }

  
// @generated_from: mojo.test.ObjectUnion.f_pod_union
  PodUnionPtr& get_f_pod_union() const {
    DCHECK(tag_ == Tag::F_POD_UNION);
    return *(data_.f_pod_union);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_pod_union
  void set_f_pod_union(
      PodUnionPtr f_pod_union);
  
// @generated_from: mojo.test.ObjectUnion.f_small_structs
  bool is_f_small_structs() const { return tag_ == Tag::F_SMALL_STRUCTS; }

  
// @generated_from: mojo.test.ObjectUnion.f_small_structs
  WTF::Vector<SmallStructPtr>& get_f_small_structs() const {
    DCHECK(tag_ == Tag::F_SMALL_STRUCTS);
    return *(data_.f_small_structs);
  }

  
// @generated_from: mojo.test.ObjectUnion.f_small_structs
  void set_f_small_structs(
      WTF::Vector<SmallStructPtr> f_small_structs);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ObjectUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<ObjectUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int8_t f_int8;
    WTF::String* f_string;
    DummyStructPtr* f_dummy;
    DummyStructPtr* f_nullable;
    WTF::Vector<int8_t>* f_array_int8;
    WTF::HashMap<WTF::String, int8_t>* f_map_int8;
    PodUnionPtr* f_pod_union;
    WTF::Vector<SmallStructPtr>* f_small_structs;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.HandleUnion
class  HandleUnion {
 public:
  using DataView = HandleUnionDataView;
  using Data_ = internal::HandleUnion_Data;
  using Tag = Data_::HandleUnion_Tag;

  static HandleUnionPtr New() {
    return HandleUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_handle|.
  static HandleUnionPtr
  NewFHandle(
      ::mojo::ScopedHandle f_handle) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_handle(std::move(f_handle));
    return result;
  }
  // Construct an instance holding |f_message_pipe|.
  static HandleUnionPtr
  NewFMessagePipe(
      ::mojo::ScopedMessagePipeHandle f_message_pipe) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_message_pipe(std::move(f_message_pipe));
    return result;
  }
  // Construct an instance holding |f_data_pipe_consumer|.
  static HandleUnionPtr
  NewFDataPipeConsumer(
      ::mojo::ScopedDataPipeConsumerHandle f_data_pipe_consumer) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_data_pipe_consumer(std::move(f_data_pipe_consumer));
    return result;
  }
  // Construct an instance holding |f_data_pipe_producer|.
  static HandleUnionPtr
  NewFDataPipeProducer(
      ::mojo::ScopedDataPipeProducerHandle f_data_pipe_producer) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_data_pipe_producer(std::move(f_data_pipe_producer));
    return result;
  }
  // Construct an instance holding |f_shared_buffer|.
  static HandleUnionPtr
  NewFSharedBuffer(
      ::mojo::ScopedSharedBufferHandle f_shared_buffer) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_shared_buffer(std::move(f_shared_buffer));
    return result;
  }
  // Construct an instance holding |f_platform|.
  static HandleUnionPtr
  NewFPlatform(
      ::mojo::PlatformHandle f_platform) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_platform(std::move(f_platform));
    return result;
  }
  // Construct an instance holding |f_small_cache|.
  static HandleUnionPtr
  NewFSmallCache(
      ::mojo::PendingRemote<SmallCache> f_small_cache) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_small_cache(std::move(f_small_cache));
    return result;
  }
  // Construct an instance holding |f_small_cache_receiver|.
  static HandleUnionPtr
  NewFSmallCacheReceiver(
      ::mojo::PendingReceiver<SmallCache> f_small_cache_receiver) {
    auto result = HandleUnionPtr(base::in_place);
    result->set_f_small_cache_receiver(std::move(f_small_cache_receiver));
    return result;
  }

  template <typename U>
  static HandleUnionPtr From(const U& u) {
    return mojo::TypeConverter<HandleUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HandleUnion>::Convert(*this);
  }

  HandleUnion();
  ~HandleUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = HandleUnionPtr>
  HandleUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, HandleUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, HandleUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.HandleUnion.f_handle
  bool is_f_handle() const { return tag_ == Tag::F_HANDLE; }

  
// @generated_from: mojo.test.HandleUnion.f_handle
  ::mojo::ScopedHandle& get_f_handle() const {
    DCHECK(tag_ == Tag::F_HANDLE);
    return *(data_.f_handle);
  }

  
// @generated_from: mojo.test.HandleUnion.f_handle
  void set_f_handle(
      ::mojo::ScopedHandle f_handle);
  
// @generated_from: mojo.test.HandleUnion.f_message_pipe
  bool is_f_message_pipe() const { return tag_ == Tag::F_MESSAGE_PIPE; }

  
// @generated_from: mojo.test.HandleUnion.f_message_pipe
  ::mojo::ScopedMessagePipeHandle& get_f_message_pipe() const {
    DCHECK(tag_ == Tag::F_MESSAGE_PIPE);
    return *(data_.f_message_pipe);
  }

  
// @generated_from: mojo.test.HandleUnion.f_message_pipe
  void set_f_message_pipe(
      ::mojo::ScopedMessagePipeHandle f_message_pipe);
  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_consumer
  bool is_f_data_pipe_consumer() const { return tag_ == Tag::F_DATA_PIPE_CONSUMER; }

  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_consumer
  ::mojo::ScopedDataPipeConsumerHandle& get_f_data_pipe_consumer() const {
    DCHECK(tag_ == Tag::F_DATA_PIPE_CONSUMER);
    return *(data_.f_data_pipe_consumer);
  }

  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_consumer
  void set_f_data_pipe_consumer(
      ::mojo::ScopedDataPipeConsumerHandle f_data_pipe_consumer);
  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_producer
  bool is_f_data_pipe_producer() const { return tag_ == Tag::F_DATA_PIPE_PRODUCER; }

  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_producer
  ::mojo::ScopedDataPipeProducerHandle& get_f_data_pipe_producer() const {
    DCHECK(tag_ == Tag::F_DATA_PIPE_PRODUCER);
    return *(data_.f_data_pipe_producer);
  }

  
// @generated_from: mojo.test.HandleUnion.f_data_pipe_producer
  void set_f_data_pipe_producer(
      ::mojo::ScopedDataPipeProducerHandle f_data_pipe_producer);
  
// @generated_from: mojo.test.HandleUnion.f_shared_buffer
  bool is_f_shared_buffer() const { return tag_ == Tag::F_SHARED_BUFFER; }

  
// @generated_from: mojo.test.HandleUnion.f_shared_buffer
  ::mojo::ScopedSharedBufferHandle& get_f_shared_buffer() const {
    DCHECK(tag_ == Tag::F_SHARED_BUFFER);
    return *(data_.f_shared_buffer);
  }

  
// @generated_from: mojo.test.HandleUnion.f_shared_buffer
  void set_f_shared_buffer(
      ::mojo::ScopedSharedBufferHandle f_shared_buffer);
  
// @generated_from: mojo.test.HandleUnion.f_platform
  bool is_f_platform() const { return tag_ == Tag::F_PLATFORM; }

  
// @generated_from: mojo.test.HandleUnion.f_platform
  ::mojo::PlatformHandle& get_f_platform() const {
    DCHECK(tag_ == Tag::F_PLATFORM);
    return *(data_.f_platform);
  }

  
// @generated_from: mojo.test.HandleUnion.f_platform
  void set_f_platform(
      ::mojo::PlatformHandle f_platform);
  
// @generated_from: mojo.test.HandleUnion.f_small_cache
  bool is_f_small_cache() const { return tag_ == Tag::F_SMALL_CACHE; }

  
// @generated_from: mojo.test.HandleUnion.f_small_cache
  ::mojo::PendingRemote<SmallCache>& get_f_small_cache() const {
    DCHECK(tag_ == Tag::F_SMALL_CACHE);
    return *(data_.f_small_cache);
  }

  
// @generated_from: mojo.test.HandleUnion.f_small_cache
  void set_f_small_cache(
      ::mojo::PendingRemote<SmallCache> f_small_cache);
  
// @generated_from: mojo.test.HandleUnion.f_small_cache_receiver
  bool is_f_small_cache_receiver() const { return tag_ == Tag::F_SMALL_CACHE_RECEIVER; }

  
// @generated_from: mojo.test.HandleUnion.f_small_cache_receiver
  ::mojo::PendingReceiver<SmallCache>& get_f_small_cache_receiver() const {
    DCHECK(tag_ == Tag::F_SMALL_CACHE_RECEIVER);
    return *(data_.f_small_cache_receiver);
  }

  
// @generated_from: mojo.test.HandleUnion.f_small_cache_receiver
  void set_f_small_cache_receiver(
      ::mojo::PendingReceiver<SmallCache> f_small_cache_receiver);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        HandleUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<HandleUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    ::mojo::ScopedHandle* f_handle;
    ::mojo::ScopedMessagePipeHandle* f_message_pipe;
    ::mojo::ScopedDataPipeConsumerHandle* f_data_pipe_consumer;
    ::mojo::ScopedDataPipeProducerHandle* f_data_pipe_producer;
    ::mojo::ScopedSharedBufferHandle* f_shared_buffer;
    ::mojo::PlatformHandle* f_platform;
    ::mojo::PendingRemote<SmallCache>* f_small_cache;
    ::mojo::PendingReceiver<SmallCache>* f_small_cache_receiver;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.OldUnion
class  OldUnion {
 public:
  using DataView = OldUnionDataView;
  using Data_ = internal::OldUnion_Data;
  using Tag = Data_::OldUnion_Tag;

  static OldUnionPtr New() {
    return OldUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_int8|.
  static OldUnionPtr
  NewFInt8(
      int8_t f_int8) {
    auto result = OldUnionPtr(base::in_place);
    result->set_f_int8(std::move(f_int8));
    return result;
  }

  template <typename U>
  static OldUnionPtr From(const U& u) {
    return mojo::TypeConverter<OldUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, OldUnion>::Convert(*this);
  }

  OldUnion();
  ~OldUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = OldUnionPtr>
  OldUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, OldUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, OldUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.OldUnion.f_int8
  bool is_f_int8() const { return tag_ == Tag::F_INT8; }

  
// @generated_from: mojo.test.OldUnion.f_int8
  int8_t get_f_int8() const {
    DCHECK(tag_ == Tag::F_INT8);
    return data_.f_int8;
  }

  
// @generated_from: mojo.test.OldUnion.f_int8
  void set_f_int8(
      int8_t f_int8);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        OldUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<OldUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int8_t f_int8;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.NewUnion
class  NewUnion {
 public:
  using DataView = NewUnionDataView;
  using Data_ = internal::NewUnion_Data;
  using Tag = Data_::NewUnion_Tag;

  static NewUnionPtr New() {
    return NewUnionPtr(base::in_place);
  }
  // Construct an instance holding |f_int8|.
  static NewUnionPtr
  NewFInt8(
      int8_t f_int8) {
    auto result = NewUnionPtr(base::in_place);
    result->set_f_int8(std::move(f_int8));
    return result;
  }
  // Construct an instance holding |f_int16|.
  static NewUnionPtr
  NewFInt16(
      int16_t f_int16) {
    auto result = NewUnionPtr(base::in_place);
    result->set_f_int16(std::move(f_int16));
    return result;
  }

  template <typename U>
  static NewUnionPtr From(const U& u) {
    return mojo::TypeConverter<NewUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NewUnion>::Convert(*this);
  }

  NewUnion();
  ~NewUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = NewUnionPtr>
  NewUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, NewUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, NewUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.NewUnion.f_int8
  bool is_f_int8() const { return tag_ == Tag::F_INT8; }

  
// @generated_from: mojo.test.NewUnion.f_int8
  int8_t get_f_int8() const {
    DCHECK(tag_ == Tag::F_INT8);
    return data_.f_int8;
  }

  
// @generated_from: mojo.test.NewUnion.f_int8
  void set_f_int8(
      int8_t f_int8);
  
// @generated_from: mojo.test.NewUnion.f_int16
  bool is_f_int16() const { return tag_ == Tag::F_INT16; }

  
// @generated_from: mojo.test.NewUnion.f_int16
  int16_t get_f_int16() const {
    DCHECK(tag_ == Tag::F_INT16);
    return data_.f_int16;
  }

  
// @generated_from: mojo.test.NewUnion.f_int16
  void set_f_int16(
      int16_t f_int16);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NewUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<NewUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int8_t f_int8;
    int16_t f_int16;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.ImportedUnionUnion
class  ImportedUnionUnion {
 public:
  using DataView = ImportedUnionUnionDataView;
  using Data_ = internal::ImportedUnionUnion_Data;
  using Tag = Data_::ImportedUnionUnion_Tag;

  static ImportedUnionUnionPtr New() {
    return ImportedUnionUnionPtr(base::in_place);
  }
  // Construct an instance holding |point_or_shape|.
  static ImportedUnionUnionPtr
  NewPointOrShape(
      ::imported::blink::PointOrShapePtr point_or_shape) {
    auto result = ImportedUnionUnionPtr(base::in_place);
    result->set_point_or_shape(std::move(point_or_shape));
    return result;
  }

  template <typename U>
  static ImportedUnionUnionPtr From(const U& u) {
    return mojo::TypeConverter<ImportedUnionUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ImportedUnionUnion>::Convert(*this);
  }

  ImportedUnionUnion();
  ~ImportedUnionUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = ImportedUnionUnionPtr>
  ImportedUnionUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, ImportedUnionUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, ImportedUnionUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.ImportedUnionUnion.point_or_shape
  bool is_point_or_shape() const { return tag_ == Tag::POINT_OR_SHAPE; }

  
// @generated_from: mojo.test.ImportedUnionUnion.point_or_shape
  ::imported::blink::PointOrShapePtr& get_point_or_shape() const {
    DCHECK(tag_ == Tag::POINT_OR_SHAPE);
    return *(data_.point_or_shape);
  }

  
// @generated_from: mojo.test.ImportedUnionUnion.point_or_shape
  void set_point_or_shape(
      ::imported::blink::PointOrShapePtr point_or_shape);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ImportedUnionUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<ImportedUnionUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    ::imported::blink::PointOrShapePtr* point_or_shape;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



// @generated_from: mojo.test.UnionWithStringForFirstField
class  UnionWithStringForFirstField {
 public:
  using DataView = UnionWithStringForFirstFieldDataView;
  using Data_ = internal::UnionWithStringForFirstField_Data;
  using Tag = Data_::UnionWithStringForFirstField_Tag;

  static UnionWithStringForFirstFieldPtr New() {
    return UnionWithStringForFirstFieldPtr(base::in_place);
  }
  // Construct an instance holding |s|.
  static UnionWithStringForFirstFieldPtr
  NewS(
      const WTF::String& s) {
    auto result = UnionWithStringForFirstFieldPtr(base::in_place);
    result->set_s(std::move(s));
    return result;
  }
  // Construct an instance holding |i|.
  static UnionWithStringForFirstFieldPtr
  NewI(
      int32_t i) {
    auto result = UnionWithStringForFirstFieldPtr(base::in_place);
    result->set_i(std::move(i));
    return result;
  }

  template <typename U>
  static UnionWithStringForFirstFieldPtr From(const U& u) {
    return mojo::TypeConverter<UnionWithStringForFirstFieldPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionWithStringForFirstField>::Convert(*this);
  }

  UnionWithStringForFirstField();
  ~UnionWithStringForFirstField();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = UnionWithStringForFirstFieldPtr>
  UnionWithStringForFirstFieldPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, UnionWithStringForFirstField>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, UnionWithStringForFirstField>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
// @generated_from: mojo.test.UnionWithStringForFirstField.s
  bool is_s() const { return tag_ == Tag::S; }

  
// @generated_from: mojo.test.UnionWithStringForFirstField.s
  WTF::String& get_s() const {
    DCHECK(tag_ == Tag::S);
    return *(data_.s);
  }

  
// @generated_from: mojo.test.UnionWithStringForFirstField.s
  void set_s(
      const WTF::String& s);
  
// @generated_from: mojo.test.UnionWithStringForFirstField.i
  bool is_i() const { return tag_ == Tag::I; }

  
// @generated_from: mojo.test.UnionWithStringForFirstField.i
  int32_t get_i() const {
    DCHECK(tag_ == Tag::I);
    return data_.i;
  }

  
// @generated_from: mojo.test.UnionWithStringForFirstField.i
  void set_i(
      int32_t i);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        UnionWithStringForFirstField::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<UnionWithStringForFirstField::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    WTF::String* s;
    int32_t i;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





// @generated_from: mojo.test.WrapperStruct
class  WrapperStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WrapperStruct, T>::value>;
  using DataView = WrapperStructDataView;
  using Data_ = internal::WrapperStruct_Data;

  template <typename... Args>
  static WrapperStructPtr New(Args&&... args) {
    return WrapperStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WrapperStructPtr From(const U& u) {
    return mojo::TypeConverter<WrapperStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WrapperStruct>::Convert(*this);
  }


  WrapperStruct();

  WrapperStruct(
      ObjectUnionPtr object_union,
      PodUnionPtr pod_union,
      HandleUnionPtr handle_union);

  ~WrapperStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WrapperStructPtr>
  WrapperStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WrapperStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WrapperStruct_UnserializedMessageContext<
            UserType, WrapperStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WrapperStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return WrapperStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WrapperStruct_UnserializedMessageContext<
            UserType, WrapperStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WrapperStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.WrapperStruct.object_union
  ObjectUnionPtr object_union;
  
// @generated_from: mojo.test.WrapperStruct.pod_union
  PodUnionPtr pod_union;
  
// @generated_from: mojo.test.WrapperStruct.handle_union
  HandleUnionPtr handle_union;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(WrapperStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WrapperStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.SmallStruct
class  SmallStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SmallStruct, T>::value>;
  using DataView = SmallStructDataView;
  using Data_ = internal::SmallStruct_Data;

  template <typename... Args>
  static SmallStructPtr New(Args&&... args) {
    return SmallStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SmallStructPtr From(const U& u) {
    return mojo::TypeConverter<SmallStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallStruct>::Convert(*this);
  }


  SmallStruct();

  SmallStruct(
      DummyStructPtr dummy_struct,
      PodUnionPtr pod_union,
      base::Optional<WTF::Vector<PodUnionPtr>> pod_union_array,
      base::Optional<WTF::Vector<PodUnionPtr>> nullable_pod_union_array,
      base::Optional<WTF::Vector<DummyStructPtr>> s_array,
      base::Optional<WTF::HashMap<WTF::String, PodUnionPtr>> pod_union_map,
      base::Optional<WTF::HashMap<WTF::String, PodUnionPtr>> nullable_pod_union_map);

  ~SmallStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SmallStructPtr>
  SmallStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SmallStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SmallStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SmallStruct_UnserializedMessageContext<
            UserType, SmallStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SmallStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return SmallStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SmallStruct_UnserializedMessageContext<
            UserType, SmallStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SmallStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SmallStruct.dummy_struct
  DummyStructPtr dummy_struct;
  
// @generated_from: mojo.test.SmallStruct.pod_union
  PodUnionPtr pod_union;
  
// @generated_from: mojo.test.SmallStruct.pod_union_array
  base::Optional<WTF::Vector<PodUnionPtr>> pod_union_array;
  
// @generated_from: mojo.test.SmallStruct.nullable_pod_union_array
  base::Optional<WTF::Vector<PodUnionPtr>> nullable_pod_union_array;
  
// @generated_from: mojo.test.SmallStruct.s_array
  base::Optional<WTF::Vector<DummyStructPtr>> s_array;
  
// @generated_from: mojo.test.SmallStruct.pod_union_map
  base::Optional<WTF::HashMap<WTF::String, PodUnionPtr>> pod_union_map;
  
// @generated_from: mojo.test.SmallStruct.nullable_pod_union_map
  base::Optional<WTF::HashMap<WTF::String, PodUnionPtr>> nullable_pod_union_map;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SmallStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SmallStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.SmallStructNonNullableUnion
class  SmallStructNonNullableUnion {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SmallStructNonNullableUnion, T>::value>;
  using DataView = SmallStructNonNullableUnionDataView;
  using Data_ = internal::SmallStructNonNullableUnion_Data;

  template <typename... Args>
  static SmallStructNonNullableUnionPtr New(Args&&... args) {
    return SmallStructNonNullableUnionPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SmallStructNonNullableUnionPtr From(const U& u) {
    return mojo::TypeConverter<SmallStructNonNullableUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallStructNonNullableUnion>::Convert(*this);
  }


  SmallStructNonNullableUnion();

  explicit SmallStructNonNullableUnion(
      PodUnionPtr pod_union);

  ~SmallStructNonNullableUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SmallStructNonNullableUnionPtr>
  SmallStructNonNullableUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SmallStructNonNullableUnion::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SmallStructNonNullableUnion::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SmallStructNonNullableUnion_UnserializedMessageContext<
            UserType, SmallStructNonNullableUnion::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SmallStructNonNullableUnion::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return SmallStructNonNullableUnion::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SmallStructNonNullableUnion_UnserializedMessageContext<
            UserType, SmallStructNonNullableUnion::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SmallStructNonNullableUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SmallStructNonNullableUnion.pod_union
  PodUnionPtr pod_union;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SmallStructNonNullableUnion);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.SmallObjStruct
class  SmallObjStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SmallObjStruct, T>::value>;
  using DataView = SmallObjStructDataView;
  using Data_ = internal::SmallObjStruct_Data;

  template <typename... Args>
  static SmallObjStructPtr New(Args&&... args) {
    return SmallObjStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SmallObjStructPtr From(const U& u) {
    return mojo::TypeConverter<SmallObjStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallObjStruct>::Convert(*this);
  }


  SmallObjStruct();

  SmallObjStruct(
      ObjectUnionPtr obj_union,
      int8_t f_int8);

  ~SmallObjStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SmallObjStructPtr>
  SmallObjStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SmallObjStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SmallObjStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SmallObjStruct_UnserializedMessageContext<
            UserType, SmallObjStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SmallObjStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return SmallObjStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SmallObjStruct_UnserializedMessageContext<
            UserType, SmallObjStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SmallObjStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SmallObjStruct.obj_union
  ObjectUnionPtr obj_union;
  
// @generated_from: mojo.test.SmallObjStruct.f_int8
  int8_t f_int8;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SmallObjStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SmallObjStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.TryNonNullStruct
class  TryNonNullStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<TryNonNullStruct, T>::value>;
  using DataView = TryNonNullStructDataView;
  using Data_ = internal::TryNonNullStruct_Data;

  template <typename... Args>
  static TryNonNullStructPtr New(Args&&... args) {
    return TryNonNullStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static TryNonNullStructPtr From(const U& u) {
    return mojo::TypeConverter<TryNonNullStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TryNonNullStruct>::Convert(*this);
  }


  TryNonNullStruct();

  TryNonNullStruct(
      DummyStructPtr nullable,
      DummyStructPtr non_nullable);

  ~TryNonNullStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = TryNonNullStructPtr>
  TryNonNullStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        TryNonNullStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        TryNonNullStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::TryNonNullStruct_UnserializedMessageContext<
            UserType, TryNonNullStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<TryNonNullStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return TryNonNullStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::TryNonNullStruct_UnserializedMessageContext<
            UserType, TryNonNullStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<TryNonNullStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.TryNonNullStruct.nullable
  DummyStructPtr nullable;
  
// @generated_from: mojo.test.TryNonNullStruct.non_nullable
  DummyStructPtr non_nullable;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(TryNonNullStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, TryNonNullStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.ImportedUnionStruct
class  ImportedUnionStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ImportedUnionStruct, T>::value>;
  using DataView = ImportedUnionStructDataView;
  using Data_ = internal::ImportedUnionStruct_Data;

  template <typename... Args>
  static ImportedUnionStructPtr New(Args&&... args) {
    return ImportedUnionStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ImportedUnionStructPtr From(const U& u) {
    return mojo::TypeConverter<ImportedUnionStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ImportedUnionStruct>::Convert(*this);
  }


  ImportedUnionStruct();

  explicit ImportedUnionStruct(
      ::imported::blink::PointOrShapePtr point_or_shape);

  ~ImportedUnionStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ImportedUnionStructPtr>
  ImportedUnionStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ImportedUnionStruct::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ImportedUnionStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ImportedUnionStruct_UnserializedMessageContext<
            UserType, ImportedUnionStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ImportedUnionStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ImportedUnionStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ImportedUnionStruct_UnserializedMessageContext<
            UserType, ImportedUnionStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ImportedUnionStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ImportedUnionStruct.point_or_shape
  ::imported::blink::PointOrShapePtr point_or_shape;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ImportedUnionStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ImportedUnionStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename UnionPtrType>
PodUnionPtr PodUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_INT8:
      rv->set_f_int8(mojo::Clone(data_.f_int8));
      break;
    case Tag::F_INT8_OTHER:
      rv->set_f_int8_other(mojo::Clone(data_.f_int8_other));
      break;
    case Tag::F_UINT8:
      rv->set_f_uint8(mojo::Clone(data_.f_uint8));
      break;
    case Tag::F_INT16:
      rv->set_f_int16(mojo::Clone(data_.f_int16));
      break;
    case Tag::F_UINT16:
      rv->set_f_uint16(mojo::Clone(data_.f_uint16));
      break;
    case Tag::F_INT32:
      rv->set_f_int32(mojo::Clone(data_.f_int32));
      break;
    case Tag::F_UINT32:
      rv->set_f_uint32(mojo::Clone(data_.f_uint32));
      break;
    case Tag::F_INT64:
      rv->set_f_int64(mojo::Clone(data_.f_int64));
      break;
    case Tag::F_UINT64:
      rv->set_f_uint64(mojo::Clone(data_.f_uint64));
      break;
    case Tag::F_FLOAT:
      rv->set_f_float(mojo::Clone(data_.f_float));
      break;
    case Tag::F_DOUBLE:
      rv->set_f_double(mojo::Clone(data_.f_double));
      break;
    case Tag::F_BOOL:
      rv->set_f_bool(mojo::Clone(data_.f_bool));
      break;
    case Tag::F_ENUM:
      rv->set_f_enum(mojo::Clone(data_.f_enum));
      break;
    case Tag::F_EXTENSIBLE_ENUM:
      rv->set_f_extensible_enum(mojo::Clone(data_.f_extensible_enum));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, PodUnion>::value>::type*>
bool PodUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_INT8:
      return mojo::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_INT8_OTHER:
      return mojo::Equals(data_.f_int8_other, other.data_.f_int8_other);
    case Tag::F_UINT8:
      return mojo::Equals(data_.f_uint8, other.data_.f_uint8);
    case Tag::F_INT16:
      return mojo::Equals(data_.f_int16, other.data_.f_int16);
    case Tag::F_UINT16:
      return mojo::Equals(data_.f_uint16, other.data_.f_uint16);
    case Tag::F_INT32:
      return mojo::Equals(data_.f_int32, other.data_.f_int32);
    case Tag::F_UINT32:
      return mojo::Equals(data_.f_uint32, other.data_.f_uint32);
    case Tag::F_INT64:
      return mojo::Equals(data_.f_int64, other.data_.f_int64);
    case Tag::F_UINT64:
      return mojo::Equals(data_.f_uint64, other.data_.f_uint64);
    case Tag::F_FLOAT:
      return mojo::Equals(data_.f_float, other.data_.f_float);
    case Tag::F_DOUBLE:
      return mojo::Equals(data_.f_double, other.data_.f_double);
    case Tag::F_BOOL:
      return mojo::Equals(data_.f_bool, other.data_.f_bool);
    case Tag::F_ENUM:
      return mojo::Equals(data_.f_enum, other.data_.f_enum);
    case Tag::F_EXTENSIBLE_ENUM:
      return mojo::Equals(data_.f_extensible_enum, other.data_.f_extensible_enum);
  }

  return false;
}
template <typename UnionPtrType>
ObjectUnionPtr ObjectUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_INT8:
      rv->set_f_int8(mojo::Clone(data_.f_int8));
      break;
    case Tag::F_STRING:
      rv->set_f_string(mojo::Clone(*data_.f_string));
      break;
    case Tag::F_DUMMY:
      rv->set_f_dummy(mojo::Clone(*data_.f_dummy));
      break;
    case Tag::F_NULLABLE:
      rv->set_f_nullable(mojo::Clone(*data_.f_nullable));
      break;
    case Tag::F_ARRAY_INT8:
      rv->set_f_array_int8(mojo::Clone(*data_.f_array_int8));
      break;
    case Tag::F_MAP_INT8:
      rv->set_f_map_int8(mojo::Clone(*data_.f_map_int8));
      break;
    case Tag::F_POD_UNION:
      rv->set_f_pod_union(mojo::Clone(*data_.f_pod_union));
      break;
    case Tag::F_SMALL_STRUCTS:
      rv->set_f_small_structs(mojo::Clone(*data_.f_small_structs));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, ObjectUnion>::value>::type*>
bool ObjectUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_INT8:
      return mojo::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_STRING:
      return mojo::Equals(*(data_.f_string), *(other.data_.f_string));
    case Tag::F_DUMMY:
      return mojo::Equals(*(data_.f_dummy), *(other.data_.f_dummy));
    case Tag::F_NULLABLE:
      return mojo::Equals(*(data_.f_nullable), *(other.data_.f_nullable));
    case Tag::F_ARRAY_INT8:
      return mojo::Equals(*(data_.f_array_int8), *(other.data_.f_array_int8));
    case Tag::F_MAP_INT8:
      return mojo::Equals(*(data_.f_map_int8), *(other.data_.f_map_int8));
    case Tag::F_POD_UNION:
      return mojo::Equals(*(data_.f_pod_union), *(other.data_.f_pod_union));
    case Tag::F_SMALL_STRUCTS:
      return mojo::Equals(*(data_.f_small_structs), *(other.data_.f_small_structs));
  }

  return false;
}
template <typename UnionPtrType>
HandleUnionPtr HandleUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_HANDLE:
      rv->set_f_handle(mojo::Clone(*data_.f_handle));
      break;
    case Tag::F_MESSAGE_PIPE:
      rv->set_f_message_pipe(mojo::Clone(*data_.f_message_pipe));
      break;
    case Tag::F_DATA_PIPE_CONSUMER:
      rv->set_f_data_pipe_consumer(mojo::Clone(*data_.f_data_pipe_consumer));
      break;
    case Tag::F_DATA_PIPE_PRODUCER:
      rv->set_f_data_pipe_producer(mojo::Clone(*data_.f_data_pipe_producer));
      break;
    case Tag::F_SHARED_BUFFER:
      rv->set_f_shared_buffer(mojo::Clone(*data_.f_shared_buffer));
      break;
    case Tag::F_PLATFORM:
      rv->set_f_platform(mojo::Clone(*data_.f_platform));
      break;
    case Tag::F_SMALL_CACHE:
      rv->set_f_small_cache(mojo::Clone(*data_.f_small_cache));
      break;
    case Tag::F_SMALL_CACHE_RECEIVER:
      rv->set_f_small_cache_receiver(mojo::Clone(*data_.f_small_cache_receiver));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, HandleUnion>::value>::type*>
bool HandleUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_HANDLE:
      return mojo::Equals(*(data_.f_handle), *(other.data_.f_handle));
    case Tag::F_MESSAGE_PIPE:
      return mojo::Equals(*(data_.f_message_pipe), *(other.data_.f_message_pipe));
    case Tag::F_DATA_PIPE_CONSUMER:
      return mojo::Equals(*(data_.f_data_pipe_consumer), *(other.data_.f_data_pipe_consumer));
    case Tag::F_DATA_PIPE_PRODUCER:
      return mojo::Equals(*(data_.f_data_pipe_producer), *(other.data_.f_data_pipe_producer));
    case Tag::F_SHARED_BUFFER:
      return mojo::Equals(*(data_.f_shared_buffer), *(other.data_.f_shared_buffer));
    case Tag::F_PLATFORM:
      return mojo::Equals(*(data_.f_platform), *(other.data_.f_platform));
    case Tag::F_SMALL_CACHE:
      return mojo::Equals(*(data_.f_small_cache), *(other.data_.f_small_cache));
    case Tag::F_SMALL_CACHE_RECEIVER:
      return mojo::Equals(*(data_.f_small_cache_receiver), *(other.data_.f_small_cache_receiver));
  }

  return false;
}
template <typename UnionPtrType>
OldUnionPtr OldUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_INT8:
      rv->set_f_int8(mojo::Clone(data_.f_int8));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, OldUnion>::value>::type*>
bool OldUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_INT8:
      return mojo::Equals(data_.f_int8, other.data_.f_int8);
  }

  return false;
}
template <typename UnionPtrType>
NewUnionPtr NewUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::F_INT8:
      rv->set_f_int8(mojo::Clone(data_.f_int8));
      break;
    case Tag::F_INT16:
      rv->set_f_int16(mojo::Clone(data_.f_int16));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, NewUnion>::value>::type*>
bool NewUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::F_INT8:
      return mojo::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_INT16:
      return mojo::Equals(data_.f_int16, other.data_.f_int16);
  }

  return false;
}
template <typename UnionPtrType>
ImportedUnionUnionPtr ImportedUnionUnion::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::POINT_OR_SHAPE:
      rv->set_point_or_shape(mojo::Clone(*data_.point_or_shape));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, ImportedUnionUnion>::value>::type*>
bool ImportedUnionUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::POINT_OR_SHAPE:
      return mojo::Equals(*(data_.point_or_shape), *(other.data_.point_or_shape));
  }

  return false;
}
template <typename UnionPtrType>
UnionWithStringForFirstFieldPtr UnionWithStringForFirstField::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::S:
      rv->set_s(mojo::Clone(*data_.s));
      break;
    case Tag::I:
      rv->set_i(mojo::Clone(data_.i));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, UnionWithStringForFirstField>::value>::type*>
bool UnionWithStringForFirstField::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::S:
      return mojo::Equals(*(data_.s), *(other.data_.s));
    case Tag::I:
      return mojo::Equals(data_.i, other.data_.i);
  }

  return false;
}
template <typename StructPtrType>
WrapperStructPtr WrapperStruct::Clone() const {
  return New(
      mojo::Clone(object_union),
      mojo::Clone(pod_union),
      mojo::Clone(handle_union)
  );
}

template <typename T, WrapperStruct::EnableIfSame<T>*>
bool WrapperStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->object_union, other_struct.object_union))
    return false;
  if (!mojo::Equals(this->pod_union, other_struct.pod_union))
    return false;
  if (!mojo::Equals(this->handle_union, other_struct.handle_union))
    return false;
  return true;
}

template <typename T, WrapperStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.object_union < rhs.object_union)
    return true;
  if (rhs.object_union < lhs.object_union)
    return false;
  if (lhs.pod_union < rhs.pod_union)
    return true;
  if (rhs.pod_union < lhs.pod_union)
    return false;
  if (lhs.handle_union < rhs.handle_union)
    return true;
  if (rhs.handle_union < lhs.handle_union)
    return false;
  return false;
}
template <typename StructPtrType>
DummyStructPtr DummyStruct::Clone() const {
  return New(
      mojo::Clone(f_int8)
  );
}

template <typename T, DummyStruct::EnableIfSame<T>*>
bool DummyStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int8, other_struct.f_int8))
    return false;
  return true;
}

template <typename T, DummyStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int8 < rhs.f_int8)
    return true;
  if (rhs.f_int8 < lhs.f_int8)
    return false;
  return false;
}
template <typename StructPtrType>
SmallStructPtr SmallStruct::Clone() const {
  return New(
      mojo::Clone(dummy_struct),
      mojo::Clone(pod_union),
      mojo::Clone(pod_union_array),
      mojo::Clone(nullable_pod_union_array),
      mojo::Clone(s_array),
      mojo::Clone(pod_union_map),
      mojo::Clone(nullable_pod_union_map)
  );
}

template <typename T, SmallStruct::EnableIfSame<T>*>
bool SmallStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->dummy_struct, other_struct.dummy_struct))
    return false;
  if (!mojo::Equals(this->pod_union, other_struct.pod_union))
    return false;
  if (!mojo::Equals(this->pod_union_array, other_struct.pod_union_array))
    return false;
  if (!mojo::Equals(this->nullable_pod_union_array, other_struct.nullable_pod_union_array))
    return false;
  if (!mojo::Equals(this->s_array, other_struct.s_array))
    return false;
  if (!mojo::Equals(this->pod_union_map, other_struct.pod_union_map))
    return false;
  if (!mojo::Equals(this->nullable_pod_union_map, other_struct.nullable_pod_union_map))
    return false;
  return true;
}

template <typename T, SmallStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.dummy_struct < rhs.dummy_struct)
    return true;
  if (rhs.dummy_struct < lhs.dummy_struct)
    return false;
  if (lhs.pod_union < rhs.pod_union)
    return true;
  if (rhs.pod_union < lhs.pod_union)
    return false;
  if (lhs.pod_union_array < rhs.pod_union_array)
    return true;
  if (rhs.pod_union_array < lhs.pod_union_array)
    return false;
  if (lhs.nullable_pod_union_array < rhs.nullable_pod_union_array)
    return true;
  if (rhs.nullable_pod_union_array < lhs.nullable_pod_union_array)
    return false;
  if (lhs.s_array < rhs.s_array)
    return true;
  if (rhs.s_array < lhs.s_array)
    return false;
  if (lhs.pod_union_map < rhs.pod_union_map)
    return true;
  if (rhs.pod_union_map < lhs.pod_union_map)
    return false;
  if (lhs.nullable_pod_union_map < rhs.nullable_pod_union_map)
    return true;
  if (rhs.nullable_pod_union_map < lhs.nullable_pod_union_map)
    return false;
  return false;
}
template <typename StructPtrType>
SmallStructNonNullableUnionPtr SmallStructNonNullableUnion::Clone() const {
  return New(
      mojo::Clone(pod_union)
  );
}

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>*>
bool SmallStructNonNullableUnion::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->pod_union, other_struct.pod_union))
    return false;
  return true;
}

template <typename T, SmallStructNonNullableUnion::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.pod_union < rhs.pod_union)
    return true;
  if (rhs.pod_union < lhs.pod_union)
    return false;
  return false;
}
template <typename StructPtrType>
SmallObjStructPtr SmallObjStruct::Clone() const {
  return New(
      mojo::Clone(obj_union),
      mojo::Clone(f_int8)
  );
}

template <typename T, SmallObjStruct::EnableIfSame<T>*>
bool SmallObjStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->obj_union, other_struct.obj_union))
    return false;
  if (!mojo::Equals(this->f_int8, other_struct.f_int8))
    return false;
  return true;
}

template <typename T, SmallObjStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.obj_union < rhs.obj_union)
    return true;
  if (rhs.obj_union < lhs.obj_union)
    return false;
  if (lhs.f_int8 < rhs.f_int8)
    return true;
  if (rhs.f_int8 < lhs.f_int8)
    return false;
  return false;
}
template <typename StructPtrType>
TryNonNullStructPtr TryNonNullStruct::Clone() const {
  return New(
      mojo::Clone(nullable),
      mojo::Clone(non_nullable)
  );
}

template <typename T, TryNonNullStruct::EnableIfSame<T>*>
bool TryNonNullStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->nullable, other_struct.nullable))
    return false;
  if (!mojo::Equals(this->non_nullable, other_struct.non_nullable))
    return false;
  return true;
}

template <typename T, TryNonNullStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.nullable < rhs.nullable)
    return true;
  if (rhs.nullable < lhs.nullable)
    return false;
  if (lhs.non_nullable < rhs.non_nullable)
    return true;
  if (rhs.non_nullable < lhs.non_nullable)
    return false;
  return false;
}
template <typename StructPtrType>
ImportedUnionStructPtr ImportedUnionStruct::Clone() const {
  return New(
      mojo::Clone(point_or_shape)
  );
}

template <typename T, ImportedUnionStruct::EnableIfSame<T>*>
bool ImportedUnionStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->point_or_shape, other_struct.point_or_shape))
    return false;
  return true;
}

template <typename T, ImportedUnionStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.point_or_shape < rhs.point_or_shape)
    return true;
  if (rhs.point_or_shape < lhs.point_or_shape)
    return false;
  return false;
}


}  // namespace blink
}  // namespace test
}  // namespace mojo

namespace mojo {


template <>
struct  StructTraits<::mojo::test::blink::WrapperStruct::DataView,
                                         ::mojo::test::blink::WrapperStructPtr> {
  static bool IsNull(const ::mojo::test::blink::WrapperStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::WrapperStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::WrapperStruct::object_union)& object_union(
      const ::mojo::test::blink::WrapperStructPtr& input) {
    return input->object_union;
  }

  static const decltype(::mojo::test::blink::WrapperStruct::pod_union)& pod_union(
      const ::mojo::test::blink::WrapperStructPtr& input) {
    return input->pod_union;
  }

  static  decltype(::mojo::test::blink::WrapperStruct::handle_union)& handle_union(
       ::mojo::test::blink::WrapperStructPtr& input) {
    return input->handle_union;
  }

  static bool Read(::mojo::test::blink::WrapperStruct::DataView input, ::mojo::test::blink::WrapperStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::DummyStruct::DataView,
                                         ::mojo::test::blink::DummyStructPtr> {
  static bool IsNull(const ::mojo::test::blink::DummyStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::DummyStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::blink::DummyStruct::f_int8) f_int8(
      const ::mojo::test::blink::DummyStructPtr& input) {
    return input->f_int8;
  }

  static bool Read(::mojo::test::blink::DummyStruct::DataView input, ::mojo::test::blink::DummyStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::SmallStruct::DataView,
                                         ::mojo::test::blink::SmallStructPtr> {
  static bool IsNull(const ::mojo::test::blink::SmallStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::SmallStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::SmallStruct::dummy_struct)& dummy_struct(
      const ::mojo::test::blink::SmallStructPtr& input) {
    return input->dummy_struct;
  }

  static const decltype(::mojo::test::blink::SmallStruct::pod_union)& pod_union(
      const ::mojo::test::blink::SmallStructPtr& input) {
    return input->pod_union;
  }

  static const decltype(::mojo::test::blink::SmallStruct::pod_union_array)& pod_union_array(
      const ::mojo::test::blink::SmallStructPtr& input) {
    return input->pod_union_array;
  }

  static const decltype(::mojo::test::blink::SmallStruct::nullable_pod_union_array)& nullable_pod_union_array(
      const ::mojo::test::blink::SmallStructPtr& input) {
    return input->nullable_pod_union_array;
  }

  static const decltype(::mojo::test::blink::SmallStruct::s_array)& s_array(
      const ::mojo::test::blink::SmallStructPtr& input) {
    return input->s_array;
  }

  static const decltype(::mojo::test::blink::SmallStruct::pod_union_map)& pod_union_map(
      const ::mojo::test::blink::SmallStructPtr& input) {
    return input->pod_union_map;
  }

  static const decltype(::mojo::test::blink::SmallStruct::nullable_pod_union_map)& nullable_pod_union_map(
      const ::mojo::test::blink::SmallStructPtr& input) {
    return input->nullable_pod_union_map;
  }

  static bool Read(::mojo::test::blink::SmallStruct::DataView input, ::mojo::test::blink::SmallStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::SmallStructNonNullableUnion::DataView,
                                         ::mojo::test::blink::SmallStructNonNullableUnionPtr> {
  static bool IsNull(const ::mojo::test::blink::SmallStructNonNullableUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::SmallStructNonNullableUnionPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::SmallStructNonNullableUnion::pod_union)& pod_union(
      const ::mojo::test::blink::SmallStructNonNullableUnionPtr& input) {
    return input->pod_union;
  }

  static bool Read(::mojo::test::blink::SmallStructNonNullableUnion::DataView input, ::mojo::test::blink::SmallStructNonNullableUnionPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::SmallObjStruct::DataView,
                                         ::mojo::test::blink::SmallObjStructPtr> {
  static bool IsNull(const ::mojo::test::blink::SmallObjStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::SmallObjStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::SmallObjStruct::obj_union)& obj_union(
      const ::mojo::test::blink::SmallObjStructPtr& input) {
    return input->obj_union;
  }

  static decltype(::mojo::test::blink::SmallObjStruct::f_int8) f_int8(
      const ::mojo::test::blink::SmallObjStructPtr& input) {
    return input->f_int8;
  }

  static bool Read(::mojo::test::blink::SmallObjStruct::DataView input, ::mojo::test::blink::SmallObjStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::TryNonNullStruct::DataView,
                                         ::mojo::test::blink::TryNonNullStructPtr> {
  static bool IsNull(const ::mojo::test::blink::TryNonNullStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::TryNonNullStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::TryNonNullStruct::nullable)& nullable(
      const ::mojo::test::blink::TryNonNullStructPtr& input) {
    return input->nullable;
  }

  static const decltype(::mojo::test::blink::TryNonNullStruct::non_nullable)& non_nullable(
      const ::mojo::test::blink::TryNonNullStructPtr& input) {
    return input->non_nullable;
  }

  static bool Read(::mojo::test::blink::TryNonNullStruct::DataView input, ::mojo::test::blink::TryNonNullStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::blink::ImportedUnionStruct::DataView,
                                         ::mojo::test::blink::ImportedUnionStructPtr> {
  static bool IsNull(const ::mojo::test::blink::ImportedUnionStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ImportedUnionStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::blink::ImportedUnionStruct::point_or_shape)& point_or_shape(
      const ::mojo::test::blink::ImportedUnionStructPtr& input) {
    return input->point_or_shape;
  }

  static bool Read(::mojo::test::blink::ImportedUnionStruct::DataView input, ::mojo::test::blink::ImportedUnionStructPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::blink::PodUnion::DataView,
                                        ::mojo::test::blink::PodUnionPtr> {
  static bool IsNull(const ::mojo::test::blink::PodUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::PodUnionPtr* output) { output->reset(); }

  static ::mojo::test::blink::PodUnion::Tag GetTag(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->which();
  }

  static  int8_t f_int8(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_int8();
  }

  static  int8_t f_int8_other(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_int8_other();
  }

  static  uint8_t f_uint8(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_uint8();
  }

  static  int16_t f_int16(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_int16();
  }

  static  uint16_t f_uint16(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_uint16();
  }

  static  int32_t f_int32(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_int32();
  }

  static  uint32_t f_uint32(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_uint32();
  }

  static  int64_t f_int64(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_int64();
  }

  static  uint64_t f_uint64(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_uint64();
  }

  static  float f_float(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_float();
  }

  static  double f_double(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_double();
  }

  static  bool f_bool(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_bool();
  }

  static  ::mojo::test::blink::AnEnum f_enum(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_enum();
  }

  static  ::mojo::test::blink::AnExtensibleEnum f_extensible_enum(const ::mojo::test::blink::PodUnionPtr& input) {
    return input->get_f_extensible_enum();
  }

  static bool Read(::mojo::test::blink::PodUnion::DataView input, ::mojo::test::blink::PodUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::blink::ObjectUnion::DataView,
                                        ::mojo::test::blink::ObjectUnionPtr> {
  static bool IsNull(const ::mojo::test::blink::ObjectUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ObjectUnionPtr* output) { output->reset(); }

  static ::mojo::test::blink::ObjectUnion::Tag GetTag(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->which();
  }

  static  int8_t f_int8(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->get_f_int8();
  }

  static const WTF::String& f_string(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->get_f_string();
  }

  static const ::mojo::test::blink::DummyStructPtr& f_dummy(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->get_f_dummy();
  }

  static const ::mojo::test::blink::DummyStructPtr& f_nullable(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->get_f_nullable();
  }

  static const WTF::Vector<int8_t>& f_array_int8(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->get_f_array_int8();
  }

  static const WTF::HashMap<WTF::String, int8_t>& f_map_int8(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->get_f_map_int8();
  }

  static const ::mojo::test::blink::PodUnionPtr& f_pod_union(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->get_f_pod_union();
  }

  static const WTF::Vector<::mojo::test::blink::SmallStructPtr>& f_small_structs(const ::mojo::test::blink::ObjectUnionPtr& input) {
    return input->get_f_small_structs();
  }

  static bool Read(::mojo::test::blink::ObjectUnion::DataView input, ::mojo::test::blink::ObjectUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::blink::HandleUnion::DataView,
                                        ::mojo::test::blink::HandleUnionPtr> {
  static bool IsNull(const ::mojo::test::blink::HandleUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::HandleUnionPtr* output) { output->reset(); }

  static ::mojo::test::blink::HandleUnion::Tag GetTag(const ::mojo::test::blink::HandleUnionPtr& input) {
    return input->which();
  }

  static  ::mojo::ScopedHandle& f_handle( ::mojo::test::blink::HandleUnionPtr& input) {
    return input->get_f_handle();
  }

  static  ::mojo::ScopedMessagePipeHandle& f_message_pipe( ::mojo::test::blink::HandleUnionPtr& input) {
    return input->get_f_message_pipe();
  }

  static  ::mojo::ScopedDataPipeConsumerHandle& f_data_pipe_consumer( ::mojo::test::blink::HandleUnionPtr& input) {
    return input->get_f_data_pipe_consumer();
  }

  static  ::mojo::ScopedDataPipeProducerHandle& f_data_pipe_producer( ::mojo::test::blink::HandleUnionPtr& input) {
    return input->get_f_data_pipe_producer();
  }

  static  ::mojo::ScopedSharedBufferHandle& f_shared_buffer( ::mojo::test::blink::HandleUnionPtr& input) {
    return input->get_f_shared_buffer();
  }

  static  ::mojo::PlatformHandle& f_platform( ::mojo::test::blink::HandleUnionPtr& input) {
    return input->get_f_platform();
  }

  static  ::mojo::PendingRemote<::mojo::test::blink::SmallCache>& f_small_cache( ::mojo::test::blink::HandleUnionPtr& input) {
    return input->get_f_small_cache();
  }

  static  ::mojo::PendingReceiver<::mojo::test::blink::SmallCache>& f_small_cache_receiver( ::mojo::test::blink::HandleUnionPtr& input) {
    return input->get_f_small_cache_receiver();
  }

  static bool Read(::mojo::test::blink::HandleUnion::DataView input, ::mojo::test::blink::HandleUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::blink::OldUnion::DataView,
                                        ::mojo::test::blink::OldUnionPtr> {
  static bool IsNull(const ::mojo::test::blink::OldUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::OldUnionPtr* output) { output->reset(); }

  static ::mojo::test::blink::OldUnion::Tag GetTag(const ::mojo::test::blink::OldUnionPtr& input) {
    return input->which();
  }

  static  int8_t f_int8(const ::mojo::test::blink::OldUnionPtr& input) {
    return input->get_f_int8();
  }

  static bool Read(::mojo::test::blink::OldUnion::DataView input, ::mojo::test::blink::OldUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::blink::NewUnion::DataView,
                                        ::mojo::test::blink::NewUnionPtr> {
  static bool IsNull(const ::mojo::test::blink::NewUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::NewUnionPtr* output) { output->reset(); }

  static ::mojo::test::blink::NewUnion::Tag GetTag(const ::mojo::test::blink::NewUnionPtr& input) {
    return input->which();
  }

  static  int8_t f_int8(const ::mojo::test::blink::NewUnionPtr& input) {
    return input->get_f_int8();
  }

  static  int16_t f_int16(const ::mojo::test::blink::NewUnionPtr& input) {
    return input->get_f_int16();
  }

  static bool Read(::mojo::test::blink::NewUnion::DataView input, ::mojo::test::blink::NewUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::blink::ImportedUnionUnion::DataView,
                                        ::mojo::test::blink::ImportedUnionUnionPtr> {
  static bool IsNull(const ::mojo::test::blink::ImportedUnionUnionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::ImportedUnionUnionPtr* output) { output->reset(); }

  static ::mojo::test::blink::ImportedUnionUnion::Tag GetTag(const ::mojo::test::blink::ImportedUnionUnionPtr& input) {
    return input->which();
  }

  static const ::imported::blink::PointOrShapePtr& point_or_shape(const ::mojo::test::blink::ImportedUnionUnionPtr& input) {
    return input->get_point_or_shape();
  }

  static bool Read(::mojo::test::blink::ImportedUnionUnion::DataView input, ::mojo::test::blink::ImportedUnionUnionPtr* output);
};


template <>
struct  UnionTraits<::mojo::test::blink::UnionWithStringForFirstField::DataView,
                                        ::mojo::test::blink::UnionWithStringForFirstFieldPtr> {
  static bool IsNull(const ::mojo::test::blink::UnionWithStringForFirstFieldPtr& input) { return !input; }
  static void SetToNull(::mojo::test::blink::UnionWithStringForFirstFieldPtr* output) { output->reset(); }

  static ::mojo::test::blink::UnionWithStringForFirstField::Tag GetTag(const ::mojo::test::blink::UnionWithStringForFirstFieldPtr& input) {
    return input->which();
  }

  static const WTF::String& s(const ::mojo::test::blink::UnionWithStringForFirstFieldPtr& input) {
    return input->get_s();
  }

  static  int32_t i(const ::mojo::test::blink::UnionWithStringForFirstFieldPtr& input) {
    return input->get_i();
  }

  static bool Read(::mojo::test::blink::UnionWithStringForFirstField::DataView input, ::mojo::test::blink::UnionWithStringForFirstFieldPtr* output);
};

}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_BLINK_H_

/* Metadata comment
eyJtZXRhIjogW3siZW5kIjogNDczMiwgImJlZ2luIjogNDcyMiwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbENhY2hlIn19LCB7ImVuZCI6
IDU0NDksICJiZWdpbiI6IDU0MzgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuU21hbGxDYWNoZS5TZXRJbnRWYWx1ZSJ9fSwgeyJlbmQiOiA1NjIz
LCAiYmVnaW4iOiA1NjEyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LlNtYWxsQ2FjaGUuR2V0SW50VmFsdWUifX0sIHsiZW5kIjogNTg5NywgImJl
Z2luIjogNTg4MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5VbmlvbkludGVyZmFjZSJ9fSwgeyJlbmQiOiA2NjU2LCAiYmVnaW4iOiA2NjUyLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuaW9u
SW50ZXJmYWNlLkVjaG8ifX0sIHsiZW5kIjogNjk5NSwgImJlZ2luIjogNjk4NCwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbENhY2hlLlNl
dEludFZhbHVlIn19LCB7ImVuZCI6IDcwOTYsICJiZWdpbiI6IDcwODUsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxDYWNoZS5HZXRJbnRW
YWx1ZSJ9fSwgeyJlbmQiOiA3NDk0LCAiYmVnaW4iOiA3NDkwLCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuaW9uSW50ZXJmYWNlLkVjaG8ifX0s
IHsiZW5kIjogMTA3MzAsICJiZWdpbiI6IDEwNzE5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkR1bW15U3RydWN0In19LCB7ImVuZCI6IDE0MzI4
LCAiYmVnaW4iOiAxNDMyMiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5EdW1teVN0cnVjdC5mX2ludDgifX0sIHsiZW5kIjogMTUzNDksICJiZWdp
biI6IDE1MzQxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlBvZFVuaW9uIn19LCB7ImVuZCI6IDE5OTUyLCAiYmVnaW4iOiAxOTk0MywgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5m
X2ludDgifX0sIHsiZW5kIjogMjAwNjIsICJiZWdpbiI6IDIwMDUyLCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlBvZFVuaW9uLmZfaW50OCJ9fSwg
eyJlbmQiOiAyMDIwMiwgImJlZ2luIjogMjAxOTIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9pbnQ4In19LCB7ImVuZCI6IDIw
MzAzLCAiYmVnaW4iOiAyMDI4OCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDhfb3RoZXIifX0sIHsiZW5kIjogMjA0MzEs
ICJiZWdpbiI6IDIwNDE1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LlBvZFVuaW9uLmZfaW50OF9vdGhlciJ9fSwgeyJlbmQiOiAyMDU5NSwgImJl
Z2luIjogMjA1NzksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuUG9kVW5pb24uZl9pbnQ4X290aGVyIn19LCB7ImVuZCI6IDIwNjkyLCAiYmVnaW4i
OiAyMDY4MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5Qb2RVbmlvbi5mX3VpbnQ4In19LCB7ImVuZCI6IDIwODA2LCAiYmVnaW4iOiAyMDc5NSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RV
bmlvbi5mX3VpbnQ4In19LCB7ImVuZCI6IDIwOTUwLCAiYmVnaW4iOiAyMDkzOSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX3Vp
bnQ4In19LCB7ImVuZCI6IDIxMDQzLCAiYmVnaW4iOiAyMTAzMywgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDE2In19LCB7
ImVuZCI6IDIxMTU3LCAiYmVnaW4iOiAyMTE0NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDE2In19LCB7ImVuZCI6IDIx
MzAxLCAiYmVnaW4iOiAyMTI5MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDE2In19LCB7ImVuZCI6IDIxMzk2LCAiYmVn
aW4iOiAyMTM4NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5Qb2RVbmlvbi5mX3VpbnQxNiJ9fSwgeyJlbmQiOiAyMTUxNCwgImJlZ2luIjogMjE1
MDIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
UG9kVW5pb24uZl91aW50MTYifX0sIHsiZW5kIjogMjE2NjIsICJiZWdpbiI6IDIxNjUwLCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlBvZFVuaW9u
LmZfdWludDE2In19LCB7ImVuZCI6IDIxNzU3LCAiYmVnaW4iOiAyMTc0NywgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDMy
In19LCB7ImVuZCI6IDIxODcxLCAiYmVnaW4iOiAyMTg2MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDMyIn19LCB7ImVu
ZCI6IDIyMDE1LCAiYmVnaW4iOiAyMjAwNCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDMyIn19LCB7ImVuZCI6IDIyMTEw
LCAiYmVnaW4iOiAyMjA5OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX3VpbnQzMiJ9fSwgeyJlbmQiOiAyMjIyOCwgImJlZ2lu
IjogMjIyMTYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuUG9kVW5pb24uZl91aW50MzIifX0sIHsiZW5kIjogMjIzNzYsICJiZWdpbiI6IDIyMzY0
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlBv
ZFVuaW9uLmZfdWludDMyIn19LCB7ImVuZCI6IDIyNDcxLCAiYmVnaW4iOiAyMjQ2MSwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5m
X2ludDY0In19LCB7ImVuZCI6IDIyNTg1LCAiYmVnaW4iOiAyMjU3NCwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDY0In19
LCB7ImVuZCI6IDIyNzI5LCAiYmVnaW4iOiAyMjcxOCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2ludDY0In19LCB7ImVuZCI6
IDIyODI0LCAiYmVnaW4iOiAyMjgxMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX3VpbnQ2NCJ9fSwgeyJlbmQiOiAyMjk0Miwg
ImJlZ2luIjogMjI5MzAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuUG9kVW5pb24uZl91aW50NjQifX0sIHsiZW5kIjogMjMwOTAsICJiZWdpbiI6
IDIzMDc4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0LlBvZFVuaW9uLmZfdWludDY0In19LCB7ImVuZCI6IDIzMTg1LCAiYmVnaW4iOiAyMzE3NSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RV
bmlvbi5mX2Zsb2F0In19LCB7ImVuZCI6IDIzMjk3LCAiYmVnaW4iOiAyMzI4NiwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2Zs
b2F0In19LCB7ImVuZCI6IDIzNDQxLCAiYmVnaW4iOiAyMzQzMCwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2Zsb2F0In19LCB7
ImVuZCI6IDIzNTM0LCAiYmVnaW4iOiAyMzUyMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2RvdWJsZSJ9fSwgeyJlbmQiOiAy
MzY1MCwgImJlZ2luIjogMjM2MzgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9kb3VibGUifX0sIHsiZW5kIjogMjM3OTgsICJi
ZWdpbiI6IDIzNzg2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0LlBvZFVuaW9uLmZfZG91YmxlIn19LCB7ImVuZCI6IDIzODg5LCAiYmVnaW4iOiAy
Mzg4MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9k
ZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9j
aHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVz
dC5Qb2RVbmlvbi5mX2Jvb2wifX0sIHsiZW5kIjogMjM5OTcsICJiZWdpbiI6IDIzOTg3LCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlBvZFVuaW9u
LmZfYm9vbCJ9fSwgeyJlbmQiOiAyNDEzNywgImJlZ2luIjogMjQxMjcsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUG9kVW5pb24uZl9ib29sIn19
LCB7ImVuZCI6IDI0MjI0LCAiYmVnaW4iOiAyNDIxNSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Qb2RVbmlvbi5mX2VudW0ifX0sIHsiZW5kIjog
MjQzMzQsICJiZWdpbiI6IDI0MzI0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0LlBvZFVuaW9uLmZfZW51bSJ9fSwgeyJlbmQiOiAyNDQ3NCwgImJl
Z2luIjogMjQ0NjQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuUG9kVW5pb24uZl9lbnVtIn19LCB7ImVuZCI6IDI0NTg1LCAiYmVnaW4iOiAyNDU2
NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Q
b2RVbmlvbi5mX2V4dGVuc2libGVfZW51bSJ9fSwgeyJlbmQiOiAyNDczOCwgImJlZ2luIjogMjQ3
MTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
UG9kVW5pb24uZl9leHRlbnNpYmxlX2VudW0ifX0sIHsiZW5kIjogMjQ5MjIsICJiZWdpbiI6IDI0
OTAxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LlBvZFVuaW9uLmZfZXh0ZW5zaWJsZV9lbnVtIn19LCB7ImVuZCI6IDI2MDYzLCAiYmVnaW4iOiAy
NjA1MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9k
ZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9j
aHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVz
dC5PYmplY3RVbmlvbiJ9fSwgeyJlbmQiOiAyOTUyOCwgImJlZ2luIjogMjk1MTksICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24u
Zl9pbnQ4In19LCB7ImVuZCI6IDI5NjQxLCAiYmVnaW4iOiAyOTYzMSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX2ludDgi
fX0sIHsiZW5kIjogMjk3ODQsICJiZWdpbiI6IDI5Nzc0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfaW50OCJ9fSwgeyJl
bmQiOiAyOTg4MCwgImJlZ2luIjogMjk4NjksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9zdHJpbmcifX0sIHsiZW5kIjog
MzAwMDUsICJiZWdpbiI6IDI5OTkzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfc3RyaW5nIn19LCB7ImVuZCI6IDMwMTU5
LCAiYmVnaW4iOiAzMDE0NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX3N0cmluZyJ9fSwgeyJlbmQiOiAzMDI2NywgImJl
Z2luIjogMzAyNTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuT2JqZWN0VW5pb24uZl9kdW1teSJ9fSwgeyJlbmQiOiAzMDM5MiwgImJlZ2luIjog
MzAzODEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuT2JqZWN0VW5pb24uZl9kdW1teSJ9fSwgeyJlbmQiOiAzMDU0MiwgImJlZ2luIjogMzA1MzEs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2Jq
ZWN0VW5pb24uZl9kdW1teSJ9fSwgeyJlbmQiOiAzMDY1MSwgImJlZ2luIjogMzA2MzgsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5p
b24uZl9udWxsYWJsZSJ9fSwgeyJlbmQiOiAzMDc4NSwgImJlZ2luIjogMzA3NzEsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24u
Zl9udWxsYWJsZSJ9fSwgeyJlbmQiOiAzMDk0NywgImJlZ2luIjogMzA5MzMsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9u
dWxsYWJsZSJ9fSwgeyJlbmQiOiAzMTA2MywgImJlZ2luIjogMzEwNDgsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9hcnJh
eV9pbnQ4In19LCB7ImVuZCI6IDMxMjA4LCAiYmVnaW4iOiAzMTE5MiwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX2FycmF5
X2ludDgifX0sIHsiZW5kIjogMzEzNzgsICJiZWdpbiI6IDMxMzYyLCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfYXJyYXlf
aW50OCJ9fSwgeyJlbmQiOiAzMTQ5NywgImJlZ2luIjogMzE0ODQsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9tYXBfaW50
OCJ9fSwgeyJlbmQiOiAzMTY1MCwgImJlZ2luIjogMzE2MzYsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9tYXBfaW50OCJ9
fSwgeyJlbmQiOiAzMTgxMiwgImJlZ2luIjogMzE3OTgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9tYXBfaW50OCJ9fSwg
eyJlbmQiOiAzMTk1MiwgImJlZ2luIjogMzE5MzgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9wb2RfdW5pb24ifX0sIHsi
ZW5kIjogMzIwODYsICJiZWdpbiI6IDMyMDcxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfcG9kX3VuaW9uIn19LCB7ImVu
ZCI6IDMyMjUyLCAiYmVnaW4iOiAzMjIzNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX3BvZF91bmlvbiJ9fSwgeyJlbmQi
OiAzMjM3MiwgImJlZ2luIjogMzIzNTQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuT2JqZWN0VW5pb24uZl9zbWFsbF9zdHJ1Y3RzIn19LCB7ImVu
ZCI6IDMyNTM0LCAiYmVnaW4iOiAzMjUxNSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5PYmplY3RVbmlvbi5mX3NtYWxsX3N0cnVjdHMifX0sIHsi
ZW5kIjogMzI3MTYsICJiZWdpbiI6IDMyNjk3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9iamVjdFVuaW9uLmZfc21hbGxfc3RydWN0cyJ9fSwg
eyJlbmQiOiAzMzgzNiwgImJlZ2luIjogMzM4MjUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSGFuZGxlVW5pb24ifX0sIHsiZW5kIjogMzc2MTEs
ICJiZWdpbiI6IDM3NjAwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZfaGFuZGxlIn19LCB7ImVuZCI6IDM3NzQ1LCAiYmVn
aW4iOiAzNzczMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5IYW5kbGVVbmlvbi5mX2hhbmRsZSJ9fSwgeyJlbmQiOiAzNzg5OSwgImJlZ2luIjog
Mzc4ODcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuSGFuZGxlVW5pb24uZl9oYW5kbGUifX0sIHsiZW5kIjogMzgwMjMsICJiZWdpbiI6IDM4MDA2
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lkhh
bmRsZVVuaW9uLmZfbWVzc2FnZV9waXBlIn19LCB7ImVuZCI6IDM4MTg2LCAiYmVnaW4iOiAzODE2
OCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5I
YW5kbGVVbmlvbi5mX21lc3NhZ2VfcGlwZSJ9fSwgeyJlbmQiOiAzODM2NCwgImJlZ2luIjogMzgz
NDYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
SGFuZGxlVW5pb24uZl9tZXNzYWdlX3BpcGUifX0sIHsiZW5kIjogMzg1MTcsICJiZWdpbiI6IDM4
NDk0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkhhbmRsZVVuaW9uLmZfZGF0YV9waXBlX2NvbnN1bWVyIn19LCB7ImVuZCI6IDM4NzAzLCAiYmVn
aW4iOiAzODY3OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5IYW5kbGVVbmlvbi5mX2RhdGFfcGlwZV9jb25zdW1lciJ9fSwgeyJlbmQiOiAzODkw
NSwgImJlZ2luIjogMzg4ODEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuSGFuZGxlVW5pb24uZl9kYXRhX3BpcGVfY29uc3VtZXIifX0sIHsiZW5k
IjogMzkwNjksICJiZWdpbiI6IDM5MDQ2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZfZGF0YV9waXBlX3Byb2R1Y2VyIn19
LCB7ImVuZCI6IDM5MjU1LCAiYmVnaW4iOiAzOTIzMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlvbi5mX2RhdGFfcGlwZV9wcm9k
dWNlciJ9fSwgeyJlbmQiOiAzOTQ1NywgImJlZ2luIjogMzk0MzMsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSGFuZGxlVW5pb24uZl9kYXRhX3Bp
cGVfcHJvZHVjZXIifX0sIHsiZW5kIjogMzk2MTEsICJiZWdpbiI6IDM5NTkzLCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZf
c2hhcmVkX2J1ZmZlciJ9fSwgeyJlbmQiOiAzOTc3OCwgImJlZ2luIjogMzk3NTksICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSGFuZGxlVW5pb24u
Zl9zaGFyZWRfYnVmZmVyIn19LCB7ImVuZCI6IDM5OTYwLCAiYmVnaW4iOiAzOTk0MSwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5IYW5kbGVVbmlv
bi5mX3NoYXJlZF9idWZmZXIifX0sIHsiZW5kIjogNDAwOTUsICJiZWdpbiI6IDQwMDgyLCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVu
aW9uLmZfcGxhdGZvcm0ifX0sIHsiZW5kIjogNDAyMzcsICJiZWdpbiI6IDQwMjIzLCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9u
LmZfcGxhdGZvcm0ifX0sIHsiZW5kIjogNDAzOTksICJiZWdpbiI6IDQwMzg1LCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZf
cGxhdGZvcm0ifX0sIHsiZW5kIjogNDA1MjUsICJiZWdpbiI6IDQwNTA5LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZfc21h
bGxfY2FjaGUifX0sIHsiZW5kIjogNDA2ODcsICJiZWdpbiI6IDQwNjcwLCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZfc21h
bGxfY2FjaGUifX0sIHsiZW5kIjogNDA4NjEsICJiZWdpbiI6IDQwODQ0LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZfc21h
bGxfY2FjaGUifX0sIHsiZW5kIjogNDEwMTksICJiZWdpbiI6IDQwOTk0LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVuaW9uLmZfc21h
bGxfY2FjaGVfcmVjZWl2ZXIifX0sIHsiZW5kIjogNDEyMTAsICJiZWdpbiI6IDQxMTg0LCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkhhbmRsZVVu
aW9uLmZfc21hbGxfY2FjaGVfcmVjZWl2ZXIifX0sIHsiZW5kIjogNDE0MjAsICJiZWdpbiI6IDQx
Mzk0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkhhbmRsZVVuaW9uLmZfc21hbGxfY2FjaGVfcmVjZWl2ZXIifX0sIHsiZW5kIjogNDI3MDMsICJi
ZWdpbiI6IDQyNjk1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0Lk9sZFVuaW9uIn19LCB7ImVuZCI6IDQ0MzU5LCAiYmVnaW4iOiA0NDM1MCwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5PbGRVbmlv
bi5mX2ludDgifX0sIHsiZW5kIjogNDQ0NjksICJiZWdpbiI6IDQ0NDU5LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk9sZFVuaW9uLmZfaW50OCJ9
fSwgeyJlbmQiOiA0NDYwOSwgImJlZ2luIjogNDQ1OTksICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuT2xkVW5pb24uZl9pbnQ4In19LCB7ImVuZCI6
IDQ1NDI5LCAiYmVnaW4iOiA0NTQyMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5OZXdVbmlvbiJ9fSwgeyJlbmQiOiA0NzMwNSwgImJlZ2luIjog
NDcyOTYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuTmV3VW5pb24uZl9pbnQ4In19LCB7ImVuZCI6IDQ3NDE1LCAiYmVnaW4iOiA0NzQwNSwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5OZXdVbmlv
bi5mX2ludDgifX0sIHsiZW5kIjogNDc1NTUsICJiZWdpbiI6IDQ3NTQ1LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5ld1VuaW9uLmZfaW50OCJ9
fSwgeyJlbmQiOiA0NzY0NiwgImJlZ2luIjogNDc2MzYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTmV3VW5pb24uZl9pbnQxNiJ9fSwgeyJlbmQi
OiA0Nzc2MCwgImJlZ2luIjogNDc3NDksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuTmV3VW5pb24uZl9pbnQxNiJ9fSwgeyJlbmQiOiA0NzkwNCwg
ImJlZ2luIjogNDc4OTMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuTmV3VW5pb24uZl9pbnQxNiJ9fSwgeyJlbmQiOiA0ODc2NywgImJlZ2luIjog
NDg3NDksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuSW1wb3J0ZWRVbmlvblVuaW9uIn19LCB7ImVuZCI6IDUwNjc2LCAiYmVnaW4iOiA1MDY1OSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbXBv
cnRlZFVuaW9uVW5pb24ucG9pbnRfb3Jfc2hhcGUifX0sIHsiZW5kIjogNTA4NDksICJiZWdpbiI6
IDUwODMxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0LkltcG9ydGVkVW5pb25Vbmlvbi5wb2ludF9vcl9zaGFwZSJ9fSwgeyJlbmQiOiA1MTAzNCwg
ImJlZ2luIjogNTEwMTYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuSW1wb3J0ZWRVbmlvblVuaW9uLnBvaW50X29yX3NoYXBlIn19LCB7ImVuZCI6
IDUxOTg3LCAiYmVnaW4iOiA1MTk1OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5VbmlvbldpdGhTdHJpbmdGb3JGaXJzdEZpZWxkIn19LCB7ImVu
ZCI6IDU0MTkyLCAiYmVnaW4iOiA1NDE4OCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5VbmlvbldpdGhTdHJpbmdGb3JGaXJzdEZpZWxkLnMifX0s
IHsiZW5kIjogNTQzMTMsICJiZWdpbiI6IDU0MzA4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuaW9uV2l0aFN0cmluZ0ZvckZpcnN0RmllbGQu
cyJ9fSwgeyJlbmQiOiA1NDQ1NiwgImJlZ2luIjogNTQ0NTEsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5pb25XaXRoU3RyaW5nRm9yRmlyc3RG
aWVsZC5zIn19LCB7ImVuZCI6IDU0NTYyLCAiYmVnaW4iOiA1NDU1OCwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5VbmlvbldpdGhTdHJpbmdGb3JG
aXJzdEZpZWxkLmkifX0sIHsiZW5kIjogNTQ2NzgsICJiZWdpbiI6IDU0NjczLCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuaW9uV2l0aFN0cmlu
Z0ZvckZpcnN0RmllbGQuaSJ9fSwgeyJlbmQiOiA1NDgxOCwgImJlZ2luIjogNTQ4MTMsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5pb25XaXRo
U3RyaW5nRm9yRmlyc3RGaWVsZC5pIn19LCB7ImVuZCI6IDU1NzAyLCAiYmVnaW4iOiA1NTY4OSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5XcmFw
cGVyU3RydWN0In19LCB7ImVuZCI6IDU5MjA2LCAiYmVnaW4iOiA1OTE5NCwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5XcmFwcGVyU3RydWN0Lm9i
amVjdF91bmlvbiJ9fSwgeyJlbmQiOiA1OTI4OCwgImJlZ2luIjogNTkyNzksICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuV3JhcHBlclN0cnVjdC5w
b2RfdW5pb24ifX0sIHsiZW5kIjogNTkzNzksICJiZWdpbiI6IDU5MzY3LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LldyYXBwZXJTdHJ1Y3QuaGFu
ZGxlX3VuaW9uIn19LCB7ImVuZCI6IDYwNDUzLCAiYmVnaW4iOiA2MDQ0MiwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbFN0cnVjdCJ9fSwg
eyJlbmQiOiA2NDQyOCwgImJlZ2luIjogNjQ0MTYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxTdHJ1Y3QuZHVtbXlfc3RydWN0In19LCB7
ImVuZCI6IDY0NTA4LCAiYmVnaW4iOiA2NDQ5OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbFN0cnVjdC5wb2RfdW5pb24ifX0sIHsiZW5k
IjogNjQ2MjksICJiZWdpbiI6IDY0NjE0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0LlNtYWxsU3RydWN0LnBvZF91bmlvbl9hcnJheSJ9fSwgeyJl
bmQiOiA2NDc2OCwgImJlZ2luIjogNjQ3NDQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU21hbGxTdHJ1Y3QubnVsbGFibGVfcG9kX3VuaW9uX2Fy
cmF5In19LCB7ImVuZCI6IDY0ODc2LCAiYmVnaW4iOiA2NDg2OSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbFN0cnVjdC5zX2FycmF5In19
LCB7ImVuZCI6IDY1MDA3LCAiYmVnaW4iOiA2NDk5NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbFN0cnVjdC5wb2RfdW5pb25fbWFwIn19
LCB7ImVuZCI6IDY1MTU2LCAiYmVnaW4iOiA2NTEzNCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbFN0cnVjdC5udWxsYWJsZV9wb2RfdW5p
b25fbWFwIn19LCB7ImVuZCI6IDY2MjUxLCAiYmVnaW4iOiA2NjIyNCwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbFN0cnVjdE5vbk51bGxh
YmxlVW5pb24ifX0sIHsiZW5kIjogNzAyNjgsICJiZWdpbiI6IDcwMjU5LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNtYWxsU3RydWN0Tm9uTnVs
bGFibGVVbmlvbi5wb2RfdW5pb24ifX0sIHsiZW5kIjogNzE0MTcsICJiZWdpbiI6IDcxNDAzLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNtYWxs
T2JqU3RydWN0In19LCB7ImVuZCI6IDc1MDkzLCAiYmVnaW4iOiA3NTA4NCwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TbWFsbE9ialN0cnVjdC5v
YmpfdW5pb24ifX0sIHsiZW5kIjogNzUxNjUsICJiZWdpbiI6IDc1MTU5LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNtYWxsT2JqU3RydWN0LmZf
aW50OCJ9fSwgeyJlbmQiOiA3NjI1MywgImJlZ2luIjogNzYyMzcsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVHJ5Tm9uTnVsbFN0cnVjdCJ9fSwg
eyJlbmQiOiA3OTk5MCwgImJlZ2luIjogNzk5ODIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVHJ5Tm9uTnVsbFN0cnVjdC5udWxsYWJsZSJ9fSwg
eyJlbmQiOiA4MDA4NCwgImJlZ2luIjogODAwNzIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVHJ5Tm9uTnVsbFN0cnVjdC5ub25fbnVsbGFibGUi
fX0sIHsiZW5kIjogODExODgsICJiZWdpbiI6IDgxMTY5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkltcG9ydGVkVW5pb25TdHJ1Y3QifX0sIHsi
ZW5kIjogODUwNjYsICJiZWdpbiI6IDg1MDUyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkltcG9ydGVkVW5pb25TdHJ1Y3QucG9pbnRfb3Jfc2hh
cGUifX1dLCAidHlwZSI6ICJreXRoZTAifQ==
*/