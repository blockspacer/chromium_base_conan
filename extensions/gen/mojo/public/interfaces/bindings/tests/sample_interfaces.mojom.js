// mojo/public/interfaces/bindings/tests/sample_interfaces.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'mojo/public/interfaces/bindings/tests/sample_interfaces.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('sample');
  var generic_pending_receiver$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/generic_pending_receiver.mojom', '../../../mojom/base/generic_pending_receiver.mojom.js');
  }


  var LONG = 4405;
  var Enum = {};
  Enum.VALUE = 0;
  Enum.MIN_VALUE = 0;
  Enum.MAX_VALUE = 0;

  Enum.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
      return true;
    }
    return false;
  };

  Enum.toKnownEnumValue = function(value) {
    return value;
  };

  Enum.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function PingTest_Ping_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PingTest_Ping_Params.prototype.initDefaults_ = function() {
  };
  PingTest_Ping_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PingTest_Ping_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PingTest_Ping_Params.encodedSize = codec.kStructHeaderSize + 0;

  PingTest_Ping_Params.decode = function(decoder) {
    var packed;
    var val = new PingTest_Ping_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  PingTest_Ping_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PingTest_Ping_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function PingTest_Ping_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PingTest_Ping_ResponseParams.prototype.initDefaults_ = function() {
  };
  PingTest_Ping_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PingTest_Ping_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PingTest_Ping_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  PingTest_Ping_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new PingTest_Ping_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  PingTest_Ping_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PingTest_Ping_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function Provider_EchoString_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoString_Params.prototype.initDefaults_ = function() {
    this.a = null;
  };
  Provider_EchoString_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoString_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoString_Params.a
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Provider_EchoString_Params.encodedSize = codec.kStructHeaderSize + 8;

  Provider_EchoString_Params.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoString_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.String);
    return val;
  };

  Provider_EchoString_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoString_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.a);
  };
  function Provider_EchoString_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoString_ResponseParams.prototype.initDefaults_ = function() {
    this.a = null;
  };
  Provider_EchoString_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoString_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoString_ResponseParams.a
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Provider_EchoString_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Provider_EchoString_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoString_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.String);
    return val;
  };

  Provider_EchoString_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoString_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.a);
  };
  function Provider_EchoStrings_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoStrings_Params.prototype.initDefaults_ = function() {
    this.a = null;
    this.b = null;
  };
  Provider_EchoStrings_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoStrings_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoStrings_Params.a
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoStrings_Params.b
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Provider_EchoStrings_Params.encodedSize = codec.kStructHeaderSize + 16;

  Provider_EchoStrings_Params.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoStrings_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.String);
    val.b =
        decoder.decodeStruct(codec.String);
    return val;
  };

  Provider_EchoStrings_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoStrings_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.a);
    encoder.encodeStruct(codec.String, val.b);
  };
  function Provider_EchoStrings_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoStrings_ResponseParams.prototype.initDefaults_ = function() {
    this.a = null;
    this.b = null;
  };
  Provider_EchoStrings_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoStrings_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoStrings_ResponseParams.a
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoStrings_ResponseParams.b
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Provider_EchoStrings_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  Provider_EchoStrings_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoStrings_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.String);
    val.b =
        decoder.decodeStruct(codec.String);
    return val;
  };

  Provider_EchoStrings_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoStrings_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.a);
    encoder.encodeStruct(codec.String, val.b);
  };
  function Provider_EchoMessagePipeHandle_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoMessagePipeHandle_Params.prototype.initDefaults_ = function() {
    this.a = null;
  };
  Provider_EchoMessagePipeHandle_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoMessagePipeHandle_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoMessagePipeHandle_Params.a
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Provider_EchoMessagePipeHandle_Params.encodedSize = codec.kStructHeaderSize + 8;

  Provider_EchoMessagePipeHandle_Params.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoMessagePipeHandle_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Provider_EchoMessagePipeHandle_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoMessagePipeHandle_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Handle, val.a);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Provider_EchoMessagePipeHandle_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoMessagePipeHandle_ResponseParams.prototype.initDefaults_ = function() {
    this.a = null;
  };
  Provider_EchoMessagePipeHandle_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoMessagePipeHandle_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoMessagePipeHandle_ResponseParams.a
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Provider_EchoMessagePipeHandle_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Provider_EchoMessagePipeHandle_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoMessagePipeHandle_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Provider_EchoMessagePipeHandle_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoMessagePipeHandle_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Handle, val.a);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Provider_EchoEnum_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoEnum_Params.prototype.initDefaults_ = function() {
    this.a = 0;
  };
  Provider_EchoEnum_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoEnum_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoEnum_Params.a
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, Enum);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Provider_EchoEnum_Params.encodedSize = codec.kStructHeaderSize + 8;

  Provider_EchoEnum_Params.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoEnum_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(new codec.Enum(Enum));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Provider_EchoEnum_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoEnum_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.a);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Provider_EchoEnum_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoEnum_ResponseParams.prototype.initDefaults_ = function() {
    this.a = 0;
  };
  Provider_EchoEnum_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoEnum_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Provider_EchoEnum_ResponseParams.a
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, Enum);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Provider_EchoEnum_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Provider_EchoEnum_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoEnum_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(new codec.Enum(Enum));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Provider_EchoEnum_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoEnum_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.a);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Provider_EchoInt_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoInt_Params.prototype.initDefaults_ = function() {
    this.a = 0;
  };
  Provider_EchoInt_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoInt_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  Provider_EchoInt_Params.encodedSize = codec.kStructHeaderSize + 8;

  Provider_EchoInt_Params.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoInt_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Provider_EchoInt_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoInt_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.a);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Provider_EchoInt_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Provider_EchoInt_ResponseParams.prototype.initDefaults_ = function() {
    this.a = 0;
  };
  Provider_EchoInt_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Provider_EchoInt_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  Provider_EchoInt_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Provider_EchoInt_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Provider_EchoInt_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Provider_EchoInt_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Provider_EchoInt_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.a);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function IntegerAccessor_GetInteger_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IntegerAccessor_GetInteger_Params.prototype.initDefaults_ = function() {
  };
  IntegerAccessor_GetInteger_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IntegerAccessor_GetInteger_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IntegerAccessor_GetInteger_Params.encodedSize = codec.kStructHeaderSize + 0;

  IntegerAccessor_GetInteger_Params.decode = function(decoder) {
    var packed;
    var val = new IntegerAccessor_GetInteger_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  IntegerAccessor_GetInteger_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IntegerAccessor_GetInteger_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function IntegerAccessor_GetInteger_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IntegerAccessor_GetInteger_ResponseParams.prototype.initDefaults_ = function() {
    this.data = 0;
    this.type = 0;
  };
  IntegerAccessor_GetInteger_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IntegerAccessor_GetInteger_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16},
      {version: 2, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    // version check IntegerAccessor_GetInteger_ResponseParams.type
    if (!messageValidator.isFieldInStructVersion(offset, 2))
      return validator.validationError.NONE;
    // validate IntegerAccessor_GetInteger_ResponseParams.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, Enum);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IntegerAccessor_GetInteger_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  IntegerAccessor_GetInteger_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new IntegerAccessor_GetInteger_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data =
        decoder.decodeStruct(codec.Int64);
    if (version >= 2) {
      val.type =
          decoder.decodeStruct(new codec.Enum(Enum));
    } else {
      val.type = null;
    }
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  IntegerAccessor_GetInteger_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IntegerAccessor_GetInteger_ResponseParams.encodedSize);
    encoder.writeUint32(2);
    encoder.encodeStruct(codec.Int64, val.data);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function IntegerAccessor_SetInteger_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IntegerAccessor_SetInteger_Params.prototype.initDefaults_ = function() {
    this.data = 0;
    this.type = 0;
  };
  IntegerAccessor_SetInteger_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IntegerAccessor_SetInteger_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16},
      {version: 3, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    // version check IntegerAccessor_SetInteger_Params.type
    if (!messageValidator.isFieldInStructVersion(offset, 3))
      return validator.validationError.NONE;
    // validate IntegerAccessor_SetInteger_Params.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, Enum);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IntegerAccessor_SetInteger_Params.encodedSize = codec.kStructHeaderSize + 16;

  IntegerAccessor_SetInteger_Params.decode = function(decoder) {
    var packed;
    var val = new IntegerAccessor_SetInteger_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data =
        decoder.decodeStruct(codec.Int64);
    if (version >= 3) {
      val.type =
          decoder.decodeStruct(new codec.Enum(Enum));
    } else {
      val.type = null;
    }
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  IntegerAccessor_SetInteger_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IntegerAccessor_SetInteger_Params.encodedSize);
    encoder.writeUint32(3);
    encoder.encodeStruct(codec.Int64, val.data);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function InterfaceFactory_BindInterface_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  InterfaceFactory_BindInterface_Params.prototype.initDefaults_ = function() {
    this.receiver = null;
  };
  InterfaceFactory_BindInterface_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  InterfaceFactory_BindInterface_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InterfaceFactory_BindInterface_Params.receiver
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, generic_pending_receiver$.GenericPendingReceiver, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  InterfaceFactory_BindInterface_Params.encodedSize = codec.kStructHeaderSize + 8;

  InterfaceFactory_BindInterface_Params.decode = function(decoder) {
    var packed;
    var val = new InterfaceFactory_BindInterface_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.receiver =
        decoder.decodeStructPointer(generic_pending_receiver$.GenericPendingReceiver);
    return val;
  };

  InterfaceFactory_BindInterface_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(InterfaceFactory_BindInterface_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(generic_pending_receiver$.GenericPendingReceiver, val.receiver);
  };
  var kPingTest_Ping_Name = 0;

  function PingTestPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(PingTest,
                                                   handleOrPtrInfo);
  }

  function PingTestAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        PingTest, associatedInterfacePtrInfo);
  }

  PingTestAssociatedPtr.prototype =
      Object.create(PingTestPtr.prototype);
  PingTestAssociatedPtr.prototype.constructor =
      PingTestAssociatedPtr;

  function PingTestProxy(receiver) {
    this.receiver_ = receiver;
  }
  PingTestPtr.prototype.ping = function() {
    return PingTestProxy.prototype.ping
        .apply(this.ptr.getProxy(), arguments);
  };

  PingTestProxy.prototype.ping = function() {
    var params_ = new PingTest_Ping_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kPingTest_Ping_Name,
          codec.align(PingTest_Ping_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(PingTest_Ping_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(PingTest_Ping_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function PingTestStub(delegate) {
    this.delegate_ = delegate;
  }
  PingTestStub.prototype.ping = function() {
    return this.delegate_ && this.delegate_.ping && this.delegate_.ping();
  }

  PingTestStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  PingTestStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kPingTest_Ping_Name:
      var params = reader.decodeStruct(PingTest_Ping_Params);
      this.ping().then(function(response) {
        var responseParams =
            new PingTest_Ping_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kPingTest_Ping_Name,
            codec.align(PingTest_Ping_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(PingTest_Ping_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validatePingTestRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kPingTest_Ping_Name:
        if (message.expectsResponse())
          paramsClass = PingTest_Ping_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validatePingTestResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kPingTest_Ping_Name:
        if (message.isResponse())
          paramsClass = PingTest_Ping_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var PingTest = {
    name: 'sample.PingTest',
    kVersion: 0,
    ptrClass: PingTestPtr,
    proxyClass: PingTestProxy,
    stubClass: PingTestStub,
    validateRequest: validatePingTestRequest,
    validateResponse: validatePingTestResponse,
  };
  PingTestStub.prototype.validator = validatePingTestRequest;
  PingTestProxy.prototype.validator = validatePingTestResponse;
  var kProvider_EchoString_Name = 0;
  var kProvider_EchoStrings_Name = 1;
  var kProvider_EchoMessagePipeHandle_Name = 2;
  var kProvider_EchoEnum_Name = 3;
  var kProvider_EchoInt_Name = 4;

  function ProviderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(Provider,
                                                   handleOrPtrInfo);
  }

  function ProviderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        Provider, associatedInterfacePtrInfo);
  }

  ProviderAssociatedPtr.prototype =
      Object.create(ProviderPtr.prototype);
  ProviderAssociatedPtr.prototype.constructor =
      ProviderAssociatedPtr;

  function ProviderProxy(receiver) {
    this.receiver_ = receiver;
  }
  ProviderPtr.prototype.echoString = function() {
    return ProviderProxy.prototype.echoString
        .apply(this.ptr.getProxy(), arguments);
  };

  ProviderProxy.prototype.echoString = function(a) {
    var params_ = new Provider_EchoString_Params();
    params_.a = a;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kProvider_EchoString_Name,
          codec.align(Provider_EchoString_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Provider_EchoString_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Provider_EchoString_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  ProviderPtr.prototype.echoStrings = function() {
    return ProviderProxy.prototype.echoStrings
        .apply(this.ptr.getProxy(), arguments);
  };

  ProviderProxy.prototype.echoStrings = function(a, b) {
    var params_ = new Provider_EchoStrings_Params();
    params_.a = a;
    params_.b = b;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kProvider_EchoStrings_Name,
          codec.align(Provider_EchoStrings_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Provider_EchoStrings_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Provider_EchoStrings_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  ProviderPtr.prototype.echoMessagePipeHandle = function() {
    return ProviderProxy.prototype.echoMessagePipeHandle
        .apply(this.ptr.getProxy(), arguments);
  };

  ProviderProxy.prototype.echoMessagePipeHandle = function(a) {
    var params_ = new Provider_EchoMessagePipeHandle_Params();
    params_.a = a;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kProvider_EchoMessagePipeHandle_Name,
          codec.align(Provider_EchoMessagePipeHandle_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Provider_EchoMessagePipeHandle_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Provider_EchoMessagePipeHandle_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  ProviderPtr.prototype.echoEnum = function() {
    return ProviderProxy.prototype.echoEnum
        .apply(this.ptr.getProxy(), arguments);
  };

  ProviderProxy.prototype.echoEnum = function(a) {
    var params_ = new Provider_EchoEnum_Params();
    params_.a = a;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kProvider_EchoEnum_Name,
          codec.align(Provider_EchoEnum_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Provider_EchoEnum_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Provider_EchoEnum_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  ProviderPtr.prototype.echoInt = function() {
    return ProviderProxy.prototype.echoInt
        .apply(this.ptr.getProxy(), arguments);
  };

  ProviderProxy.prototype.echoInt = function(a) {
    var params_ = new Provider_EchoInt_Params();
    params_.a = a;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kProvider_EchoInt_Name,
          codec.align(Provider_EchoInt_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Provider_EchoInt_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Provider_EchoInt_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function ProviderStub(delegate) {
    this.delegate_ = delegate;
  }
  ProviderStub.prototype.echoString = function(a) {
    return this.delegate_ && this.delegate_.echoString && this.delegate_.echoString(a);
  }
  ProviderStub.prototype.echoStrings = function(a, b) {
    return this.delegate_ && this.delegate_.echoStrings && this.delegate_.echoStrings(a, b);
  }
  ProviderStub.prototype.echoMessagePipeHandle = function(a) {
    return this.delegate_ && this.delegate_.echoMessagePipeHandle && this.delegate_.echoMessagePipeHandle(a);
  }
  ProviderStub.prototype.echoEnum = function(a) {
    return this.delegate_ && this.delegate_.echoEnum && this.delegate_.echoEnum(a);
  }
  ProviderStub.prototype.echoInt = function(a) {
    return this.delegate_ && this.delegate_.echoInt && this.delegate_.echoInt(a);
  }

  ProviderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  ProviderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kProvider_EchoString_Name:
      var params = reader.decodeStruct(Provider_EchoString_Params);
      this.echoString(params.a).then(function(response) {
        var responseParams =
            new Provider_EchoString_ResponseParams();
        responseParams.a = response.a;
        var builder = new codec.MessageV1Builder(
            kProvider_EchoString_Name,
            codec.align(Provider_EchoString_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Provider_EchoString_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kProvider_EchoStrings_Name:
      var params = reader.decodeStruct(Provider_EchoStrings_Params);
      this.echoStrings(params.a, params.b).then(function(response) {
        var responseParams =
            new Provider_EchoStrings_ResponseParams();
        responseParams.a = response.a;
        responseParams.b = response.b;
        var builder = new codec.MessageV1Builder(
            kProvider_EchoStrings_Name,
            codec.align(Provider_EchoStrings_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Provider_EchoStrings_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kProvider_EchoMessagePipeHandle_Name:
      var params = reader.decodeStruct(Provider_EchoMessagePipeHandle_Params);
      this.echoMessagePipeHandle(params.a).then(function(response) {
        var responseParams =
            new Provider_EchoMessagePipeHandle_ResponseParams();
        responseParams.a = response.a;
        var builder = new codec.MessageV1Builder(
            kProvider_EchoMessagePipeHandle_Name,
            codec.align(Provider_EchoMessagePipeHandle_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Provider_EchoMessagePipeHandle_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kProvider_EchoEnum_Name:
      var params = reader.decodeStruct(Provider_EchoEnum_Params);
      this.echoEnum(params.a).then(function(response) {
        var responseParams =
            new Provider_EchoEnum_ResponseParams();
        responseParams.a = response.a;
        var builder = new codec.MessageV1Builder(
            kProvider_EchoEnum_Name,
            codec.align(Provider_EchoEnum_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Provider_EchoEnum_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kProvider_EchoInt_Name:
      var params = reader.decodeStruct(Provider_EchoInt_Params);
      this.echoInt(params.a).then(function(response) {
        var responseParams =
            new Provider_EchoInt_ResponseParams();
        responseParams.a = response.a;
        var builder = new codec.MessageV1Builder(
            kProvider_EchoInt_Name,
            codec.align(Provider_EchoInt_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Provider_EchoInt_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateProviderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kProvider_EchoString_Name:
        if (message.expectsResponse())
          paramsClass = Provider_EchoString_Params;
      break;
      case kProvider_EchoStrings_Name:
        if (message.expectsResponse())
          paramsClass = Provider_EchoStrings_Params;
      break;
      case kProvider_EchoMessagePipeHandle_Name:
        if (message.expectsResponse())
          paramsClass = Provider_EchoMessagePipeHandle_Params;
      break;
      case kProvider_EchoEnum_Name:
        if (message.expectsResponse())
          paramsClass = Provider_EchoEnum_Params;
      break;
      case kProvider_EchoInt_Name:
        if (message.expectsResponse())
          paramsClass = Provider_EchoInt_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateProviderResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kProvider_EchoString_Name:
        if (message.isResponse())
          paramsClass = Provider_EchoString_ResponseParams;
        break;
      case kProvider_EchoStrings_Name:
        if (message.isResponse())
          paramsClass = Provider_EchoStrings_ResponseParams;
        break;
      case kProvider_EchoMessagePipeHandle_Name:
        if (message.isResponse())
          paramsClass = Provider_EchoMessagePipeHandle_ResponseParams;
        break;
      case kProvider_EchoEnum_Name:
        if (message.isResponse())
          paramsClass = Provider_EchoEnum_ResponseParams;
        break;
      case kProvider_EchoInt_Name:
        if (message.isResponse())
          paramsClass = Provider_EchoInt_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var Provider = {
    name: 'sample.Provider',
    kVersion: 0,
    ptrClass: ProviderPtr,
    proxyClass: ProviderProxy,
    stubClass: ProviderStub,
    validateRequest: validateProviderRequest,
    validateResponse: validateProviderResponse,
  };
  ProviderStub.prototype.validator = validateProviderRequest;
  ProviderProxy.prototype.validator = validateProviderResponse;
  var kIntegerAccessor_GetInteger_Name = 0;
  var kIntegerAccessor_SetInteger_Name = 1;

  function IntegerAccessorPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(IntegerAccessor,
                                                   handleOrPtrInfo);
  }

  function IntegerAccessorAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        IntegerAccessor, associatedInterfacePtrInfo);
  }

  IntegerAccessorAssociatedPtr.prototype =
      Object.create(IntegerAccessorPtr.prototype);
  IntegerAccessorAssociatedPtr.prototype.constructor =
      IntegerAccessorAssociatedPtr;

  function IntegerAccessorProxy(receiver) {
    this.receiver_ = receiver;
  }
  IntegerAccessorPtr.prototype.getInteger = function() {
    return IntegerAccessorProxy.prototype.getInteger
        .apply(this.ptr.getProxy(), arguments);
  };

  IntegerAccessorProxy.prototype.getInteger = function() {
    var params_ = new IntegerAccessor_GetInteger_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kIntegerAccessor_GetInteger_Name,
          codec.align(IntegerAccessor_GetInteger_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(IntegerAccessor_GetInteger_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(IntegerAccessor_GetInteger_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  IntegerAccessorPtr.prototype.setInteger = function() {
    return IntegerAccessorProxy.prototype.setInteger
        .apply(this.ptr.getProxy(), arguments);
  };

  IntegerAccessorProxy.prototype.setInteger = function(data, type) {
    var params_ = new IntegerAccessor_SetInteger_Params();
    params_.data = data;
    params_.type = type;
    var builder = new codec.MessageV0Builder(
        kIntegerAccessor_SetInteger_Name,
        codec.align(IntegerAccessor_SetInteger_Params.encodedSize));
    builder.encodeStruct(IntegerAccessor_SetInteger_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function IntegerAccessorStub(delegate) {
    this.delegate_ = delegate;
  }
  IntegerAccessorStub.prototype.getInteger = function() {
    return this.delegate_ && this.delegate_.getInteger && this.delegate_.getInteger();
  }
  IntegerAccessorStub.prototype.setInteger = function(data, type) {
    return this.delegate_ && this.delegate_.setInteger && this.delegate_.setInteger(data, type);
  }

  IntegerAccessorStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kIntegerAccessor_SetInteger_Name:
      var params = reader.decodeStruct(IntegerAccessor_SetInteger_Params);
      this.setInteger(params.data, params.type);
      return true;
    default:
      return false;
    }
  };

  IntegerAccessorStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kIntegerAccessor_GetInteger_Name:
      var params = reader.decodeStruct(IntegerAccessor_GetInteger_Params);
      this.getInteger().then(function(response) {
        var responseParams =
            new IntegerAccessor_GetInteger_ResponseParams();
        responseParams.data = response.data;
        responseParams.type = response.type;
        var builder = new codec.MessageV1Builder(
            kIntegerAccessor_GetInteger_Name,
            codec.align(IntegerAccessor_GetInteger_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(IntegerAccessor_GetInteger_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateIntegerAccessorRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kIntegerAccessor_GetInteger_Name:
        if (message.expectsResponse())
          paramsClass = IntegerAccessor_GetInteger_Params;
      break;
      case kIntegerAccessor_SetInteger_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = IntegerAccessor_SetInteger_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateIntegerAccessorResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kIntegerAccessor_GetInteger_Name:
        if (message.isResponse())
          paramsClass = IntegerAccessor_GetInteger_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var IntegerAccessor = {
    name: 'sample.IntegerAccessor',
    kVersion: 3,
    ptrClass: IntegerAccessorPtr,
    proxyClass: IntegerAccessorProxy,
    stubClass: IntegerAccessorStub,
    validateRequest: validateIntegerAccessorRequest,
    validateResponse: validateIntegerAccessorResponse,
  };
  IntegerAccessorStub.prototype.validator = validateIntegerAccessorRequest;
  IntegerAccessorProxy.prototype.validator = validateIntegerAccessorResponse;
  var kInterfaceFactory_BindInterface_Name = 0;

  function InterfaceFactoryPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(InterfaceFactory,
                                                   handleOrPtrInfo);
  }

  function InterfaceFactoryAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        InterfaceFactory, associatedInterfacePtrInfo);
  }

  InterfaceFactoryAssociatedPtr.prototype =
      Object.create(InterfaceFactoryPtr.prototype);
  InterfaceFactoryAssociatedPtr.prototype.constructor =
      InterfaceFactoryAssociatedPtr;

  function InterfaceFactoryProxy(receiver) {
    this.receiver_ = receiver;
  }
  InterfaceFactoryPtr.prototype.bindInterface = function() {
    return InterfaceFactoryProxy.prototype.bindInterface
        .apply(this.ptr.getProxy(), arguments);
  };

  InterfaceFactoryProxy.prototype.bindInterface = function(receiver) {
    var params_ = new InterfaceFactory_BindInterface_Params();
    params_.receiver = receiver;
    var builder = new codec.MessageV0Builder(
        kInterfaceFactory_BindInterface_Name,
        codec.align(InterfaceFactory_BindInterface_Params.encodedSize));
    builder.encodeStruct(InterfaceFactory_BindInterface_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function InterfaceFactoryStub(delegate) {
    this.delegate_ = delegate;
  }
  InterfaceFactoryStub.prototype.bindInterface = function(receiver) {
    return this.delegate_ && this.delegate_.bindInterface && this.delegate_.bindInterface(receiver);
  }

  InterfaceFactoryStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kInterfaceFactory_BindInterface_Name:
      var params = reader.decodeStruct(InterfaceFactory_BindInterface_Params);
      this.bindInterface(params.receiver);
      return true;
    default:
      return false;
    }
  };

  InterfaceFactoryStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateInterfaceFactoryRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kInterfaceFactory_BindInterface_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = InterfaceFactory_BindInterface_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateInterfaceFactoryResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var InterfaceFactory = {
    name: 'sample.InterfaceFactory',
    kVersion: 0,
    ptrClass: InterfaceFactoryPtr,
    proxyClass: InterfaceFactoryProxy,
    stubClass: InterfaceFactoryStub,
    validateRequest: validateInterfaceFactoryRequest,
    validateResponse: null,
  };
  InterfaceFactoryStub.prototype.validator = validateInterfaceFactoryRequest;
  InterfaceFactoryProxy.prototype.validator = null;
  exports.LONG = LONG;
  exports.Enum = Enum;
  exports.PingTest = PingTest;
  exports.PingTestPtr = PingTestPtr;
  exports.PingTestAssociatedPtr = PingTestAssociatedPtr;
  exports.Provider = Provider;
  exports.ProviderPtr = ProviderPtr;
  exports.ProviderAssociatedPtr = ProviderAssociatedPtr;
  exports.IntegerAccessor = IntegerAccessor;
  exports.IntegerAccessorPtr = IntegerAccessorPtr;
  exports.IntegerAccessorAssociatedPtr = IntegerAccessorAssociatedPtr;
  exports.InterfaceFactory = InterfaceFactory;
  exports.InterfaceFactoryPtr = InterfaceFactoryPtr;
  exports.InterfaceFactoryAssociatedPtr = InterfaceFactoryAssociatedPtr;
})();