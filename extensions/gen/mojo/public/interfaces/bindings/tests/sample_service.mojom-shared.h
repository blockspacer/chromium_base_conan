// mojo/public/interfaces/bindings/tests/sample_service.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_SAMPLE_SERVICE_MOJOM_SHARED_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_SAMPLE_SERVICE_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <ostream>
#include <type_traits>
#include <utility>

#include "base/compiler_specific.h"
#include "base/containers/flat_map.h"
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
#include "mojo/public/interfaces/bindings/tests/sample_service.mojom-shared-internal.h"
#include "mojo/public/interfaces/bindings/tests/sample_import.mojom-shared.h"
#include "mojo/public/interfaces/bindings/tests/sample_import2.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"



#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif


namespace sample {
class BarDataView;

class FooDataView;

class DefaultsTestDataView;

class StructWithHoleV1DataView;

class StructWithHoleV2DataView;



}  // namespace sample

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::sample::BarDataView> {
  using Data = ::sample::internal::Bar_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::sample::FooDataView> {
  using Data = ::sample::internal::Foo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::sample::DefaultsTestDataView> {
  using Data = ::sample::internal::DefaultsTest_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::sample::StructWithHoleV1DataView> {
  using Data = ::sample::internal::StructWithHoleV1_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::sample::StructWithHoleV2DataView> {
  using Data = ::sample::internal::StructWithHoleV2_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace sample {


// @generated_from: sample.Bar.Type
enum class Bar_Type : int32_t {
  
// @generated_from: sample.Bar.Type.VERTICAL
  VERTICAL = 1,
  
// @generated_from: sample.Bar.Type.HORIZONTAL
  HORIZONTAL = 2,
  
// @generated_from: sample.Bar.Type.BOTH
  BOTH = 3,
  
// @generated_from: sample.Bar.Type.INVALID
  INVALID = 4,
  kMinValue = 1,
  kMaxValue = 4,
};

 std::ostream& operator<<(std::ostream& os, Bar_Type value);
inline bool IsKnownEnumValue(Bar_Type value) {
  return internal::Bar_Type_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


// @generated_from: sample.Service.BazOptions
enum class Service_BazOptions : int32_t {
  
// @generated_from: sample.Service.BazOptions.REGULAR
  REGULAR = 0,
  
// @generated_from: sample.Service.BazOptions.EXTRA
  EXTRA = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, Service_BazOptions value);
inline bool IsKnownEnumValue(Service_BazOptions value) {
  return internal::Service_BazOptions_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class DefaultsSenderInterfaceBase {};

using DefaultsSenderPtrDataView =
    mojo::InterfacePtrDataView<DefaultsSenderInterfaceBase>;
using DefaultsSenderRequestDataView =
    mojo::InterfaceRequestDataView<DefaultsSenderInterfaceBase>;
using DefaultsSenderAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<DefaultsSenderInterfaceBase>;
using DefaultsSenderAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<DefaultsSenderInterfaceBase>;
class ServiceInterfaceBase {};

using ServicePtrDataView =
    mojo::InterfacePtrDataView<ServiceInterfaceBase>;
using ServiceRequestDataView =
    mojo::InterfaceRequestDataView<ServiceInterfaceBase>;
using ServiceAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<ServiceInterfaceBase>;
using ServiceAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<ServiceInterfaceBase>;
class PortInterfaceBase {};

using PortPtrDataView =
    mojo::InterfacePtrDataView<PortInterfaceBase>;
using PortRequestDataView =
    mojo::InterfaceRequestDataView<PortInterfaceBase>;
using PortAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<PortInterfaceBase>;
using PortAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<PortInterfaceBase>;


class BarDataView {
 public:
  BarDataView() {}

  BarDataView(
      internal::Bar_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint8_t alpha() const {
    return data_->alpha;
  }
  uint8_t beta() const {
    return data_->beta;
  }
  uint8_t gamma() const {
    return data_->gamma;
  }
  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::sample::Bar_Type>(
        data_value, output);
  }
  Bar_Type type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::sample::Bar_Type>(data_->type));
  }
 private:
  internal::Bar_Data* data_ = nullptr;
};



class FooDataView {
 public:
  FooDataView() {}

  FooDataView(
      internal::Foo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t x() const {
    return data_->x;
  }
  int32_t y() const {
    return data_->y;
  }
  bool a() const {
    return data_->a;
  }
  bool b() const {
    return data_->b;
  }
  bool c() const {
    return data_->c;
  }
  inline void GetBarDataView(
      BarDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadBar(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::sample::BarDataView, UserType>(),
    "Attempting to read the optional `bar` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBar` instead "
    "of `ReadBar if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->bar.Get();
    return mojo::internal::Deserialize<::sample::BarDataView>(
        pointer, output, message_);
  }
  inline void GetDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadData` instead "
    "of `ReadData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetExtraBarsDataView(
      mojo::ArrayDataView<BarDataView>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadExtraBars(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::sample::BarDataView>, UserType>(),
    "Attempting to read the optional `extra_bars` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadExtraBars` instead "
    "of `ReadExtraBars if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->extra_bars.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::sample::BarDataView>>(
        pointer, output, message_);
  }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  mojo::ScopedMessagePipeHandle TakeSource() {
    mojo::ScopedMessagePipeHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedMessagePipeHandle>(
            &data_->source, &result, message_);
    DCHECK(ret);
    return result;
  }
  inline void GetInputStreamsDataView(
      mojo::ArrayDataView<mojo::ScopedDataPipeConsumerHandle>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadInputStreams(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<mojo::ScopedDataPipeConsumerHandle>, UserType>(),
    "Attempting to read the optional `input_streams` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInputStreams` instead "
    "of `ReadInputStreams if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->input_streams.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::ScopedDataPipeConsumerHandle>>(
        pointer, output, message_);
  }
  inline void GetOutputStreamsDataView(
      mojo::ArrayDataView<mojo::ScopedDataPipeProducerHandle>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadOutputStreams(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<mojo::ScopedDataPipeProducerHandle>, UserType>(),
    "Attempting to read the optional `output_streams` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadOutputStreams` instead "
    "of `ReadOutputStreams if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->output_streams.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::ScopedDataPipeProducerHandle>>(
        pointer, output, message_);
  }
  inline void GetArrayOfArrayOfBoolsDataView(
      mojo::ArrayDataView<mojo::ArrayDataView<bool>>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadArrayOfArrayOfBools(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<mojo::ArrayDataView<bool>>, UserType>(),
    "Attempting to read the optional `array_of_array_of_bools` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadArrayOfArrayOfBools` instead "
    "of `ReadArrayOfArrayOfBools if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->array_of_array_of_bools.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::ArrayDataView<bool>>>(
        pointer, output, message_);
  }
  inline void GetMultiArrayOfStringsDataView(
      mojo::ArrayDataView<mojo::ArrayDataView<mojo::ArrayDataView<mojo::StringDataView>>>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadMultiArrayOfStrings(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<mojo::ArrayDataView<mojo::ArrayDataView<mojo::StringDataView>>>, UserType>(),
    "Attempting to read the optional `multi_array_of_strings` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMultiArrayOfStrings` instead "
    "of `ReadMultiArrayOfStrings if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->multi_array_of_strings.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::ArrayDataView<mojo::ArrayDataView<mojo::StringDataView>>>>(
        pointer, output, message_);
  }
  inline void GetArrayOfBoolsDataView(
      mojo::ArrayDataView<bool>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadArrayOfBools(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<bool>, UserType>(),
    "Attempting to read the optional `array_of_bools` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with base::Optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadArrayOfBools` instead "
    "of `ReadArrayOfBools if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->array_of_bools.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<bool>>(
        pointer, output, message_);
  }
 private:
  internal::Foo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DefaultsTestDataView {
 public:
  DefaultsTestDataView() {}

  DefaultsTestDataView(
      internal::DefaultsTest_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int8_t a0() const {
    return data_->a0;
  }
  uint8_t a1() const {
    return data_->a1;
  }
  int16_t a2() const {
    return data_->a2;
  }
  uint16_t a3() const {
    return data_->a3;
  }
  int32_t a4() const {
    return data_->a4;
  }
  uint32_t a5() const {
    return data_->a5;
  }
  int64_t a6() const {
    return data_->a6;
  }
  uint64_t a7() const {
    return data_->a7;
  }
  int32_t a8() const {
    return data_->a8;
  }
  int32_t a9() const {
    return data_->a9;
  }
  int32_t a10() const {
    return data_->a10;
  }
  bool a11() const {
    return data_->a11;
  }
  bool a12() const {
    return data_->a12;
  }
  float a13() const {
    return data_->a13;
  }
  double a14() const {
    return data_->a14;
  }
  double a15() const {
    return data_->a15;
  }
  double a16() const {
    return data_->a16;
  }
  double a17() const {
    return data_->a17;
  }
  inline void GetA18DataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadA18(UserType* output) {
    
    auto* pointer = data_->a18.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetA19DataView(
      mojo::StringDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadA19(UserType* output) {
    
    auto* pointer = data_->a19.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadA20(UserType* output) const {
    auto data_value = data_->a20;
    return mojo::internal::Deserialize<::sample::Bar_Type>(
        data_value, output);
  }
  Bar_Type a20() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::sample::Bar_Type>(data_->a20));
  }
  inline void GetA21DataView(
      ::imported::PointDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadA21(UserType* output) {
    
    auto* pointer = data_->a21.Get();
    return mojo::internal::Deserialize<::imported::PointDataView>(
        pointer, output, message_);
  }
  inline void GetA22DataView(
      ::imported::ThingDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadA22(UserType* output) {
    
    auto* pointer = data_->a22.Get();
    return mojo::internal::Deserialize<::imported::ThingDataView>(
        pointer, output, message_);
  }
  uint64_t a23() const {
    return data_->a23;
  }
  int64_t a24() const {
    return data_->a24;
  }
  int64_t a25() const {
    return data_->a25;
  }
  double a26() const {
    return data_->a26;
  }
  double a27() const {
    return data_->a27;
  }
  double a28() const {
    return data_->a28;
  }
  float a29() const {
    return data_->a29;
  }
  float a30() const {
    return data_->a30;
  }
  float a31() const {
    return data_->a31;
  }
 private:
  internal::DefaultsTest_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class StructWithHoleV1DataView {
 public:
  StructWithHoleV1DataView() {}

  StructWithHoleV1DataView(
      internal::StructWithHoleV1_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t v1() const {
    return data_->v1;
  }
  int64_t v2() const {
    return data_->v2;
  }
 private:
  internal::StructWithHoleV1_Data* data_ = nullptr;
};



class StructWithHoleV2DataView {
 public:
  StructWithHoleV2DataView() {}

  StructWithHoleV2DataView(
      internal::StructWithHoleV2_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t v1() const {
    return data_->v1;
  }
  int64_t v2() const {
    return data_->v2;
  }
  int32_t v3() const {
    return data_->v3;
  }
 private:
  internal::StructWithHoleV2_Data* data_ = nullptr;
};



}  // namespace sample

namespace std {

template <>
struct hash<::sample::Bar_Type>
    : public mojo::internal::EnumHashImpl<::sample::Bar_Type> {};

template <>
struct hash<::sample::Service_BazOptions>
    : public mojo::internal::EnumHashImpl<::sample::Service_BazOptions> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::sample::Bar_Type, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::sample::Bar_Type, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::sample::Bar_Type>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::sample::Service_BazOptions, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::sample::Service_BazOptions, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::sample::Service_BazOptions>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::sample::BarDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::sample::BarDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::sample::internal::Bar_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->alpha = Traits::alpha(input);
    fragment->beta = Traits::beta(input);
    fragment->gamma = Traits::gamma(input);
    mojo::internal::Serialize<::sample::Bar_Type>(
        Traits::type(input), &fragment->type);
  }

  static bool Deserialize(::sample::internal::Bar_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::sample::BarDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::sample::FooDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::sample::FooDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::sample::internal::Foo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->x = Traits::x(input);
    fragment->y = Traits::y(input);
    fragment->a = Traits::a(input);
    fragment->b = Traits::b(input);
    fragment->c = Traits::c(input);
    decltype(Traits::bar(input)) in_bar = Traits::bar(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->bar)::BaseType> bar_fragment(
            fragment.message());
    mojo::internal::Serialize<::sample::BarDataView>(
        in_bar, bar_fragment);
    fragment->bar.Set(
        bar_fragment.is_null() ? nullptr : bar_fragment.data());
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->data)::BaseType>
        data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_data, data_fragment, &data_validate_params);
    fragment->data.Set(
        data_fragment.is_null() ? nullptr : data_fragment.data());
    decltype(Traits::extra_bars(input)) in_extra_bars = Traits::extra_bars(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->extra_bars)::BaseType>
        extra_bars_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams extra_bars_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::sample::BarDataView>>(
        in_extra_bars, extra_bars_fragment, &extra_bars_validate_params);
    fragment->extra_bars.Set(
        extra_bars_fragment.is_null() ? nullptr : extra_bars_fragment.data());
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in Foo struct");
    decltype(Traits::source(input)) in_source = Traits::source(input);
    mojo::internal::Serialize<mojo::ScopedMessagePipeHandle>(
        in_source, &fragment->source, &fragment.message());
    decltype(Traits::input_streams(input)) in_input_streams = Traits::input_streams(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->input_streams)::BaseType>
        input_streams_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams input_streams_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::ScopedDataPipeConsumerHandle>>(
        in_input_streams, input_streams_fragment, &input_streams_validate_params);
    fragment->input_streams.Set(
        input_streams_fragment.is_null() ? nullptr : input_streams_fragment.data());
    decltype(Traits::output_streams(input)) in_output_streams = Traits::output_streams(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->output_streams)::BaseType>
        output_streams_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams output_streams_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::ScopedDataPipeProducerHandle>>(
        in_output_streams, output_streams_fragment, &output_streams_validate_params);
    fragment->output_streams.Set(
        output_streams_fragment.is_null() ? nullptr : output_streams_fragment.data());
    decltype(Traits::array_of_array_of_bools(input)) in_array_of_array_of_bools = Traits::array_of_array_of_bools(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->array_of_array_of_bools)::BaseType>
        array_of_array_of_bools_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams array_of_array_of_bools_validate_params(
        0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::ArrayDataView<bool>>>(
        in_array_of_array_of_bools, array_of_array_of_bools_fragment, &array_of_array_of_bools_validate_params);
    fragment->array_of_array_of_bools.Set(
        array_of_array_of_bools_fragment.is_null() ? nullptr : array_of_array_of_bools_fragment.data());
    decltype(Traits::multi_array_of_strings(input)) in_multi_array_of_strings = Traits::multi_array_of_strings(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->multi_array_of_strings)::BaseType>
        multi_array_of_strings_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams multi_array_of_strings_validate_params(
        0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::ArrayDataView<mojo::ArrayDataView<mojo::StringDataView>>>>(
        in_multi_array_of_strings, multi_array_of_strings_fragment, &multi_array_of_strings_validate_params);
    fragment->multi_array_of_strings.Set(
        multi_array_of_strings_fragment.is_null() ? nullptr : multi_array_of_strings_fragment.data());
    decltype(Traits::array_of_bools(input)) in_array_of_bools = Traits::array_of_bools(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->array_of_bools)::BaseType>
        array_of_bools_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams array_of_bools_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<bool>>(
        in_array_of_bools, array_of_bools_fragment, &array_of_bools_validate_params);
    fragment->array_of_bools.Set(
        array_of_bools_fragment.is_null() ? nullptr : array_of_bools_fragment.data());
  }

  static bool Deserialize(::sample::internal::Foo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::sample::FooDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::sample::DefaultsTestDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::sample::DefaultsTestDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::sample::internal::DefaultsTest_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->a0 = Traits::a0(input);
    fragment->a1 = Traits::a1(input);
    fragment->a2 = Traits::a2(input);
    fragment->a3 = Traits::a3(input);
    fragment->a4 = Traits::a4(input);
    fragment->a5 = Traits::a5(input);
    fragment->a6 = Traits::a6(input);
    fragment->a7 = Traits::a7(input);
    fragment->a8 = Traits::a8(input);
    fragment->a9 = Traits::a9(input);
    fragment->a10 = Traits::a10(input);
    fragment->a11 = Traits::a11(input);
    fragment->a12 = Traits::a12(input);
    fragment->a13 = Traits::a13(input);
    fragment->a14 = Traits::a14(input);
    fragment->a15 = Traits::a15(input);
    fragment->a16 = Traits::a16(input);
    fragment->a17 = Traits::a17(input);
    decltype(Traits::a18(input)) in_a18 = Traits::a18(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->a18)::BaseType>
        a18_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams a18_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_a18, a18_fragment, &a18_validate_params);
    fragment->a18.Set(
        a18_fragment.is_null() ? nullptr : a18_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->a18.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null a18 in DefaultsTest struct");
    decltype(Traits::a19(input)) in_a19 = Traits::a19(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->a19)::BaseType> a19_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_a19, a19_fragment);
    fragment->a19.Set(
        a19_fragment.is_null() ? nullptr : a19_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->a19.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null a19 in DefaultsTest struct");
    mojo::internal::Serialize<::sample::Bar_Type>(
        Traits::a20(input), &fragment->a20);
    decltype(Traits::a21(input)) in_a21 = Traits::a21(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->a21)::BaseType> a21_fragment(
            fragment.message());
    mojo::internal::Serialize<::imported::PointDataView>(
        in_a21, a21_fragment);
    fragment->a21.Set(
        a21_fragment.is_null() ? nullptr : a21_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->a21.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null a21 in DefaultsTest struct");
    decltype(Traits::a22(input)) in_a22 = Traits::a22(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->a22)::BaseType> a22_fragment(
            fragment.message());
    mojo::internal::Serialize<::imported::ThingDataView>(
        in_a22, a22_fragment);
    fragment->a22.Set(
        a22_fragment.is_null() ? nullptr : a22_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->a22.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null a22 in DefaultsTest struct");
    fragment->a23 = Traits::a23(input);
    fragment->a24 = Traits::a24(input);
    fragment->a25 = Traits::a25(input);
    fragment->a26 = Traits::a26(input);
    fragment->a27 = Traits::a27(input);
    fragment->a28 = Traits::a28(input);
    fragment->a29 = Traits::a29(input);
    fragment->a30 = Traits::a30(input);
    fragment->a31 = Traits::a31(input);
  }

  static bool Deserialize(::sample::internal::DefaultsTest_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::sample::DefaultsTestDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::sample::StructWithHoleV1DataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::sample::StructWithHoleV1DataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::sample::internal::StructWithHoleV1_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->v1 = Traits::v1(input);
    fragment->v2 = Traits::v2(input);
  }

  static bool Deserialize(::sample::internal::StructWithHoleV1_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::sample::StructWithHoleV1DataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::sample::StructWithHoleV2DataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::sample::StructWithHoleV2DataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::sample::internal::StructWithHoleV2_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->v1 = Traits::v1(input);
    fragment->v2 = Traits::v2(input);
    fragment->v3 = Traits::v3(input);
  }

  static bool Deserialize(::sample::internal::StructWithHoleV2_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::sample::StructWithHoleV2DataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace sample {



inline void FooDataView::GetBarDataView(
    BarDataView* output) {
  auto pointer = data_->bar.Get();
  *output = BarDataView(pointer, message_);
}
inline void FooDataView::GetDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void FooDataView::GetExtraBarsDataView(
    mojo::ArrayDataView<BarDataView>* output) {
  auto pointer = data_->extra_bars.Get();
  *output = mojo::ArrayDataView<BarDataView>(pointer, message_);
}
inline void FooDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void FooDataView::GetInputStreamsDataView(
    mojo::ArrayDataView<mojo::ScopedDataPipeConsumerHandle>* output) {
  auto pointer = data_->input_streams.Get();
  *output = mojo::ArrayDataView<mojo::ScopedDataPipeConsumerHandle>(pointer, message_);
}
inline void FooDataView::GetOutputStreamsDataView(
    mojo::ArrayDataView<mojo::ScopedDataPipeProducerHandle>* output) {
  auto pointer = data_->output_streams.Get();
  *output = mojo::ArrayDataView<mojo::ScopedDataPipeProducerHandle>(pointer, message_);
}
inline void FooDataView::GetArrayOfArrayOfBoolsDataView(
    mojo::ArrayDataView<mojo::ArrayDataView<bool>>* output) {
  auto pointer = data_->array_of_array_of_bools.Get();
  *output = mojo::ArrayDataView<mojo::ArrayDataView<bool>>(pointer, message_);
}
inline void FooDataView::GetMultiArrayOfStringsDataView(
    mojo::ArrayDataView<mojo::ArrayDataView<mojo::ArrayDataView<mojo::StringDataView>>>* output) {
  auto pointer = data_->multi_array_of_strings.Get();
  *output = mojo::ArrayDataView<mojo::ArrayDataView<mojo::ArrayDataView<mojo::StringDataView>>>(pointer, message_);
}
inline void FooDataView::GetArrayOfBoolsDataView(
    mojo::ArrayDataView<bool>* output) {
  auto pointer = data_->array_of_bools.Get();
  *output = mojo::ArrayDataView<bool>(pointer, message_);
}


inline void DefaultsTestDataView::GetA18DataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->a18.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void DefaultsTestDataView::GetA19DataView(
    mojo::StringDataView* output) {
  auto pointer = data_->a19.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void DefaultsTestDataView::GetA21DataView(
    ::imported::PointDataView* output) {
  auto pointer = data_->a21.Get();
  *output = ::imported::PointDataView(pointer, message_);
}
inline void DefaultsTestDataView::GetA22DataView(
    ::imported::ThingDataView* output) {
  auto pointer = data_->a22.Get();
  *output = ::imported::ThingDataView(pointer, message_);
}







}  // namespace sample

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::sample::Bar_Type> {
 static void WriteIntoTracedValue(perfetto::TracedValue context, ::sample::Bar_Type value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::sample::Service_BazOptions> {
 static void WriteIntoTracedValue(perfetto::TracedValue context, ::sample::Service_BazOptions value);
};

} // namespace perfetto

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_SAMPLE_SERVICE_MOJOM_SHARED_H_

/* Metadata comment
eyJtZXRhIjogW3siZW5kIjogMzA1MywgImJlZ2luIjogMzA0NSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogInNhbXBsZS5CYXIuVHlwZSJ9fSwgeyJlbmQiOiAzMTI0
LCAiYmVnaW4iOiAzMTE2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAic2FtcGxlLkJhci5UeXBlLlZFUlRJQ0FMIn19LCB7ImVuZCI6IDMxOTIsICJiZWdpbiI6IDMx
ODIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJzYW1wbGUuQmFy
LlR5cGUuSE9SSVpPTlRBTCJ9fSwgeyJlbmQiOiAzMjQ4LCAiYmVnaW4iOiAzMjQ0LCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAic2FtcGxlLkJhci5UeXBlLkJPVEgi
fX0sIHsiZW5kIjogMzMxMCwgImJlZ2luIjogMzMwMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogInNhbXBsZS5CYXIuVHlwZS5JTlZBTElEIn19LCB7ImVuZCI6IDM2
MjUsICJiZWdpbiI6IDM2MDcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJzYW1wbGUuU2VydmljZS5CYXpPcHRpb25zIn19LCB7ImVuZCI6IDM3MDQsICJiZWdpbiI6
IDM2OTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJzYW1wbGUu
U2VydmljZS5CYXpPcHRpb25zLlJFR1VMQVIifX0sIHsiZW5kIjogMzc3MiwgImJlZ2luIjogMzc2
NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogInNhbXBsZS5TZXJ2
aWNlLkJhek9wdGlvbnMuRVhUUkEifX1dLCAidHlwZSI6ICJreXRoZTAifQ==
*/