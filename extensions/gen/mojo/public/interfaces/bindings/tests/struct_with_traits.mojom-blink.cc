// mojo/public/interfaces/bindings/tests/struct_with_traits.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "mojo/public/interfaces/bindings/tests/struct_with_traits.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/common/task_annotator.h"
#include "base/trace_event/trace_event.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "mojo/public/interfaces/bindings/tests/struct_with_traits.mojom-params-data.h"
#include "mojo/public/interfaces/bindings/tests/struct_with_traits.mojom-shared-message-ids.h"

#include "mojo/public/interfaces/bindings/tests/struct_with_traits.mojom-blink-import-headers.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_STRUCT_WITH_TRAITS_MOJOM_BLINK_JUMBO_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_STRUCT_WITH_TRAITS_MOJOM_BLINK_JUMBO_H_
#endif
namespace mojo {
namespace test {
namespace blink {
NestedStructWithTraits::NestedStructWithTraits()
    : value() {}

NestedStructWithTraits::NestedStructWithTraits(
    int32_t value_in)
    : value(std::move(value_in)) {}

NestedStructWithTraits::~NestedStructWithTraits() = default;
size_t NestedStructWithTraits::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->value);
  return seed;
}

void NestedStructWithTraits::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool NestedStructWithTraits::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StructWithTraits::StructWithTraits()
    : f_enum(),
      f_bool(),
      f_uint32(),
      f_uint64(),
      f_string(),
      f_string2(),
      f_string_array(),
      f_string_set(),
      f_struct(),
      f_struct_array(),
      f_struct_map() {}

StructWithTraits::StructWithTraits(
    EnumWithTraits f_enum_in,
    bool f_bool_in,
    uint32_t f_uint32_in,
    uint64_t f_uint64_in,
    const WTF::String& f_string_in,
    const WTF::String& f_string2_in,
    WTF::Vector<WTF::String> f_string_array_in,
    WTF::Vector<WTF::String> f_string_set_in,
    NestedStructWithTraitsPtr f_struct_in,
    WTF::Vector<NestedStructWithTraitsPtr> f_struct_array_in,
    WTF::HashMap<WTF::String, NestedStructWithTraitsPtr> f_struct_map_in)
    : f_enum(std::move(f_enum_in)),
      f_bool(std::move(f_bool_in)),
      f_uint32(std::move(f_uint32_in)),
      f_uint64(std::move(f_uint64_in)),
      f_string(std::move(f_string_in)),
      f_string2(std::move(f_string2_in)),
      f_string_array(std::move(f_string_array_in)),
      f_string_set(std::move(f_string_set_in)),
      f_struct(std::move(f_struct_in)),
      f_struct_array(std::move(f_struct_array_in)),
      f_struct_map(std::move(f_struct_map_in)) {}

StructWithTraits::~StructWithTraits() = default;

void StructWithTraits::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_enum"), this->f_enum,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type EnumWithTraits>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_bool"), this->f_bool,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_uint32"), this->f_uint32,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_uint64"), this->f_uint64,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_string"), this->f_string,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_string2"), this->f_string2,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_string_array"), this->f_string_array,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<WTF::String>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_string_set"), this->f_string_set,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<WTF::String>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_struct"), this->f_struct,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type NestedStructWithTraitsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_struct_array"), this->f_struct_array,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<NestedStructWithTraitsPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_struct_map"), this->f_struct_map,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::HashMap<WTF::String, NestedStructWithTraitsPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StructWithTraits::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StructWithUnreachableTraits::StructWithUnreachableTraits()
    : ignore_me() {}

StructWithUnreachableTraits::StructWithUnreachableTraits(
    bool ignore_me_in)
    : ignore_me(std::move(ignore_me_in)) {}

StructWithUnreachableTraits::~StructWithUnreachableTraits() = default;
size_t StructWithUnreachableTraits::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->ignore_me);
  return seed;
}

void StructWithUnreachableTraits::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ignore_me"), this->ignore_me,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StructWithUnreachableTraits::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StructWithTraitsContainer::StructWithTraitsContainer()
    : f_struct() {}

StructWithTraitsContainer::StructWithTraitsContainer(
    StructWithTraitsPtr f_struct_in)
    : f_struct(std::move(f_struct_in)) {}

StructWithTraitsContainer::~StructWithTraitsContainer() = default;

void StructWithTraitsContainer::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_struct"), this->f_struct,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type StructWithTraitsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StructWithTraitsContainer::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
TrivialStructWithTraits::TrivialStructWithTraits()
    : value() {}

TrivialStructWithTraits::TrivialStructWithTraits(
    int32_t value_in)
    : value(std::move(value_in)) {}

TrivialStructWithTraits::~TrivialStructWithTraits() = default;
size_t TrivialStructWithTraits::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->value);
  return seed;
}

void TrivialStructWithTraits::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool TrivialStructWithTraits::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MoveOnlyStructWithTraits::MoveOnlyStructWithTraits()
    : f_handle() {}

MoveOnlyStructWithTraits::MoveOnlyStructWithTraits(
    ::mojo::ScopedHandle f_handle_in)
    : f_handle(std::move(f_handle_in)) {}

MoveOnlyStructWithTraits::~MoveOnlyStructWithTraits() = default;

void MoveOnlyStructWithTraits::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_handle"), this->f_handle,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::ScopedHandle>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MoveOnlyStructWithTraits::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MoveOnlyStructWithTraitsContainer::MoveOnlyStructWithTraitsContainer()
    : f_struct() {}

MoveOnlyStructWithTraitsContainer::MoveOnlyStructWithTraitsContainer(
    MoveOnlyStructWithTraitsPtr f_struct_in)
    : f_struct(std::move(f_struct_in)) {}

MoveOnlyStructWithTraitsContainer::~MoveOnlyStructWithTraitsContainer() = default;

void MoveOnlyStructWithTraitsContainer::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_struct"), this->f_struct,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MoveOnlyStructWithTraitsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MoveOnlyStructWithTraitsContainer::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StructWithTraitsForUniquePtr::StructWithTraitsForUniquePtr()
    : f_int32() {}

StructWithTraitsForUniquePtr::StructWithTraitsForUniquePtr(
    int32_t f_int32_in)
    : f_int32(std::move(f_int32_in)) {}

StructWithTraitsForUniquePtr::~StructWithTraitsForUniquePtr() = default;
size_t StructWithTraitsForUniquePtr::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->f_int32);
  return seed;
}

void StructWithTraitsForUniquePtr::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_int32"), this->f_int32,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StructWithTraitsForUniquePtr::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
EnumWithTraitsContainer::EnumWithTraitsContainer()
    : f_field(EnumWithTraits::VALUE_1) {}

EnumWithTraitsContainer::EnumWithTraitsContainer(
    EnumWithTraits f_field_in)
    : f_field(std::move(f_field_in)) {}

EnumWithTraitsContainer::~EnumWithTraitsContainer() = default;
size_t EnumWithTraitsContainer::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->f_field);
  return seed;
}

void EnumWithTraitsContainer::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_field"), this->f_field,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type EnumWithTraits>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool EnumWithTraitsContainer::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StructForceSerialize::StructForceSerialize()
    : value() {}

StructForceSerialize::StructForceSerialize(
    int32_t value_in)
    : value(std::move(value_in)) {}

StructForceSerialize::~StructForceSerialize() = default;
size_t StructForceSerialize::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->value);
  return seed;
}

void StructForceSerialize::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StructForceSerialize::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StructNestedForceSerialize::StructNestedForceSerialize()
    : force() {}

StructNestedForceSerialize::StructNestedForceSerialize(
    StructForceSerializePtr force_in)
    : force(std::move(force_in)) {}

StructNestedForceSerialize::~StructNestedForceSerialize() = default;
size_t StructNestedForceSerialize::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->force);
  return seed;
}

void StructNestedForceSerialize::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "force"), this->force,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type StructForceSerializePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StructNestedForceSerialize::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
UnionWithTraits::UnionWithTraits() : tag_(Tag::F_INT32) {
  data_.f_int32 = int32_t();
}

UnionWithTraits::~UnionWithTraits() {
  DestroyActive();
}


void UnionWithTraits::set_f_int32(
    int32_t f_int32) {
  if (tag_ != Tag::F_INT32) {
    DestroyActive();
    tag_ = Tag::F_INT32;
  }
  data_.f_int32 = f_int32;
}
void UnionWithTraits::set_f_struct(
    NestedStructWithTraitsPtr f_struct) {
  if (tag_ == Tag::F_STRUCT) {
    *(data_.f_struct) = std::move(f_struct);
  } else {
    DestroyActive();
    tag_ = Tag::F_STRUCT;
    data_.f_struct = new NestedStructWithTraitsPtr(
        std::move(f_struct));
  }
}

void UnionWithTraits::DestroyActive() {
  switch (tag_) {

    case Tag::F_INT32:

      break;
    case Tag::F_STRUCT:

      delete data_.f_struct;
      break;
  }
}
size_t UnionWithTraits::Hash(size_t seed) const {
  seed = mojo::internal::HashCombine(seed, static_cast<uint32_t>(tag_));
  switch (tag_) {

    case Tag::F_INT32:
      return mojo::internal::WTFHash(seed, data_.f_int32);
    case Tag::F_STRUCT:
      return mojo::internal::WTFHash(seed, data_.f_struct);
    default:
      NOTREACHED();
      return seed;
  }
}

bool UnionWithTraits::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char TraitsTestService::Name_[] = "mojo.test.TraitsTestService";

class TraitsTestService_EchoStructWithTraits_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TraitsTestService_EchoStructWithTraits_ForwardToCallback(
      TraitsTestService::EchoStructWithTraitsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TraitsTestService::EchoStructWithTraitsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoStructWithTraits_ForwardToCallback);
};

class TraitsTestService_EchoTrivialStructWithTraits_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TraitsTestService_EchoTrivialStructWithTraits_ForwardToCallback(
      TraitsTestService::EchoTrivialStructWithTraitsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TraitsTestService::EchoTrivialStructWithTraitsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoTrivialStructWithTraits_ForwardToCallback);
};

class TraitsTestService_EchoMoveOnlyStructWithTraits_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TraitsTestService_EchoMoveOnlyStructWithTraits_ForwardToCallback(
      TraitsTestService::EchoMoveOnlyStructWithTraitsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TraitsTestService::EchoMoveOnlyStructWithTraitsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoMoveOnlyStructWithTraits_ForwardToCallback);
};

class TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ForwardToCallback(
      TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ForwardToCallback);
};

class TraitsTestService_EchoEnumWithTraits_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TraitsTestService_EchoEnumWithTraits_ForwardToCallback(
      TraitsTestService::EchoEnumWithTraitsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TraitsTestService::EchoEnumWithTraitsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoEnumWithTraits_ForwardToCallback);
};

class TraitsTestService_EchoStructWithTraitsForUniquePtr_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TraitsTestService_EchoStructWithTraitsForUniquePtr_ForwardToCallback(
      TraitsTestService::EchoStructWithTraitsForUniquePtrCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TraitsTestService::EchoStructWithTraitsForUniquePtrCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoStructWithTraitsForUniquePtr_ForwardToCallback);
};

class TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ForwardToCallback(
      TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ForwardToCallback);
};

class TraitsTestService_EchoUnionWithTraits_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TraitsTestService_EchoUnionWithTraits_ForwardToCallback(
      TraitsTestService::EchoUnionWithTraitsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TraitsTestService::EchoUnionWithTraitsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoUnionWithTraits_ForwardToCallback);
};

TraitsTestServiceProxy::TraitsTestServiceProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class TraitsTestServiceProxy_EchoStructWithTraits_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestServiceProxy_EchoStructWithTraits_Message(
      uint32_t message_flags
      , StructWithTraitsPtr param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoStructWithTraits_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~TraitsTestServiceProxy_EchoStructWithTraits_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      StructWithTraitsPtr param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestServiceProxy_EchoStructWithTraits_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoStructWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoStructWithTraits_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TraitsTestService.EchoStructWithTraits request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TraitsTestService* impl, TraitsTestService::EchoStructWithTraitsCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->EchoStructWithTraits(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoStructWithTraits_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TraitsTestService.EchoStructWithTraits request");
  }
  StructWithTraitsPtr param_s_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestServiceProxy_EchoStructWithTraits_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestServiceProxy_EchoStructWithTraits_Message::kMessageTag = {};

void TraitsTestServiceProxy::EchoStructWithTraits(
    StructWithTraitsPtr in_s, EchoStructWithTraitsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TraitsTestService::EchoStructWithTraits", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type StructWithTraitsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TraitsTestServiceProxy_EchoStructWithTraits_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoStructWithTraits");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TraitsTestService_EchoStructWithTraits_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TraitsTestServiceProxy_EchoTrivialStructWithTraits_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestServiceProxy_EchoTrivialStructWithTraits_Message(
      uint32_t message_flags
      , TrivialStructWithTraitsPtr param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoTrivialStructWithTraits_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~TraitsTestServiceProxy_EchoTrivialStructWithTraits_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      TrivialStructWithTraitsPtr param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestServiceProxy_EchoTrivialStructWithTraits_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoTrivialStructWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoTrivialStructWithTraits_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TrivialStructWithTraitsDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TraitsTestService.EchoTrivialStructWithTraits request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TraitsTestService* impl, TraitsTestService::EchoTrivialStructWithTraitsCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->EchoTrivialStructWithTraits(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoTrivialStructWithTraits_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TrivialStructWithTraitsDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TraitsTestService.EchoTrivialStructWithTraits request");
  }
  TrivialStructWithTraitsPtr param_s_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestServiceProxy_EchoTrivialStructWithTraits_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestServiceProxy_EchoTrivialStructWithTraits_Message::kMessageTag = {};

void TraitsTestServiceProxy::EchoTrivialStructWithTraits(
    TrivialStructWithTraitsPtr in_s, EchoTrivialStructWithTraitsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TraitsTestService::EchoTrivialStructWithTraits", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type TrivialStructWithTraitsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TraitsTestServiceProxy_EchoTrivialStructWithTraits_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoTrivialStructWithTraits");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TraitsTestService_EchoTrivialStructWithTraits_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TraitsTestServiceProxy_EchoMoveOnlyStructWithTraits_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestServiceProxy_EchoMoveOnlyStructWithTraits_Message(
      uint32_t message_flags
      , MoveOnlyStructWithTraitsPtr param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoMoveOnlyStructWithTraits_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~TraitsTestServiceProxy_EchoMoveOnlyStructWithTraits_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      MoveOnlyStructWithTraitsPtr param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestServiceProxy_EchoMoveOnlyStructWithTraits_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoMoveOnlyStructWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoMoveOnlyStructWithTraits_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::MoveOnlyStructWithTraitsDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TraitsTestService.EchoMoveOnlyStructWithTraits request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TraitsTestService* impl, TraitsTestService::EchoMoveOnlyStructWithTraitsCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->EchoMoveOnlyStructWithTraits(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoMoveOnlyStructWithTraits_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::MoveOnlyStructWithTraitsDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TraitsTestService.EchoMoveOnlyStructWithTraits request");
  }
  MoveOnlyStructWithTraitsPtr param_s_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestServiceProxy_EchoMoveOnlyStructWithTraits_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestServiceProxy_EchoMoveOnlyStructWithTraits_Message::kMessageTag = {};

void TraitsTestServiceProxy::EchoMoveOnlyStructWithTraits(
    MoveOnlyStructWithTraitsPtr in_s, EchoMoveOnlyStructWithTraitsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TraitsTestService::EchoMoveOnlyStructWithTraits", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type MoveOnlyStructWithTraitsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TraitsTestServiceProxy_EchoMoveOnlyStructWithTraits_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoMoveOnlyStructWithTraits");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TraitsTestService_EchoMoveOnlyStructWithTraits_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TraitsTestServiceProxy_EchoNullableMoveOnlyStructWithTraits_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestServiceProxy_EchoNullableMoveOnlyStructWithTraits_Message(
      uint32_t message_flags
      , MoveOnlyStructWithTraitsPtr param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoNullableMoveOnlyStructWithTraits_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~TraitsTestServiceProxy_EchoNullableMoveOnlyStructWithTraits_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      MoveOnlyStructWithTraitsPtr param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestServiceProxy_EchoNullableMoveOnlyStructWithTraits_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoNullableMoveOnlyStructWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::MoveOnlyStructWithTraitsDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TraitsTestService* impl, TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->EchoNullableMoveOnlyStructWithTraits(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::MoveOnlyStructWithTraitsDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  }
  MoveOnlyStructWithTraitsPtr param_s_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestServiceProxy_EchoNullableMoveOnlyStructWithTraits_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestServiceProxy_EchoNullableMoveOnlyStructWithTraits_Message::kMessageTag = {};

void TraitsTestServiceProxy::EchoNullableMoveOnlyStructWithTraits(
    MoveOnlyStructWithTraitsPtr in_s, EchoNullableMoveOnlyStructWithTraitsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TraitsTestService::EchoNullableMoveOnlyStructWithTraits", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type MoveOnlyStructWithTraitsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TraitsTestServiceProxy_EchoNullableMoveOnlyStructWithTraits_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoNullableMoveOnlyStructWithTraits");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TraitsTestServiceProxy_EchoEnumWithTraits_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestServiceProxy_EchoEnumWithTraits_Message(
      uint32_t message_flags
      , EnumWithTraits param_e
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoEnumWithTraits_Name,
          message_flags)
      , param_e_(std::move(param_e)){}
  ~TraitsTestServiceProxy_EchoEnumWithTraits_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      EnumWithTraits param_e) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestServiceProxy_EchoEnumWithTraits_Message>(
          kFlags
          , std::move(param_e)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoEnumWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoEnumWithTraits_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::mojo::test::EnumWithTraits>(
      param_e, &params->e);
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TraitsTestService* impl, TraitsTestService::EchoEnumWithTraitsCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->EchoEnumWithTraits(
        std::move(param_e_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoEnumWithTraits_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::Serialize<::mojo::test::EnumWithTraits>(
      param_e_, &params->e);
  }
  EnumWithTraits param_e_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestServiceProxy_EchoEnumWithTraits_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestServiceProxy_EchoEnumWithTraits_Message::kMessageTag = {};

void TraitsTestServiceProxy::EchoEnumWithTraits(
    EnumWithTraits in_e, EchoEnumWithTraitsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TraitsTestService::EchoEnumWithTraits", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("e"), in_e, 
                        "<value of type EnumWithTraits>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TraitsTestServiceProxy_EchoEnumWithTraits_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_e));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoEnumWithTraits");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TraitsTestService_EchoEnumWithTraits_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TraitsTestServiceProxy_EchoStructWithTraitsForUniquePtr_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestServiceProxy_EchoStructWithTraitsForUniquePtr_Message(
      uint32_t message_flags
      , StructWithTraitsForUniquePtrPtr param_e
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoStructWithTraitsForUniquePtr_Name,
          message_flags)
      , param_e_(std::move(param_e)){}
  ~TraitsTestServiceProxy_EchoStructWithTraitsForUniquePtr_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      StructWithTraitsForUniquePtrPtr param_e) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestServiceProxy_EchoStructWithTraitsForUniquePtr_Message>(
          kFlags
          , std::move(param_e)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoStructWithTraitsForUniquePtr_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->e)::BaseType> e_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsForUniquePtrDataView>(
      param_e, e_fragment);
  params->e.Set(
      e_fragment.is_null() ? nullptr : e_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->e.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null e in TraitsTestService.EchoStructWithTraitsForUniquePtr request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TraitsTestService* impl, TraitsTestService::EchoStructWithTraitsForUniquePtrCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->EchoStructWithTraitsForUniquePtr(
        std::move(param_e_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->e)::BaseType> e_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsForUniquePtrDataView>(
      param_e_, e_fragment);
  params->e.Set(
      e_fragment.is_null() ? nullptr : e_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->e.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null e in TraitsTestService.EchoStructWithTraitsForUniquePtr request");
  }
  StructWithTraitsForUniquePtrPtr param_e_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestServiceProxy_EchoStructWithTraitsForUniquePtr_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestServiceProxy_EchoStructWithTraitsForUniquePtr_Message::kMessageTag = {};

void TraitsTestServiceProxy::EchoStructWithTraitsForUniquePtr(
    StructWithTraitsForUniquePtrPtr in_e, EchoStructWithTraitsForUniquePtrCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TraitsTestService::EchoStructWithTraitsForUniquePtr", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("e"), in_e, 
                        "<value of type StructWithTraitsForUniquePtrPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TraitsTestServiceProxy_EchoStructWithTraitsForUniquePtr_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_e));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoStructWithTraitsForUniquePtr");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TraitsTestService_EchoStructWithTraitsForUniquePtr_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TraitsTestServiceProxy_EchoNullableStructWithTraitsForUniquePtr_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestServiceProxy_EchoNullableStructWithTraitsForUniquePtr_Message(
      uint32_t message_flags
      , StructWithTraitsForUniquePtrPtr param_e
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Name,
          message_flags)
      , param_e_(std::move(param_e)){}
  ~TraitsTestServiceProxy_EchoNullableStructWithTraitsForUniquePtr_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      StructWithTraitsForUniquePtrPtr param_e) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestServiceProxy_EchoNullableStructWithTraitsForUniquePtr_Message>(
          kFlags
          , std::move(param_e)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->e)::BaseType> e_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsForUniquePtrDataView>(
      param_e, e_fragment);
  params->e.Set(
      e_fragment.is_null() ? nullptr : e_fragment.data());
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TraitsTestService* impl, TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->EchoNullableStructWithTraitsForUniquePtr(
        std::move(param_e_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->e)::BaseType> e_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsForUniquePtrDataView>(
      param_e_, e_fragment);
  params->e.Set(
      e_fragment.is_null() ? nullptr : e_fragment.data());
  }
  StructWithTraitsForUniquePtrPtr param_e_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestServiceProxy_EchoNullableStructWithTraitsForUniquePtr_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestServiceProxy_EchoNullableStructWithTraitsForUniquePtr_Message::kMessageTag = {};

void TraitsTestServiceProxy::EchoNullableStructWithTraitsForUniquePtr(
    StructWithTraitsForUniquePtrPtr in_e, EchoNullableStructWithTraitsForUniquePtrCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TraitsTestService::EchoNullableStructWithTraitsForUniquePtr", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("e"), in_e, 
                        "<value of type StructWithTraitsForUniquePtrPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TraitsTestServiceProxy_EchoNullableStructWithTraitsForUniquePtr_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_e));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoNullableStructWithTraitsForUniquePtr");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TraitsTestServiceProxy_EchoUnionWithTraits_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestServiceProxy_EchoUnionWithTraits_Message(
      uint32_t message_flags
      , UnionWithTraitsPtr param_u
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoUnionWithTraits_Name,
          message_flags)
      , param_u_(std::move(param_u)){}
  ~TraitsTestServiceProxy_EchoUnionWithTraits_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      UnionWithTraitsPtr param_u) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestServiceProxy_EchoUnionWithTraits_Message>(
          kFlags
          , std::move(param_u)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoUnionWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoUnionWithTraits_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->u)>
      u_fragment(params.message());
  u_fragment.Claim(&params->u);
  mojo::internal::Serialize<::mojo::test::UnionWithTraitsDataView>(
      param_u, u_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->u.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null u in TraitsTestService.EchoUnionWithTraits request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TraitsTestService* impl, TraitsTestService::EchoUnionWithTraitsCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->EchoUnionWithTraits(
        std::move(param_u_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoUnionWithTraits_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<decltype(params->u)>
      u_fragment(params.message());
  u_fragment.Claim(&params->u);
  mojo::internal::Serialize<::mojo::test::UnionWithTraitsDataView>(
      param_u_, u_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->u.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null u in TraitsTestService.EchoUnionWithTraits request");
  }
  UnionWithTraitsPtr param_u_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestServiceProxy_EchoUnionWithTraits_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestServiceProxy_EchoUnionWithTraits_Message::kMessageTag = {};

void TraitsTestServiceProxy::EchoUnionWithTraits(
    UnionWithTraitsPtr in_u, EchoUnionWithTraitsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TraitsTestService::EchoUnionWithTraits", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("u"), in_u, 
                        "<value of type UnionWithTraitsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TraitsTestServiceProxy_EchoUnionWithTraits_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_u));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoUnionWithTraits");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TraitsTestService_EchoUnionWithTraits_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TraitsTestService_EchoStructWithTraits_ProxyToResponder {
 public:
  static TraitsTestService::EchoStructWithTraitsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TraitsTestService_EchoStructWithTraits_ProxyToResponder> proxy(
        new TraitsTestService_EchoStructWithTraits_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TraitsTestService_EchoStructWithTraits_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TraitsTestService_EchoStructWithTraits_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TraitsTestService_EchoStructWithTraits_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TraitsTestService::EchoStructWithTraitsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      StructWithTraitsPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoStructWithTraits_ProxyToResponder);
};
class TraitsTestService_EchoStructWithTraits_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestService_EchoStructWithTraits_Response_Message(
      uint32_t message_flags
      , StructWithTraitsPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoStructWithTraits_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TraitsTestService_EchoStructWithTraits_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      StructWithTraitsPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestService_EchoStructWithTraits_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoStructWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoStructWithTraits_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoStructWithTraits response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                TraitsTestService::EchoStructWithTraitsCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoStructWithTraits_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoStructWithTraits response");
  }
  StructWithTraitsPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoStructWithTraits_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestService_EchoStructWithTraits_Response_Message::kMessageTag = {};

bool TraitsTestService_EchoStructWithTraits_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TraitsTestService::EchoStructWithTraitsCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TraitsTestService_EchoStructWithTraits_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TraitsTestService_EchoStructWithTraits_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TraitsTestService_EchoStructWithTraits_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  StructWithTraitsPtr p_passed{};
  TraitsTestService_EchoStructWithTraits_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TraitsTestService::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TraitsTestService_EchoStructWithTraits_ProxyToResponder::Run(
    StructWithTraitsPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TraitsTestService::EchoStructWithTraitsCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type StructWithTraitsPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TraitsTestService_EchoStructWithTraits_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TraitsTestService::EchoStructWithTraitsCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoStructWithTraits");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder {
 public:
  static TraitsTestService::EchoTrivialStructWithTraitsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder> proxy(
        new TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TraitsTestService::EchoTrivialStructWithTraitsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      TrivialStructWithTraitsPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder);
};
class TraitsTestService_EchoTrivialStructWithTraits_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestService_EchoTrivialStructWithTraits_Response_Message(
      uint32_t message_flags
      , TrivialStructWithTraitsPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoTrivialStructWithTraits_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TraitsTestService_EchoTrivialStructWithTraits_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      TrivialStructWithTraitsPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestService_EchoTrivialStructWithTraits_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoTrivialStructWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoTrivialStructWithTraits_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TrivialStructWithTraitsDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoTrivialStructWithTraits response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                TraitsTestService::EchoTrivialStructWithTraitsCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoTrivialStructWithTraits_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TrivialStructWithTraitsDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoTrivialStructWithTraits response");
  }
  TrivialStructWithTraitsPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoTrivialStructWithTraits_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestService_EchoTrivialStructWithTraits_Response_Message::kMessageTag = {};

bool TraitsTestService_EchoTrivialStructWithTraits_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TraitsTestService::EchoTrivialStructWithTraitsCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TraitsTestService_EchoTrivialStructWithTraits_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TraitsTestService_EchoTrivialStructWithTraits_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TraitsTestService_EchoTrivialStructWithTraits_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  TrivialStructWithTraitsPtr p_passed{};
  TraitsTestService_EchoTrivialStructWithTraits_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TraitsTestService::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder::Run(
    TrivialStructWithTraitsPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TraitsTestService::EchoTrivialStructWithTraitsCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type TrivialStructWithTraitsPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TraitsTestService_EchoTrivialStructWithTraits_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TraitsTestService::EchoTrivialStructWithTraitsCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoTrivialStructWithTraits");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder {
 public:
  static TraitsTestService::EchoMoveOnlyStructWithTraitsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder> proxy(
        new TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TraitsTestService::EchoMoveOnlyStructWithTraitsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      MoveOnlyStructWithTraitsPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder);
};
class TraitsTestService_EchoMoveOnlyStructWithTraits_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestService_EchoMoveOnlyStructWithTraits_Response_Message(
      uint32_t message_flags
      , MoveOnlyStructWithTraitsPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoMoveOnlyStructWithTraits_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TraitsTestService_EchoMoveOnlyStructWithTraits_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      MoveOnlyStructWithTraitsPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestService_EchoMoveOnlyStructWithTraits_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoMoveOnlyStructWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoMoveOnlyStructWithTraits_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::MoveOnlyStructWithTraitsDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoMoveOnlyStructWithTraits response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                TraitsTestService::EchoMoveOnlyStructWithTraitsCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoMoveOnlyStructWithTraits_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::MoveOnlyStructWithTraitsDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoMoveOnlyStructWithTraits response");
  }
  MoveOnlyStructWithTraitsPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoMoveOnlyStructWithTraits_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestService_EchoMoveOnlyStructWithTraits_Response_Message::kMessageTag = {};

bool TraitsTestService_EchoMoveOnlyStructWithTraits_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TraitsTestService::EchoMoveOnlyStructWithTraitsCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TraitsTestService_EchoMoveOnlyStructWithTraits_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TraitsTestService_EchoMoveOnlyStructWithTraits_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TraitsTestService_EchoMoveOnlyStructWithTraits_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  MoveOnlyStructWithTraitsPtr p_passed{};
  TraitsTestService_EchoMoveOnlyStructWithTraits_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TraitsTestService::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder::Run(
    MoveOnlyStructWithTraitsPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TraitsTestService::EchoMoveOnlyStructWithTraitsCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type MoveOnlyStructWithTraitsPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TraitsTestService_EchoMoveOnlyStructWithTraits_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TraitsTestService::EchoMoveOnlyStructWithTraitsCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoMoveOnlyStructWithTraits");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder {
 public:
  static TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder> proxy(
        new TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      MoveOnlyStructWithTraitsPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder);
};
class TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Response_Message(
      uint32_t message_flags
      , MoveOnlyStructWithTraitsPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoNullableMoveOnlyStructWithTraits_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      MoveOnlyStructWithTraitsPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoNullableMoveOnlyStructWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::MoveOnlyStructWithTraitsDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
    return message;
  }


  void Dispatch(mojo::Message* message,
                TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::MoveOnlyStructWithTraitsDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  }
  MoveOnlyStructWithTraitsPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Response_Message::kMessageTag = {};

bool TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  MoveOnlyStructWithTraitsPtr p_passed{};
  TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TraitsTestService::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder::Run(
    MoveOnlyStructWithTraitsPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type MoveOnlyStructWithTraitsPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoNullableMoveOnlyStructWithTraits");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class TraitsTestService_EchoEnumWithTraits_ProxyToResponder {
 public:
  static TraitsTestService::EchoEnumWithTraitsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TraitsTestService_EchoEnumWithTraits_ProxyToResponder> proxy(
        new TraitsTestService_EchoEnumWithTraits_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TraitsTestService_EchoEnumWithTraits_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TraitsTestService_EchoEnumWithTraits_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TraitsTestService_EchoEnumWithTraits_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TraitsTestService::EchoEnumWithTraitsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      EnumWithTraits in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoEnumWithTraits_ProxyToResponder);
};
class TraitsTestService_EchoEnumWithTraits_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestService_EchoEnumWithTraits_Response_Message(
      uint32_t message_flags
      , EnumWithTraits param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoEnumWithTraits_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TraitsTestService_EchoEnumWithTraits_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      EnumWithTraits param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestService_EchoEnumWithTraits_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoEnumWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoEnumWithTraits_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::mojo::test::EnumWithTraits>(
      param_passed, &params->passed);
    return message;
  }


  void Dispatch(mojo::Message* message,
                TraitsTestService::EchoEnumWithTraitsCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoEnumWithTraits_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::Serialize<::mojo::test::EnumWithTraits>(
      param_passed_, &params->passed);
  }
  EnumWithTraits param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoEnumWithTraits_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestService_EchoEnumWithTraits_Response_Message::kMessageTag = {};

bool TraitsTestService_EchoEnumWithTraits_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TraitsTestService::EchoEnumWithTraitsCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TraitsTestService_EchoEnumWithTraits_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TraitsTestService_EchoEnumWithTraits_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TraitsTestService_EchoEnumWithTraits_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  EnumWithTraits p_passed{};
  TraitsTestService_EchoEnumWithTraits_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TraitsTestService::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TraitsTestService_EchoEnumWithTraits_ProxyToResponder::Run(
    EnumWithTraits in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TraitsTestService::EchoEnumWithTraitsCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type EnumWithTraits>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TraitsTestService_EchoEnumWithTraits_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TraitsTestService::EchoEnumWithTraitsCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoEnumWithTraits");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder {
 public:
  static TraitsTestService::EchoStructWithTraitsForUniquePtrCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder> proxy(
        new TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TraitsTestService::EchoStructWithTraitsForUniquePtrCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      StructWithTraitsForUniquePtrPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder);
};
class TraitsTestService_EchoStructWithTraitsForUniquePtr_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestService_EchoStructWithTraitsForUniquePtr_Response_Message(
      uint32_t message_flags
      , StructWithTraitsForUniquePtrPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoStructWithTraitsForUniquePtr_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TraitsTestService_EchoStructWithTraitsForUniquePtr_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      StructWithTraitsForUniquePtrPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestService_EchoStructWithTraitsForUniquePtr_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoStructWithTraitsForUniquePtr_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsForUniquePtrDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoStructWithTraitsForUniquePtr response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                TraitsTestService::EchoStructWithTraitsForUniquePtrCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsForUniquePtrDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoStructWithTraitsForUniquePtr response");
  }
  StructWithTraitsForUniquePtrPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoStructWithTraitsForUniquePtr_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestService_EchoStructWithTraitsForUniquePtr_Response_Message::kMessageTag = {};

bool TraitsTestService_EchoStructWithTraitsForUniquePtr_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TraitsTestService::EchoStructWithTraitsForUniquePtrCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TraitsTestService_EchoStructWithTraitsForUniquePtr_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  StructWithTraitsForUniquePtrPtr p_passed{};
  TraitsTestService_EchoStructWithTraitsForUniquePtr_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TraitsTestService::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder::Run(
    StructWithTraitsForUniquePtrPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TraitsTestService::EchoStructWithTraitsForUniquePtrCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type StructWithTraitsForUniquePtrPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TraitsTestService_EchoStructWithTraitsForUniquePtr_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TraitsTestService::EchoStructWithTraitsForUniquePtrCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoStructWithTraitsForUniquePtr");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder {
 public:
  static TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder> proxy(
        new TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      StructWithTraitsForUniquePtrPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder);
};
class TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Response_Message(
      uint32_t message_flags
      , StructWithTraitsForUniquePtrPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      StructWithTraitsForUniquePtrPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsForUniquePtrDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
    return message;
  }


  void Dispatch(mojo::Message* message,
                TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithTraitsForUniquePtrDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  }
  StructWithTraitsForUniquePtrPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Response_Message::kMessageTag = {};

bool TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  StructWithTraitsForUniquePtrPtr p_passed{};
  TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TraitsTestService::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder::Run(
    StructWithTraitsForUniquePtrPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type StructWithTraitsForUniquePtrPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoNullableStructWithTraitsForUniquePtr");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class TraitsTestService_EchoUnionWithTraits_ProxyToResponder {
 public:
  static TraitsTestService::EchoUnionWithTraitsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TraitsTestService_EchoUnionWithTraits_ProxyToResponder> proxy(
        new TraitsTestService_EchoUnionWithTraits_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TraitsTestService_EchoUnionWithTraits_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TraitsTestService_EchoUnionWithTraits_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TraitsTestService_EchoUnionWithTraits_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TraitsTestService::EchoUnionWithTraitsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      UnionWithTraitsPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoUnionWithTraits_ProxyToResponder);
};
class TraitsTestService_EchoUnionWithTraits_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TraitsTestService_EchoUnionWithTraits_Response_Message(
      uint32_t message_flags
      , UnionWithTraitsPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTraitsTestService_EchoUnionWithTraits_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TraitsTestService_EchoUnionWithTraits_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      UnionWithTraitsPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TraitsTestService_EchoUnionWithTraits_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTraitsTestService_EchoUnionWithTraits_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TraitsTestService_EchoUnionWithTraits_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->passed)>
      passed_fragment(params.message());
  passed_fragment.Claim(&params->passed);
  mojo::internal::Serialize<::mojo::test::UnionWithTraitsDataView>(
      param_passed, passed_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoUnionWithTraits response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                TraitsTestService::EchoUnionWithTraitsCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TraitsTestService_EchoUnionWithTraits_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<decltype(params->passed)>
      passed_fragment(params.message());
  passed_fragment.Claim(&params->passed);
  mojo::internal::Serialize<::mojo::test::UnionWithTraitsDataView>(
      param_passed_, passed_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TraitsTestService.EchoUnionWithTraits response");
  }
  UnionWithTraitsPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TraitsTestService_EchoUnionWithTraits_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TraitsTestService_EchoUnionWithTraits_Response_Message::kMessageTag = {};

bool TraitsTestService_EchoUnionWithTraits_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TraitsTestService::EchoUnionWithTraitsCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TraitsTestService_EchoUnionWithTraits_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TraitsTestService_EchoUnionWithTraits_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TraitsTestService_EchoUnionWithTraits_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  UnionWithTraitsPtr p_passed{};
  TraitsTestService_EchoUnionWithTraits_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TraitsTestService::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TraitsTestService_EchoUnionWithTraits_ProxyToResponder::Run(
    UnionWithTraitsPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TraitsTestService::EchoUnionWithTraitsCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type UnionWithTraitsPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TraitsTestService_EchoUnionWithTraits_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TraitsTestService::EchoUnionWithTraitsCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TraitsTestService::Name_);
  message.set_method_name("EchoUnionWithTraits");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool TraitsTestServiceStubDispatch::Accept(
    TraitsTestService* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kTraitsTestService_EchoStructWithTraits_Name: {
      break;
    }
    case internal::kTraitsTestService_EchoTrivialStructWithTraits_Name: {
      break;
    }
    case internal::kTraitsTestService_EchoMoveOnlyStructWithTraits_Name: {
      break;
    }
    case internal::kTraitsTestService_EchoNullableMoveOnlyStructWithTraits_Name: {
      break;
    }
    case internal::kTraitsTestService_EchoEnumWithTraits_Name: {
      break;
    }
    case internal::kTraitsTestService_EchoStructWithTraitsForUniquePtr_Name: {
      break;
    }
    case internal::kTraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Name: {
      break;
    }
    case internal::kTraitsTestService_EchoUnionWithTraits_Name: {
      break;
    }
  }
  return false;
}

// static
bool TraitsTestServiceStubDispatch::AcceptWithResponder(
    TraitsTestService* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kTraitsTestService_EchoStructWithTraits_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TraitsTestService::EchoStructWithTraits",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TraitsTestService::EchoStructWithTraits");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TraitsTestServiceProxy_EchoStructWithTraits_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TraitsTestService::EchoStructWithTraitsCallback callback =
              TraitsTestService_EchoStructWithTraits_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TraitsTestService_EchoStructWithTraits_Params_Data* params =
          reinterpret_cast<
              internal::TraitsTestService_EchoStructWithTraits_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      StructWithTraitsPtr p_s{};
      TraitsTestService_EchoStructWithTraits_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TraitsTestService::Name_, 0, false);
        return false;
      }
      TraitsTestService::EchoStructWithTraitsCallback callback =
          TraitsTestService_EchoStructWithTraits_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EchoStructWithTraits(
std::move(p_s), std::move(callback));
      return true;
    }
    case internal::kTraitsTestService_EchoTrivialStructWithTraits_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TraitsTestService::EchoTrivialStructWithTraits",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TraitsTestService::EchoTrivialStructWithTraits");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TraitsTestServiceProxy_EchoTrivialStructWithTraits_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TraitsTestService::EchoTrivialStructWithTraitsCallback callback =
              TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TraitsTestService_EchoTrivialStructWithTraits_Params_Data* params =
          reinterpret_cast<
              internal::TraitsTestService_EchoTrivialStructWithTraits_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      TrivialStructWithTraitsPtr p_s{};
      TraitsTestService_EchoTrivialStructWithTraits_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TraitsTestService::Name_, 1, false);
        return false;
      }
      TraitsTestService::EchoTrivialStructWithTraitsCallback callback =
          TraitsTestService_EchoTrivialStructWithTraits_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EchoTrivialStructWithTraits(
std::move(p_s), std::move(callback));
      return true;
    }
    case internal::kTraitsTestService_EchoMoveOnlyStructWithTraits_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TraitsTestService::EchoMoveOnlyStructWithTraits",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TraitsTestService::EchoMoveOnlyStructWithTraits");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TraitsTestServiceProxy_EchoMoveOnlyStructWithTraits_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TraitsTestService::EchoMoveOnlyStructWithTraitsCallback callback =
              TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TraitsTestService_EchoMoveOnlyStructWithTraits_Params_Data* params =
          reinterpret_cast<
              internal::TraitsTestService_EchoMoveOnlyStructWithTraits_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      MoveOnlyStructWithTraitsPtr p_s{};
      TraitsTestService_EchoMoveOnlyStructWithTraits_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TraitsTestService::Name_, 2, false);
        return false;
      }
      TraitsTestService::EchoMoveOnlyStructWithTraitsCallback callback =
          TraitsTestService_EchoMoveOnlyStructWithTraits_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EchoMoveOnlyStructWithTraits(
std::move(p_s), std::move(callback));
      return true;
    }
    case internal::kTraitsTestService_EchoNullableMoveOnlyStructWithTraits_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TraitsTestService::EchoNullableMoveOnlyStructWithTraits",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TraitsTestService::EchoNullableMoveOnlyStructWithTraits");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TraitsTestServiceProxy_EchoNullableMoveOnlyStructWithTraits_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback callback =
              TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Params_Data* params =
          reinterpret_cast<
              internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      MoveOnlyStructWithTraitsPtr p_s{};
      TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TraitsTestService::Name_, 3, false);
        return false;
      }
      TraitsTestService::EchoNullableMoveOnlyStructWithTraitsCallback callback =
          TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EchoNullableMoveOnlyStructWithTraits(
std::move(p_s), std::move(callback));
      return true;
    }
    case internal::kTraitsTestService_EchoEnumWithTraits_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TraitsTestService::EchoEnumWithTraits",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TraitsTestService::EchoEnumWithTraits");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TraitsTestServiceProxy_EchoEnumWithTraits_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TraitsTestService::EchoEnumWithTraitsCallback callback =
              TraitsTestService_EchoEnumWithTraits_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TraitsTestService_EchoEnumWithTraits_Params_Data* params =
          reinterpret_cast<
              internal::TraitsTestService_EchoEnumWithTraits_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      EnumWithTraits p_e{};
      TraitsTestService_EchoEnumWithTraits_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadE(&p_e))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TraitsTestService::Name_, 4, false);
        return false;
      }
      TraitsTestService::EchoEnumWithTraitsCallback callback =
          TraitsTestService_EchoEnumWithTraits_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EchoEnumWithTraits(
std::move(p_e), std::move(callback));
      return true;
    }
    case internal::kTraitsTestService_EchoStructWithTraitsForUniquePtr_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TraitsTestService::EchoStructWithTraitsForUniquePtr",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TraitsTestService::EchoStructWithTraitsForUniquePtr");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TraitsTestServiceProxy_EchoStructWithTraitsForUniquePtr_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TraitsTestService::EchoStructWithTraitsForUniquePtrCallback callback =
              TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_Params_Data* params =
          reinterpret_cast<
              internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      StructWithTraitsForUniquePtrPtr p_e{};
      TraitsTestService_EchoStructWithTraitsForUniquePtr_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadE(&p_e))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TraitsTestService::Name_, 5, false);
        return false;
      }
      TraitsTestService::EchoStructWithTraitsForUniquePtrCallback callback =
          TraitsTestService_EchoStructWithTraitsForUniquePtr_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EchoStructWithTraitsForUniquePtr(
std::move(p_e), std::move(callback));
      return true;
    }
    case internal::kTraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TraitsTestService::EchoNullableStructWithTraitsForUniquePtr",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TraitsTestService::EchoNullableStructWithTraitsForUniquePtr");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TraitsTestServiceProxy_EchoNullableStructWithTraitsForUniquePtr_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback callback =
              TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Params_Data* params =
          reinterpret_cast<
              internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      StructWithTraitsForUniquePtrPtr p_e{};
      TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadE(&p_e))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TraitsTestService::Name_, 6, false);
        return false;
      }
      TraitsTestService::EchoNullableStructWithTraitsForUniquePtrCallback callback =
          TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EchoNullableStructWithTraitsForUniquePtr(
std::move(p_e), std::move(callback));
      return true;
    }
    case internal::kTraitsTestService_EchoUnionWithTraits_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TraitsTestService::EchoUnionWithTraits",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TraitsTestService::EchoUnionWithTraits");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TraitsTestServiceProxy_EchoUnionWithTraits_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TraitsTestService::EchoUnionWithTraitsCallback callback =
              TraitsTestService_EchoUnionWithTraits_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TraitsTestService_EchoUnionWithTraits_Params_Data* params =
          reinterpret_cast<
              internal::TraitsTestService_EchoUnionWithTraits_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      UnionWithTraitsPtr p_u{};
      TraitsTestService_EchoUnionWithTraits_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadU(&p_u))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TraitsTestService::Name_, 7, false);
        return false;
      }
      TraitsTestService::EchoUnionWithTraitsCallback callback =
          TraitsTestService_EchoUnionWithTraits_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EchoUnionWithTraits(
std::move(p_u), std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kTraitsTestServiceValidationInfo[] = {
    {internal::kTraitsTestService_EchoStructWithTraits_Name,
     {&internal::TraitsTestService_EchoStructWithTraits_Params_Data::Validate,
      &internal::TraitsTestService_EchoStructWithTraits_ResponseParams_Data::Validate}},
    {internal::kTraitsTestService_EchoTrivialStructWithTraits_Name,
     {&internal::TraitsTestService_EchoTrivialStructWithTraits_Params_Data::Validate,
      &internal::TraitsTestService_EchoTrivialStructWithTraits_ResponseParams_Data::Validate}},
    {internal::kTraitsTestService_EchoMoveOnlyStructWithTraits_Name,
     {&internal::TraitsTestService_EchoMoveOnlyStructWithTraits_Params_Data::Validate,
      &internal::TraitsTestService_EchoMoveOnlyStructWithTraits_ResponseParams_Data::Validate}},
    {internal::kTraitsTestService_EchoNullableMoveOnlyStructWithTraits_Name,
     {&internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_Params_Data::Validate,
      &internal::TraitsTestService_EchoNullableMoveOnlyStructWithTraits_ResponseParams_Data::Validate}},
    {internal::kTraitsTestService_EchoEnumWithTraits_Name,
     {&internal::TraitsTestService_EchoEnumWithTraits_Params_Data::Validate,
      &internal::TraitsTestService_EchoEnumWithTraits_ResponseParams_Data::Validate}},
    {internal::kTraitsTestService_EchoStructWithTraitsForUniquePtr_Name,
     {&internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_Params_Data::Validate,
      &internal::TraitsTestService_EchoStructWithTraitsForUniquePtr_ResponseParams_Data::Validate}},
    {internal::kTraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Name,
     {&internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_Params_Data::Validate,
      &internal::TraitsTestService_EchoNullableStructWithTraitsForUniquePtr_ResponseParams_Data::Validate}},
    {internal::kTraitsTestService_EchoUnionWithTraits_Name,
     {&internal::TraitsTestService_EchoUnionWithTraits_Params_Data::Validate,
      &internal::TraitsTestService_EchoUnionWithTraits_ResponseParams_Data::Validate}},
};

bool TraitsTestServiceRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::blink::TraitsTestService::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kTraitsTestServiceValidationInfo);
}

bool TraitsTestServiceResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::blink::TraitsTestService::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kTraitsTestServiceValidationInfo);

}
const char TestUnserializedStruct::Name_[] = "mojo.test.TestUnserializedStruct";

class TestUnserializedStruct_PassUnserializedStruct_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TestUnserializedStruct_PassUnserializedStruct_ForwardToCallback(
      TestUnserializedStruct::PassUnserializedStructCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  TestUnserializedStruct::PassUnserializedStructCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(TestUnserializedStruct_PassUnserializedStruct_ForwardToCallback);
};

TestUnserializedStructProxy::TestUnserializedStructProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class TestUnserializedStructProxy_PassUnserializedStruct_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TestUnserializedStructProxy_PassUnserializedStruct_Message(
      uint32_t message_flags
      , StructWithUnreachableTraitsPtr param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTestUnserializedStruct_PassUnserializedStruct_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~TestUnserializedStructProxy_PassUnserializedStruct_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      StructWithUnreachableTraitsPtr param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TestUnserializedStructProxy_PassUnserializedStruct_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTestUnserializedStruct_PassUnserializedStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TestUnserializedStruct_PassUnserializedStruct_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithUnreachableTraitsDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TestUnserializedStruct.PassUnserializedStruct request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TestUnserializedStruct* impl, TestUnserializedStruct::PassUnserializedStructCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassUnserializedStruct(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TestUnserializedStruct_PassUnserializedStruct_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithUnreachableTraitsDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TestUnserializedStruct.PassUnserializedStruct request");
  }
  StructWithUnreachableTraitsPtr param_s_;

  DISALLOW_COPY_AND_ASSIGN(TestUnserializedStructProxy_PassUnserializedStruct_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TestUnserializedStructProxy_PassUnserializedStruct_Message::kMessageTag = {};

void TestUnserializedStructProxy::PassUnserializedStruct(
    StructWithUnreachableTraitsPtr in_s, PassUnserializedStructCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::TestUnserializedStruct::PassUnserializedStruct", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type StructWithUnreachableTraitsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TestUnserializedStructProxy_PassUnserializedStruct_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TestUnserializedStruct::Name_);
  message.set_method_name("PassUnserializedStruct");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TestUnserializedStruct_PassUnserializedStruct_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder {
 public:
  static TestUnserializedStruct::PassUnserializedStructCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder> proxy(
        new TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TestUnserializedStruct::PassUnserializedStructCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      StructWithUnreachableTraitsPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder);
};
class TestUnserializedStruct_PassUnserializedStruct_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TestUnserializedStruct_PassUnserializedStruct_Response_Message(
      uint32_t message_flags
      , StructWithUnreachableTraitsPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTestUnserializedStruct_PassUnserializedStruct_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~TestUnserializedStruct_PassUnserializedStruct_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      StructWithUnreachableTraitsPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TestUnserializedStruct_PassUnserializedStruct_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTestUnserializedStruct_PassUnserializedStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::TestUnserializedStruct_PassUnserializedStruct_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithUnreachableTraitsDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TestUnserializedStruct.PassUnserializedStruct response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                TestUnserializedStruct::PassUnserializedStructCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::TestUnserializedStruct_PassUnserializedStruct_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructWithUnreachableTraitsDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in TestUnserializedStruct.PassUnserializedStruct response");
  }
  StructWithUnreachableTraitsPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(TestUnserializedStruct_PassUnserializedStruct_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TestUnserializedStruct_PassUnserializedStruct_Response_Message::kMessageTag = {};

bool TestUnserializedStruct_PassUnserializedStruct_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::TestUnserializedStruct::PassUnserializedStructCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<TestUnserializedStruct_PassUnserializedStruct_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::TestUnserializedStruct_PassUnserializedStruct_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TestUnserializedStruct_PassUnserializedStruct_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  StructWithUnreachableTraitsPtr p_passed{};
  TestUnserializedStruct_PassUnserializedStruct_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TestUnserializedStruct::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder::Run(
    StructWithUnreachableTraitsPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::TestUnserializedStruct::PassUnserializedStructCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type StructWithUnreachableTraitsPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = TestUnserializedStruct_PassUnserializedStruct_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::TestUnserializedStruct::PassUnserializedStructCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TestUnserializedStruct::Name_);
  message.set_method_name("PassUnserializedStruct");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool TestUnserializedStructStubDispatch::Accept(
    TestUnserializedStruct* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kTestUnserializedStruct_PassUnserializedStruct_Name: {
      break;
    }
  }
  return false;
}

// static
bool TestUnserializedStructStubDispatch::AcceptWithResponder(
    TestUnserializedStruct* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kTestUnserializedStruct_PassUnserializedStruct_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::TestUnserializedStruct::PassUnserializedStruct",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::TestUnserializedStruct::PassUnserializedStruct");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TestUnserializedStructProxy_PassUnserializedStruct_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          TestUnserializedStruct::PassUnserializedStructCallback callback =
              TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::TestUnserializedStruct_PassUnserializedStruct_Params_Data* params =
          reinterpret_cast<
              internal::TestUnserializedStruct_PassUnserializedStruct_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      StructWithUnreachableTraitsPtr p_s{};
      TestUnserializedStruct_PassUnserializedStruct_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TestUnserializedStruct::Name_, 0, false);
        return false;
      }
      TestUnserializedStruct::PassUnserializedStructCallback callback =
          TestUnserializedStruct_PassUnserializedStruct_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassUnserializedStruct(
std::move(p_s), std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kTestUnserializedStructValidationInfo[] = {
    {internal::kTestUnserializedStruct_PassUnserializedStruct_Name,
     {&internal::TestUnserializedStruct_PassUnserializedStruct_Params_Data::Validate,
      &internal::TestUnserializedStruct_PassUnserializedStruct_ResponseParams_Data::Validate}},
};

bool TestUnserializedStructRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::blink::TestUnserializedStruct::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kTestUnserializedStructValidationInfo);
}

bool TestUnserializedStructResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::blink::TestUnserializedStruct::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kTestUnserializedStructValidationInfo);

}
const char ForceSerializeTester::Name_[] = "mojo.test.ForceSerializeTester";

class ForceSerializeTester_SendForceSerializedStruct_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  ForceSerializeTester_SendForceSerializedStruct_ForwardToCallback(
      ForceSerializeTester::SendForceSerializedStructCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  ForceSerializeTester::SendForceSerializedStructCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(ForceSerializeTester_SendForceSerializedStruct_ForwardToCallback);
};

class ForceSerializeTester_SendNestedForceSerializedStruct_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  ForceSerializeTester_SendNestedForceSerializedStruct_ForwardToCallback(
      ForceSerializeTester::SendNestedForceSerializedStructCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  ForceSerializeTester::SendNestedForceSerializedStructCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(ForceSerializeTester_SendNestedForceSerializedStruct_ForwardToCallback);
};

ForceSerializeTesterProxy::ForceSerializeTesterProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class ForceSerializeTesterProxy_SendForceSerializedStruct_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ForceSerializeTesterProxy_SendForceSerializedStruct_Message(
      uint32_t message_flags
      , StructForceSerializePtr param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kForceSerializeTester_SendForceSerializedStruct_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~ForceSerializeTesterProxy_SendForceSerializedStruct_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      StructForceSerializePtr param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ForceSerializeTesterProxy_SendForceSerializedStruct_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kForceSerializeTester_SendForceSerializedStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::ForceSerializeTester_SendForceSerializedStruct_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructForceSerializeDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in ForceSerializeTester.SendForceSerializedStruct request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      ForceSerializeTester* impl, ForceSerializeTester::SendForceSerializedStructCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->SendForceSerializedStruct(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::ForceSerializeTester_SendForceSerializedStruct_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructForceSerializeDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in ForceSerializeTester.SendForceSerializedStruct request");
  }
  StructForceSerializePtr param_s_;

  DISALLOW_COPY_AND_ASSIGN(ForceSerializeTesterProxy_SendForceSerializedStruct_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ForceSerializeTesterProxy_SendForceSerializedStruct_Message::kMessageTag = {};

void ForceSerializeTesterProxy::SendForceSerializedStruct(
    StructForceSerializePtr in_s, SendForceSerializedStructCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::ForceSerializeTester::SendForceSerializedStruct", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type StructForceSerializePtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = ForceSerializeTesterProxy_SendForceSerializedStruct_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(ForceSerializeTester::Name_);
  message.set_method_name("SendForceSerializedStruct");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new ForceSerializeTester_SendForceSerializedStruct_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class ForceSerializeTesterProxy_SendNestedForceSerializedStruct_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ForceSerializeTesterProxy_SendNestedForceSerializedStruct_Message(
      uint32_t message_flags
      , StructNestedForceSerializePtr param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kForceSerializeTester_SendNestedForceSerializedStruct_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~ForceSerializeTesterProxy_SendNestedForceSerializedStruct_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      StructNestedForceSerializePtr param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ForceSerializeTesterProxy_SendNestedForceSerializedStruct_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kForceSerializeTester_SendNestedForceSerializedStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::ForceSerializeTester_SendNestedForceSerializedStruct_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructNestedForceSerializeDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in ForceSerializeTester.SendNestedForceSerializedStruct request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      ForceSerializeTester* impl, ForceSerializeTester::SendNestedForceSerializedStructCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->SendNestedForceSerializedStruct(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::ForceSerializeTester_SendNestedForceSerializedStruct_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructNestedForceSerializeDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in ForceSerializeTester.SendNestedForceSerializedStruct request");
  }
  StructNestedForceSerializePtr param_s_;

  DISALLOW_COPY_AND_ASSIGN(ForceSerializeTesterProxy_SendNestedForceSerializedStruct_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ForceSerializeTesterProxy_SendNestedForceSerializedStruct_Message::kMessageTag = {};

void ForceSerializeTesterProxy::SendNestedForceSerializedStruct(
    StructNestedForceSerializePtr in_s, SendNestedForceSerializedStructCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::ForceSerializeTester::SendNestedForceSerializedStruct", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type StructNestedForceSerializePtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = ForceSerializeTesterProxy_SendNestedForceSerializedStruct_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(ForceSerializeTester::Name_);
  message.set_method_name("SendNestedForceSerializedStruct");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new ForceSerializeTester_SendNestedForceSerializedStruct_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder {
 public:
  static ForceSerializeTester::SendForceSerializedStructCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder> proxy(
        new ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "ForceSerializeTester::SendForceSerializedStructCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      StructForceSerializePtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder);
};
class ForceSerializeTester_SendForceSerializedStruct_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ForceSerializeTester_SendForceSerializedStruct_Response_Message(
      uint32_t message_flags
      , StructForceSerializePtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kForceSerializeTester_SendForceSerializedStruct_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~ForceSerializeTester_SendForceSerializedStruct_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      StructForceSerializePtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ForceSerializeTester_SendForceSerializedStruct_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kForceSerializeTester_SendForceSerializedStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::ForceSerializeTester_SendForceSerializedStruct_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructForceSerializeDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in ForceSerializeTester.SendForceSerializedStruct response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                ForceSerializeTester::SendForceSerializedStructCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::ForceSerializeTester_SendForceSerializedStruct_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructForceSerializeDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in ForceSerializeTester.SendForceSerializedStruct response");
  }
  StructForceSerializePtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(ForceSerializeTester_SendForceSerializedStruct_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ForceSerializeTester_SendForceSerializedStruct_Response_Message::kMessageTag = {};

bool ForceSerializeTester_SendForceSerializedStruct_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::ForceSerializeTester::SendForceSerializedStructCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<ForceSerializeTester_SendForceSerializedStruct_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::ForceSerializeTester_SendForceSerializedStruct_ResponseParams_Data* params =
      reinterpret_cast<
          internal::ForceSerializeTester_SendForceSerializedStruct_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  StructForceSerializePtr p_passed{};
  ForceSerializeTester_SendForceSerializedStruct_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        ForceSerializeTester::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder::Run(
    StructForceSerializePtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::ForceSerializeTester::SendForceSerializedStructCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type StructForceSerializePtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = ForceSerializeTester_SendForceSerializedStruct_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::ForceSerializeTester::SendForceSerializedStructCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(ForceSerializeTester::Name_);
  message.set_method_name("SendForceSerializedStruct");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder {
 public:
  static ForceSerializeTester::SendNestedForceSerializedStructCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder> proxy(
        new ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "ForceSerializeTester::SendNestedForceSerializedStructCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      StructNestedForceSerializePtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder);
};
class ForceSerializeTester_SendNestedForceSerializedStruct_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ForceSerializeTester_SendNestedForceSerializedStruct_Response_Message(
      uint32_t message_flags
      , StructNestedForceSerializePtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kForceSerializeTester_SendNestedForceSerializedStruct_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~ForceSerializeTester_SendNestedForceSerializedStruct_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      StructNestedForceSerializePtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ForceSerializeTester_SendNestedForceSerializedStruct_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kForceSerializeTester_SendNestedForceSerializedStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::ForceSerializeTester_SendNestedForceSerializedStruct_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructNestedForceSerializeDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in ForceSerializeTester.SendNestedForceSerializedStruct response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                ForceSerializeTester::SendNestedForceSerializedStructCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::ForceSerializeTester_SendNestedForceSerializedStruct_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::StructNestedForceSerializeDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in ForceSerializeTester.SendNestedForceSerializedStruct response");
  }
  StructNestedForceSerializePtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(ForceSerializeTester_SendNestedForceSerializedStruct_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ForceSerializeTester_SendNestedForceSerializedStruct_Response_Message::kMessageTag = {};

bool ForceSerializeTester_SendNestedForceSerializedStruct_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::ForceSerializeTester::SendNestedForceSerializedStructCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<ForceSerializeTester_SendNestedForceSerializedStruct_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::ForceSerializeTester_SendNestedForceSerializedStruct_ResponseParams_Data* params =
      reinterpret_cast<
          internal::ForceSerializeTester_SendNestedForceSerializedStruct_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  StructNestedForceSerializePtr p_passed{};
  ForceSerializeTester_SendNestedForceSerializedStruct_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        ForceSerializeTester::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder::Run(
    StructNestedForceSerializePtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::ForceSerializeTester::SendNestedForceSerializedStructCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type StructNestedForceSerializePtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = ForceSerializeTester_SendNestedForceSerializedStruct_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::ForceSerializeTester::SendNestedForceSerializedStructCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(ForceSerializeTester::Name_);
  message.set_method_name("SendNestedForceSerializedStruct");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool ForceSerializeTesterStubDispatch::Accept(
    ForceSerializeTester* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kForceSerializeTester_SendForceSerializedStruct_Name: {
      break;
    }
    case internal::kForceSerializeTester_SendNestedForceSerializedStruct_Name: {
      break;
    }
  }
  return false;
}

// static
bool ForceSerializeTesterStubDispatch::AcceptWithResponder(
    ForceSerializeTester* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kForceSerializeTester_SendForceSerializedStruct_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::ForceSerializeTester::SendForceSerializedStruct",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::ForceSerializeTester::SendForceSerializedStruct");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            ForceSerializeTesterProxy_SendForceSerializedStruct_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          ForceSerializeTester::SendForceSerializedStructCallback callback =
              ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::ForceSerializeTester_SendForceSerializedStruct_Params_Data* params =
          reinterpret_cast<
              internal::ForceSerializeTester_SendForceSerializedStruct_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      StructForceSerializePtr p_s{};
      ForceSerializeTester_SendForceSerializedStruct_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            ForceSerializeTester::Name_, 0, false);
        return false;
      }
      ForceSerializeTester::SendForceSerializedStructCallback callback =
          ForceSerializeTester_SendForceSerializedStruct_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendForceSerializedStruct(
std::move(p_s), std::move(callback));
      return true;
    }
    case internal::kForceSerializeTester_SendNestedForceSerializedStruct_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::ForceSerializeTester::SendNestedForceSerializedStruct",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::ForceSerializeTester::SendNestedForceSerializedStruct");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            ForceSerializeTesterProxy_SendNestedForceSerializedStruct_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          ForceSerializeTester::SendNestedForceSerializedStructCallback callback =
              ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::ForceSerializeTester_SendNestedForceSerializedStruct_Params_Data* params =
          reinterpret_cast<
              internal::ForceSerializeTester_SendNestedForceSerializedStruct_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      StructNestedForceSerializePtr p_s{};
      ForceSerializeTester_SendNestedForceSerializedStruct_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            ForceSerializeTester::Name_, 1, false);
        return false;
      }
      ForceSerializeTester::SendNestedForceSerializedStructCallback callback =
          ForceSerializeTester_SendNestedForceSerializedStruct_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendNestedForceSerializedStruct(
std::move(p_s), std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kForceSerializeTesterValidationInfo[] = {
    {internal::kForceSerializeTester_SendForceSerializedStruct_Name,
     {&internal::ForceSerializeTester_SendForceSerializedStruct_Params_Data::Validate,
      &internal::ForceSerializeTester_SendForceSerializedStruct_ResponseParams_Data::Validate}},
    {internal::kForceSerializeTester_SendNestedForceSerializedStruct_Name,
     {&internal::ForceSerializeTester_SendNestedForceSerializedStruct_Params_Data::Validate,
      &internal::ForceSerializeTester_SendNestedForceSerializedStruct_ResponseParams_Data::Validate}},
};

bool ForceSerializeTesterRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::blink::ForceSerializeTester::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kForceSerializeTesterValidationInfo);
}

bool ForceSerializeTesterResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::blink::ForceSerializeTester::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kForceSerializeTesterValidationInfo);

}
}  // namespace blink
}  // namespace test
}  // namespace mojo

namespace mojo {


// static
bool StructTraits<::mojo::test::blink::NestedStructWithTraits::DataView, ::mojo::test::blink::NestedStructWithTraitsPtr>::Read(
    ::mojo::test::blink::NestedStructWithTraits::DataView input,
    ::mojo::test::blink::NestedStructWithTraitsPtr* output) {
  bool success = true;
  ::mojo::test::blink::NestedStructWithTraitsPtr result(::mojo::test::blink::NestedStructWithTraits::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::StructWithTraits::DataView, ::mojo::test::blink::StructWithTraitsPtr>::Read(
    ::mojo::test::blink::StructWithTraits::DataView input,
    ::mojo::test::blink::StructWithTraitsPtr* output) {
  bool success = true;
  ::mojo::test::blink::StructWithTraitsPtr result(::mojo::test::blink::StructWithTraits::New());
  
      if (success && !input.ReadFEnum(&result->f_enum))
        success = false;
      if (success)
        result->f_bool = input.f_bool();
      if (success)
        result->f_uint32 = input.f_uint32();
      if (success)
        result->f_uint64 = input.f_uint64();
      if (success && !input.ReadFString(&result->f_string))
        success = false;
      if (success && !input.ReadFString2(&result->f_string2))
        success = false;
      if (success && !input.ReadFStringArray(&result->f_string_array))
        success = false;
      if (success && !input.ReadFStringSet(&result->f_string_set))
        success = false;
      if (success && !input.ReadFStruct(&result->f_struct))
        success = false;
      if (success && !input.ReadFStructArray(&result->f_struct_array))
        success = false;
      if (success && !input.ReadFStructMap(&result->f_struct_map))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::StructWithUnreachableTraits::DataView, ::mojo::test::blink::StructWithUnreachableTraitsPtr>::Read(
    ::mojo::test::blink::StructWithUnreachableTraits::DataView input,
    ::mojo::test::blink::StructWithUnreachableTraitsPtr* output) {
  bool success = true;
  ::mojo::test::blink::StructWithUnreachableTraitsPtr result(::mojo::test::blink::StructWithUnreachableTraits::New());
  
      if (success)
        result->ignore_me = input.ignore_me();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::StructWithTraitsContainer::DataView, ::mojo::test::blink::StructWithTraitsContainerPtr>::Read(
    ::mojo::test::blink::StructWithTraitsContainer::DataView input,
    ::mojo::test::blink::StructWithTraitsContainerPtr* output) {
  bool success = true;
  ::mojo::test::blink::StructWithTraitsContainerPtr result(::mojo::test::blink::StructWithTraitsContainer::New());
  
      if (success && !input.ReadFStruct(&result->f_struct))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::TrivialStructWithTraits::DataView, ::mojo::test::blink::TrivialStructWithTraitsPtr>::Read(
    ::mojo::test::blink::TrivialStructWithTraits::DataView input,
    ::mojo::test::blink::TrivialStructWithTraitsPtr* output) {
  bool success = true;
  ::mojo::test::blink::TrivialStructWithTraitsPtr result(::mojo::test::blink::TrivialStructWithTraits::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::MoveOnlyStructWithTraits::DataView, ::mojo::test::blink::MoveOnlyStructWithTraitsPtr>::Read(
    ::mojo::test::blink::MoveOnlyStructWithTraits::DataView input,
    ::mojo::test::blink::MoveOnlyStructWithTraitsPtr* output) {
  bool success = true;
  ::mojo::test::blink::MoveOnlyStructWithTraitsPtr result(::mojo::test::blink::MoveOnlyStructWithTraits::New());
  
      if (success)
        result->f_handle = input.TakeFHandle();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::MoveOnlyStructWithTraitsContainer::DataView, ::mojo::test::blink::MoveOnlyStructWithTraitsContainerPtr>::Read(
    ::mojo::test::blink::MoveOnlyStructWithTraitsContainer::DataView input,
    ::mojo::test::blink::MoveOnlyStructWithTraitsContainerPtr* output) {
  bool success = true;
  ::mojo::test::blink::MoveOnlyStructWithTraitsContainerPtr result(::mojo::test::blink::MoveOnlyStructWithTraitsContainer::New());
  
      if (success && !input.ReadFStruct(&result->f_struct))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::StructWithTraitsForUniquePtr::DataView, ::mojo::test::blink::StructWithTraitsForUniquePtrPtr>::Read(
    ::mojo::test::blink::StructWithTraitsForUniquePtr::DataView input,
    ::mojo::test::blink::StructWithTraitsForUniquePtrPtr* output) {
  bool success = true;
  ::mojo::test::blink::StructWithTraitsForUniquePtrPtr result(::mojo::test::blink::StructWithTraitsForUniquePtr::New());
  
      if (success)
        result->f_int32 = input.f_int32();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::EnumWithTraitsContainer::DataView, ::mojo::test::blink::EnumWithTraitsContainerPtr>::Read(
    ::mojo::test::blink::EnumWithTraitsContainer::DataView input,
    ::mojo::test::blink::EnumWithTraitsContainerPtr* output) {
  bool success = true;
  ::mojo::test::blink::EnumWithTraitsContainerPtr result(::mojo::test::blink::EnumWithTraitsContainer::New());
  
      if (success && !input.ReadFField(&result->f_field))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::StructForceSerialize::DataView, ::mojo::test::blink::StructForceSerializePtr>::Read(
    ::mojo::test::blink::StructForceSerialize::DataView input,
    ::mojo::test::blink::StructForceSerializePtr* output) {
  bool success = true;
  ::mojo::test::blink::StructForceSerializePtr result(::mojo::test::blink::StructForceSerialize::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::mojo::test::blink::StructNestedForceSerialize::DataView, ::mojo::test::blink::StructNestedForceSerializePtr>::Read(
    ::mojo::test::blink::StructNestedForceSerialize::DataView input,
    ::mojo::test::blink::StructNestedForceSerializePtr* output) {
  bool success = true;
  ::mojo::test::blink::StructNestedForceSerializePtr result(::mojo::test::blink::StructNestedForceSerialize::New());
  
      if (success && !input.ReadForce(&result->force))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::mojo::test::blink::UnionWithTraits::DataView, ::mojo::test::blink::UnionWithTraitsPtr>::Read(
    ::mojo::test::blink::UnionWithTraits::DataView input,
    ::mojo::test::blink::UnionWithTraitsPtr* output) {
  using UnionType = ::mojo::test::blink::UnionWithTraits;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::F_INT32: {
      *output = UnionType::NewFInt32(input.f_int32());
      break;
    }
    case Tag::F_STRUCT: {
      ::mojo::test::blink::NestedStructWithTraitsPtr result_f_struct;
      if (!input.ReadFStruct(&result_f_struct))
        return false;

      *output = UnionType::NewFStruct(
          std::move(result_f_struct));
      break;
    }
    default:
      return false;
  }
  return true;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif