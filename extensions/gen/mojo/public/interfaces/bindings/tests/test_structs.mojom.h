// mojo/public/interfaces/bindings/tests/test_structs.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
#include "mojo/public/interfaces/bindings/tests/test_structs.mojom-shared.h"
#include "mojo/public/interfaces/bindings/tests/test_structs.mojom-forward.h"
#include "mojo/public/interfaces/bindings/tests/rect.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"

#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif


namespace mojo {
namespace test {

class SomeInterfaceProxy;

template <typename ImplRefTraits>
class SomeInterfaceStub;

class SomeInterfaceRequestValidator;
class SomeInterfaceResponseValidator;


// @generated_from: mojo.test.SomeInterface
class  SomeInterface
    : public SomeInterfaceInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = SomeInterfaceInterfaceBase;
  using Proxy_ = SomeInterfaceProxy;

  template <typename ImplRefTraits>
  using Stub_ = SomeInterfaceStub<ImplRefTraits>;

  using RequestValidator_ = SomeInterfaceRequestValidator;
  using ResponseValidator_ = SomeInterfaceResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSomeMethodMinVersion = 0,
  };
  virtual ~SomeInterface() {}


  using SomeMethodCallback = base::OnceCallback<void(RectPairPtr)>;
  
// @generated_from: mojo.test.SomeInterface.SomeMethod
  virtual void SomeMethod(RectPairPtr pair, SomeMethodCallback callback) = 0;
};



// @generated_from: mojo.test.SomeInterface
class  SomeInterfaceProxy
    : public SomeInterface {
 public:
  using InterfaceType = SomeInterface;

  explicit SomeInterfaceProxy(mojo::MessageReceiverWithResponder* receiver);
  
// @generated_from: mojo.test.SomeInterface.SomeMethod
  void SomeMethod(RectPairPtr pair, SomeMethodCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  SomeInterfaceStubDispatch {
 public:
  static bool Accept(SomeInterface* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SomeInterface* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SomeInterface>>
class SomeInterfaceStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SomeInterfaceStub() {}
  ~SomeInterfaceStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SomeInterfaceStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SomeInterfaceStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  SomeInterfaceRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  SomeInterfaceResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};







// @generated_from: mojo.test.EmptyStruct
class  EmptyStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EmptyStruct, T>::value>;
  using DataView = EmptyStructDataView;
  using Data_ = internal::EmptyStruct_Data;

  template <typename... Args>
  static EmptyStructPtr New(Args&&... args) {
    return EmptyStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EmptyStructPtr From(const U& u) {
    return mojo::TypeConverter<EmptyStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EmptyStruct>::Convert(*this);
  }


  EmptyStruct();

  ~EmptyStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EmptyStructPtr>
  EmptyStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EmptyStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EmptyStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EmptyStruct_UnserializedMessageContext<
            UserType, EmptyStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EmptyStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return EmptyStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EmptyStruct_UnserializedMessageContext<
            UserType, EmptyStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EmptyStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }


  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EmptyStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

















// @generated_from: mojo.test.MultiVersionStructV0
class  MultiVersionStructV0 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV0, T>::value>;
  using DataView = MultiVersionStructV0DataView;
  using Data_ = internal::MultiVersionStructV0_Data;

  template <typename... Args>
  static MultiVersionStructV0Ptr New(Args&&... args) {
    return MultiVersionStructV0Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV0Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV0Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV0>::Convert(*this);
  }


  MultiVersionStructV0();

  explicit MultiVersionStructV0(
      int32_t f_int32);

  ~MultiVersionStructV0();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV0Ptr>
  MultiVersionStructV0Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MultiVersionStructV0::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV0::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV0_UnserializedMessageContext<
            UserType, MultiVersionStructV0::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV0::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV0::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV0_UnserializedMessageContext<
            UserType, MultiVersionStructV0::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV0::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV0.f_int32
  int32_t f_int32;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV0::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}









// @generated_from: mojo.test.ReorderedStruct
class  ReorderedStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ReorderedStruct, T>::value>;
  using DataView = ReorderedStructDataView;
  using Data_ = internal::ReorderedStruct_Data;

  template <typename... Args>
  static ReorderedStructPtr New(Args&&... args) {
    return ReorderedStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ReorderedStructPtr From(const U& u) {
    return mojo::TypeConverter<ReorderedStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ReorderedStruct>::Convert(*this);
  }


  ReorderedStruct();

  explicit ReorderedStruct(
      int32_t c);

  ReorderedStruct(
      int32_t a,
      int32_t c);

  ReorderedStruct(
      int32_t a,
      int32_t b,
      int32_t c);

  ~ReorderedStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ReorderedStructPtr>
  ReorderedStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ReorderedStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ReorderedStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ReorderedStruct_UnserializedMessageContext<
            UserType, ReorderedStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ReorderedStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ReorderedStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ReorderedStruct_UnserializedMessageContext<
            UserType, ReorderedStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ReorderedStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ReorderedStruct.a
  int32_t a;
  
// @generated_from: mojo.test.ReorderedStruct.b
  int32_t b;
  
// @generated_from: mojo.test.ReorderedStruct.c
  int32_t c;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ReorderedStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.ContainsOther
class  ContainsOther {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ContainsOther, T>::value>;
  using DataView = ContainsOtherDataView;
  using Data_ = internal::ContainsOther_Data;

  template <typename... Args>
  static ContainsOtherPtr New(Args&&... args) {
    return ContainsOtherPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ContainsOtherPtr From(const U& u) {
    return mojo::TypeConverter<ContainsOtherPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsOther>::Convert(*this);
  }


  ContainsOther();

  explicit ContainsOther(
      int32_t other);

  ~ContainsOther();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ContainsOtherPtr>
  ContainsOtherPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ContainsOther::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ContainsOther::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ContainsOther_UnserializedMessageContext<
            UserType, ContainsOther::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ContainsOther::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ContainsOther::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ContainsOther_UnserializedMessageContext<
            UserType, ContainsOther::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ContainsOther::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ContainsOther.other
  int32_t other;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ContainsOther::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.SingleBoolStruct
class  SingleBoolStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SingleBoolStruct, T>::value>;
  using DataView = SingleBoolStructDataView;
  using Data_ = internal::SingleBoolStruct_Data;

  template <typename... Args>
  static SingleBoolStructPtr New(Args&&... args) {
    return SingleBoolStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SingleBoolStructPtr From(const U& u) {
    return mojo::TypeConverter<SingleBoolStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SingleBoolStruct>::Convert(*this);
  }


  SingleBoolStruct();

  explicit SingleBoolStruct(
      bool value);

  ~SingleBoolStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SingleBoolStructPtr>
  SingleBoolStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SingleBoolStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SingleBoolStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SingleBoolStruct_UnserializedMessageContext<
            UserType, SingleBoolStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SingleBoolStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SingleBoolStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SingleBoolStruct_UnserializedMessageContext<
            UserType, SingleBoolStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SingleBoolStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SingleBoolStruct.value
  bool value;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SingleBoolStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







// @generated_from: mojo.test.EnumNestedStruct
class  EnumNestedStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EnumNestedStruct, T>::value>;
  using DataView = EnumNestedStructDataView;
  using Data_ = internal::EnumNestedStruct_Data;
// @generated_from: mojo.test.EnumNestedStruct.StructEnum
  using StructEnum = EnumNestedStruct_StructEnum;

  template <typename... Args>
  static EnumNestedStructPtr New(Args&&... args) {
    return EnumNestedStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EnumNestedStructPtr From(const U& u) {
    return mojo::TypeConverter<EnumNestedStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EnumNestedStruct>::Convert(*this);
  }


  EnumNestedStruct();

  explicit EnumNestedStruct(
      EnumNestedStruct::StructEnum local_enum_state_);

  ~EnumNestedStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EnumNestedStructPtr>
  EnumNestedStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EnumNestedStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EnumNestedStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EnumNestedStruct_UnserializedMessageContext<
            UserType, EnumNestedStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EnumNestedStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return EnumNestedStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EnumNestedStruct_UnserializedMessageContext<
            UserType, EnumNestedStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EnumNestedStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.EnumNestedStruct.local_enum_state_
  EnumNestedStruct::StructEnum local_enum_state_;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EnumNestedStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







// @generated_from: mojo.test.NamedRegion
class  NamedRegion {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NamedRegion, T>::value>;
  using DataView = NamedRegionDataView;
  using Data_ = internal::NamedRegion_Data;

  template <typename... Args>
  static NamedRegionPtr New(Args&&... args) {
    return NamedRegionPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NamedRegionPtr From(const U& u) {
    return mojo::TypeConverter<NamedRegionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NamedRegion>::Convert(*this);
  }


  NamedRegion();

  NamedRegion(
      const base::Optional<std::string>& name,
      base::Optional<std::vector<::mojo::test::RectPtr>> rects);

  ~NamedRegion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NamedRegionPtr>
  NamedRegionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        NamedRegion::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NamedRegion::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NamedRegion_UnserializedMessageContext<
            UserType, NamedRegion::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NamedRegion::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return NamedRegion::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NamedRegion_UnserializedMessageContext<
            UserType, NamedRegion::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NamedRegion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.NamedRegion.name
  base::Optional<std::string> name;
  
// @generated_from: mojo.test.NamedRegion.rects
  base::Optional<std::vector<::mojo::test::RectPtr>> rects;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(NamedRegion);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NamedRegion::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.RectPair
class  RectPair {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<RectPair, T>::value>;
  using DataView = RectPairDataView;
  using Data_ = internal::RectPair_Data;

  template <typename... Args>
  static RectPairPtr New(Args&&... args) {
    return RectPairPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static RectPairPtr From(const U& u) {
    return mojo::TypeConverter<RectPairPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RectPair>::Convert(*this);
  }


  RectPair();

  RectPair(
      ::mojo::test::RectPtr first,
      ::mojo::test::RectPtr second);

  ~RectPair();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = RectPairPtr>
  RectPairPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, RectPair::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, RectPair::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        RectPair::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        RectPair::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::RectPair_UnserializedMessageContext<
            UserType, RectPair::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<RectPair::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return RectPair::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::RectPair_UnserializedMessageContext<
            UserType, RectPair::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<RectPair::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.RectPair.first
  ::mojo::test::RectPtr first;
  
// @generated_from: mojo.test.RectPair.second
  ::mojo::test::RectPtr second;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(RectPair);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RectPair::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, RectPair::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, RectPair::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, RectPair::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







// @generated_from: mojo.test.NoDefaultFieldValues
class  NoDefaultFieldValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NoDefaultFieldValues, T>::value>;
  using DataView = NoDefaultFieldValuesDataView;
  using Data_ = internal::NoDefaultFieldValues_Data;

  template <typename... Args>
  static NoDefaultFieldValuesPtr New(Args&&... args) {
    return NoDefaultFieldValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NoDefaultFieldValuesPtr From(const U& u) {
    return mojo::TypeConverter<NoDefaultFieldValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NoDefaultFieldValues>::Convert(*this);
  }


  NoDefaultFieldValues();

  NoDefaultFieldValues(
      bool f0,
      int8_t f1,
      uint8_t f2,
      int16_t f3,
      uint16_t f4,
      int32_t f5,
      uint32_t f6,
      int64_t f7,
      uint64_t f8,
      float f9,
      double f10,
      const std::string& f11,
      const base::Optional<std::string>& f12,
      ::mojo::ScopedMessagePipeHandle f13,
      ::mojo::ScopedDataPipeConsumerHandle f14,
      ::mojo::ScopedDataPipeProducerHandle f15,
      ::mojo::ScopedMessagePipeHandle f16,
      ::mojo::ScopedDataPipeConsumerHandle f17,
      ::mojo::ScopedDataPipeProducerHandle f18,
      ::mojo::ScopedHandle f19,
      ::mojo::ScopedHandle f20,
      ::mojo::ScopedSharedBufferHandle f21,
      ::mojo::ScopedSharedBufferHandle f22,
      std::vector<std::string> f23,
      std::vector<base::Optional<std::string>> f24,
      base::Optional<std::vector<std::string>> f25,
      base::Optional<std::vector<base::Optional<std::string>>> f26,
      EmptyStructPtr f27,
      EmptyStructPtr f28,
      ::mojo::PlatformHandle f29,
      ::mojo::PlatformHandle f30);

  ~NoDefaultFieldValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NoDefaultFieldValuesPtr>
  NoDefaultFieldValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NoDefaultFieldValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NoDefaultFieldValues_UnserializedMessageContext<
            UserType, NoDefaultFieldValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NoDefaultFieldValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return NoDefaultFieldValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NoDefaultFieldValues_UnserializedMessageContext<
            UserType, NoDefaultFieldValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NoDefaultFieldValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.NoDefaultFieldValues.f0
  bool f0;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f1
  int8_t f1;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f2
  uint8_t f2;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f3
  int16_t f3;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f4
  uint16_t f4;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f5
  int32_t f5;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f6
  uint32_t f6;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f7
  int64_t f7;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f8
  uint64_t f8;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f9
  float f9;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f10
  double f10;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f11
  std::string f11;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f12
  base::Optional<std::string> f12;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f13
  ::mojo::ScopedMessagePipeHandle f13;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f14
  ::mojo::ScopedDataPipeConsumerHandle f14;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f15
  ::mojo::ScopedDataPipeProducerHandle f15;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f16
  ::mojo::ScopedMessagePipeHandle f16;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f17
  ::mojo::ScopedDataPipeConsumerHandle f17;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f18
  ::mojo::ScopedDataPipeProducerHandle f18;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f19
  ::mojo::ScopedHandle f19;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f20
  ::mojo::ScopedHandle f20;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f21
  ::mojo::ScopedSharedBufferHandle f21;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f22
  ::mojo::ScopedSharedBufferHandle f22;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f23
  std::vector<std::string> f23;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f24
  std::vector<base::Optional<std::string>> f24;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f25
  base::Optional<std::vector<std::string>> f25;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f26
  base::Optional<std::vector<base::Optional<std::string>>> f26;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f27
  EmptyStructPtr f27;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f28
  EmptyStructPtr f28;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f29
  ::mojo::PlatformHandle f29;
  
// @generated_from: mojo.test.NoDefaultFieldValues.f30
  ::mojo::PlatformHandle f30;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(NoDefaultFieldValues);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NoDefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.DefaultFieldValues
class  DefaultFieldValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DefaultFieldValues, T>::value>;
  using DataView = DefaultFieldValuesDataView;
  using Data_ = internal::DefaultFieldValues_Data;
  
// @generated_from: mojo.test.DefaultFieldValues.kFoo
  static const char kFoo[];

  template <typename... Args>
  static DefaultFieldValuesPtr New(Args&&... args) {
    return DefaultFieldValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DefaultFieldValuesPtr From(const U& u) {
    return mojo::TypeConverter<DefaultFieldValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DefaultFieldValues>::Convert(*this);
  }


  DefaultFieldValues();

  DefaultFieldValues(
      bool f0,
      int8_t f1,
      uint8_t f2,
      int16_t f3,
      uint16_t f4,
      int32_t f5,
      uint32_t f6,
      int64_t f7,
      uint64_t f8,
      float f9,
      float f10,
      double f11,
      double f12,
      const std::string& f13,
      const base::Optional<std::string>& f14,
      ::mojo::test::RectPtr f15,
      ::mojo::test::RectPtr f16);

  ~DefaultFieldValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DefaultFieldValuesPtr>
  DefaultFieldValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DefaultFieldValues::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DefaultFieldValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DefaultFieldValues_UnserializedMessageContext<
            UserType, DefaultFieldValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DefaultFieldValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DefaultFieldValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DefaultFieldValues_UnserializedMessageContext<
            UserType, DefaultFieldValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DefaultFieldValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.DefaultFieldValues.f0
  bool f0;
  
// @generated_from: mojo.test.DefaultFieldValues.f1
  int8_t f1;
  
// @generated_from: mojo.test.DefaultFieldValues.f2
  uint8_t f2;
  
// @generated_from: mojo.test.DefaultFieldValues.f3
  int16_t f3;
  
// @generated_from: mojo.test.DefaultFieldValues.f4
  uint16_t f4;
  
// @generated_from: mojo.test.DefaultFieldValues.f5
  int32_t f5;
  
// @generated_from: mojo.test.DefaultFieldValues.f6
  uint32_t f6;
  
// @generated_from: mojo.test.DefaultFieldValues.f7
  int64_t f7;
  
// @generated_from: mojo.test.DefaultFieldValues.f8
  uint64_t f8;
  
// @generated_from: mojo.test.DefaultFieldValues.f9
  float f9;
  
// @generated_from: mojo.test.DefaultFieldValues.f10
  float f10;
  
// @generated_from: mojo.test.DefaultFieldValues.f11
  double f11;
  
// @generated_from: mojo.test.DefaultFieldValues.f12
  double f12;
  
// @generated_from: mojo.test.DefaultFieldValues.f13
  std::string f13;
  
// @generated_from: mojo.test.DefaultFieldValues.f14
  base::Optional<std::string> f14;
  
// @generated_from: mojo.test.DefaultFieldValues.f15
  ::mojo::test::RectPtr f15;
  
// @generated_from: mojo.test.DefaultFieldValues.f16
  ::mojo::test::RectPtr f16;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(DefaultFieldValues);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DefaultFieldValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.ScopedConstants
class  ScopedConstants {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ScopedConstants, T>::value>;
  using DataView = ScopedConstantsDataView;
  using Data_ = internal::ScopedConstants_Data;
// @generated_from: mojo.test.ScopedConstants.EType
  using EType = ScopedConstants_EType;
  
// @generated_from: mojo.test.ScopedConstants.TEN
  static constexpr int32_t TEN = 10;
  
// @generated_from: mojo.test.ScopedConstants.ALSO_TEN
  static constexpr int32_t ALSO_TEN = 10;

  template <typename... Args>
  static ScopedConstantsPtr New(Args&&... args) {
    return ScopedConstantsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ScopedConstantsPtr From(const U& u) {
    return mojo::TypeConverter<ScopedConstantsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ScopedConstants>::Convert(*this);
  }


  ScopedConstants();

  ScopedConstants(
      ScopedConstants::EType f0,
      ScopedConstants::EType f1,
      ScopedConstants::EType f2,
      ScopedConstants::EType f3,
      ScopedConstants::EType f4,
      int32_t f5,
      int32_t f6);

  ~ScopedConstants();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ScopedConstantsPtr>
  ScopedConstantsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ScopedConstants::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ScopedConstants::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ScopedConstants_UnserializedMessageContext<
            UserType, ScopedConstants::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ScopedConstants::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ScopedConstants::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ScopedConstants_UnserializedMessageContext<
            UserType, ScopedConstants::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ScopedConstants::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ScopedConstants.f0
  ScopedConstants::EType f0;
  
// @generated_from: mojo.test.ScopedConstants.f1
  ScopedConstants::EType f1;
  
// @generated_from: mojo.test.ScopedConstants.f2
  ScopedConstants::EType f2;
  
// @generated_from: mojo.test.ScopedConstants.f3
  ScopedConstants::EType f3;
  
// @generated_from: mojo.test.ScopedConstants.f4
  ScopedConstants::EType f4;
  
// @generated_from: mojo.test.ScopedConstants.f5
  int32_t f5;
  
// @generated_from: mojo.test.ScopedConstants.f6
  int32_t f6;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ScopedConstants::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MapKeyTypes
class  MapKeyTypes {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MapKeyTypes, T>::value>;
  using DataView = MapKeyTypesDataView;
  using Data_ = internal::MapKeyTypes_Data;

  template <typename... Args>
  static MapKeyTypesPtr New(Args&&... args) {
    return MapKeyTypesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MapKeyTypesPtr From(const U& u) {
    return mojo::TypeConverter<MapKeyTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MapKeyTypes>::Convert(*this);
  }


  MapKeyTypes();

  MapKeyTypes(
      const base::flat_map<int8_t, int8_t>& f1,
      const base::flat_map<uint8_t, uint8_t>& f2,
      const base::flat_map<int16_t, int16_t>& f3,
      const base::flat_map<uint16_t, uint16_t>& f4,
      const base::flat_map<int32_t, int32_t>& f5,
      const base::flat_map<uint32_t, uint32_t>& f6,
      const base::flat_map<int64_t, int64_t>& f7,
      const base::flat_map<uint64_t, uint64_t>& f8,
      const base::flat_map<float, float>& f9,
      const base::flat_map<double, double>& f10,
      const base::flat_map<std::string, std::string>& f11);

  ~MapKeyTypes();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MapKeyTypesPtr>
  MapKeyTypesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MapKeyTypes::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MapKeyTypes::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MapKeyTypes_UnserializedMessageContext<
            UserType, MapKeyTypes::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MapKeyTypes::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MapKeyTypes::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MapKeyTypes_UnserializedMessageContext<
            UserType, MapKeyTypes::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MapKeyTypes::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MapKeyTypes.f1
  base::flat_map<int8_t, int8_t> f1;
  
// @generated_from: mojo.test.MapKeyTypes.f2
  base::flat_map<uint8_t, uint8_t> f2;
  
// @generated_from: mojo.test.MapKeyTypes.f3
  base::flat_map<int16_t, int16_t> f3;
  
// @generated_from: mojo.test.MapKeyTypes.f4
  base::flat_map<uint16_t, uint16_t> f4;
  
// @generated_from: mojo.test.MapKeyTypes.f5
  base::flat_map<int32_t, int32_t> f5;
  
// @generated_from: mojo.test.MapKeyTypes.f6
  base::flat_map<uint32_t, uint32_t> f6;
  
// @generated_from: mojo.test.MapKeyTypes.f7
  base::flat_map<int64_t, int64_t> f7;
  
// @generated_from: mojo.test.MapKeyTypes.f8
  base::flat_map<uint64_t, uint64_t> f8;
  
// @generated_from: mojo.test.MapKeyTypes.f9
  base::flat_map<float, float> f9;
  
// @generated_from: mojo.test.MapKeyTypes.f10
  base::flat_map<double, double> f10;
  
// @generated_from: mojo.test.MapKeyTypes.f11
  base::flat_map<std::string, std::string> f11;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MapKeyTypes::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MapValueTypes
class  MapValueTypes {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MapValueTypes, T>::value>;
  using DataView = MapValueTypesDataView;
  using Data_ = internal::MapValueTypes_Data;

  template <typename... Args>
  static MapValueTypesPtr New(Args&&... args) {
    return MapValueTypesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MapValueTypesPtr From(const U& u) {
    return mojo::TypeConverter<MapValueTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MapValueTypes>::Convert(*this);
  }


  MapValueTypes();

  MapValueTypes(
      const base::flat_map<std::string, std::vector<std::string>>& f0,
      const base::flat_map<std::string, base::Optional<std::vector<std::string>>>& f1,
      const base::flat_map<std::string, std::vector<base::Optional<std::string>>>& f2,
      const base::flat_map<std::string, std::vector<std::string>>& f3,
      const base::flat_map<std::string, std::vector<base::Optional<std::vector<std::string>>>>& f4,
      const base::flat_map<std::string, std::vector<std::vector<std::string>>>& f5,
      base::flat_map<std::string, ::mojo::test::RectPtr> f6,
      const base::flat_map<std::string, base::flat_map<std::string, std::string>>& f7,
      const base::flat_map<std::string, std::vector<base::flat_map<std::string, std::string>>>& f8,
      base::flat_map<std::string, ::mojo::ScopedHandle> f9,
      base::flat_map<std::string, std::vector<::mojo::ScopedHandle>> f10,
      base::flat_map<std::string, base::flat_map<std::string, ::mojo::ScopedHandle>> f11);

  ~MapValueTypes();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MapValueTypesPtr>
  MapValueTypesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MapValueTypes::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MapValueTypes_UnserializedMessageContext<
            UserType, MapValueTypes::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MapValueTypes::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MapValueTypes::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MapValueTypes_UnserializedMessageContext<
            UserType, MapValueTypes::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MapValueTypes::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MapValueTypes.f0
  base::flat_map<std::string, std::vector<std::string>> f0;
  
// @generated_from: mojo.test.MapValueTypes.f1
  base::flat_map<std::string, base::Optional<std::vector<std::string>>> f1;
  
// @generated_from: mojo.test.MapValueTypes.f2
  base::flat_map<std::string, std::vector<base::Optional<std::string>>> f2;
  
// @generated_from: mojo.test.MapValueTypes.f3
  base::flat_map<std::string, std::vector<std::string>> f3;
  
// @generated_from: mojo.test.MapValueTypes.f4
  base::flat_map<std::string, std::vector<base::Optional<std::vector<std::string>>>> f4;
  
// @generated_from: mojo.test.MapValueTypes.f5
  base::flat_map<std::string, std::vector<std::vector<std::string>>> f5;
  
// @generated_from: mojo.test.MapValueTypes.f6
  base::flat_map<std::string, ::mojo::test::RectPtr> f6;
  
// @generated_from: mojo.test.MapValueTypes.f7
  base::flat_map<std::string, base::flat_map<std::string, std::string>> f7;
  
// @generated_from: mojo.test.MapValueTypes.f8
  base::flat_map<std::string, std::vector<base::flat_map<std::string, std::string>>> f8;
  
// @generated_from: mojo.test.MapValueTypes.f9
  base::flat_map<std::string, ::mojo::ScopedHandle> f9;
  
// @generated_from: mojo.test.MapValueTypes.f10
  base::flat_map<std::string, std::vector<::mojo::ScopedHandle>> f10;
  
// @generated_from: mojo.test.MapValueTypes.f11
  base::flat_map<std::string, base::flat_map<std::string, ::mojo::ScopedHandle>> f11;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MapValueTypes);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MapValueTypes::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.ArrayValueTypes
class  ArrayValueTypes {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ArrayValueTypes, T>::value>;
  using DataView = ArrayValueTypesDataView;
  using Data_ = internal::ArrayValueTypes_Data;

  template <typename... Args>
  static ArrayValueTypesPtr New(Args&&... args) {
    return ArrayValueTypesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ArrayValueTypesPtr From(const U& u) {
    return mojo::TypeConverter<ArrayValueTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ArrayValueTypes>::Convert(*this);
  }


  ArrayValueTypes();

  ArrayValueTypes(
      std::vector<int8_t> f0,
      std::vector<int16_t> f1,
      std::vector<int32_t> f2,
      std::vector<int64_t> f3,
      std::vector<float> f4,
      std::vector<double> f5,
      std::vector<::mojo::PendingRemote<SomeInterface>> f6,
      std::vector<::mojo::PendingReceiver<SomeInterface>> f7);

  ~ArrayValueTypes();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ArrayValueTypesPtr>
  ArrayValueTypesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ArrayValueTypes::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ArrayValueTypes_UnserializedMessageContext<
            UserType, ArrayValueTypes::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ArrayValueTypes::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ArrayValueTypes::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ArrayValueTypes_UnserializedMessageContext<
            UserType, ArrayValueTypes::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ArrayValueTypes::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ArrayValueTypes.f0
  std::vector<int8_t> f0;
  
// @generated_from: mojo.test.ArrayValueTypes.f1
  std::vector<int16_t> f1;
  
// @generated_from: mojo.test.ArrayValueTypes.f2
  std::vector<int32_t> f2;
  
// @generated_from: mojo.test.ArrayValueTypes.f3
  std::vector<int64_t> f3;
  
// @generated_from: mojo.test.ArrayValueTypes.f4
  std::vector<float> f4;
  
// @generated_from: mojo.test.ArrayValueTypes.f5
  std::vector<double> f5;
  
// @generated_from: mojo.test.ArrayValueTypes.f6
  std::vector<::mojo::PendingRemote<SomeInterface>> f6;
  
// @generated_from: mojo.test.ArrayValueTypes.f7
  std::vector<::mojo::PendingReceiver<SomeInterface>> f7;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ArrayValueTypes);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ArrayValueTypes::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.FloatNumberValues
class  FloatNumberValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FloatNumberValues, T>::value>;
  using DataView = FloatNumberValuesDataView;
  using Data_ = internal::FloatNumberValues_Data;
  
// @generated_from: mojo.test.FloatNumberValues.V0
  static constexpr double V0 = std::numeric_limits<double>::infinity();
  
// @generated_from: mojo.test.FloatNumberValues.V1
  static constexpr double V1 = -std::numeric_limits<double>::infinity();
  
// @generated_from: mojo.test.FloatNumberValues.V2
  static constexpr double V2 = std::numeric_limits<double>::quiet_NaN();
  
// @generated_from: mojo.test.FloatNumberValues.V3
  static constexpr float V3 = std::numeric_limits<float>::infinity();
  
// @generated_from: mojo.test.FloatNumberValues.V4
  static constexpr float V4 = -std::numeric_limits<float>::infinity();
  
// @generated_from: mojo.test.FloatNumberValues.V5
  static constexpr float V5 = std::numeric_limits<float>::quiet_NaN();
  
// @generated_from: mojo.test.FloatNumberValues.V6
  static constexpr float V6 = 0;
  
// @generated_from: mojo.test.FloatNumberValues.V7
  static constexpr double V7 = 1234567890.123;
  
// @generated_from: mojo.test.FloatNumberValues.V8
  static constexpr double V8 = 1.2E+20;
  
// @generated_from: mojo.test.FloatNumberValues.V9
  static constexpr double V9 = -1.2E+20;

  template <typename... Args>
  static FloatNumberValuesPtr New(Args&&... args) {
    return FloatNumberValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FloatNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<FloatNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FloatNumberValues>::Convert(*this);
  }


  FloatNumberValues();

  FloatNumberValues(
      double f0,
      double f1,
      double f2,
      float f3,
      float f4,
      float f5,
      float f6,
      double f7,
      double f8,
      double f9);

  ~FloatNumberValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FloatNumberValuesPtr>
  FloatNumberValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FloatNumberValues::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FloatNumberValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FloatNumberValues_UnserializedMessageContext<
            UserType, FloatNumberValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FloatNumberValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FloatNumberValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FloatNumberValues_UnserializedMessageContext<
            UserType, FloatNumberValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FloatNumberValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.FloatNumberValues.f0
  double f0;
  
// @generated_from: mojo.test.FloatNumberValues.f1
  double f1;
  
// @generated_from: mojo.test.FloatNumberValues.f2
  double f2;
  
// @generated_from: mojo.test.FloatNumberValues.f3
  float f3;
  
// @generated_from: mojo.test.FloatNumberValues.f4
  float f4;
  
// @generated_from: mojo.test.FloatNumberValues.f5
  float f5;
  
// @generated_from: mojo.test.FloatNumberValues.f6
  float f6;
  
// @generated_from: mojo.test.FloatNumberValues.f7
  double f7;
  
// @generated_from: mojo.test.FloatNumberValues.f8
  double f8;
  
// @generated_from: mojo.test.FloatNumberValues.f9
  double f9;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FloatNumberValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.IntegerNumberValues
class  IntegerNumberValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<IntegerNumberValues, T>::value>;
  using DataView = IntegerNumberValuesDataView;
  using Data_ = internal::IntegerNumberValues_Data;
  
// @generated_from: mojo.test.IntegerNumberValues.V0
  static constexpr int8_t V0 = -128;
  
// @generated_from: mojo.test.IntegerNumberValues.V1
  static constexpr int8_t V1 = -1;
  
// @generated_from: mojo.test.IntegerNumberValues.V2
  static constexpr int8_t V2 = 0;
  
// @generated_from: mojo.test.IntegerNumberValues.V3
  static constexpr int8_t V3 = 42;
  
// @generated_from: mojo.test.IntegerNumberValues.V4
  static constexpr int8_t V4 = 127;
  
// @generated_from: mojo.test.IntegerNumberValues.V5
  static constexpr int16_t V5 = -32768;
  
// @generated_from: mojo.test.IntegerNumberValues.V6
  static constexpr int16_t V6 = -1;
  
// @generated_from: mojo.test.IntegerNumberValues.V7
  static constexpr int16_t V7 = 0;
  
// @generated_from: mojo.test.IntegerNumberValues.V8
  static constexpr int16_t V8 = 12345;
  
// @generated_from: mojo.test.IntegerNumberValues.V9
  static constexpr int16_t V9 = 32767;
  
// @generated_from: mojo.test.IntegerNumberValues.V10
  static constexpr int32_t V10 = -2147483648;
  
// @generated_from: mojo.test.IntegerNumberValues.V11
  static constexpr int32_t V11 = -1;
  
// @generated_from: mojo.test.IntegerNumberValues.V12
  static constexpr int32_t V12 = 0;
  
// @generated_from: mojo.test.IntegerNumberValues.V13
  static constexpr int32_t V13 = 1234567890;
  
// @generated_from: mojo.test.IntegerNumberValues.V14
  static constexpr int32_t V14 = 2147483647;
  
// @generated_from: mojo.test.IntegerNumberValues.V15
  static constexpr int64_t V15 = -9007199254740991;
  
// @generated_from: mojo.test.IntegerNumberValues.V16
  static constexpr int64_t V16 = -1;
  
// @generated_from: mojo.test.IntegerNumberValues.V17
  static constexpr int64_t V17 = 0;
  
// @generated_from: mojo.test.IntegerNumberValues.V18
  static constexpr int64_t V18 = 1234567890123456;
  
// @generated_from: mojo.test.IntegerNumberValues.V19
  static constexpr int64_t V19 = 9007199254740991;

  template <typename... Args>
  static IntegerNumberValuesPtr New(Args&&... args) {
    return IntegerNumberValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static IntegerNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<IntegerNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IntegerNumberValues>::Convert(*this);
  }


  IntegerNumberValues();

  IntegerNumberValues(
      int8_t f0,
      int8_t f1,
      int8_t f2,
      int8_t f3,
      int8_t f4,
      int16_t f5,
      int16_t f6,
      int16_t f7,
      int16_t f8,
      int16_t f9,
      int32_t f10,
      int32_t f11,
      int32_t f12,
      int32_t f13,
      int32_t f14,
      int64_t f15,
      int64_t f16,
      int64_t f17,
      int64_t f18,
      int64_t f19);

  ~IntegerNumberValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = IntegerNumberValuesPtr>
  IntegerNumberValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        IntegerNumberValues::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        IntegerNumberValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::IntegerNumberValues_UnserializedMessageContext<
            UserType, IntegerNumberValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<IntegerNumberValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return IntegerNumberValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::IntegerNumberValues_UnserializedMessageContext<
            UserType, IntegerNumberValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<IntegerNumberValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.IntegerNumberValues.f0
  int8_t f0;
  
// @generated_from: mojo.test.IntegerNumberValues.f1
  int8_t f1;
  
// @generated_from: mojo.test.IntegerNumberValues.f2
  int8_t f2;
  
// @generated_from: mojo.test.IntegerNumberValues.f3
  int8_t f3;
  
// @generated_from: mojo.test.IntegerNumberValues.f4
  int8_t f4;
  
// @generated_from: mojo.test.IntegerNumberValues.f5
  int16_t f5;
  
// @generated_from: mojo.test.IntegerNumberValues.f6
  int16_t f6;
  
// @generated_from: mojo.test.IntegerNumberValues.f7
  int16_t f7;
  
// @generated_from: mojo.test.IntegerNumberValues.f8
  int16_t f8;
  
// @generated_from: mojo.test.IntegerNumberValues.f9
  int16_t f9;
  
// @generated_from: mojo.test.IntegerNumberValues.f10
  int32_t f10;
  
// @generated_from: mojo.test.IntegerNumberValues.f11
  int32_t f11;
  
// @generated_from: mojo.test.IntegerNumberValues.f12
  int32_t f12;
  
// @generated_from: mojo.test.IntegerNumberValues.f13
  int32_t f13;
  
// @generated_from: mojo.test.IntegerNumberValues.f14
  int32_t f14;
  
// @generated_from: mojo.test.IntegerNumberValues.f15
  int64_t f15;
  
// @generated_from: mojo.test.IntegerNumberValues.f16
  int64_t f16;
  
// @generated_from: mojo.test.IntegerNumberValues.f17
  int64_t f17;
  
// @generated_from: mojo.test.IntegerNumberValues.f18
  int64_t f18;
  
// @generated_from: mojo.test.IntegerNumberValues.f19
  int64_t f19;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, IntegerNumberValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.UnsignedNumberValues
class  UnsignedNumberValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<UnsignedNumberValues, T>::value>;
  using DataView = UnsignedNumberValuesDataView;
  using Data_ = internal::UnsignedNumberValues_Data;
  
// @generated_from: mojo.test.UnsignedNumberValues.V0
  static constexpr uint8_t V0 = 0U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V1
  static constexpr uint8_t V1 = 42U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V2
  static constexpr uint8_t V2 = 0xFFU;
  
// @generated_from: mojo.test.UnsignedNumberValues.V3
  static constexpr uint16_t V3 = 0U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V4
  static constexpr uint16_t V4 = 12345U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V5
  static constexpr uint16_t V5 = 0xFFFFU;
  
// @generated_from: mojo.test.UnsignedNumberValues.V6
  static constexpr uint32_t V6 = 0U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V7
  static constexpr uint32_t V7 = 1234567890U;
  
// @generated_from: mojo.test.UnsignedNumberValues.V8
  static constexpr uint32_t V8 = 0xFFFFFFFFU;
  
// @generated_from: mojo.test.UnsignedNumberValues.V9
  static constexpr uint64_t V9 = 0ULL;
  
// @generated_from: mojo.test.UnsignedNumberValues.V10
  static constexpr uint64_t V10 = 1234567890123456ULL;
  
// @generated_from: mojo.test.UnsignedNumberValues.V11
  static constexpr uint64_t V11 = 9007199254740991ULL;

  template <typename... Args>
  static UnsignedNumberValuesPtr New(Args&&... args) {
    return UnsignedNumberValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static UnsignedNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<UnsignedNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnsignedNumberValues>::Convert(*this);
  }


  UnsignedNumberValues();

  UnsignedNumberValues(
      uint8_t f0,
      uint8_t f1,
      uint8_t f2,
      uint16_t f3,
      uint16_t f4,
      uint16_t f5,
      uint32_t f6,
      uint32_t f7,
      uint32_t f8,
      uint64_t f9,
      uint64_t f10,
      uint64_t f11);

  ~UnsignedNumberValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = UnsignedNumberValuesPtr>
  UnsignedNumberValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        UnsignedNumberValues::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        UnsignedNumberValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::UnsignedNumberValues_UnserializedMessageContext<
            UserType, UnsignedNumberValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<UnsignedNumberValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return UnsignedNumberValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::UnsignedNumberValues_UnserializedMessageContext<
            UserType, UnsignedNumberValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<UnsignedNumberValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.UnsignedNumberValues.f0
  uint8_t f0;
  
// @generated_from: mojo.test.UnsignedNumberValues.f1
  uint8_t f1;
  
// @generated_from: mojo.test.UnsignedNumberValues.f2
  uint8_t f2;
  
// @generated_from: mojo.test.UnsignedNumberValues.f3
  uint16_t f3;
  
// @generated_from: mojo.test.UnsignedNumberValues.f4
  uint16_t f4;
  
// @generated_from: mojo.test.UnsignedNumberValues.f5
  uint16_t f5;
  
// @generated_from: mojo.test.UnsignedNumberValues.f6
  uint32_t f6;
  
// @generated_from: mojo.test.UnsignedNumberValues.f7
  uint32_t f7;
  
// @generated_from: mojo.test.UnsignedNumberValues.f8
  uint32_t f8;
  
// @generated_from: mojo.test.UnsignedNumberValues.f9
  uint64_t f9;
  
// @generated_from: mojo.test.UnsignedNumberValues.f10
  uint64_t f10;
  
// @generated_from: mojo.test.UnsignedNumberValues.f11
  uint64_t f11;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, UnsignedNumberValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.BitArrayValues
class  BitArrayValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BitArrayValues, T>::value>;
  using DataView = BitArrayValuesDataView;
  using Data_ = internal::BitArrayValues_Data;

  template <typename... Args>
  static BitArrayValuesPtr New(Args&&... args) {
    return BitArrayValuesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BitArrayValuesPtr From(const U& u) {
    return mojo::TypeConverter<BitArrayValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BitArrayValues>::Convert(*this);
  }


  BitArrayValues();

  BitArrayValues(
      std::vector<bool> f0,
      std::vector<bool> f1,
      std::vector<bool> f2,
      std::vector<bool> f3,
      std::vector<std::vector<bool>> f4,
      std::vector<base::Optional<std::vector<bool>>> f5,
      std::vector<base::Optional<std::vector<bool>>> f6);

  ~BitArrayValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BitArrayValuesPtr>
  BitArrayValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BitArrayValues::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BitArrayValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BitArrayValues_UnserializedMessageContext<
            UserType, BitArrayValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BitArrayValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BitArrayValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BitArrayValues_UnserializedMessageContext<
            UserType, BitArrayValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BitArrayValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.BitArrayValues.f0
  std::vector<bool> f0;
  
// @generated_from: mojo.test.BitArrayValues.f1
  std::vector<bool> f1;
  
// @generated_from: mojo.test.BitArrayValues.f2
  std::vector<bool> f2;
  
// @generated_from: mojo.test.BitArrayValues.f3
  std::vector<bool> f3;
  
// @generated_from: mojo.test.BitArrayValues.f4
  std::vector<std::vector<bool>> f4;
  
// @generated_from: mojo.test.BitArrayValues.f5
  std::vector<base::Optional<std::vector<bool>>> f5;
  
// @generated_from: mojo.test.BitArrayValues.f6
  std::vector<base::Optional<std::vector<bool>>> f6;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BitArrayValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MultiVersionStruct
class  MultiVersionStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStruct, T>::value>;
  using DataView = MultiVersionStructDataView;
  using Data_ = internal::MultiVersionStruct_Data;

  template <typename... Args>
  static MultiVersionStructPtr New(Args&&... args) {
    return MultiVersionStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructPtr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStruct>::Convert(*this);
  }


  MultiVersionStruct();

  explicit MultiVersionStruct(
      int32_t f_int32);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string,
      base::Optional<std::vector<int8_t>> f_array);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string,
      base::Optional<std::vector<int8_t>> f_array,
      ::mojo::ScopedMessagePipeHandle f_message_pipe,
      bool f_bool);

  MultiVersionStruct(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string,
      base::Optional<std::vector<int8_t>> f_array,
      ::mojo::ScopedMessagePipeHandle f_message_pipe,
      bool f_bool,
      int16_t f_int16);

  ~MultiVersionStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructPtr>
  MultiVersionStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStruct_UnserializedMessageContext<
            UserType, MultiVersionStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStruct_UnserializedMessageContext<
            UserType, MultiVersionStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStruct.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStruct.f_rect
  ::mojo::test::RectPtr f_rect;
  
// @generated_from: mojo.test.MultiVersionStruct.f_string
  base::Optional<std::string> f_string;
  
// @generated_from: mojo.test.MultiVersionStruct.f_array
  base::Optional<std::vector<int8_t>> f_array;
  
// @generated_from: mojo.test.MultiVersionStruct.f_message_pipe
  ::mojo::ScopedMessagePipeHandle f_message_pipe;
  
// @generated_from: mojo.test.MultiVersionStruct.f_bool
  bool f_bool;
  
// @generated_from: mojo.test.MultiVersionStruct.f_int16
  int16_t f_int16;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.MultiVersionStructV1
class  MultiVersionStructV1 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV1, T>::value>;
  using DataView = MultiVersionStructV1DataView;
  using Data_ = internal::MultiVersionStructV1_Data;

  template <typename... Args>
  static MultiVersionStructV1Ptr New(Args&&... args) {
    return MultiVersionStructV1Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV1Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV1Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV1>::Convert(*this);
  }


  MultiVersionStructV1();

  explicit MultiVersionStructV1(
      int32_t f_int32);

  MultiVersionStructV1(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect);

  ~MultiVersionStructV1();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV1Ptr>
  MultiVersionStructV1Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MultiVersionStructV1::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV1::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV1_UnserializedMessageContext<
            UserType, MultiVersionStructV1::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV1::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV1::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV1_UnserializedMessageContext<
            UserType, MultiVersionStructV1::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV1::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV1.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStructV1.f_rect
  ::mojo::test::RectPtr f_rect;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStructV1);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV1::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MultiVersionStructV3
class  MultiVersionStructV3 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV3, T>::value>;
  using DataView = MultiVersionStructV3DataView;
  using Data_ = internal::MultiVersionStructV3_Data;

  template <typename... Args>
  static MultiVersionStructV3Ptr New(Args&&... args) {
    return MultiVersionStructV3Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV3Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV3Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV3>::Convert(*this);
  }


  MultiVersionStructV3();

  explicit MultiVersionStructV3(
      int32_t f_int32);

  MultiVersionStructV3(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect);

  MultiVersionStructV3(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string);

  ~MultiVersionStructV3();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV3Ptr>
  MultiVersionStructV3Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MultiVersionStructV3::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV3::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV3_UnserializedMessageContext<
            UserType, MultiVersionStructV3::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV3::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV3::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV3_UnserializedMessageContext<
            UserType, MultiVersionStructV3::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV3::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV3.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStructV3.f_rect
  ::mojo::test::RectPtr f_rect;
  
// @generated_from: mojo.test.MultiVersionStructV3.f_string
  base::Optional<std::string> f_string;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStructV3);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV3::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MultiVersionStructV5
class  MultiVersionStructV5 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV5, T>::value>;
  using DataView = MultiVersionStructV5DataView;
  using Data_ = internal::MultiVersionStructV5_Data;

  template <typename... Args>
  static MultiVersionStructV5Ptr New(Args&&... args) {
    return MultiVersionStructV5Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV5Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV5Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV5>::Convert(*this);
  }


  MultiVersionStructV5();

  explicit MultiVersionStructV5(
      int32_t f_int32);

  MultiVersionStructV5(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect);

  MultiVersionStructV5(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string);

  MultiVersionStructV5(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string,
      base::Optional<std::vector<int8_t>> f_array);

  ~MultiVersionStructV5();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV5Ptr>
  MultiVersionStructV5Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MultiVersionStructV5::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV5::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV5_UnserializedMessageContext<
            UserType, MultiVersionStructV5::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV5::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV5::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV5_UnserializedMessageContext<
            UserType, MultiVersionStructV5::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV5::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV5.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStructV5.f_rect
  ::mojo::test::RectPtr f_rect;
  
// @generated_from: mojo.test.MultiVersionStructV5.f_string
  base::Optional<std::string> f_string;
  
// @generated_from: mojo.test.MultiVersionStructV5.f_array
  base::Optional<std::vector<int8_t>> f_array;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStructV5);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV5::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.MultiVersionStructV7
class  MultiVersionStructV7 {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MultiVersionStructV7, T>::value>;
  using DataView = MultiVersionStructV7DataView;
  using Data_ = internal::MultiVersionStructV7_Data;

  template <typename... Args>
  static MultiVersionStructV7Ptr New(Args&&... args) {
    return MultiVersionStructV7Ptr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MultiVersionStructV7Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV7Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV7>::Convert(*this);
  }


  MultiVersionStructV7();

  explicit MultiVersionStructV7(
      int32_t f_int32);

  MultiVersionStructV7(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect);

  MultiVersionStructV7(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string);

  MultiVersionStructV7(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string,
      base::Optional<std::vector<int8_t>> f_array);

  MultiVersionStructV7(
      int32_t f_int32,
      ::mojo::test::RectPtr f_rect,
      const base::Optional<std::string>& f_string,
      base::Optional<std::vector<int8_t>> f_array,
      ::mojo::ScopedMessagePipeHandle f_message_pipe,
      bool f_bool);

  ~MultiVersionStructV7();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MultiVersionStructV7Ptr>
  MultiVersionStructV7Ptr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MultiVersionStructV7::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MultiVersionStructV7_UnserializedMessageContext<
            UserType, MultiVersionStructV7::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MultiVersionStructV7::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MultiVersionStructV7::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MultiVersionStructV7_UnserializedMessageContext<
            UserType, MultiVersionStructV7::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MultiVersionStructV7::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.MultiVersionStructV7.f_int32
  int32_t f_int32;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_rect
  ::mojo::test::RectPtr f_rect;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_string
  base::Optional<std::string> f_string;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_array
  base::Optional<std::vector<int8_t>> f_array;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_message_pipe
  ::mojo::ScopedMessagePipeHandle f_message_pipe;
  
// @generated_from: mojo.test.MultiVersionStructV7.f_bool
  bool f_bool;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MultiVersionStructV7);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MultiVersionStructV7::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.ContainsInterface
class  ContainsInterface {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ContainsInterface, T>::value>;
  using DataView = ContainsInterfaceDataView;
  using Data_ = internal::ContainsInterface_Data;

  template <typename... Args>
  static ContainsInterfacePtr New(Args&&... args) {
    return ContainsInterfacePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ContainsInterfacePtr From(const U& u) {
    return mojo::TypeConverter<ContainsInterfacePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsInterface>::Convert(*this);
  }


  ContainsInterface();

  explicit ContainsInterface(
      ::mojo::PendingRemote<SomeInterface> some_interface);

  ~ContainsInterface();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ContainsInterfacePtr>
  ContainsInterfacePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ContainsInterface::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ContainsInterface_UnserializedMessageContext<
            UserType, ContainsInterface::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ContainsInterface::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ContainsInterface::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ContainsInterface_UnserializedMessageContext<
            UserType, ContainsInterface::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ContainsInterface::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ContainsInterface.some_interface
  ::mojo::PendingRemote<SomeInterface> some_interface;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ContainsInterface);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ContainsInterface::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.ContainsInterfaceRequest
class  ContainsInterfaceRequest {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ContainsInterfaceRequest, T>::value>;
  using DataView = ContainsInterfaceRequestDataView;
  using Data_ = internal::ContainsInterfaceRequest_Data;

  template <typename... Args>
  static ContainsInterfaceRequestPtr New(Args&&... args) {
    return ContainsInterfaceRequestPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ContainsInterfaceRequestPtr From(const U& u) {
    return mojo::TypeConverter<ContainsInterfaceRequestPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsInterfaceRequest>::Convert(*this);
  }


  ContainsInterfaceRequest();

  explicit ContainsInterfaceRequest(
      ::mojo::PendingReceiver<SomeInterface> request);

  ~ContainsInterfaceRequest();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ContainsInterfaceRequestPtr>
  ContainsInterfaceRequestPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ContainsInterfaceRequest::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ContainsInterfaceRequest_UnserializedMessageContext<
            UserType, ContainsInterfaceRequest::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ContainsInterfaceRequest::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ContainsInterfaceRequest::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ContainsInterfaceRequest_UnserializedMessageContext<
            UserType, ContainsInterfaceRequest::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ContainsInterfaceRequest::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ContainsInterfaceRequest.request
  ::mojo::PendingReceiver<SomeInterface> request;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ContainsInterfaceRequest);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






// @generated_from: mojo.test.ContainsHashable
class  ContainsHashable {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ContainsHashable, T>::value>;
  using DataView = ContainsHashableDataView;
  using Data_ = internal::ContainsHashable_Data;

  template <typename... Args>
  static ContainsHashablePtr New(Args&&... args) {
    return ContainsHashablePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ContainsHashablePtr From(const U& u) {
    return mojo::TypeConverter<ContainsHashablePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsHashable>::Convert(*this);
  }


  ContainsHashable();

  explicit ContainsHashable(
      const ::mojo::test::RectChromium& rect);

  ~ContainsHashable();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ContainsHashablePtr>
  ContainsHashablePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ContainsHashable::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ContainsHashable::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ContainsHashable_UnserializedMessageContext<
            UserType, ContainsHashable::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ContainsHashable::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ContainsHashable::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ContainsHashable_UnserializedMessageContext<
            UserType, ContainsHashable::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ContainsHashable::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.ContainsHashable.rect
  ::mojo::test::RectChromium rect;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ContainsHashable::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





// @generated_from: mojo.test.SimpleNestedStruct
class  SimpleNestedStruct {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SimpleNestedStruct, T>::value>;
  using DataView = SimpleNestedStructDataView;
  using Data_ = internal::SimpleNestedStruct_Data;

  template <typename... Args>
  static SimpleNestedStructPtr New(Args&&... args) {
    return SimpleNestedStructPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SimpleNestedStructPtr From(const U& u) {
    return mojo::TypeConverter<SimpleNestedStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SimpleNestedStruct>::Convert(*this);
  }


  SimpleNestedStruct();

  explicit SimpleNestedStruct(
      ContainsOtherPtr nested);

  ~SimpleNestedStruct();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SimpleNestedStructPtr>
  SimpleNestedStructPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SimpleNestedStruct::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SimpleNestedStruct::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SimpleNestedStruct_UnserializedMessageContext<
            UserType, SimpleNestedStruct::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SimpleNestedStruct::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SimpleNestedStruct::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SimpleNestedStruct_UnserializedMessageContext<
            UserType, SimpleNestedStruct::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SimpleNestedStruct::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
// @generated_from: mojo.test.SimpleNestedStruct.nested
  ContainsOtherPtr nested;

  // Serialise this struct into a trace.
  void WriteIntoTracedValue(perfetto::TracedValue context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SimpleNestedStruct);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SimpleNestedStruct::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}


template <typename StructPtrType>
NamedRegionPtr NamedRegion::Clone() const {
  return New(
      mojo::Clone(name),
      mojo::Clone(rects)
  );
}

template <typename T, NamedRegion::EnableIfSame<T>*>
bool NamedRegion::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->rects, other_struct.rects))
    return false;
  return true;
}

template <typename T, NamedRegion::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.rects < rhs.rects)
    return true;
  if (rhs.rects < lhs.rects)
    return false;
  return false;
}
template <typename StructPtrType>
RectPairPtr RectPair::Clone() const {
  return New(
      mojo::Clone(first),
      mojo::Clone(second)
  );
}

template <typename T, RectPair::EnableIfSame<T>*>
bool RectPair::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->first, other_struct.first))
    return false;
  if (!mojo::Equals(this->second, other_struct.second))
    return false;
  return true;
}

template <typename T, RectPair::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.first < rhs.first)
    return true;
  if (rhs.first < lhs.first)
    return false;
  if (lhs.second < rhs.second)
    return true;
  if (rhs.second < lhs.second)
    return false;
  return false;
}
template <typename StructPtrType>
EmptyStructPtr EmptyStruct::Clone() const {
  return New(
  );
}

template <typename T, EmptyStruct::EnableIfSame<T>*>
bool EmptyStruct::Equals(const T& other_struct) const {
  return true;
}

template <typename T, EmptyStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  return false;
}
template <typename StructPtrType>
NoDefaultFieldValuesPtr NoDefaultFieldValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11),
      mojo::Clone(f12),
      mojo::Clone(f13),
      mojo::Clone(f14),
      mojo::Clone(f15),
      mojo::Clone(f16),
      mojo::Clone(f17),
      mojo::Clone(f18),
      mojo::Clone(f19),
      mojo::Clone(f20),
      mojo::Clone(f21),
      mojo::Clone(f22),
      mojo::Clone(f23),
      mojo::Clone(f24),
      mojo::Clone(f25),
      mojo::Clone(f26),
      mojo::Clone(f27),
      mojo::Clone(f28),
      mojo::Clone(f29),
      mojo::Clone(f30)
  );
}

template <typename T, NoDefaultFieldValues::EnableIfSame<T>*>
bool NoDefaultFieldValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  if (!mojo::Equals(this->f12, other_struct.f12))
    return false;
  if (!mojo::Equals(this->f13, other_struct.f13))
    return false;
  if (!mojo::Equals(this->f14, other_struct.f14))
    return false;
  if (!mojo::Equals(this->f15, other_struct.f15))
    return false;
  if (!mojo::Equals(this->f16, other_struct.f16))
    return false;
  if (!mojo::Equals(this->f17, other_struct.f17))
    return false;
  if (!mojo::Equals(this->f18, other_struct.f18))
    return false;
  if (!mojo::Equals(this->f19, other_struct.f19))
    return false;
  if (!mojo::Equals(this->f20, other_struct.f20))
    return false;
  if (!mojo::Equals(this->f21, other_struct.f21))
    return false;
  if (!mojo::Equals(this->f22, other_struct.f22))
    return false;
  if (!mojo::Equals(this->f23, other_struct.f23))
    return false;
  if (!mojo::Equals(this->f24, other_struct.f24))
    return false;
  if (!mojo::Equals(this->f25, other_struct.f25))
    return false;
  if (!mojo::Equals(this->f26, other_struct.f26))
    return false;
  if (!mojo::Equals(this->f27, other_struct.f27))
    return false;
  if (!mojo::Equals(this->f28, other_struct.f28))
    return false;
  if (!mojo::Equals(this->f29, other_struct.f29))
    return false;
  if (!mojo::Equals(this->f30, other_struct.f30))
    return false;
  return true;
}

template <typename T, NoDefaultFieldValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  if (lhs.f12 < rhs.f12)
    return true;
  if (rhs.f12 < lhs.f12)
    return false;
  if (lhs.f13 < rhs.f13)
    return true;
  if (rhs.f13 < lhs.f13)
    return false;
  if (lhs.f14 < rhs.f14)
    return true;
  if (rhs.f14 < lhs.f14)
    return false;
  if (lhs.f15 < rhs.f15)
    return true;
  if (rhs.f15 < lhs.f15)
    return false;
  if (lhs.f16 < rhs.f16)
    return true;
  if (rhs.f16 < lhs.f16)
    return false;
  if (lhs.f17 < rhs.f17)
    return true;
  if (rhs.f17 < lhs.f17)
    return false;
  if (lhs.f18 < rhs.f18)
    return true;
  if (rhs.f18 < lhs.f18)
    return false;
  if (lhs.f19 < rhs.f19)
    return true;
  if (rhs.f19 < lhs.f19)
    return false;
  if (lhs.f20 < rhs.f20)
    return true;
  if (rhs.f20 < lhs.f20)
    return false;
  if (lhs.f21 < rhs.f21)
    return true;
  if (rhs.f21 < lhs.f21)
    return false;
  if (lhs.f22 < rhs.f22)
    return true;
  if (rhs.f22 < lhs.f22)
    return false;
  if (lhs.f23 < rhs.f23)
    return true;
  if (rhs.f23 < lhs.f23)
    return false;
  if (lhs.f24 < rhs.f24)
    return true;
  if (rhs.f24 < lhs.f24)
    return false;
  if (lhs.f25 < rhs.f25)
    return true;
  if (rhs.f25 < lhs.f25)
    return false;
  if (lhs.f26 < rhs.f26)
    return true;
  if (rhs.f26 < lhs.f26)
    return false;
  if (lhs.f27 < rhs.f27)
    return true;
  if (rhs.f27 < lhs.f27)
    return false;
  if (lhs.f28 < rhs.f28)
    return true;
  if (rhs.f28 < lhs.f28)
    return false;
  if (lhs.f29 < rhs.f29)
    return true;
  if (rhs.f29 < lhs.f29)
    return false;
  if (lhs.f30 < rhs.f30)
    return true;
  if (rhs.f30 < lhs.f30)
    return false;
  return false;
}
template <typename StructPtrType>
DefaultFieldValuesPtr DefaultFieldValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11),
      mojo::Clone(f12),
      mojo::Clone(f13),
      mojo::Clone(f14),
      mojo::Clone(f15),
      mojo::Clone(f16)
  );
}

template <typename T, DefaultFieldValues::EnableIfSame<T>*>
bool DefaultFieldValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  if (!mojo::Equals(this->f12, other_struct.f12))
    return false;
  if (!mojo::Equals(this->f13, other_struct.f13))
    return false;
  if (!mojo::Equals(this->f14, other_struct.f14))
    return false;
  if (!mojo::Equals(this->f15, other_struct.f15))
    return false;
  if (!mojo::Equals(this->f16, other_struct.f16))
    return false;
  return true;
}

template <typename T, DefaultFieldValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  if (lhs.f12 < rhs.f12)
    return true;
  if (rhs.f12 < lhs.f12)
    return false;
  if (lhs.f13 < rhs.f13)
    return true;
  if (rhs.f13 < lhs.f13)
    return false;
  if (lhs.f14 < rhs.f14)
    return true;
  if (rhs.f14 < lhs.f14)
    return false;
  if (lhs.f15 < rhs.f15)
    return true;
  if (rhs.f15 < lhs.f15)
    return false;
  if (lhs.f16 < rhs.f16)
    return true;
  if (rhs.f16 < lhs.f16)
    return false;
  return false;
}
template <typename StructPtrType>
ScopedConstantsPtr ScopedConstants::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6)
  );
}

template <typename T, ScopedConstants::EnableIfSame<T>*>
bool ScopedConstants::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  return true;
}

template <typename T, ScopedConstants::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  return false;
}
template <typename StructPtrType>
MapKeyTypesPtr MapKeyTypes::Clone() const {
  return New(
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11)
  );
}

template <typename T, MapKeyTypes::EnableIfSame<T>*>
bool MapKeyTypes::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  return true;
}

template <typename T, MapKeyTypes::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  return false;
}
template <typename StructPtrType>
MapValueTypesPtr MapValueTypes::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11)
  );
}

template <typename T, MapValueTypes::EnableIfSame<T>*>
bool MapValueTypes::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  return true;
}

template <typename T, MapValueTypes::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  return false;
}
template <typename StructPtrType>
ArrayValueTypesPtr ArrayValueTypes::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7)
  );
}

template <typename T, ArrayValueTypes::EnableIfSame<T>*>
bool ArrayValueTypes::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  return true;
}

template <typename T, ArrayValueTypes::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  return false;
}
template <typename StructPtrType>
FloatNumberValuesPtr FloatNumberValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9)
  );
}

template <typename T, FloatNumberValues::EnableIfSame<T>*>
bool FloatNumberValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  return true;
}

template <typename T, FloatNumberValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  return false;
}
template <typename StructPtrType>
IntegerNumberValuesPtr IntegerNumberValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11),
      mojo::Clone(f12),
      mojo::Clone(f13),
      mojo::Clone(f14),
      mojo::Clone(f15),
      mojo::Clone(f16),
      mojo::Clone(f17),
      mojo::Clone(f18),
      mojo::Clone(f19)
  );
}

template <typename T, IntegerNumberValues::EnableIfSame<T>*>
bool IntegerNumberValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  if (!mojo::Equals(this->f12, other_struct.f12))
    return false;
  if (!mojo::Equals(this->f13, other_struct.f13))
    return false;
  if (!mojo::Equals(this->f14, other_struct.f14))
    return false;
  if (!mojo::Equals(this->f15, other_struct.f15))
    return false;
  if (!mojo::Equals(this->f16, other_struct.f16))
    return false;
  if (!mojo::Equals(this->f17, other_struct.f17))
    return false;
  if (!mojo::Equals(this->f18, other_struct.f18))
    return false;
  if (!mojo::Equals(this->f19, other_struct.f19))
    return false;
  return true;
}

template <typename T, IntegerNumberValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  if (lhs.f12 < rhs.f12)
    return true;
  if (rhs.f12 < lhs.f12)
    return false;
  if (lhs.f13 < rhs.f13)
    return true;
  if (rhs.f13 < lhs.f13)
    return false;
  if (lhs.f14 < rhs.f14)
    return true;
  if (rhs.f14 < lhs.f14)
    return false;
  if (lhs.f15 < rhs.f15)
    return true;
  if (rhs.f15 < lhs.f15)
    return false;
  if (lhs.f16 < rhs.f16)
    return true;
  if (rhs.f16 < lhs.f16)
    return false;
  if (lhs.f17 < rhs.f17)
    return true;
  if (rhs.f17 < lhs.f17)
    return false;
  if (lhs.f18 < rhs.f18)
    return true;
  if (rhs.f18 < lhs.f18)
    return false;
  if (lhs.f19 < rhs.f19)
    return true;
  if (rhs.f19 < lhs.f19)
    return false;
  return false;
}
template <typename StructPtrType>
UnsignedNumberValuesPtr UnsignedNumberValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6),
      mojo::Clone(f7),
      mojo::Clone(f8),
      mojo::Clone(f9),
      mojo::Clone(f10),
      mojo::Clone(f11)
  );
}

template <typename T, UnsignedNumberValues::EnableIfSame<T>*>
bool UnsignedNumberValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  if (!mojo::Equals(this->f7, other_struct.f7))
    return false;
  if (!mojo::Equals(this->f8, other_struct.f8))
    return false;
  if (!mojo::Equals(this->f9, other_struct.f9))
    return false;
  if (!mojo::Equals(this->f10, other_struct.f10))
    return false;
  if (!mojo::Equals(this->f11, other_struct.f11))
    return false;
  return true;
}

template <typename T, UnsignedNumberValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  if (lhs.f7 < rhs.f7)
    return true;
  if (rhs.f7 < lhs.f7)
    return false;
  if (lhs.f8 < rhs.f8)
    return true;
  if (rhs.f8 < lhs.f8)
    return false;
  if (lhs.f9 < rhs.f9)
    return true;
  if (rhs.f9 < lhs.f9)
    return false;
  if (lhs.f10 < rhs.f10)
    return true;
  if (rhs.f10 < lhs.f10)
    return false;
  if (lhs.f11 < rhs.f11)
    return true;
  if (rhs.f11 < lhs.f11)
    return false;
  return false;
}
template <typename StructPtrType>
BitArrayValuesPtr BitArrayValues::Clone() const {
  return New(
      mojo::Clone(f0),
      mojo::Clone(f1),
      mojo::Clone(f2),
      mojo::Clone(f3),
      mojo::Clone(f4),
      mojo::Clone(f5),
      mojo::Clone(f6)
  );
}

template <typename T, BitArrayValues::EnableIfSame<T>*>
bool BitArrayValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f0, other_struct.f0))
    return false;
  if (!mojo::Equals(this->f1, other_struct.f1))
    return false;
  if (!mojo::Equals(this->f2, other_struct.f2))
    return false;
  if (!mojo::Equals(this->f3, other_struct.f3))
    return false;
  if (!mojo::Equals(this->f4, other_struct.f4))
    return false;
  if (!mojo::Equals(this->f5, other_struct.f5))
    return false;
  if (!mojo::Equals(this->f6, other_struct.f6))
    return false;
  return true;
}

template <typename T, BitArrayValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f0 < rhs.f0)
    return true;
  if (rhs.f0 < lhs.f0)
    return false;
  if (lhs.f1 < rhs.f1)
    return true;
  if (rhs.f1 < lhs.f1)
    return false;
  if (lhs.f2 < rhs.f2)
    return true;
  if (rhs.f2 < lhs.f2)
    return false;
  if (lhs.f3 < rhs.f3)
    return true;
  if (rhs.f3 < lhs.f3)
    return false;
  if (lhs.f4 < rhs.f4)
    return true;
  if (rhs.f4 < lhs.f4)
    return false;
  if (lhs.f5 < rhs.f5)
    return true;
  if (rhs.f5 < lhs.f5)
    return false;
  if (lhs.f6 < rhs.f6)
    return true;
  if (rhs.f6 < lhs.f6)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructPtr MultiVersionStruct::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect),
      mojo::Clone(f_string),
      mojo::Clone(f_array),
      mojo::Clone(f_message_pipe),
      mojo::Clone(f_bool),
      mojo::Clone(f_int16)
  );
}

template <typename T, MultiVersionStruct::EnableIfSame<T>*>
bool MultiVersionStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  if (!mojo::Equals(this->f_string, other_struct.f_string))
    return false;
  if (!mojo::Equals(this->f_array, other_struct.f_array))
    return false;
  if (!mojo::Equals(this->f_message_pipe, other_struct.f_message_pipe))
    return false;
  if (!mojo::Equals(this->f_bool, other_struct.f_bool))
    return false;
  if (!mojo::Equals(this->f_int16, other_struct.f_int16))
    return false;
  return true;
}

template <typename T, MultiVersionStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  if (lhs.f_string < rhs.f_string)
    return true;
  if (rhs.f_string < lhs.f_string)
    return false;
  if (lhs.f_array < rhs.f_array)
    return true;
  if (rhs.f_array < lhs.f_array)
    return false;
  if (lhs.f_message_pipe < rhs.f_message_pipe)
    return true;
  if (rhs.f_message_pipe < lhs.f_message_pipe)
    return false;
  if (lhs.f_bool < rhs.f_bool)
    return true;
  if (rhs.f_bool < lhs.f_bool)
    return false;
  if (lhs.f_int16 < rhs.f_int16)
    return true;
  if (rhs.f_int16 < lhs.f_int16)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV0Ptr MultiVersionStructV0::Clone() const {
  return New(
      mojo::Clone(f_int32)
  );
}

template <typename T, MultiVersionStructV0::EnableIfSame<T>*>
bool MultiVersionStructV0::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  return true;
}

template <typename T, MultiVersionStructV0::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV1Ptr MultiVersionStructV1::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect)
  );
}

template <typename T, MultiVersionStructV1::EnableIfSame<T>*>
bool MultiVersionStructV1::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  return true;
}

template <typename T, MultiVersionStructV1::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV3Ptr MultiVersionStructV3::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect),
      mojo::Clone(f_string)
  );
}

template <typename T, MultiVersionStructV3::EnableIfSame<T>*>
bool MultiVersionStructV3::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  if (!mojo::Equals(this->f_string, other_struct.f_string))
    return false;
  return true;
}

template <typename T, MultiVersionStructV3::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  if (lhs.f_string < rhs.f_string)
    return true;
  if (rhs.f_string < lhs.f_string)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV5Ptr MultiVersionStructV5::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect),
      mojo::Clone(f_string),
      mojo::Clone(f_array)
  );
}

template <typename T, MultiVersionStructV5::EnableIfSame<T>*>
bool MultiVersionStructV5::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  if (!mojo::Equals(this->f_string, other_struct.f_string))
    return false;
  if (!mojo::Equals(this->f_array, other_struct.f_array))
    return false;
  return true;
}

template <typename T, MultiVersionStructV5::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  if (lhs.f_string < rhs.f_string)
    return true;
  if (rhs.f_string < lhs.f_string)
    return false;
  if (lhs.f_array < rhs.f_array)
    return true;
  if (rhs.f_array < lhs.f_array)
    return false;
  return false;
}
template <typename StructPtrType>
MultiVersionStructV7Ptr MultiVersionStructV7::Clone() const {
  return New(
      mojo::Clone(f_int32),
      mojo::Clone(f_rect),
      mojo::Clone(f_string),
      mojo::Clone(f_array),
      mojo::Clone(f_message_pipe),
      mojo::Clone(f_bool)
  );
}

template <typename T, MultiVersionStructV7::EnableIfSame<T>*>
bool MultiVersionStructV7::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->f_int32, other_struct.f_int32))
    return false;
  if (!mojo::Equals(this->f_rect, other_struct.f_rect))
    return false;
  if (!mojo::Equals(this->f_string, other_struct.f_string))
    return false;
  if (!mojo::Equals(this->f_array, other_struct.f_array))
    return false;
  if (!mojo::Equals(this->f_message_pipe, other_struct.f_message_pipe))
    return false;
  if (!mojo::Equals(this->f_bool, other_struct.f_bool))
    return false;
  return true;
}

template <typename T, MultiVersionStructV7::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.f_int32 < rhs.f_int32)
    return true;
  if (rhs.f_int32 < lhs.f_int32)
    return false;
  if (lhs.f_rect < rhs.f_rect)
    return true;
  if (rhs.f_rect < lhs.f_rect)
    return false;
  if (lhs.f_string < rhs.f_string)
    return true;
  if (rhs.f_string < lhs.f_string)
    return false;
  if (lhs.f_array < rhs.f_array)
    return true;
  if (rhs.f_array < lhs.f_array)
    return false;
  if (lhs.f_message_pipe < rhs.f_message_pipe)
    return true;
  if (rhs.f_message_pipe < lhs.f_message_pipe)
    return false;
  if (lhs.f_bool < rhs.f_bool)
    return true;
  if (rhs.f_bool < lhs.f_bool)
    return false;
  return false;
}
template <typename StructPtrType>
ReorderedStructPtr ReorderedStruct::Clone() const {
  return New(
      mojo::Clone(a),
      mojo::Clone(b),
      mojo::Clone(c)
  );
}

template <typename T, ReorderedStruct::EnableIfSame<T>*>
bool ReorderedStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->a, other_struct.a))
    return false;
  if (!mojo::Equals(this->b, other_struct.b))
    return false;
  if (!mojo::Equals(this->c, other_struct.c))
    return false;
  return true;
}

template <typename T, ReorderedStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.a < rhs.a)
    return true;
  if (rhs.a < lhs.a)
    return false;
  if (lhs.b < rhs.b)
    return true;
  if (rhs.b < lhs.b)
    return false;
  if (lhs.c < rhs.c)
    return true;
  if (rhs.c < lhs.c)
    return false;
  return false;
}
template <typename StructPtrType>
ContainsInterfacePtr ContainsInterface::Clone() const {
  return New(
      mojo::Clone(some_interface)
  );
}

template <typename T, ContainsInterface::EnableIfSame<T>*>
bool ContainsInterface::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->some_interface, other_struct.some_interface))
    return false;
  return true;
}

template <typename T, ContainsInterface::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.some_interface < rhs.some_interface)
    return true;
  if (rhs.some_interface < lhs.some_interface)
    return false;
  return false;
}
template <typename StructPtrType>
ContainsOtherPtr ContainsOther::Clone() const {
  return New(
      mojo::Clone(other)
  );
}

template <typename T, ContainsOther::EnableIfSame<T>*>
bool ContainsOther::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->other, other_struct.other))
    return false;
  return true;
}

template <typename T, ContainsOther::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.other < rhs.other)
    return true;
  if (rhs.other < lhs.other)
    return false;
  return false;
}
template <typename StructPtrType>
ContainsInterfaceRequestPtr ContainsInterfaceRequest::Clone() const {
  return New(
      mojo::Clone(request)
  );
}

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>*>
bool ContainsInterfaceRequest::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->request, other_struct.request))
    return false;
  return true;
}

template <typename T, ContainsInterfaceRequest::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.request < rhs.request)
    return true;
  if (rhs.request < lhs.request)
    return false;
  return false;
}
template <typename StructPtrType>
SingleBoolStructPtr SingleBoolStruct::Clone() const {
  return New(
      mojo::Clone(value)
  );
}

template <typename T, SingleBoolStruct::EnableIfSame<T>*>
bool SingleBoolStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, SingleBoolStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
ContainsHashablePtr ContainsHashable::Clone() const {
  return New(
      mojo::Clone(rect)
  );
}

template <typename T, ContainsHashable::EnableIfSame<T>*>
bool ContainsHashable::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->rect, other_struct.rect))
    return false;
  return true;
}

template <typename T, ContainsHashable::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.rect < rhs.rect)
    return true;
  if (rhs.rect < lhs.rect)
    return false;
  return false;
}
template <typename StructPtrType>
SimpleNestedStructPtr SimpleNestedStruct::Clone() const {
  return New(
      mojo::Clone(nested)
  );
}

template <typename T, SimpleNestedStruct::EnableIfSame<T>*>
bool SimpleNestedStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->nested, other_struct.nested))
    return false;
  return true;
}

template <typename T, SimpleNestedStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.nested < rhs.nested)
    return true;
  if (rhs.nested < lhs.nested)
    return false;
  return false;
}
template <typename StructPtrType>
EnumNestedStructPtr EnumNestedStruct::Clone() const {
  return New(
      mojo::Clone(local_enum_state_)
  );
}

template <typename T, EnumNestedStruct::EnableIfSame<T>*>
bool EnumNestedStruct::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->local_enum_state_, other_struct.local_enum_state_))
    return false;
  return true;
}

template <typename T, EnumNestedStruct::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.local_enum_state_ < rhs.local_enum_state_)
    return true;
  if (rhs.local_enum_state_ < lhs.local_enum_state_)
    return false;
  return false;
}


}  // namespace test
}  // namespace mojo

namespace mojo {


template <>
struct  StructTraits<::mojo::test::NamedRegion::DataView,
                                         ::mojo::test::NamedRegionPtr> {
  static bool IsNull(const ::mojo::test::NamedRegionPtr& input) { return !input; }
  static void SetToNull(::mojo::test::NamedRegionPtr* output) { output->reset(); }

  static const decltype(::mojo::test::NamedRegion::name)& name(
      const ::mojo::test::NamedRegionPtr& input) {
    return input->name;
  }

  static const decltype(::mojo::test::NamedRegion::rects)& rects(
      const ::mojo::test::NamedRegionPtr& input) {
    return input->rects;
  }

  static bool Read(::mojo::test::NamedRegion::DataView input, ::mojo::test::NamedRegionPtr* output);
};


template <>
struct  StructTraits<::mojo::test::RectPair::DataView,
                                         ::mojo::test::RectPairPtr> {
  static bool IsNull(const ::mojo::test::RectPairPtr& input) { return !input; }
  static void SetToNull(::mojo::test::RectPairPtr* output) { output->reset(); }

  static const decltype(::mojo::test::RectPair::first)& first(
      const ::mojo::test::RectPairPtr& input) {
    return input->first;
  }

  static const decltype(::mojo::test::RectPair::second)& second(
      const ::mojo::test::RectPairPtr& input) {
    return input->second;
  }

  static bool Read(::mojo::test::RectPair::DataView input, ::mojo::test::RectPairPtr* output);
};


template <>
struct  StructTraits<::mojo::test::EmptyStruct::DataView,
                                         ::mojo::test::EmptyStructPtr> {
  static bool IsNull(const ::mojo::test::EmptyStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::EmptyStructPtr* output) { output->reset(); }

  static bool Read(::mojo::test::EmptyStruct::DataView input, ::mojo::test::EmptyStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::NoDefaultFieldValues::DataView,
                                         ::mojo::test::NoDefaultFieldValuesPtr> {
  static bool IsNull(const ::mojo::test::NoDefaultFieldValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::NoDefaultFieldValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::NoDefaultFieldValues::f0) f0(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f1) f1(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f2) f2(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f3) f3(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f4) f4(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f5) f5(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f6) f6(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f7) f7(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f8) f8(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f9) f9(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f9;
  }

  static decltype(::mojo::test::NoDefaultFieldValues::f10) f10(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f10;
  }

  static const decltype(::mojo::test::NoDefaultFieldValues::f11)& f11(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f11;
  }

  static const decltype(::mojo::test::NoDefaultFieldValues::f12)& f12(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f12;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f13)& f13(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f13;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f14)& f14(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f14;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f15)& f15(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f15;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f16)& f16(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f16;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f17)& f17(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f17;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f18)& f18(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f18;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f19)& f19(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f19;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f20)& f20(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f20;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f21)& f21(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f21;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f22)& f22(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f22;
  }

  static const decltype(::mojo::test::NoDefaultFieldValues::f23)& f23(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f23;
  }

  static const decltype(::mojo::test::NoDefaultFieldValues::f24)& f24(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f24;
  }

  static const decltype(::mojo::test::NoDefaultFieldValues::f25)& f25(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f25;
  }

  static const decltype(::mojo::test::NoDefaultFieldValues::f26)& f26(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f26;
  }

  static const decltype(::mojo::test::NoDefaultFieldValues::f27)& f27(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f27;
  }

  static const decltype(::mojo::test::NoDefaultFieldValues::f28)& f28(
      const ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f28;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f29)& f29(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f29;
  }

  static  decltype(::mojo::test::NoDefaultFieldValues::f30)& f30(
       ::mojo::test::NoDefaultFieldValuesPtr& input) {
    return input->f30;
  }

  static bool Read(::mojo::test::NoDefaultFieldValues::DataView input, ::mojo::test::NoDefaultFieldValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::DefaultFieldValues::DataView,
                                         ::mojo::test::DefaultFieldValuesPtr> {
  static bool IsNull(const ::mojo::test::DefaultFieldValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::DefaultFieldValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::DefaultFieldValues::f0) f0(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::DefaultFieldValues::f1) f1(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::DefaultFieldValues::f2) f2(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::DefaultFieldValues::f3) f3(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::DefaultFieldValues::f4) f4(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::DefaultFieldValues::f5) f5(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::DefaultFieldValues::f6) f6(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::DefaultFieldValues::f7) f7(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::DefaultFieldValues::f8) f8(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::DefaultFieldValues::f9) f9(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f9;
  }

  static decltype(::mojo::test::DefaultFieldValues::f10) f10(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f10;
  }

  static decltype(::mojo::test::DefaultFieldValues::f11) f11(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f11;
  }

  static decltype(::mojo::test::DefaultFieldValues::f12) f12(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f12;
  }

  static const decltype(::mojo::test::DefaultFieldValues::f13)& f13(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f13;
  }

  static const decltype(::mojo::test::DefaultFieldValues::f14)& f14(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f14;
  }

  static const decltype(::mojo::test::DefaultFieldValues::f15)& f15(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f15;
  }

  static const decltype(::mojo::test::DefaultFieldValues::f16)& f16(
      const ::mojo::test::DefaultFieldValuesPtr& input) {
    return input->f16;
  }

  static bool Read(::mojo::test::DefaultFieldValues::DataView input, ::mojo::test::DefaultFieldValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::ScopedConstants::DataView,
                                         ::mojo::test::ScopedConstantsPtr> {
  static bool IsNull(const ::mojo::test::ScopedConstantsPtr& input) { return !input; }
  static void SetToNull(::mojo::test::ScopedConstantsPtr* output) { output->reset(); }

  static decltype(::mojo::test::ScopedConstants::f0) f0(
      const ::mojo::test::ScopedConstantsPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::ScopedConstants::f1) f1(
      const ::mojo::test::ScopedConstantsPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::ScopedConstants::f2) f2(
      const ::mojo::test::ScopedConstantsPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::ScopedConstants::f3) f3(
      const ::mojo::test::ScopedConstantsPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::ScopedConstants::f4) f4(
      const ::mojo::test::ScopedConstantsPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::ScopedConstants::f5) f5(
      const ::mojo::test::ScopedConstantsPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::ScopedConstants::f6) f6(
      const ::mojo::test::ScopedConstantsPtr& input) {
    return input->f6;
  }

  static bool Read(::mojo::test::ScopedConstants::DataView input, ::mojo::test::ScopedConstantsPtr* output);
};


template <>
struct  StructTraits<::mojo::test::MapKeyTypes::DataView,
                                         ::mojo::test::MapKeyTypesPtr> {
  static bool IsNull(const ::mojo::test::MapKeyTypesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::MapKeyTypesPtr* output) { output->reset(); }

  static const decltype(::mojo::test::MapKeyTypes::f1)& f1(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f1;
  }

  static const decltype(::mojo::test::MapKeyTypes::f2)& f2(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f2;
  }

  static const decltype(::mojo::test::MapKeyTypes::f3)& f3(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f3;
  }

  static const decltype(::mojo::test::MapKeyTypes::f4)& f4(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f4;
  }

  static const decltype(::mojo::test::MapKeyTypes::f5)& f5(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f5;
  }

  static const decltype(::mojo::test::MapKeyTypes::f6)& f6(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f6;
  }

  static const decltype(::mojo::test::MapKeyTypes::f7)& f7(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f7;
  }

  static const decltype(::mojo::test::MapKeyTypes::f8)& f8(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f8;
  }

  static const decltype(::mojo::test::MapKeyTypes::f9)& f9(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f9;
  }

  static const decltype(::mojo::test::MapKeyTypes::f10)& f10(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f10;
  }

  static const decltype(::mojo::test::MapKeyTypes::f11)& f11(
      const ::mojo::test::MapKeyTypesPtr& input) {
    return input->f11;
  }

  static bool Read(::mojo::test::MapKeyTypes::DataView input, ::mojo::test::MapKeyTypesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::MapValueTypes::DataView,
                                         ::mojo::test::MapValueTypesPtr> {
  static bool IsNull(const ::mojo::test::MapValueTypesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::MapValueTypesPtr* output) { output->reset(); }

  static const decltype(::mojo::test::MapValueTypes::f0)& f0(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f0;
  }

  static const decltype(::mojo::test::MapValueTypes::f1)& f1(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f1;
  }

  static const decltype(::mojo::test::MapValueTypes::f2)& f2(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f2;
  }

  static const decltype(::mojo::test::MapValueTypes::f3)& f3(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f3;
  }

  static const decltype(::mojo::test::MapValueTypes::f4)& f4(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f4;
  }

  static const decltype(::mojo::test::MapValueTypes::f5)& f5(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f5;
  }

  static const decltype(::mojo::test::MapValueTypes::f6)& f6(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f6;
  }

  static const decltype(::mojo::test::MapValueTypes::f7)& f7(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f7;
  }

  static const decltype(::mojo::test::MapValueTypes::f8)& f8(
      const ::mojo::test::MapValueTypesPtr& input) {
    return input->f8;
  }

  static  decltype(::mojo::test::MapValueTypes::f9)& f9(
       ::mojo::test::MapValueTypesPtr& input) {
    return input->f9;
  }

  static  decltype(::mojo::test::MapValueTypes::f10)& f10(
       ::mojo::test::MapValueTypesPtr& input) {
    return input->f10;
  }

  static  decltype(::mojo::test::MapValueTypes::f11)& f11(
       ::mojo::test::MapValueTypesPtr& input) {
    return input->f11;
  }

  static bool Read(::mojo::test::MapValueTypes::DataView input, ::mojo::test::MapValueTypesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::ArrayValueTypes::DataView,
                                         ::mojo::test::ArrayValueTypesPtr> {
  static bool IsNull(const ::mojo::test::ArrayValueTypesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::ArrayValueTypesPtr* output) { output->reset(); }

  static const decltype(::mojo::test::ArrayValueTypes::f0)& f0(
      const ::mojo::test::ArrayValueTypesPtr& input) {
    return input->f0;
  }

  static const decltype(::mojo::test::ArrayValueTypes::f1)& f1(
      const ::mojo::test::ArrayValueTypesPtr& input) {
    return input->f1;
  }

  static const decltype(::mojo::test::ArrayValueTypes::f2)& f2(
      const ::mojo::test::ArrayValueTypesPtr& input) {
    return input->f2;
  }

  static const decltype(::mojo::test::ArrayValueTypes::f3)& f3(
      const ::mojo::test::ArrayValueTypesPtr& input) {
    return input->f3;
  }

  static const decltype(::mojo::test::ArrayValueTypes::f4)& f4(
      const ::mojo::test::ArrayValueTypesPtr& input) {
    return input->f4;
  }

  static const decltype(::mojo::test::ArrayValueTypes::f5)& f5(
      const ::mojo::test::ArrayValueTypesPtr& input) {
    return input->f5;
  }

  static  decltype(::mojo::test::ArrayValueTypes::f6)& f6(
       ::mojo::test::ArrayValueTypesPtr& input) {
    return input->f6;
  }

  static  decltype(::mojo::test::ArrayValueTypes::f7)& f7(
       ::mojo::test::ArrayValueTypesPtr& input) {
    return input->f7;
  }

  static bool Read(::mojo::test::ArrayValueTypes::DataView input, ::mojo::test::ArrayValueTypesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::FloatNumberValues::DataView,
                                         ::mojo::test::FloatNumberValuesPtr> {
  static bool IsNull(const ::mojo::test::FloatNumberValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::FloatNumberValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::FloatNumberValues::f0) f0(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::FloatNumberValues::f1) f1(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::FloatNumberValues::f2) f2(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::FloatNumberValues::f3) f3(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::FloatNumberValues::f4) f4(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::FloatNumberValues::f5) f5(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::FloatNumberValues::f6) f6(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::FloatNumberValues::f7) f7(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::FloatNumberValues::f8) f8(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::FloatNumberValues::f9) f9(
      const ::mojo::test::FloatNumberValuesPtr& input) {
    return input->f9;
  }

  static bool Read(::mojo::test::FloatNumberValues::DataView input, ::mojo::test::FloatNumberValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::IntegerNumberValues::DataView,
                                         ::mojo::test::IntegerNumberValuesPtr> {
  static bool IsNull(const ::mojo::test::IntegerNumberValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::IntegerNumberValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::IntegerNumberValues::f0) f0(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::IntegerNumberValues::f1) f1(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::IntegerNumberValues::f2) f2(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::IntegerNumberValues::f3) f3(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::IntegerNumberValues::f4) f4(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::IntegerNumberValues::f5) f5(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::IntegerNumberValues::f6) f6(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::IntegerNumberValues::f7) f7(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::IntegerNumberValues::f8) f8(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::IntegerNumberValues::f9) f9(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f9;
  }

  static decltype(::mojo::test::IntegerNumberValues::f10) f10(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f10;
  }

  static decltype(::mojo::test::IntegerNumberValues::f11) f11(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f11;
  }

  static decltype(::mojo::test::IntegerNumberValues::f12) f12(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f12;
  }

  static decltype(::mojo::test::IntegerNumberValues::f13) f13(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f13;
  }

  static decltype(::mojo::test::IntegerNumberValues::f14) f14(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f14;
  }

  static decltype(::mojo::test::IntegerNumberValues::f15) f15(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f15;
  }

  static decltype(::mojo::test::IntegerNumberValues::f16) f16(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f16;
  }

  static decltype(::mojo::test::IntegerNumberValues::f17) f17(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f17;
  }

  static decltype(::mojo::test::IntegerNumberValues::f18) f18(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f18;
  }

  static decltype(::mojo::test::IntegerNumberValues::f19) f19(
      const ::mojo::test::IntegerNumberValuesPtr& input) {
    return input->f19;
  }

  static bool Read(::mojo::test::IntegerNumberValues::DataView input, ::mojo::test::IntegerNumberValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::UnsignedNumberValues::DataView,
                                         ::mojo::test::UnsignedNumberValuesPtr> {
  static bool IsNull(const ::mojo::test::UnsignedNumberValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::UnsignedNumberValuesPtr* output) { output->reset(); }

  static decltype(::mojo::test::UnsignedNumberValues::f0) f0(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f0;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f1) f1(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f1;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f2) f2(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f2;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f3) f3(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f3;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f4) f4(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f4;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f5) f5(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f5;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f6) f6(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f6;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f7) f7(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f7;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f8) f8(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f8;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f9) f9(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f9;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f10) f10(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f10;
  }

  static decltype(::mojo::test::UnsignedNumberValues::f11) f11(
      const ::mojo::test::UnsignedNumberValuesPtr& input) {
    return input->f11;
  }

  static bool Read(::mojo::test::UnsignedNumberValues::DataView input, ::mojo::test::UnsignedNumberValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::BitArrayValues::DataView,
                                         ::mojo::test::BitArrayValuesPtr> {
  static bool IsNull(const ::mojo::test::BitArrayValuesPtr& input) { return !input; }
  static void SetToNull(::mojo::test::BitArrayValuesPtr* output) { output->reset(); }

  static const decltype(::mojo::test::BitArrayValues::f0)& f0(
      const ::mojo::test::BitArrayValuesPtr& input) {
    return input->f0;
  }

  static const decltype(::mojo::test::BitArrayValues::f1)& f1(
      const ::mojo::test::BitArrayValuesPtr& input) {
    return input->f1;
  }

  static const decltype(::mojo::test::BitArrayValues::f2)& f2(
      const ::mojo::test::BitArrayValuesPtr& input) {
    return input->f2;
  }

  static const decltype(::mojo::test::BitArrayValues::f3)& f3(
      const ::mojo::test::BitArrayValuesPtr& input) {
    return input->f3;
  }

  static const decltype(::mojo::test::BitArrayValues::f4)& f4(
      const ::mojo::test::BitArrayValuesPtr& input) {
    return input->f4;
  }

  static const decltype(::mojo::test::BitArrayValues::f5)& f5(
      const ::mojo::test::BitArrayValuesPtr& input) {
    return input->f5;
  }

  static const decltype(::mojo::test::BitArrayValues::f6)& f6(
      const ::mojo::test::BitArrayValuesPtr& input) {
    return input->f6;
  }

  static bool Read(::mojo::test::BitArrayValues::DataView input, ::mojo::test::BitArrayValuesPtr* output);
};


template <>
struct  StructTraits<::mojo::test::MultiVersionStruct::DataView,
                                         ::mojo::test::MultiVersionStructPtr> {
  static bool IsNull(const ::mojo::test::MultiVersionStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::MultiVersionStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::MultiVersionStruct::f_int32) f_int32(
      const ::mojo::test::MultiVersionStructPtr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::MultiVersionStruct::f_rect)& f_rect(
      const ::mojo::test::MultiVersionStructPtr& input) {
    return input->f_rect;
  }

  static const decltype(::mojo::test::MultiVersionStruct::f_string)& f_string(
      const ::mojo::test::MultiVersionStructPtr& input) {
    return input->f_string;
  }

  static const decltype(::mojo::test::MultiVersionStruct::f_array)& f_array(
      const ::mojo::test::MultiVersionStructPtr& input) {
    return input->f_array;
  }

  static  decltype(::mojo::test::MultiVersionStruct::f_message_pipe)& f_message_pipe(
       ::mojo::test::MultiVersionStructPtr& input) {
    return input->f_message_pipe;
  }

  static decltype(::mojo::test::MultiVersionStruct::f_bool) f_bool(
      const ::mojo::test::MultiVersionStructPtr& input) {
    return input->f_bool;
  }

  static decltype(::mojo::test::MultiVersionStruct::f_int16) f_int16(
      const ::mojo::test::MultiVersionStructPtr& input) {
    return input->f_int16;
  }

  static bool Read(::mojo::test::MultiVersionStruct::DataView input, ::mojo::test::MultiVersionStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::MultiVersionStructV0::DataView,
                                         ::mojo::test::MultiVersionStructV0Ptr> {
  static bool IsNull(const ::mojo::test::MultiVersionStructV0Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::MultiVersionStructV0Ptr* output) { output->reset(); }

  static decltype(::mojo::test::MultiVersionStructV0::f_int32) f_int32(
      const ::mojo::test::MultiVersionStructV0Ptr& input) {
    return input->f_int32;
  }

  static bool Read(::mojo::test::MultiVersionStructV0::DataView input, ::mojo::test::MultiVersionStructV0Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::MultiVersionStructV1::DataView,
                                         ::mojo::test::MultiVersionStructV1Ptr> {
  static bool IsNull(const ::mojo::test::MultiVersionStructV1Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::MultiVersionStructV1Ptr* output) { output->reset(); }

  static decltype(::mojo::test::MultiVersionStructV1::f_int32) f_int32(
      const ::mojo::test::MultiVersionStructV1Ptr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::MultiVersionStructV1::f_rect)& f_rect(
      const ::mojo::test::MultiVersionStructV1Ptr& input) {
    return input->f_rect;
  }

  static bool Read(::mojo::test::MultiVersionStructV1::DataView input, ::mojo::test::MultiVersionStructV1Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::MultiVersionStructV3::DataView,
                                         ::mojo::test::MultiVersionStructV3Ptr> {
  static bool IsNull(const ::mojo::test::MultiVersionStructV3Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::MultiVersionStructV3Ptr* output) { output->reset(); }

  static decltype(::mojo::test::MultiVersionStructV3::f_int32) f_int32(
      const ::mojo::test::MultiVersionStructV3Ptr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::MultiVersionStructV3::f_rect)& f_rect(
      const ::mojo::test::MultiVersionStructV3Ptr& input) {
    return input->f_rect;
  }

  static const decltype(::mojo::test::MultiVersionStructV3::f_string)& f_string(
      const ::mojo::test::MultiVersionStructV3Ptr& input) {
    return input->f_string;
  }

  static bool Read(::mojo::test::MultiVersionStructV3::DataView input, ::mojo::test::MultiVersionStructV3Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::MultiVersionStructV5::DataView,
                                         ::mojo::test::MultiVersionStructV5Ptr> {
  static bool IsNull(const ::mojo::test::MultiVersionStructV5Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::MultiVersionStructV5Ptr* output) { output->reset(); }

  static decltype(::mojo::test::MultiVersionStructV5::f_int32) f_int32(
      const ::mojo::test::MultiVersionStructV5Ptr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::MultiVersionStructV5::f_rect)& f_rect(
      const ::mojo::test::MultiVersionStructV5Ptr& input) {
    return input->f_rect;
  }

  static const decltype(::mojo::test::MultiVersionStructV5::f_string)& f_string(
      const ::mojo::test::MultiVersionStructV5Ptr& input) {
    return input->f_string;
  }

  static const decltype(::mojo::test::MultiVersionStructV5::f_array)& f_array(
      const ::mojo::test::MultiVersionStructV5Ptr& input) {
    return input->f_array;
  }

  static bool Read(::mojo::test::MultiVersionStructV5::DataView input, ::mojo::test::MultiVersionStructV5Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::MultiVersionStructV7::DataView,
                                         ::mojo::test::MultiVersionStructV7Ptr> {
  static bool IsNull(const ::mojo::test::MultiVersionStructV7Ptr& input) { return !input; }
  static void SetToNull(::mojo::test::MultiVersionStructV7Ptr* output) { output->reset(); }

  static decltype(::mojo::test::MultiVersionStructV7::f_int32) f_int32(
      const ::mojo::test::MultiVersionStructV7Ptr& input) {
    return input->f_int32;
  }

  static const decltype(::mojo::test::MultiVersionStructV7::f_rect)& f_rect(
      const ::mojo::test::MultiVersionStructV7Ptr& input) {
    return input->f_rect;
  }

  static const decltype(::mojo::test::MultiVersionStructV7::f_string)& f_string(
      const ::mojo::test::MultiVersionStructV7Ptr& input) {
    return input->f_string;
  }

  static const decltype(::mojo::test::MultiVersionStructV7::f_array)& f_array(
      const ::mojo::test::MultiVersionStructV7Ptr& input) {
    return input->f_array;
  }

  static  decltype(::mojo::test::MultiVersionStructV7::f_message_pipe)& f_message_pipe(
       ::mojo::test::MultiVersionStructV7Ptr& input) {
    return input->f_message_pipe;
  }

  static decltype(::mojo::test::MultiVersionStructV7::f_bool) f_bool(
      const ::mojo::test::MultiVersionStructV7Ptr& input) {
    return input->f_bool;
  }

  static bool Read(::mojo::test::MultiVersionStructV7::DataView input, ::mojo::test::MultiVersionStructV7Ptr* output);
};


template <>
struct  StructTraits<::mojo::test::ReorderedStruct::DataView,
                                         ::mojo::test::ReorderedStructPtr> {
  static bool IsNull(const ::mojo::test::ReorderedStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::ReorderedStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::ReorderedStruct::a) a(
      const ::mojo::test::ReorderedStructPtr& input) {
    return input->a;
  }

  static decltype(::mojo::test::ReorderedStruct::b) b(
      const ::mojo::test::ReorderedStructPtr& input) {
    return input->b;
  }

  static decltype(::mojo::test::ReorderedStruct::c) c(
      const ::mojo::test::ReorderedStructPtr& input) {
    return input->c;
  }

  static bool Read(::mojo::test::ReorderedStruct::DataView input, ::mojo::test::ReorderedStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::ContainsInterface::DataView,
                                         ::mojo::test::ContainsInterfacePtr> {
  static bool IsNull(const ::mojo::test::ContainsInterfacePtr& input) { return !input; }
  static void SetToNull(::mojo::test::ContainsInterfacePtr* output) { output->reset(); }

  static  decltype(::mojo::test::ContainsInterface::some_interface)& some_interface(
       ::mojo::test::ContainsInterfacePtr& input) {
    return input->some_interface;
  }

  static bool Read(::mojo::test::ContainsInterface::DataView input, ::mojo::test::ContainsInterfacePtr* output);
};


template <>
struct  StructTraits<::mojo::test::ContainsOther::DataView,
                                         ::mojo::test::ContainsOtherPtr> {
  static bool IsNull(const ::mojo::test::ContainsOtherPtr& input) { return !input; }
  static void SetToNull(::mojo::test::ContainsOtherPtr* output) { output->reset(); }

  static decltype(::mojo::test::ContainsOther::other) other(
      const ::mojo::test::ContainsOtherPtr& input) {
    return input->other;
  }

  static bool Read(::mojo::test::ContainsOther::DataView input, ::mojo::test::ContainsOtherPtr* output);
};


template <>
struct  StructTraits<::mojo::test::ContainsInterfaceRequest::DataView,
                                         ::mojo::test::ContainsInterfaceRequestPtr> {
  static bool IsNull(const ::mojo::test::ContainsInterfaceRequestPtr& input) { return !input; }
  static void SetToNull(::mojo::test::ContainsInterfaceRequestPtr* output) { output->reset(); }

  static  decltype(::mojo::test::ContainsInterfaceRequest::request)& request(
       ::mojo::test::ContainsInterfaceRequestPtr& input) {
    return input->request;
  }

  static bool Read(::mojo::test::ContainsInterfaceRequest::DataView input, ::mojo::test::ContainsInterfaceRequestPtr* output);
};


template <>
struct  StructTraits<::mojo::test::SingleBoolStruct::DataView,
                                         ::mojo::test::SingleBoolStructPtr> {
  static bool IsNull(const ::mojo::test::SingleBoolStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::SingleBoolStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::SingleBoolStruct::value) value(
      const ::mojo::test::SingleBoolStructPtr& input) {
    return input->value;
  }

  static bool Read(::mojo::test::SingleBoolStruct::DataView input, ::mojo::test::SingleBoolStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::ContainsHashable::DataView,
                                         ::mojo::test::ContainsHashablePtr> {
  static bool IsNull(const ::mojo::test::ContainsHashablePtr& input) { return !input; }
  static void SetToNull(::mojo::test::ContainsHashablePtr* output) { output->reset(); }

  static const decltype(::mojo::test::ContainsHashable::rect)& rect(
      const ::mojo::test::ContainsHashablePtr& input) {
    return input->rect;
  }

  static bool Read(::mojo::test::ContainsHashable::DataView input, ::mojo::test::ContainsHashablePtr* output);
};


template <>
struct  StructTraits<::mojo::test::SimpleNestedStruct::DataView,
                                         ::mojo::test::SimpleNestedStructPtr> {
  static bool IsNull(const ::mojo::test::SimpleNestedStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::SimpleNestedStructPtr* output) { output->reset(); }

  static const decltype(::mojo::test::SimpleNestedStruct::nested)& nested(
      const ::mojo::test::SimpleNestedStructPtr& input) {
    return input->nested;
  }

  static bool Read(::mojo::test::SimpleNestedStruct::DataView input, ::mojo::test::SimpleNestedStructPtr* output);
};


template <>
struct  StructTraits<::mojo::test::EnumNestedStruct::DataView,
                                         ::mojo::test::EnumNestedStructPtr> {
  static bool IsNull(const ::mojo::test::EnumNestedStructPtr& input) { return !input; }
  static void SetToNull(::mojo::test::EnumNestedStructPtr* output) { output->reset(); }

  static decltype(::mojo::test::EnumNestedStruct::local_enum_state_) local_enum_state_(
      const ::mojo::test::EnumNestedStructPtr& input) {
    return input->local_enum_state_;
  }

  static bool Read(::mojo::test::EnumNestedStruct::DataView input, ::mojo::test::EnumNestedStructPtr* output);
};

}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_H_

/* Metadata comment
eyJtZXRhIjogW3siZW5kIjogMjA5MiwgImJlZ2luIjogMjA3OSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Tb21lSW50ZXJmYWNlIn19LCB7ImVu
ZCI6IDI4NjcsICJiZWdpbiI6IDI4NTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuU29tZUludGVyZmFjZS5Tb21lTWV0aG9kIn19LCB7ImVuZCI6
IDMyMjYsICJiZWdpbiI6IDMyMTYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuU29tZUludGVyZmFjZS5Tb21lTWV0aG9kIn19LCB7ImVuZCI6IDQ5
NTAsICJiZWdpbiI6IDQ5MzksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuRW1wdHlTdHJ1Y3QifX0sIHsiZW5kIjogOTQ4NCwgImJlZ2luIjogOTQ2
NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5N
dWx0aVZlcnNpb25TdHJ1Y3RWMCJ9fSwgeyJlbmQiOiAxMzMxMiwgImJlZ2luIjogMTMzMDUsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlW
ZXJzaW9uU3RydWN0VjAuZl9pbnQzMiJ9fSwgeyJlbmQiOiAxNDM4MiwgImJlZ2luIjogMTQzNjcs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUmVv
cmRlcmVkU3RydWN0In19LCB7ImVuZCI6IDE4MTk0LCAiYmVnaW4iOiAxODE5MywgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5SZW9yZGVyZWRTdHJ1
Y3QuYSJ9fSwgeyJlbmQiOiAxODI1OCwgImJlZ2luIjogMTgyNTcsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuUmVvcmRlcmVkU3RydWN0LmIifX0s
IHsiZW5kIjogMTgzMjIsICJiZWdpbiI6IDE4MzIxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlJlb3JkZXJlZFN0cnVjdC5jIn19LCB7ImVuZCI6
IDE5MzY1LCAiYmVnaW4iOiAxOTM1MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5Db250YWluc090aGVyIn19LCB7ImVuZCI6IDIzMDEyLCAiYmVn
aW4iOiAyMzAwNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5Db250YWluc090aGVyLm90aGVyIn19LCB7ImVuZCI6IDI0MDUzLCAiYmVnaW4iOiAy
NDAzNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9k
ZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9j
aHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVz
dC5TaW5nbGVCb29sU3RydWN0In19LCB7ImVuZCI6IDI3NzY5LCAiYmVnaW4iOiAyNzc2NCwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TaW5nbGVC
b29sU3RydWN0LnZhbHVlIn19LCB7ImVuZCI6IDI4ODIzLCAiYmVnaW4iOiAyODgwNywgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5FbnVtTmVzdGVk
U3RydWN0In19LCB7ImVuZCI6IDI5MTEyLCAiYmVnaW4iOiAyOTEwMiwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5FbnVtTmVzdGVkU3RydWN0LlN0
cnVjdEVudW0ifX0sIHsiZW5kIjogMzI3MzEsICJiZWdpbiI6IDMyNzE0LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkVudW1OZXN0ZWRTdHJ1Y3Qu
bG9jYWxfZW51bV9zdGF0ZV8ifX0sIHsiZW5kIjogMzM3NzUsICJiZWdpbiI6IDMzNzY0LCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5hbWVkUmVn
aW9uIn19LCB7ImVuZCI6IDM3NDM3LCAiYmVnaW4iOiAzNzQzMywgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5OYW1lZFJlZ2lvbi5uYW1lIn19LCB7
ImVuZCI6IDM3NTQ4LCAiYmVnaW4iOiAzNzU0MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5OYW1lZFJlZ2lvbi5yZWN0cyJ9fSwgeyJlbmQiOiAz
ODYwNSwgImJlZ2luIjogMzg1OTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuUmVjdFBhaXIifX0sIHsiZW5kIjogNDIxNDgsICJiZWdpbiI6IDQy
MTQzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LlJlY3RQYWlyLmZpcnN0In19LCB7ImVuZCI6IDQyMjI5LCAiYmVnaW4iOiA0MjIyMywgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5SZWN0UGFpci5z
ZWNvbmQifX0sIHsiZW5kIjogNDMyOTcsICJiZWdpbiI6IDQzMjc3LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVz
In19LCB7ImVuZCI6IDQ3ODY5LCAiYmVnaW4iOiA0Nzg2NywgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMCJ9
fSwgeyJlbmQiOiA0NzkzOSwgImJlZ2luIjogNDc5MzcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjEifX0s
IHsiZW5kIjogNDgwMTAsICJiZWdpbiI6IDQ4MDA4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2Vu
ZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJj
aHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pv
bSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYyIn19LCB7
ImVuZCI6IDQ4MDgxLCAiYmVnaW4iOiA0ODA3OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMyJ9fSwgeyJl
bmQiOiA0ODE1MywgImJlZ2luIjogNDgxNTEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjQifX0sIHsiZW5k
IjogNDgyMjQsICJiZWdpbiI6IDQ4MjIyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmY1In19LCB7ImVuZCI6
IDQ4Mjk2LCAiYmVnaW4iOiA0ODI5NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mNiJ9fSwgeyJlbmQiOiA0
ODM2NywgImJlZ2luIjogNDgzNjUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjcifX0sIHsiZW5kIjogNDg0
MzksICJiZWdpbiI6IDQ4NDM3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmY4In19LCB7ImVuZCI6IDQ4NTA4
LCAiYmVnaW4iOiA0ODUwNiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mOSJ9fSwgeyJlbmQiOiA0ODU4MCwg
ImJlZ2luIjogNDg1NzcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjEwIn19LCB7ImVuZCI6IDQ4NjU3LCAi
YmVnaW4iOiA0ODY1NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMTEifX0sIHsiZW5kIjogNDg3NTAsICJi
ZWdpbiI6IDQ4NzQ3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYxMiJ9fSwgeyJlbmQiOiA0ODg0NywgImJl
Z2luIjogNDg4NDQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjEzIn19LCB7ImVuZCI6IDQ4OTQ5LCAiYmVn
aW4iOiA0ODk0NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMTQifX0sIHsiZW5kIjogNDkwNTEsICJiZWdp
biI6IDQ5MDQ4LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYxNSJ9fSwgeyJlbmQiOiA0OTE0OCwgImJlZ2lu
IjogNDkxNDUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjE2In19LCB7ImVuZCI6IDQ5MjUwLCAiYmVnaW4i
OiA0OTI0NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMTcifX0sIHsiZW5kIjogNDkzNTIsICJiZWdpbiI6
IDQ5MzQ5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYxOCJ9fSwgeyJlbmQiOiA0OTQzOCwgImJlZ2luIjog
NDk0MzUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuTm9EZWZhdWx0RmllbGRWYWx1ZXMuZjE5In19LCB7ImVuZCI6IDQ5NTI0LCAiYmVnaW4iOiA0
OTUyMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9k
ZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9j
aHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVz
dC5Ob0RlZmF1bHRGaWVsZFZhbHVlcy5mMjAifX0sIHsiZW5kIjogNDk2MjIsICJiZWdpbiI6IDQ5
NjE5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
Lk5vRGVmYXVsdEZpZWxkVmFsdWVzLmYyMSJ9fSwgeyJlbmQiOiA0OTcyMCwgImJlZ2luIjogNDk3
MTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
Tm9EZWZhdWx0RmllbGRWYWx1ZXMuZjIyIn19LCB7ImVuZCI6IDQ5ODEwLCAiYmVnaW4iOiA0OTgw
NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5O
b0RlZmF1bHRGaWVsZFZhbHVlcy5mMjMifX0sIHsiZW5kIjogNDk5MTYsICJiZWdpbiI6IDQ5OTEz
LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmlu
ZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9t
aXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5v
RGVmYXVsdEZpZWxkVmFsdWVzLmYyNCJ9fSwgeyJlbmQiOiA1MDAyMiwgImJlZ2luIjogNTAwMTks
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9E
ZWZhdWx0RmllbGRWYWx1ZXMuZjI1In19LCB7ImVuZCI6IDUwMTQ0LCAiYmVnaW4iOiA1MDE0MSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Ob0Rl
ZmF1bHRGaWVsZFZhbHVlcy5mMjYifX0sIHsiZW5kIjogNTAyMjQsICJiZWdpbiI6IDUwMjIxLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVm
YXVsdEZpZWxkVmFsdWVzLmYyNyJ9fSwgeyJlbmQiOiA1MDMwNCwgImJlZ2luIjogNTAzMDEsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTm9EZWZh
dWx0RmllbGRWYWx1ZXMuZjI4In19LCB7ImVuZCI6IDUwMzkyLCAiYmVnaW4iOiA1MDM4OSwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Ob0RlZmF1
bHRGaWVsZFZhbHVlcy5mMjkifX0sIHsiZW5kIjogNTA0ODAsICJiZWdpbiI6IDUwNDc3LCAiZWRn
ZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAi
dm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3Ny
YyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk5vRGVmYXVs
dEZpZWxkVmFsdWVzLmYzMCJ9fSwgeyJlbmQiOiA1MTYwMiwgImJlZ2luIjogNTE1ODQsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRGVmYXVsdEZp
ZWxkVmFsdWVzIn19LCB7ImVuZCI6IDUxOTAyLCAiYmVnaW4iOiA1MTg5OCwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1
ZXMua0ZvbyJ9fSwgeyJlbmQiOiA1NTc1OCwgImJlZ2luIjogNTU3NTYsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRGVmYXVsdEZpZWxkVmFsdWVz
LmYwIn19LCB7ImVuZCI6IDU1ODI2LCAiYmVnaW4iOiA1NTgyNCwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1ZXMuZjEi
fX0sIHsiZW5kIjogNTU4OTUsICJiZWdpbiI6IDU1ODkzLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRGaWVsZFZhbHVlcy5mMiJ9fSwg
eyJlbmQiOiA1NTk2NCwgImJlZ2luIjogNTU5NjIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRGVmYXVsdEZpZWxkVmFsdWVzLmYzIn19LCB7ImVu
ZCI6IDU2MDM0LCAiYmVnaW4iOiA1NjAzMiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1ZXMuZjQifX0sIHsiZW5kIjog
NTYxMDMsICJiZWdpbiI6IDU2MTAxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0LkRlZmF1bHRGaWVsZFZhbHVlcy5mNSJ9fSwgeyJlbmQiOiA1NjE3
MywgImJlZ2luIjogNTYxNzEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuRGVmYXVsdEZpZWxkVmFsdWVzLmY2In19LCB7ImVuZCI6IDU2MjQyLCAi
YmVnaW4iOiA1NjI0MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1ZXMuZjcifX0sIHsiZW5kIjogNTYzMTIsICJiZWdp
biI6IDU2MzEwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LkRlZmF1bHRGaWVsZFZhbHVlcy5mOCJ9fSwgeyJlbmQiOiA1NjM3OSwgImJlZ2luIjog
NTYzNzcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuRGVmYXVsdEZpZWxkVmFsdWVzLmY5In19LCB7ImVuZCI6IDU2NDQ4LCAiYmVnaW4iOiA1NjQ0
NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5E
ZWZhdWx0RmllbGRWYWx1ZXMuZjEwIn19LCB7ImVuZCI6IDU2NTE4LCAiYmVnaW4iOiA1NjUxNSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZh
dWx0RmllbGRWYWx1ZXMuZjExIn19LCB7ImVuZCI6IDU2NTg4LCAiYmVnaW4iOiA1NjU4NSwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0
RmllbGRWYWx1ZXMuZjEyIn19LCB7ImVuZCI6IDU2NjYzLCAiYmVnaW4iOiA1NjY2MCwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0Rmll
bGRWYWx1ZXMuZjEzIn19LCB7ImVuZCI6IDU2NzU0LCAiYmVnaW4iOiA1Njc1MSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRW
YWx1ZXMuZjE0In19LCB7ImVuZCI6IDU2ODM5LCAiYmVnaW4iOiA1NjgzNiwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1
ZXMuZjE1In19LCB7ImVuZCI6IDU2OTI0LCAiYmVnaW4iOiA1NjkyMSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5EZWZhdWx0RmllbGRWYWx1ZXMu
ZjE2In19LCB7ImVuZCI6IDU4MDMwLCAiYmVnaW4iOiA1ODAxNSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TY29wZWRDb25zdGFudHMifX0sIHsi
ZW5kIjogNTgzMDUsICJiZWdpbiI6IDU4MzAwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNjb3BlZENvbnN0YW50cy5FVHlwZSJ9fSwgeyJlbmQi
OiA1ODQxNCwgImJlZ2luIjogNTg0MTEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuU2NvcGVkQ29uc3RhbnRzLlRFTiJ9fSwgeyJlbmQiOiA1ODUx
NCwgImJlZ2luIjogNTg1MDYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuU2NvcGVkQ29uc3RhbnRzLkFMU09fVEVOIn19LCB7ImVuZCI6IDYyMTg4
LCAiYmVnaW4iOiA2MjE4NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5TY29wZWRDb25zdGFudHMuZjAifX0sIHsiZW5kIjogNjIyNjksICJiZWdp
biI6IDYyMjY3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LlNjb3BlZENvbnN0YW50cy5mMSJ9fSwgeyJlbmQiOiA2MjM1MCwgImJlZ2luIjogNjIz
NDgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVm
aW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hy
b21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3Qu
U2NvcGVkQ29uc3RhbnRzLmYyIn19LCB7ImVuZCI6IDYyNDMxLCAiYmVnaW4iOiA2MjQyOSwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TY29wZWRD
b25zdGFudHMuZjMifX0sIHsiZW5kIjogNjI1MTIsICJiZWdpbiI6IDYyNTEwLCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlNjb3BlZENvbnN0YW50
cy5mNCJ9fSwgeyJlbmQiOiA2MjU3OCwgImJlZ2luIjogNjI1NzYsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU2NvcGVkQ29uc3RhbnRzLmY1In19
LCB7ImVuZCI6IDYyNjQ0LCAiYmVnaW4iOiA2MjY0MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5TY29wZWRDb25zdGFudHMuZjYifX0sIHsiZW5k
IjogNjM2ODIsICJiZWdpbiI6IDYzNjcxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0Lk1hcEtleVR5cGVzIn19LCB7ImVuZCI6IDY3NzkwLCAiYmVn
aW4iOiA2Nzc4OCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5NYXBLZXlUeXBlcy5mMSJ9fSwgeyJlbmQiOiA2Nzg3NywgImJlZ2luIjogNjc4NzUs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFw
S2V5VHlwZXMuZjIifX0sIHsiZW5kIjogNjc5NjQsICJiZWdpbiI6IDY3OTYyLCAiZWRnZSI6ICIl
L2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUi
OiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJs
YW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk1hcEtleVR5cGVzLmYz
In19LCB7ImVuZCI6IDY4MDUzLCAiYmVnaW4iOiA2ODA1MSwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBLZXlUeXBlcy5mNCJ9fSwgeyJlbmQi
OiA2ODE0MCwgImJlZ2luIjogNjgxMzgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwS2V5VHlwZXMuZjUifX0sIHsiZW5kIjogNjgyMjksICJi
ZWdpbiI6IDY4MjI3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0Lk1hcEtleVR5cGVzLmY2In19LCB7ImVuZCI6IDY4MzE2LCAiYmVnaW4iOiA2ODMx
NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5N
YXBLZXlUeXBlcy5mNyJ9fSwgeyJlbmQiOiA2ODQwNSwgImJlZ2luIjogNjg0MDMsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwS2V5VHlwZXMu
ZjgifX0sIHsiZW5kIjogNjg0ODgsICJiZWdpbiI6IDY4NDg2LCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk1hcEtleVR5cGVzLmY5In19LCB7ImVu
ZCI6IDY4NTc1LCAiYmVnaW4iOiA2ODU3MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5NYXBLZXlUeXBlcy5mMTAifX0sIHsiZW5kIjogNjg2NzIs
ICJiZWdpbiI6IDY4NjY5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0Lk1hcEtleVR5cGVzLmYxMSJ9fSwgeyJlbmQiOiA2OTY5OCwgImJlZ2luIjog
Njk2ODUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuTWFwVmFsdWVUeXBlcyJ9fSwgeyJlbmQiOiA3NDA5NCwgImJlZ2luIjogNzQwOTIsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwVmFsdWVU
eXBlcy5mMCJ9fSwgeyJlbmQiOiA3NDIyMCwgImJlZ2luIjogNzQyMTgsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5mMSJ9
fSwgeyJlbmQiOiA3NDM0NiwgImJlZ2luIjogNzQzNDQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5mMiJ9fSwgeyJlbmQi
OiA3NDQ1NiwgImJlZ2luIjogNzQ0NTQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5mMyJ9fSwgeyJlbmQiOiA3NDU5NSwg
ImJlZ2luIjogNzQ1OTMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5mNCJ9fSwgeyJlbmQiOiA3NDcxOCwgImJlZ2luIjog
NzQ3MTYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuTWFwVmFsdWVUeXBlcy5mNSJ9fSwgeyJlbmQiOiA3NDgyNSwgImJlZ2luIjogNzQ4MjMsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwVmFs
dWVUeXBlcy5mNiJ9fSwgeyJlbmQiOiA3NDk1MSwgImJlZ2luIjogNzQ5NDksICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5m
NyJ9fSwgeyJlbmQiOiA3NTA5MCwgImJlZ2luIjogNzUwODgsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5mOCJ9fSwgeyJl
bmQiOiA3NTE5NiwgImJlZ2luIjogNzUxOTQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5mOSJ9fSwgeyJlbmQiOiA3NTMx
NywgImJlZ2luIjogNzUzMTQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuTWFwVmFsdWVUeXBlcy5mMTAifX0sIHsiZW5kIjogNzU0NTQsICJiZWdp
biI6IDc1NDUxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0Lk1hcFZhbHVlVHlwZXMuZjExIn19LCB7ImVuZCI6IDc2NTM1LCAiYmVnaW4iOiA3NjUy
MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5B
cnJheVZhbHVlVHlwZXMifX0sIHsiZW5kIjogODAyNzcsICJiZWdpbiI6IDgwMjc1LCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkFycmF5VmFsdWVU
eXBlcy5mMCJ9fSwgeyJlbmQiOiA4MDM1NiwgImJlZ2luIjogODAzNTQsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQXJyYXlWYWx1ZVR5cGVzLmYx
In19LCB7ImVuZCI6IDgwNDM1LCAiYmVnaW4iOiA4MDQzMywgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5BcnJheVZhbHVlVHlwZXMuZjIifX0sIHsi
ZW5kIjogODA1MTQsICJiZWdpbiI6IDgwNTEyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJh
dGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJv
bWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIs
ICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkFycmF5VmFsdWVUeXBlcy5mMyJ9fSwgeyJlbmQiOiA4
MDU5MSwgImJlZ2luIjogODA1ODksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuQXJyYXlWYWx1ZVR5cGVzLmY0In19LCB7ImVuZCI6IDgwNjY5LCAi
YmVnaW4iOiA4MDY2NywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5BcnJheVZhbHVlVHlwZXMuZjUifX0sIHsiZW5kIjogODA3NzcsICJiZWdpbiI6
IDgwNzc1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0LkFycmF5VmFsdWVUeXBlcy5mNiJ9fSwgeyJlbmQiOiA4MDg4NywgImJlZ2luIjogODA4ODUs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQXJy
YXlWYWx1ZVR5cGVzLmY3In19LCB7ImVuZCI6IDgxOTgyLCAiYmVnaW4iOiA4MTk2NSwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9hdE51bWJl
clZhbHVlcyJ9fSwgeyJlbmQiOiA4MjI4MCwgImJlZ2luIjogODIyNzgsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMu
VjAifX0sIHsiZW5kIjogODI0MDYsICJiZWdpbiI6IDgyNDA0LCAiZWRnZSI6ICIlL2t5dGhlL2Vk
Z2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1
cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6
ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLlYxIn19
LCB7ImVuZCI6IDgyNTMzLCAiYmVnaW4iOiA4MjUzMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5WMiJ9fSwgeyJl
bmQiOiA4MjY1OSwgImJlZ2luIjogODI2NTcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuVjMifX0sIHsiZW5kIjog
ODI3ODMsICJiZWdpbiI6IDgyNzgxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLlY0In19LCB7ImVuZCI6IDgyOTA4
LCAiYmVnaW4iOiA4MjkwNiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5WNSJ9fSwgeyJlbmQiOiA4MzAzMywgImJl
Z2luIjogODMwMzEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuVjYifX0sIHsiZW5kIjogODMxMjEsICJiZWdpbiI6
IDgzMTE5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLlY3In19LCB7ImVuZCI6IDgzMjIyLCAiYmVnaW4iOiA4MzIy
MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5G
bG9hdE51bWJlclZhbHVlcy5WOCJ9fSwgeyJlbmQiOiA4MzMxNiwgImJlZ2luIjogODMzMTQsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXRO
dW1iZXJWYWx1ZXMuVjkifX0sIHsiZW5kIjogODY5ODksICJiZWdpbiI6IDg2OTg3LCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVy
VmFsdWVzLmYwIn19LCB7ImVuZCI6IDg3MDU2LCAiYmVnaW4iOiA4NzA1NCwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9hdE51bWJlclZhbHVl
cy5mMSJ9fSwgeyJlbmQiOiA4NzEyMywgImJlZ2luIjogODcxMjEsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuZjIi
fX0sIHsiZW5kIjogODcxODksICJiZWdpbiI6IDg3MTg3LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLmYzIn19LCB7
ImVuZCI6IDg3MjU1LCAiYmVnaW4iOiA4NzI1MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5mNCJ9fSwgeyJlbmQi
OiA4NzMyMSwgImJlZ2luIjogODczMTksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuZjUifX0sIHsiZW5kIjogODcz
ODcsICJiZWdpbiI6IDg3Mzg1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0LkZsb2F0TnVtYmVyVmFsdWVzLmY2In19LCB7ImVuZCI6IDg3NDU0LCAi
YmVnaW4iOiA4NzQ1MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5GbG9hdE51bWJlclZhbHVlcy5mNyJ9fSwgeyJlbmQiOiA4NzUyMSwgImJlZ2lu
IjogODc1MTksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuRmxvYXROdW1iZXJWYWx1ZXMuZjgifX0sIHsiZW5kIjogODc1ODgsICJiZWdpbiI6IDg3
NTg2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkZsb2F0TnVtYmVyVmFsdWVzLmY5In19LCB7ImVuZCI6IDg4NjUwLCAiYmVnaW4iOiA4ODYzMSwg
ImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVz
IiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1
bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRl
Z2VyTnVtYmVyVmFsdWVzIn19LCB7ImVuZCI6IDg4OTU2LCAiYmVnaW4iOiA4ODk1NCwgImVkZ2Ui
OiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZu
YW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMi
LCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVt
YmVyVmFsdWVzLlYwIn19LCB7ImVuZCI6IDg5MDQ5LCAiYmVnaW4iOiA4OTA0NywgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVy
VmFsdWVzLlYxIn19LCB7ImVuZCI6IDg5MTQwLCAiYmVnaW4iOiA4OTEzOCwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFs
dWVzLlYyIn19LCB7ImVuZCI6IDg5MjMwLCAiYmVnaW4iOiA4OTIyOCwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVz
LlYzIn19LCB7ImVuZCI6IDg5MzIxLCAiYmVnaW4iOiA4OTMxOSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlY0
In19LCB7ImVuZCI6IDg5NDE0LCAiYmVnaW4iOiA4OTQxMiwgImVkZ2UiOiAiJS9reXRoZS9lZGdl
L2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMi
OiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAi
bW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlY1In19
LCB7ImVuZCI6IDg5NTEwLCAiYmVnaW4iOiA4OTUwOCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlY2In19LCB7
ImVuZCI6IDg5NjAyLCAiYmVnaW4iOiA4OTYwMCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlY3In19LCB7ImVu
ZCI6IDg5NjkzLCAiYmVnaW4iOiA4OTY5MSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlY4In19LCB7ImVuZCI6
IDg5Nzg4LCAiYmVnaW4iOiA4OTc4NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlY5In19LCB7ImVuZCI6IDg5
ODg1LCAiYmVnaW4iOiA4OTg4MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlYxMCJ9fSwgeyJlbmQiOiA4OTk4
OCwgImJlZ2luIjogODk5ODUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5WMTEifX0sIHsiZW5kIjogOTAwODIs
ICJiZWdpbiI6IDkwMDc5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUi
OiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVz
b3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUi
OiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjEyIn19LCB7ImVuZCI6IDkwMTc1LCAi
YmVnaW4iOiA5MDE3MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlYxMyJ9fSwgeyJlbmQiOiA5MDI3NywgImJl
Z2luIjogOTAyNzQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5WMTQifX0sIHsiZW5kIjogOTAzNzksICJiZWdp
biI6IDkwMzc2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5j
aG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2Uu
Y29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9q
by50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuVjE1In19LCB7ImVuZCI6IDkwNDg4LCAiYmVnaW4i
OiA5MDQ4NSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLlYxNiJ9fSwgeyJlbmQiOiA5MDU4MiwgImJlZ2luIjog
OTA1NzksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3Jf
ZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20v
Y2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRl
c3QuSW50ZWdlck51bWJlclZhbHVlcy5WMTcifX0sIHsiZW5kIjogOTA2NzUsICJiZWdpbiI6IDkw
NjcyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LkludGVnZXJOdW1iZXJWYWx1ZXMuVjE4In19LCB7ImVuZCI6IDkwNzgzLCAiYmVnaW4iOiA5MDc4
MCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5J
bnRlZ2VyTnVtYmVyVmFsdWVzLlYxOSJ9fSwgeyJlbmQiOiA5NDcwNywgImJlZ2luIjogOTQ3MDUs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50
ZWdlck51bWJlclZhbHVlcy5mMCJ9fSwgeyJlbmQiOiA5NDc3NiwgImJlZ2luIjogOTQ3NzQsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdl
ck51bWJlclZhbHVlcy5mMSJ9fSwgeyJlbmQiOiA5NDg0NSwgImJlZ2luIjogOTQ4NDMsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51
bWJlclZhbHVlcy5mMiJ9fSwgeyJlbmQiOiA5NDkxNCwgImJlZ2luIjogOTQ5MTIsICJlZGdlIjog
IiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFt
ZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwg
Imxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJl
clZhbHVlcy5mMyJ9fSwgeyJlbmQiOiA5NDk4MywgImJlZ2luIjogOTQ5ODEsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZh
bHVlcy5mNCJ9fSwgeyJlbmQiOiA5NTA1MywgImJlZ2luIjogOTUwNTEsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVl
cy5mNSJ9fSwgeyJlbmQiOiA5NTEyMywgImJlZ2luIjogOTUxMjEsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5m
NiJ9fSwgeyJlbmQiOiA5NTE5MywgImJlZ2luIjogOTUxOTEsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mNyJ9
fSwgeyJlbmQiOiA5NTI2MywgImJlZ2luIjogOTUyNjEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mOCJ9fSwg
eyJlbmQiOiA5NTMzMywgImJlZ2luIjogOTUzMzEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mOSJ9fSwgeyJl
bmQiOiA5NTQwNSwgImJlZ2luIjogOTU0MDIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mMTAifX0sIHsiZW5k
IjogOTU0NzcsICJiZWdpbiI6IDk1NDc0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVz
IiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1
bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJz
aWduYXR1cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuZjExIn19LCB7ImVuZCI6
IDk1NTQ5LCAiYmVnaW4iOiA5NTU0NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmYxMiJ9fSwgeyJlbmQiOiA5
NTYyMSwgImJlZ2luIjogOTU2MTgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAi
dHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdv
b2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25h
dHVyZSI6ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mMTMifX0sIHsiZW5kIjogOTU2
OTMsICJiZWdpbiI6IDk1NjkwLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuZjE0In19LCB7ImVuZCI6IDk1NzY1
LCAiYmVnaW4iOiA5NTc2MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmYxNSJ9fSwgeyJlbmQiOiA5NTgzNywg
ImJlZ2luIjogOTU4MzQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mMTYifX0sIHsiZW5kIjogOTU5MDksICJi
ZWdpbiI6IDk1OTA2LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAi
YW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3Vy
Y2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAi
bW9qby50ZXN0LkludGVnZXJOdW1iZXJWYWx1ZXMuZjE3In19LCB7ImVuZCI6IDk1OTgxLCAiYmVn
aW4iOiA5NTk3OCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFu
Y2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNl
LmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1v
am8udGVzdC5JbnRlZ2VyTnVtYmVyVmFsdWVzLmYxOCJ9fSwgeyJlbmQiOiA5NjA1MywgImJlZ2lu
IjogOTYwNTAsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuSW50ZWdlck51bWJlclZhbHVlcy5mMTkifX0sIHsiZW5kIjogOTcxMjUsICJiZWdpbiI6
IDk3MTA1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVzIn19LCB7ImVuZCI6IDk3NDM2LCAiYmVnaW4iOiA5NzQz
NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5V
bnNpZ25lZE51bWJlclZhbHVlcy5WMCJ9fSwgeyJlbmQiOiA5NzUyOSwgImJlZ2luIjogOTc1Mjcs
ICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5l
cyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21p
dW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5z
aWduZWROdW1iZXJWYWx1ZXMuVjEifX0sIHsiZW5kIjogOTc2MjMsICJiZWdpbiI6IDk3NjIxLCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuc2ln
bmVkTnVtYmVyVmFsdWVzLlYyIn19LCB7ImVuZCI6IDk3NzIwLCAiYmVnaW4iOiA5NzcxOCwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5VbnNpZ25l
ZE51bWJlclZhbHVlcy5WMyJ9fSwgeyJlbmQiOiA5NzgxNCwgImJlZ2luIjogOTc4MTIsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWRO
dW1iZXJWYWx1ZXMuVjQifX0sIHsiZW5kIjogOTc5MTIsICJiZWdpbiI6IDk3OTEwLCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuc2lnbmVkTnVt
YmVyVmFsdWVzLlY1In19LCB7ImVuZCI6IDk4MDExLCAiYmVnaW4iOiA5ODAwOSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5VbnNpZ25lZE51bWJl
clZhbHVlcy5WNiJ9fSwgeyJlbmQiOiA5ODEwNSwgImJlZ2luIjogOTgxMDMsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJW
YWx1ZXMuVjcifX0sIHsiZW5kIjogOTgyMDgsICJiZWdpbiI6IDk4MjA2LCAiZWRnZSI6ICIlL2t5
dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7
ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5n
dWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuc2lnbmVkTnVtYmVyVmFs
dWVzLlY4In19LCB7ImVuZCI6IDk4MzExLCAiYmVnaW4iOiA5ODMwOSwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5VbnNpZ25lZE51bWJlclZhbHVl
cy5WOSJ9fSwgeyJlbmQiOiA5ODQwOSwgImJlZ2luIjogOTg0MDYsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
VjEwIn19LCB7ImVuZCI6IDk4NTIyLCAiYmVnaW4iOiA5ODUxOSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5VbnNpZ25lZE51bWJlclZhbHVlcy5W
MTEifX0sIHsiZW5kIjogMTAyMzM0LCAiYmVnaW4iOiAxMDIzMzIsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjAifX0sIHsiZW5kIjogMTAyNDA1LCAiYmVnaW4iOiAxMDI0MDMsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjEifX0sIHsiZW5kIjogMTAyNDc2LCAiYmVnaW4iOiAxMDI0NzQsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjIifX0sIHsiZW5kIjogMTAyNTQ4LCAiYmVnaW4iOiAxMDI1NDYsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjMifX0sIHsiZW5kIjogMTAyNjIwLCAiYmVnaW4iOiAxMDI2MTgsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjQifX0sIHsiZW5kIjogMTAyNjkyLCAiYmVnaW4iOiAxMDI2OTAsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjUifX0sIHsiZW5kIjogMTAyNzY0LCAiYmVnaW4iOiAxMDI3NjIsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjYifX0sIHsiZW5kIjogMTAyODM2LCAiYmVnaW4iOiAxMDI4MzQsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjcifX0sIHsiZW5kIjogMTAyOTA4LCAiYmVnaW4iOiAxMDI5MDYsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjgifX0sIHsiZW5kIjogMTAyOTgwLCAiYmVnaW4iOiAxMDI5NzgsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjkifX0sIHsiZW5kIjogMTAzMDU0LCAiYmVnaW4iOiAxMDMwNTEsICJlZGdlIjogIiUva3l0aGUv
ZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29y
cHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdl
IjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuVW5zaWduZWROdW1iZXJWYWx1ZXMu
ZjEwIn19LCB7ImVuZCI6IDEwMzEyOCwgImJlZ2luIjogMTAzMTI1LCAiZWRnZSI6ICIlL2t5dGhl
L2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNv
cnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFn
ZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LlVuc2lnbmVkTnVtYmVyVmFsdWVz
LmYxMSJ9fSwgeyJlbmQiOiAxMDQxOTIsICJiZWdpbiI6IDEwNDE3OCwgImVkZ2UiOiAiJS9reXRo
ZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJj
b3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3Vh
Z2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5CaXRBcnJheVZhbHVlcyJ9fSwg
eyJlbmQiOiAxMDgwNzEsICJiZWdpbiI6IDEwODA2OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5CaXRBcnJheVZhbHVlcy5mMCJ9fSwgeyJlbmQi
OiAxMDgxNDYsICJiZWdpbiI6IDEwODE0NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5CaXRBcnJheVZhbHVlcy5mMSJ9fSwgeyJlbmQiOiAxMDgy
MjEsICJiZWdpbiI6IDEwODIxOSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5CaXRBcnJheVZhbHVlcy5mMiJ9fSwgeyJlbmQiOiAxMDgyOTYsICJi
ZWdpbiI6IDEwODI5NCwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5CaXRBcnJheVZhbHVlcy5mMyJ9fSwgeyJlbmQiOiAxMDgzODQsICJiZWdpbiI6
IDEwODM4MiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hv
cl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNv
bS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8u
dGVzdC5CaXRBcnJheVZhbHVlcy5mNCJ9fSwgeyJlbmQiOiAxMDg0ODgsICJiZWdpbiI6IDEwODQ4
NiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5C
aXRBcnJheVZhbHVlcy5mNSJ9fSwgeyJlbmQiOiAxMDg1OTIsICJiZWdpbiI6IDEwODU5MCwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5CaXRBcnJh
eVZhbHVlcy5mNiJ9fSwgeyJlbmQiOiAxMDk2NDAsICJiZWdpbiI6IDEwOTYyMiwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25T
dHJ1Y3QifX0sIHsiZW5kIjogMTE0MTIxLCAiYmVnaW4iOiAxMTQxMTQsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0
LmZfaW50MzIifX0sIHsiZW5kIjogMTE0MjEyLCAiYmVnaW4iOiAxMTQyMDYsICJlZGdlIjogIiUv
a3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6
IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxh
bmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3Ry
dWN0LmZfcmVjdCJ9fSwgeyJlbmQiOiAxMTQzMTMsICJiZWdpbiI6IDExNDMwNSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25T
dHJ1Y3QuZl9zdHJpbmcifX0sIHsiZW5kIjogMTE0NDIwLCAiYmVnaW4iOiAxMTQ0MTMsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJz
aW9uU3RydWN0LmZfYXJyYXkifX0sIHsiZW5kIjogMTE0NTM3LCAiYmVnaW4iOiAxMTQ1MjMsICJl
ZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIs
ICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0v
c3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlW
ZXJzaW9uU3RydWN0LmZfbWVzc2FnZV9waXBlIn19LCB7ImVuZCI6IDExNDYxMSwgImJlZ2luIjog
MTE0NjA1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0Lk11bHRpVmVyc2lvblN0cnVjdC5mX2Jvb2wifX0sIHsiZW5kIjogMTE0NjkwLCAiYmVnaW4i
OiAxMTQ2ODMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0LmZfaW50MTYifX0sIHsiZW5kIjogMTE1ODA3LCAiYmVn
aW4iOiAxMTU3ODcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjEifX0sIHsiZW5kIjogMTE5Njg2LCAiYmVnaW4i
OiAxMTk2NzksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNo
b3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5j
b20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pv
LnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjEuZl9pbnQzMiJ9fSwgeyJlbmQiOiAxMTk3NzksICJi
ZWdpbiI6IDExOTc3MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjog
ImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291
cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjog
Im1vam8udGVzdC5NdWx0aVZlcnNpb25TdHJ1Y3RWMS5mX3JlY3QifX0sIHsiZW5kIjogMTIwOTA1
LCAiYmVnaW4iOiAxMjA4ODUsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlw
ZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2ds
ZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVy
ZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjMifX0sIHsiZW5kIjogMTI0OTIwLCAi
YmVnaW4iOiAxMjQ5MTMsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjMuZl9pbnQzMiJ9fSwgeyJlbmQiOiAxMjUw
MTMsICJiZWdpbiI6IDEyNTAwNywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0
eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29v
Z2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0
dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25TdHJ1Y3RWMy5mX3JlY3QifX0sIHsiZW5kIjog
MTI1MTE2LCAiYmVnaW4iOiAxMjUxMDgsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMi
LCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVt
Lmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNp
Z25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjMuZl9zdHJpbmcifX0sIHsi
ZW5kIjogMTI2MjQyLCAiYmVnaW4iOiAxMjYyMjIsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5l
cmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNo
cm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9t
IiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjUifX0sIHsiZW5k
IjogMTMwNDQ0LCAiYmVnaW4iOiAxMzA0MzcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjUuZl9pbnQzMiJ9fSwg
eyJlbmQiOiAxMzA1MzcsICJiZWdpbiI6IDEzMDUzMSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dl
bmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAi
Y2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9q
b20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25TdHJ1Y3RWNS5mX3JlY3Qi
fX0sIHsiZW5kIjogMTMwNjQwLCAiYmVnaW4iOiAxMzA2MzIsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0VjUuZl9z
dHJpbmcifX0sIHsiZW5kIjogMTMwNzQ5LCAiYmVnaW4iOiAxMzA3NDIsICJlZGdlIjogIiUva3l0
aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsi
Y29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1
YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuTXVsdGlWZXJzaW9uU3RydWN0
VjUuZl9hcnJheSJ9fSwgeyJlbmQiOiAxMzE4NzUsICJiZWdpbiI6IDEzMTg1NSwgImVkZ2UiOiAi
JS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1l
IjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAi
bGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25T
dHJ1Y3RWNyJ9fSwgeyJlbmQiOiAxMzYxMzEsICJiZWdpbiI6IDEzNjEyNCwgImVkZ2UiOiAiJS9r
eXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjog
eyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFu
Z3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZlcnNpb25TdHJ1
Y3RWNy5mX2ludDMyIn19LCB7ImVuZCI6IDEzNjIyNCwgImJlZ2luIjogMTM2MjE4LCAiZWRnZSI6
ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5h
bWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIs
ICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lv
blN0cnVjdFY3LmZfcmVjdCJ9fSwgeyJlbmQiOiAxMzYzMjcsICJiZWdpbiI6IDEzNjMxOSwgImVk
Z2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwg
InZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9z
cmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5NdWx0aVZl
cnNpb25TdHJ1Y3RWNy5mX3N0cmluZyJ9fSwgeyJlbmQiOiAxMzY0MzYsICJiZWdpbiI6IDEzNjQy
OSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZp
bmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJv
bWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5N
dWx0aVZlcnNpb25TdHJ1Y3RWNy5mX2FycmF5In19LCB7ImVuZCI6IDEzNjU1NSwgImJlZ2luIjog
MTM2NTQxLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9y
X2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29t
L2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50
ZXN0Lk11bHRpVmVyc2lvblN0cnVjdFY3LmZfbWVzc2FnZV9waXBlIn19LCB7ImVuZCI6IDEzNjYz
MSwgImJlZ2luIjogMTM2NjI1LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5
cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29n
bGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1
cmUiOiAibW9qby50ZXN0Lk11bHRpVmVyc2lvblN0cnVjdFY3LmZfYm9vbCJ9fSwgeyJlbmQiOiAx
Mzc3NTIsICJiZWdpbiI6IDEzNzczNSwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIs
ICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0u
Z29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2ln
bmF0dXJlIjogIm1vam8udGVzdC5Db250YWluc0ludGVyZmFjZSJ9fSwgeyJlbmQiOiAxNDEzNDcs
ICJiZWdpbiI6IDE0MTMzMywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRlcyIsICJ0eXBl
IjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21pdW0uZ29vZ2xl
c291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAic2lnbmF0dXJl
IjogIm1vam8udGVzdC5Db250YWluc0ludGVyZmFjZS5zb21lX2ludGVyZmFjZSJ9fSwgeyJlbmQi
OiAxNDI0NjcsICJiZWdpbiI6IDE0MjQ0MywgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVyYXRl
cyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hyb21p
dW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20iLCAi
c2lnbmF0dXJlIjogIm1vam8udGVzdC5Db250YWluc0ludGVyZmFjZVJlcXVlc3QifX0sIHsiZW5k
IjogMTQ2MjEzLCAiYmVnaW4iOiAxNDYyMDYsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQ29udGFpbnNJbnRlcmZhY2VSZXF1ZXN0LnJlcXVlc3Qi
fX0sIHsiZW5kIjogMTQ3MzUyLCAiYmVnaW4iOiAxNDczMzYsICJlZGdlIjogIiUva3l0aGUvZWRn
ZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVz
IjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjog
Im1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuQ29udGFpbnNIYXNoYWJsZSJ9fSwgeyJl
bmQiOiAxNTExMTYsICJiZWdpbiI6IDE1MTExMiwgImVkZ2UiOiAiJS9reXRoZS9lZGdlL2dlbmVy
YXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3JwdXMiOiAiY2hy
b21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2UiOiAibW9qb20i
LCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5Db250YWluc0hhc2hhYmxlLnJlY3QifX0sIHsiZW5k
IjogMTUyMTcyLCAiYmVnaW4iOiAxNTIxNTQsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0
ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9t
aXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwg
InNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuU2ltcGxlTmVzdGVkU3RydWN0In19LCB7ImVuZCI6IDE1
NTk2NSwgImJlZ2luIjogMTU1OTU5LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwg
InR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5n
b29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWdu
YXR1cmUiOiAibW9qby50ZXN0LlNpbXBsZU5lc3RlZFN0cnVjdC5uZXN0ZWQifX1dLCAidHlwZSI6
ICJreXRoZTAifQ==
*/