// mojo/public/interfaces/bindings/tests/test_native_types.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "mojo/public/interfaces/bindings/tests/test_native_types.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/common/task_annotator.h"
#include "base/trace_event/trace_event.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "mojo/public/interfaces/bindings/tests/test_native_types.mojom-params-data.h"
#include "mojo/public/interfaces/bindings/tests/test_native_types.mojom-shared-message-ids.h"

#include "mojo/public/interfaces/bindings/tests/test_native_types.mojom-import-headers.h"


#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_NATIVE_TYPES_MOJOM_JUMBO_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_NATIVE_TYPES_MOJOM_JUMBO_H_
#endif
namespace mojo {
namespace test {
PickleContainer::PickleContainer()
    : f_struct(),
      f_enum() {}

PickleContainer::PickleContainer(
    ::mojo::test::PickledStructChromium f_struct_in,
    ::mojo::test::PickledEnumChromium f_enum_in)
    : f_struct(std::move(f_struct_in)),
      f_enum(std::move(f_enum_in)) {}

PickleContainer::~PickleContainer() = default;

void PickleContainer::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_struct"), this->f_struct,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::test::PickledStructChromium>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "f_enum"), this->f_enum,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::test::PickledEnumChromium>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PickleContainer::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char PicklePasser::Name_[] = "mojo.test.PicklePasser";

class PicklePasser_PassPickledStruct_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PicklePasser_PassPickledStruct_ForwardToCallback(
      PicklePasser::PassPickledStructCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PicklePasser::PassPickledStructCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickledStruct_ForwardToCallback);
};

class PicklePasser_PassPickledEnum_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PicklePasser_PassPickledEnum_ForwardToCallback(
      PicklePasser::PassPickledEnumCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PicklePasser::PassPickledEnumCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickledEnum_ForwardToCallback);
};

class PicklePasser_PassPickleContainer_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PicklePasser_PassPickleContainer_ForwardToCallback(
      PicklePasser::PassPickleContainerCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PicklePasser::PassPickleContainerCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickleContainer_ForwardToCallback);
};

class PicklePasser_PassPickles_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PicklePasser_PassPickles_ForwardToCallback(
      PicklePasser::PassPicklesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PicklePasser::PassPicklesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickles_ForwardToCallback);
};

class PicklePasser_PassPickleArrays_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PicklePasser_PassPickleArrays_ForwardToCallback(
      PicklePasser::PassPickleArraysCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PicklePasser::PassPickleArraysCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickleArrays_ForwardToCallback);
};

PicklePasserProxy::PicklePasserProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class PicklePasserProxy_PassPickledStruct_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasserProxy_PassPickledStruct_Message(
      uint32_t message_flags
      , ::mojo::test::PickledStructChromium param_pickle
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickledStruct_Name,
          message_flags)
      , param_pickle_(std::move(param_pickle)){}
  ~PicklePasserProxy_PassPickledStruct_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      ::mojo::test::PickledStructChromium param_pickle) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasserProxy_PassPickledStruct_Message>(
          kFlags
          , std::move(param_pickle)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickledStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickledStruct_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->pickle)::BaseType> pickle_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::PickledStructDataView>(
      param_pickle, pickle_fragment);
  params->pickle.Set(
      pickle_fragment.is_null() ? nullptr : pickle_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pickle.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pickle in PicklePasser.PassPickledStruct request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      PicklePasser* impl, PicklePasser::PassPickledStructCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassPickledStruct(
        std::move(param_pickle_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickledStruct_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->pickle)::BaseType> pickle_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::PickledStructDataView>(
      param_pickle_, pickle_fragment);
  params->pickle.Set(
      pickle_fragment.is_null() ? nullptr : pickle_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pickle.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pickle in PicklePasser.PassPickledStruct request");
  }
  ::mojo::test::PickledStructChromium param_pickle_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasserProxy_PassPickledStruct_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasserProxy_PassPickledStruct_Message::kMessageTag = {};

void PicklePasserProxy::PassPickledStruct(
    ::mojo::test::PickledStructChromium in_pickle, PassPickledStructCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::PicklePasser::PassPickledStruct", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pickle"), in_pickle, 
                        "<value of type ::mojo::test::PickledStructChromium>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = PicklePasserProxy_PassPickledStruct_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_pickle));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickledStruct");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PicklePasser_PassPickledStruct_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class PicklePasserProxy_PassPickledEnum_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasserProxy_PassPickledEnum_Message(
      uint32_t message_flags
      , ::mojo::test::PickledEnumChromium param_pickle
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickledEnum_Name,
          message_flags)
      , param_pickle_(std::move(param_pickle)){}
  ~PicklePasserProxy_PassPickledEnum_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      ::mojo::test::PickledEnumChromium param_pickle) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasserProxy_PassPickledEnum_Message>(
          kFlags
          , std::move(param_pickle)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickledEnum_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickledEnum_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::mojo::test::PickledEnum>(
      param_pickle, &params->pickle);
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      PicklePasser* impl, PicklePasser::PassPickledEnumCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassPickledEnum(
        std::move(param_pickle_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickledEnum_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::Serialize<::mojo::test::PickledEnum>(
      param_pickle_, &params->pickle);
  }
  ::mojo::test::PickledEnumChromium param_pickle_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasserProxy_PassPickledEnum_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasserProxy_PassPickledEnum_Message::kMessageTag = {};

void PicklePasserProxy::PassPickledEnum(
    ::mojo::test::PickledEnumChromium in_pickle, PassPickledEnumCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::PicklePasser::PassPickledEnum", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pickle"), in_pickle, 
                        "<value of type ::mojo::test::PickledEnumChromium>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = PicklePasserProxy_PassPickledEnum_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_pickle));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickledEnum");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PicklePasser_PassPickledEnum_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class PicklePasserProxy_PassPickleContainer_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasserProxy_PassPickleContainer_Message(
      uint32_t message_flags
      , PickleContainerPtr param_container
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickleContainer_Name,
          message_flags)
      , param_container_(std::move(param_container)){}
  ~PicklePasserProxy_PassPickleContainer_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      PickleContainerPtr param_container) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasserProxy_PassPickleContainer_Message>(
          kFlags
          , std::move(param_container)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickleContainer_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickleContainer_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->container)::BaseType> container_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::PickleContainerDataView>(
      param_container, container_fragment);
  params->container.Set(
      container_fragment.is_null() ? nullptr : container_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->container.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null container in PicklePasser.PassPickleContainer request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      PicklePasser* impl, PicklePasser::PassPickleContainerCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassPickleContainer(
        std::move(param_container_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickleContainer_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->container)::BaseType> container_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::PickleContainerDataView>(
      param_container_, container_fragment);
  params->container.Set(
      container_fragment.is_null() ? nullptr : container_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->container.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null container in PicklePasser.PassPickleContainer request");
  }
  PickleContainerPtr param_container_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasserProxy_PassPickleContainer_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasserProxy_PassPickleContainer_Message::kMessageTag = {};

void PicklePasserProxy::PassPickleContainer(
    PickleContainerPtr in_container, PassPickleContainerCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::PicklePasser::PassPickleContainer", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("container"), in_container, 
                        "<value of type PickleContainerPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = PicklePasserProxy_PassPickleContainer_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_container));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickleContainer");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PicklePasser_PassPickleContainer_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class PicklePasserProxy_PassPickles_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasserProxy_PassPickles_Message(
      uint32_t message_flags
      , std::vector<::mojo::test::PickledStructChromium> param_pickles
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickles_Name,
          message_flags)
      , param_pickles_(std::move(param_pickles)){}
  ~PicklePasserProxy_PassPickles_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      std::vector<::mojo::test::PickledStructChromium> param_pickles) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasserProxy_PassPickles_Message>(
          kFlags
          , std::move(param_pickles)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickles_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickles_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->pickles)::BaseType>
      pickles_fragment(params.message());
  const mojo::internal::ContainerValidateParams pickles_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo::test::PickledStructDataView>>(
      param_pickles, pickles_fragment, &pickles_validate_params);
  params->pickles.Set(
      pickles_fragment.is_null() ? nullptr : pickles_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pickles.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pickles in PicklePasser.PassPickles request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      PicklePasser* impl, PicklePasser::PassPicklesCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassPickles(
        std::move(param_pickles_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickles_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->pickles)::BaseType>
      pickles_fragment(params.message());
  const mojo::internal::ContainerValidateParams pickles_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo::test::PickledStructDataView>>(
      param_pickles_, pickles_fragment, &pickles_validate_params);
  params->pickles.Set(
      pickles_fragment.is_null() ? nullptr : pickles_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pickles.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pickles in PicklePasser.PassPickles request");
  }
  std::vector<::mojo::test::PickledStructChromium> param_pickles_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasserProxy_PassPickles_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasserProxy_PassPickles_Message::kMessageTag = {};

void PicklePasserProxy::PassPickles(
    std::vector<::mojo::test::PickledStructChromium> in_pickles, PassPicklesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::PicklePasser::PassPickles", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pickles"), in_pickles, 
                        "<value of type std::vector<::mojo::test::PickledStructChromium>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = PicklePasserProxy_PassPickles_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_pickles));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickles");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PicklePasser_PassPickles_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class PicklePasserProxy_PassPickleArrays_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasserProxy_PassPickleArrays_Message(
      uint32_t message_flags
      , std::vector<std::vector<::mojo::test::PickledStructChromium>> param_pickle_arrays
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickleArrays_Name,
          message_flags)
      , param_pickle_arrays_(std::move(param_pickle_arrays)){}
  ~PicklePasserProxy_PassPickleArrays_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      std::vector<std::vector<::mojo::test::PickledStructChromium>> param_pickle_arrays) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasserProxy_PassPickleArrays_Message>(
          kFlags
          , std::move(param_pickle_arrays)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickleArrays_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickleArrays_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->pickle_arrays)::BaseType>
      pickle_arrays_fragment(params.message());
  const mojo::internal::ContainerValidateParams pickle_arrays_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::ArrayDataView<::mojo::test::PickledStructDataView>>>(
      param_pickle_arrays, pickle_arrays_fragment, &pickle_arrays_validate_params);
  params->pickle_arrays.Set(
      pickle_arrays_fragment.is_null() ? nullptr : pickle_arrays_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pickle_arrays.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pickle_arrays in PicklePasser.PassPickleArrays request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      PicklePasser* impl, PicklePasser::PassPickleArraysCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassPickleArrays(
        std::move(param_pickle_arrays_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickleArrays_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->pickle_arrays)::BaseType>
      pickle_arrays_fragment(params.message());
  const mojo::internal::ContainerValidateParams pickle_arrays_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::ArrayDataView<::mojo::test::PickledStructDataView>>>(
      param_pickle_arrays_, pickle_arrays_fragment, &pickle_arrays_validate_params);
  params->pickle_arrays.Set(
      pickle_arrays_fragment.is_null() ? nullptr : pickle_arrays_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pickle_arrays.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pickle_arrays in PicklePasser.PassPickleArrays request");
  }
  std::vector<std::vector<::mojo::test::PickledStructChromium>> param_pickle_arrays_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasserProxy_PassPickleArrays_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasserProxy_PassPickleArrays_Message::kMessageTag = {};

void PicklePasserProxy::PassPickleArrays(
    std::vector<std::vector<::mojo::test::PickledStructChromium>> in_pickle_arrays, PassPickleArraysCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::PicklePasser::PassPickleArrays", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pickle_arrays"), in_pickle_arrays, 
                        "<value of type std::vector<std::vector<::mojo::test::PickledStructChromium>>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = PicklePasserProxy_PassPickleArrays_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_pickle_arrays));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickleArrays");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PicklePasser_PassPickleArrays_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class PicklePasser_PassPickledStruct_ProxyToResponder {
 public:
  static PicklePasser::PassPickledStructCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PicklePasser_PassPickledStruct_ProxyToResponder> proxy(
        new PicklePasser_PassPickledStruct_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PicklePasser_PassPickledStruct_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PicklePasser_PassPickledStruct_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PicklePasser_PassPickledStruct_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PicklePasser::PassPickledStructCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::test::PickledStructChromium in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickledStruct_ProxyToResponder);
};
class PicklePasser_PassPickledStruct_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasser_PassPickledStruct_Response_Message(
      uint32_t message_flags
      , ::mojo::test::PickledStructChromium param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickledStruct_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~PicklePasser_PassPickledStruct_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      ::mojo::test::PickledStructChromium param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasser_PassPickledStruct_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickledStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickledStruct_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::PickledStructDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in PicklePasser.PassPickledStruct response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                PicklePasser::PassPickledStructCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickledStruct_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::PickledStructDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in PicklePasser.PassPickledStruct response");
  }
  ::mojo::test::PickledStructChromium param_passed_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickledStruct_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasser_PassPickledStruct_Response_Message::kMessageTag = {};

bool PicklePasser_PassPickledStruct_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::PicklePasser::PassPickledStructCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<PicklePasser_PassPickledStruct_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::PicklePasser_PassPickledStruct_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PicklePasser_PassPickledStruct_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::test::PickledStructChromium p_passed{};
  PicklePasser_PassPickledStruct_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PicklePasser::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void PicklePasser_PassPickledStruct_ProxyToResponder::Run(
    ::mojo::test::PickledStructChromium in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::PicklePasser::PassPickledStructCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type ::mojo::test::PickledStructChromium>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = PicklePasser_PassPickledStruct_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::PicklePasser::PassPickledStructCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickledStruct");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PicklePasser_PassPickledEnum_ProxyToResponder {
 public:
  static PicklePasser::PassPickledEnumCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PicklePasser_PassPickledEnum_ProxyToResponder> proxy(
        new PicklePasser_PassPickledEnum_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PicklePasser_PassPickledEnum_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PicklePasser_PassPickledEnum_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PicklePasser_PassPickledEnum_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PicklePasser::PassPickledEnumCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::test::PickledEnumChromium in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickledEnum_ProxyToResponder);
};
class PicklePasser_PassPickledEnum_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasser_PassPickledEnum_Response_Message(
      uint32_t message_flags
      , ::mojo::test::PickledEnumChromium param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickledEnum_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~PicklePasser_PassPickledEnum_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      ::mojo::test::PickledEnumChromium param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasser_PassPickledEnum_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickledEnum_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickledEnum_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::mojo::test::PickledEnum>(
      param_passed, &params->passed);
    return message;
  }


  void Dispatch(mojo::Message* message,
                PicklePasser::PassPickledEnumCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickledEnum_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::Serialize<::mojo::test::PickledEnum>(
      param_passed_, &params->passed);
  }
  ::mojo::test::PickledEnumChromium param_passed_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickledEnum_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasser_PassPickledEnum_Response_Message::kMessageTag = {};

bool PicklePasser_PassPickledEnum_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::PicklePasser::PassPickledEnumCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<PicklePasser_PassPickledEnum_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::PicklePasser_PassPickledEnum_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PicklePasser_PassPickledEnum_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::test::PickledEnumChromium p_passed{};
  PicklePasser_PassPickledEnum_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PicklePasser::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void PicklePasser_PassPickledEnum_ProxyToResponder::Run(
    ::mojo::test::PickledEnumChromium in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::PicklePasser::PassPickledEnumCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type ::mojo::test::PickledEnumChromium>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = PicklePasser_PassPickledEnum_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::PicklePasser::PassPickledEnumCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickledEnum");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PicklePasser_PassPickleContainer_ProxyToResponder {
 public:
  static PicklePasser::PassPickleContainerCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PicklePasser_PassPickleContainer_ProxyToResponder> proxy(
        new PicklePasser_PassPickleContainer_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PicklePasser_PassPickleContainer_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PicklePasser_PassPickleContainer_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PicklePasser_PassPickleContainer_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PicklePasser::PassPickleContainerCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      PickleContainerPtr in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickleContainer_ProxyToResponder);
};
class PicklePasser_PassPickleContainer_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasser_PassPickleContainer_Response_Message(
      uint32_t message_flags
      , PickleContainerPtr param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickleContainer_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~PicklePasser_PassPickleContainer_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      PickleContainerPtr param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasser_PassPickleContainer_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickleContainer_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickleContainer_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::PickleContainerDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in PicklePasser.PassPickleContainer response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                PicklePasser::PassPickleContainerCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickleContainer_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::PickleContainerDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in PicklePasser.PassPickleContainer response");
  }
  PickleContainerPtr param_passed_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickleContainer_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasser_PassPickleContainer_Response_Message::kMessageTag = {};

bool PicklePasser_PassPickleContainer_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::PicklePasser::PassPickleContainerCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<PicklePasser_PassPickleContainer_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::PicklePasser_PassPickleContainer_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PicklePasser_PassPickleContainer_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  PickleContainerPtr p_passed{};
  PicklePasser_PassPickleContainer_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PicklePasser::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void PicklePasser_PassPickleContainer_ProxyToResponder::Run(
    PickleContainerPtr in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::PicklePasser::PassPickleContainerCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type PickleContainerPtr>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = PicklePasser_PassPickleContainer_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::PicklePasser::PassPickleContainerCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickleContainer");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PicklePasser_PassPickles_ProxyToResponder {
 public:
  static PicklePasser::PassPicklesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PicklePasser_PassPickles_ProxyToResponder> proxy(
        new PicklePasser_PassPickles_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PicklePasser_PassPickles_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PicklePasser_PassPickles_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PicklePasser_PassPickles_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PicklePasser::PassPicklesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<::mojo::test::PickledStructChromium> in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickles_ProxyToResponder);
};
class PicklePasser_PassPickles_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasser_PassPickles_Response_Message(
      uint32_t message_flags
      , std::vector<::mojo::test::PickledStructChromium> param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickles_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~PicklePasser_PassPickles_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      std::vector<::mojo::test::PickledStructChromium> param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasser_PassPickles_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickles_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickles_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType>
      passed_fragment(params.message());
  const mojo::internal::ContainerValidateParams passed_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo::test::PickledStructDataView>>(
      param_passed, passed_fragment, &passed_validate_params);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in PicklePasser.PassPickles response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                PicklePasser::PassPicklesCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickles_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType>
      passed_fragment(params.message());
  const mojo::internal::ContainerValidateParams passed_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo::test::PickledStructDataView>>(
      param_passed_, passed_fragment, &passed_validate_params);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in PicklePasser.PassPickles response");
  }
  std::vector<::mojo::test::PickledStructChromium> param_passed_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickles_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasser_PassPickles_Response_Message::kMessageTag = {};

bool PicklePasser_PassPickles_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::PicklePasser::PassPicklesCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<PicklePasser_PassPickles_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::PicklePasser_PassPickles_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PicklePasser_PassPickles_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::vector<::mojo::test::PickledStructChromium> p_passed{};
  PicklePasser_PassPickles_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PicklePasser::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void PicklePasser_PassPickles_ProxyToResponder::Run(
    std::vector<::mojo::test::PickledStructChromium> in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::PicklePasser::PassPicklesCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type std::vector<::mojo::test::PickledStructChromium>>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = PicklePasser_PassPickles_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::PicklePasser::PassPicklesCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickles");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PicklePasser_PassPickleArrays_ProxyToResponder {
 public:
  static PicklePasser::PassPickleArraysCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PicklePasser_PassPickleArrays_ProxyToResponder> proxy(
        new PicklePasser_PassPickleArrays_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PicklePasser_PassPickleArrays_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PicklePasser_PassPickleArrays_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PicklePasser_PassPickleArrays_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PicklePasser::PassPickleArraysCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<std::vector<::mojo::test::PickledStructChromium>> in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickleArrays_ProxyToResponder);
};
class PicklePasser_PassPickleArrays_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PicklePasser_PassPickleArrays_Response_Message(
      uint32_t message_flags
      , std::vector<std::vector<::mojo::test::PickledStructChromium>> param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPicklePasser_PassPickleArrays_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~PicklePasser_PassPickleArrays_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      std::vector<std::vector<::mojo::test::PickledStructChromium>> param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PicklePasser_PassPickleArrays_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPicklePasser_PassPickleArrays_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::PicklePasser_PassPickleArrays_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType>
      passed_fragment(params.message());
  const mojo::internal::ContainerValidateParams passed_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::ArrayDataView<::mojo::test::PickledStructDataView>>>(
      param_passed, passed_fragment, &passed_validate_params);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in PicklePasser.PassPickleArrays response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                PicklePasser::PassPickleArraysCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::PicklePasser_PassPickleArrays_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType>
      passed_fragment(params.message());
  const mojo::internal::ContainerValidateParams passed_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::ArrayDataView<::mojo::test::PickledStructDataView>>>(
      param_passed_, passed_fragment, &passed_validate_params);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in PicklePasser.PassPickleArrays response");
  }
  std::vector<std::vector<::mojo::test::PickledStructChromium>> param_passed_;

  DISALLOW_COPY_AND_ASSIGN(PicklePasser_PassPickleArrays_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PicklePasser_PassPickleArrays_Response_Message::kMessageTag = {};

bool PicklePasser_PassPickleArrays_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::PicklePasser::PassPickleArraysCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<PicklePasser_PassPickleArrays_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::PicklePasser_PassPickleArrays_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PicklePasser_PassPickleArrays_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::vector<std::vector<::mojo::test::PickledStructChromium>> p_passed{};
  PicklePasser_PassPickleArrays_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PicklePasser::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void PicklePasser_PassPickleArrays_ProxyToResponder::Run(
    std::vector<std::vector<::mojo::test::PickledStructChromium>> in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::PicklePasser::PassPickleArraysCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type std::vector<std::vector<::mojo::test::PickledStructChromium>>>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = PicklePasser_PassPickleArrays_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::PicklePasser::PassPickleArraysCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PicklePasser::Name_);
  message.set_method_name("PassPickleArrays");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PicklePasserStubDispatch::Accept(
    PicklePasser* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPicklePasser_PassPickledStruct_Name: {
      break;
    }
    case internal::kPicklePasser_PassPickledEnum_Name: {
      break;
    }
    case internal::kPicklePasser_PassPickleContainer_Name: {
      break;
    }
    case internal::kPicklePasser_PassPickles_Name: {
      break;
    }
    case internal::kPicklePasser_PassPickleArrays_Name: {
      break;
    }
  }
  return false;
}

// static
bool PicklePasserStubDispatch::AcceptWithResponder(
    PicklePasser* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPicklePasser_PassPickledStruct_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::PicklePasser::PassPickledStruct",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::PicklePasser::PassPickledStruct");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            PicklePasserProxy_PassPickledStruct_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          PicklePasser::PassPickledStructCallback callback =
              PicklePasser_PassPickledStruct_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::PicklePasser_PassPickledStruct_Params_Data* params =
          reinterpret_cast<
              internal::PicklePasser_PassPickledStruct_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::test::PickledStructChromium p_pickle{};
      PicklePasser_PassPickledStruct_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPickle(&p_pickle))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PicklePasser::Name_, 0, false);
        return false;
      }
      PicklePasser::PassPickledStructCallback callback =
          PicklePasser_PassPickledStruct_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassPickledStruct(
std::move(p_pickle), std::move(callback));
      return true;
    }
    case internal::kPicklePasser_PassPickledEnum_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::PicklePasser::PassPickledEnum",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::PicklePasser::PassPickledEnum");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            PicklePasserProxy_PassPickledEnum_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          PicklePasser::PassPickledEnumCallback callback =
              PicklePasser_PassPickledEnum_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::PicklePasser_PassPickledEnum_Params_Data* params =
          reinterpret_cast<
              internal::PicklePasser_PassPickledEnum_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::test::PickledEnumChromium p_pickle{};
      PicklePasser_PassPickledEnum_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPickle(&p_pickle))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PicklePasser::Name_, 1, false);
        return false;
      }
      PicklePasser::PassPickledEnumCallback callback =
          PicklePasser_PassPickledEnum_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassPickledEnum(
std::move(p_pickle), std::move(callback));
      return true;
    }
    case internal::kPicklePasser_PassPickleContainer_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::PicklePasser::PassPickleContainer",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::PicklePasser::PassPickleContainer");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            PicklePasserProxy_PassPickleContainer_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          PicklePasser::PassPickleContainerCallback callback =
              PicklePasser_PassPickleContainer_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::PicklePasser_PassPickleContainer_Params_Data* params =
          reinterpret_cast<
              internal::PicklePasser_PassPickleContainer_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PickleContainerPtr p_container{};
      PicklePasser_PassPickleContainer_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadContainer(&p_container))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PicklePasser::Name_, 2, false);
        return false;
      }
      PicklePasser::PassPickleContainerCallback callback =
          PicklePasser_PassPickleContainer_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassPickleContainer(
std::move(p_container), std::move(callback));
      return true;
    }
    case internal::kPicklePasser_PassPickles_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::PicklePasser::PassPickles",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::PicklePasser::PassPickles");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            PicklePasserProxy_PassPickles_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          PicklePasser::PassPicklesCallback callback =
              PicklePasser_PassPickles_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::PicklePasser_PassPickles_Params_Data* params =
          reinterpret_cast<
              internal::PicklePasser_PassPickles_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<::mojo::test::PickledStructChromium> p_pickles{};
      PicklePasser_PassPickles_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPickles(&p_pickles))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PicklePasser::Name_, 3, false);
        return false;
      }
      PicklePasser::PassPicklesCallback callback =
          PicklePasser_PassPickles_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassPickles(
std::move(p_pickles), std::move(callback));
      return true;
    }
    case internal::kPicklePasser_PassPickleArrays_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::PicklePasser::PassPickleArrays",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::PicklePasser::PassPickleArrays");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            PicklePasserProxy_PassPickleArrays_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          PicklePasser::PassPickleArraysCallback callback =
              PicklePasser_PassPickleArrays_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::PicklePasser_PassPickleArrays_Params_Data* params =
          reinterpret_cast<
              internal::PicklePasser_PassPickleArrays_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<std::vector<::mojo::test::PickledStructChromium>> p_pickle_arrays{};
      PicklePasser_PassPickleArrays_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPickleArrays(&p_pickle_arrays))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PicklePasser::Name_, 4, false);
        return false;
      }
      PicklePasser::PassPickleArraysCallback callback =
          PicklePasser_PassPickleArrays_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassPickleArrays(
std::move(p_pickle_arrays), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPicklePasserValidationInfo[] = {
    {&internal::PicklePasser_PassPickledStruct_Params_Data::Validate,
     &internal::PicklePasser_PassPickledStruct_ResponseParams_Data::Validate},
    {&internal::PicklePasser_PassPickledEnum_Params_Data::Validate,
     &internal::PicklePasser_PassPickledEnum_ResponseParams_Data::Validate},
    {&internal::PicklePasser_PassPickleContainer_Params_Data::Validate,
     &internal::PicklePasser_PassPickleContainer_ResponseParams_Data::Validate},
    {&internal::PicklePasser_PassPickles_Params_Data::Validate,
     &internal::PicklePasser_PassPickles_ResponseParams_Data::Validate},
    {&internal::PicklePasser_PassPickleArrays_Params_Data::Validate,
     &internal::PicklePasser_PassPickleArrays_ResponseParams_Data::Validate},
};

bool PicklePasserRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::PicklePasser::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPicklePasserValidationInfo);
}

bool PicklePasserResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::PicklePasser::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kPicklePasserValidationInfo);
}
const char RectService::Name_[] = "mojo.test.RectService";

class RectService_GetLargestRect_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  RectService_GetLargestRect_ForwardToCallback(
      RectService::GetLargestRectCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  RectService::GetLargestRectCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(RectService_GetLargestRect_ForwardToCallback);
};

class RectService_PassSharedRect_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  RectService_PassSharedRect_ForwardToCallback(
      RectService::PassSharedRectCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  RectService::PassSharedRectCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(RectService_PassSharedRect_ForwardToCallback);
};

RectServiceProxy::RectServiceProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class RectServiceProxy_AddRect_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit RectServiceProxy_AddRect_Message(
      uint32_t message_flags
      , const ::mojo::test::RectChromium& param_r
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kRectService_AddRect_Name,
          message_flags)
      , param_r_(std::move(param_r)){}
  ~RectServiceProxy_AddRect_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      const ::mojo::test::RectChromium& param_r) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<RectServiceProxy_AddRect_Message>(
          kFlags
          , std::move(param_r)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kRectService_AddRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::RectService_AddRect_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->r)::BaseType> r_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TypemappedRectDataView>(
      param_r, r_fragment);
  params->r.Set(
      r_fragment.is_null() ? nullptr : r_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->r.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null r in RectService.AddRect request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      RectService* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->AddRect(
        std::move(param_r_));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::RectService_AddRect_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->r)::BaseType> r_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TypemappedRectDataView>(
      param_r_, r_fragment);
  params->r.Set(
      r_fragment.is_null() ? nullptr : r_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->r.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null r in RectService.AddRect request");
  }
  ::mojo::test::RectChromium param_r_;

  DISALLOW_COPY_AND_ASSIGN(RectServiceProxy_AddRect_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
RectServiceProxy_AddRect_Message::kMessageTag = {};

void RectServiceProxy::AddRect(
    const ::mojo::test::RectChromium& in_r) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::RectService::AddRect", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("r"), in_r, 
                        "<value of type const ::mojo::test::RectChromium&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = RectServiceProxy_AddRect_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_r));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RectService::Name_);
  message.set_method_name("AddRect");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class RectServiceProxy_GetLargestRect_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit RectServiceProxy_GetLargestRect_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kRectService_GetLargestRect_Name,
          message_flags){}
  ~RectServiceProxy_GetLargestRect_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<RectServiceProxy_GetLargestRect_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kRectService_GetLargestRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::RectService_GetLargestRect_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      RectService* impl, RectService::GetLargestRectCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->GetLargestRect(std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::RectService_GetLargestRect_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(RectServiceProxy_GetLargestRect_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
RectServiceProxy_GetLargestRect_Message::kMessageTag = {};

void RectServiceProxy::GetLargestRect(
    GetLargestRectCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "mojo::test::RectService::GetLargestRect");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = RectServiceProxy_GetLargestRect_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RectService::Name_);
  message.set_method_name("GetLargestRect");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new RectService_GetLargestRect_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class RectServiceProxy_PassSharedRect_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit RectServiceProxy_PassSharedRect_Message(
      uint32_t message_flags
      , const ::mojo::test::SharedRect& param_r
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kRectService_PassSharedRect_Name,
          message_flags)
      , param_r_(std::move(param_r)){}
  ~RectServiceProxy_PassSharedRect_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      const ::mojo::test::SharedRect& param_r) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<RectServiceProxy_PassSharedRect_Message>(
          kFlags
          , std::move(param_r)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kRectService_PassSharedRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::RectService_PassSharedRect_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->r)::BaseType> r_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::SharedTypemappedRectDataView>(
      param_r, r_fragment);
  params->r.Set(
      r_fragment.is_null() ? nullptr : r_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->r.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null r in RectService.PassSharedRect request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      RectService* impl, RectService::PassSharedRectCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassSharedRect(
        std::move(param_r_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::RectService_PassSharedRect_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->r)::BaseType> r_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::SharedTypemappedRectDataView>(
      param_r_, r_fragment);
  params->r.Set(
      r_fragment.is_null() ? nullptr : r_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->r.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null r in RectService.PassSharedRect request");
  }
  ::mojo::test::SharedRect param_r_;

  DISALLOW_COPY_AND_ASSIGN(RectServiceProxy_PassSharedRect_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
RectServiceProxy_PassSharedRect_Message::kMessageTag = {};

void RectServiceProxy::PassSharedRect(
    const ::mojo::test::SharedRect& in_r, PassSharedRectCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::RectService::PassSharedRect", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("r"), in_r, 
                        "<value of type const ::mojo::test::SharedRect&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = RectServiceProxy_PassSharedRect_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_r));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RectService::Name_);
  message.set_method_name("PassSharedRect");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new RectService_PassSharedRect_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class RectService_GetLargestRect_ProxyToResponder {
 public:
  static RectService::GetLargestRectCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<RectService_GetLargestRect_ProxyToResponder> proxy(
        new RectService_GetLargestRect_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&RectService_GetLargestRect_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~RectService_GetLargestRect_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  RectService_GetLargestRect_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "RectService::GetLargestRectCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::mojo::test::RectChromium& in_largest);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(RectService_GetLargestRect_ProxyToResponder);
};
class RectService_GetLargestRect_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit RectService_GetLargestRect_Response_Message(
      uint32_t message_flags
      , const ::mojo::test::RectChromium& param_largest
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kRectService_GetLargestRect_Name,
          message_flags)
      , param_largest_(std::move(param_largest)){}
  ~RectService_GetLargestRect_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      const ::mojo::test::RectChromium& param_largest) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<RectService_GetLargestRect_Response_Message>(
          kFlags
          , std::move(param_largest)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kRectService_GetLargestRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::RectService_GetLargestRect_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->largest)::BaseType> largest_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TypemappedRectDataView>(
      param_largest, largest_fragment);
  params->largest.Set(
      largest_fragment.is_null() ? nullptr : largest_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->largest.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null largest in RectService.GetLargestRect response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                RectService::GetLargestRectCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_largest_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::RectService_GetLargestRect_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->largest)::BaseType> largest_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TypemappedRectDataView>(
      param_largest_, largest_fragment);
  params->largest.Set(
      largest_fragment.is_null() ? nullptr : largest_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->largest.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null largest in RectService.GetLargestRect response");
  }
  ::mojo::test::RectChromium param_largest_;

  DISALLOW_COPY_AND_ASSIGN(RectService_GetLargestRect_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
RectService_GetLargestRect_Response_Message::kMessageTag = {};

bool RectService_GetLargestRect_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::RectService::GetLargestRectCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<RectService_GetLargestRect_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::RectService_GetLargestRect_ResponseParams_Data* params =
      reinterpret_cast<
          internal::RectService_GetLargestRect_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::test::RectChromium p_largest{};
  RectService_GetLargestRect_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadLargest(&p_largest))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        RectService::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_largest));
  return true;
}

void RectService_GetLargestRect_ProxyToResponder::Run(
    const ::mojo::test::RectChromium& in_largest) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::RectService::GetLargestRectCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("largest"), in_largest, 
                        "<value of type const ::mojo::test::RectChromium&>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = RectService_GetLargestRect_Response_Message::Build(kSerialize, is_sync_, std::move(in_largest));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::RectService::GetLargestRectCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RectService::Name_);
  message.set_method_name("GetLargestRect");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class RectService_PassSharedRect_ProxyToResponder {
 public:
  static RectService::PassSharedRectCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<RectService_PassSharedRect_ProxyToResponder> proxy(
        new RectService_PassSharedRect_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&RectService_PassSharedRect_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~RectService_PassSharedRect_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  RectService_PassSharedRect_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "RectService::PassSharedRectCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::mojo::test::SharedRect& in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(RectService_PassSharedRect_ProxyToResponder);
};
class RectService_PassSharedRect_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit RectService_PassSharedRect_Response_Message(
      uint32_t message_flags
      , const ::mojo::test::SharedRect& param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kRectService_PassSharedRect_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~RectService_PassSharedRect_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      const ::mojo::test::SharedRect& param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<RectService_PassSharedRect_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kRectService_PassSharedRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::RectService_PassSharedRect_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::SharedTypemappedRectDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in RectService.PassSharedRect response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                RectService::PassSharedRectCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::RectService_PassSharedRect_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::SharedTypemappedRectDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in RectService.PassSharedRect response");
  }
  ::mojo::test::SharedRect param_passed_;

  DISALLOW_COPY_AND_ASSIGN(RectService_PassSharedRect_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
RectService_PassSharedRect_Response_Message::kMessageTag = {};

bool RectService_PassSharedRect_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::RectService::PassSharedRectCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<RectService_PassSharedRect_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::RectService_PassSharedRect_ResponseParams_Data* params =
      reinterpret_cast<
          internal::RectService_PassSharedRect_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::test::SharedRect p_passed{};
  RectService_PassSharedRect_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        RectService::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void RectService_PassSharedRect_ProxyToResponder::Run(
    const ::mojo::test::SharedRect& in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::RectService::PassSharedRectCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type const ::mojo::test::SharedRect&>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = RectService_PassSharedRect_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::RectService::PassSharedRectCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RectService::Name_);
  message.set_method_name("PassSharedRect");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool RectServiceStubDispatch::Accept(
    RectService* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kRectService_AddRect_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::RectService::AddRect",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::RectService::AddRect");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            RectServiceProxy_AddRect_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::RectService_AddRect_Params_Data* params =
          reinterpret_cast<internal::RectService_AddRect_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::test::RectChromium p_r{};
      RectService_AddRect_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadR(&p_r))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RectService::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddRect(
std::move(p_r));
      return true;
    }
    case internal::kRectService_GetLargestRect_Name: {
      break;
    }
    case internal::kRectService_PassSharedRect_Name: {
      break;
    }
  }
  return false;
}

// static
bool RectServiceStubDispatch::AcceptWithResponder(
    RectService* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kRectService_AddRect_Name: {
      break;
    }
    case internal::kRectService_GetLargestRect_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::RectService::GetLargestRect",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::RectService::GetLargestRect");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            RectServiceProxy_GetLargestRect_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          RectService::GetLargestRectCallback callback =
              RectService_GetLargestRect_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::RectService_GetLargestRect_Params_Data* params =
          reinterpret_cast<
              internal::RectService_GetLargestRect_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      RectService_GetLargestRect_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RectService::Name_, 1, false);
        return false;
      }
      RectService::GetLargestRectCallback callback =
          RectService_GetLargestRect_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetLargestRect(std::move(callback));
      return true;
    }
    case internal::kRectService_PassSharedRect_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::RectService::PassSharedRect",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::RectService::PassSharedRect");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            RectServiceProxy_PassSharedRect_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          RectService::PassSharedRectCallback callback =
              RectService_PassSharedRect_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::RectService_PassSharedRect_Params_Data* params =
          reinterpret_cast<
              internal::RectService_PassSharedRect_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::test::SharedRect p_r{};
      RectService_PassSharedRect_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadR(&p_r))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RectService::Name_, 2, false);
        return false;
      }
      RectService::PassSharedRectCallback callback =
          RectService_PassSharedRect_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassSharedRect(
std::move(p_r), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kRectServiceValidationInfo[] = {
    {&internal::RectService_AddRect_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RectService_GetLargestRect_Params_Data::Validate,
     &internal::RectService_GetLargestRect_ResponseParams_Data::Validate},
    {&internal::RectService_PassSharedRect_Params_Data::Validate,
     &internal::RectService_PassSharedRect_ResponseParams_Data::Validate},
};

bool RectServiceRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::RectService::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kRectServiceValidationInfo);
}

bool RectServiceResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::RectService::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kRectServiceValidationInfo);
}
const char NativeTypeTester::Name_[] = "mojo.test.NativeTypeTester";

class NativeTypeTester_PassNativeStruct_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NativeTypeTester_PassNativeStruct_ForwardToCallback(
      NativeTypeTester::PassNativeStructCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  NativeTypeTester::PassNativeStructCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(NativeTypeTester_PassNativeStruct_ForwardToCallback);
};

class NativeTypeTester_PassNativeStructWithAttachments_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NativeTypeTester_PassNativeStructWithAttachments_ForwardToCallback(
      NativeTypeTester::PassNativeStructWithAttachmentsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  NativeTypeTester::PassNativeStructWithAttachmentsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(NativeTypeTester_PassNativeStructWithAttachments_ForwardToCallback);
};

NativeTypeTesterProxy::NativeTypeTesterProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class NativeTypeTesterProxy_PassNativeStruct_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit NativeTypeTesterProxy_PassNativeStruct_Message(
      uint32_t message_flags
      , const ::mojo::test::TestNativeStruct& param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kNativeTypeTester_PassNativeStruct_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~NativeTypeTesterProxy_PassNativeStruct_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      const ::mojo::test::TestNativeStruct& param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<NativeTypeTesterProxy_PassNativeStruct_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kNativeTypeTester_PassNativeStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::NativeTypeTester_PassNativeStruct_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TestNativeStructMojomDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in NativeTypeTester.PassNativeStruct request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      NativeTypeTester* impl, NativeTypeTester::PassNativeStructCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassNativeStruct(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::NativeTypeTester_PassNativeStruct_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TestNativeStructMojomDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in NativeTypeTester.PassNativeStruct request");
  }
  ::mojo::test::TestNativeStruct param_s_;

  DISALLOW_COPY_AND_ASSIGN(NativeTypeTesterProxy_PassNativeStruct_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
NativeTypeTesterProxy_PassNativeStruct_Message::kMessageTag = {};

void NativeTypeTesterProxy::PassNativeStruct(
    const ::mojo::test::TestNativeStruct& in_s, PassNativeStructCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::NativeTypeTester::PassNativeStruct", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type const ::mojo::test::TestNativeStruct&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = NativeTypeTesterProxy_PassNativeStruct_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NativeTypeTester::Name_);
  message.set_method_name("PassNativeStruct");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NativeTypeTester_PassNativeStruct_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class NativeTypeTesterProxy_PassNativeStructWithAttachments_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit NativeTypeTesterProxy_PassNativeStructWithAttachments_Message(
      uint32_t message_flags
      , ::mojo::test::TestNativeStructWithAttachments param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kNativeTypeTester_PassNativeStructWithAttachments_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~NativeTypeTesterProxy_PassNativeStructWithAttachments_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      ::mojo::test::TestNativeStructWithAttachments param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<NativeTypeTesterProxy_PassNativeStructWithAttachments_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kNativeTypeTester_PassNativeStructWithAttachments_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::NativeTypeTester_PassNativeStructWithAttachments_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TestNativeStructWithAttachmentsMojomDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in NativeTypeTester.PassNativeStructWithAttachments request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      NativeTypeTester* impl, NativeTypeTester::PassNativeStructWithAttachmentsCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->PassNativeStructWithAttachments(
        std::move(param_s_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::NativeTypeTester_PassNativeStructWithAttachments_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TestNativeStructWithAttachmentsMojomDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in NativeTypeTester.PassNativeStructWithAttachments request");
  }
  ::mojo::test::TestNativeStructWithAttachments param_s_;

  DISALLOW_COPY_AND_ASSIGN(NativeTypeTesterProxy_PassNativeStructWithAttachments_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
NativeTypeTesterProxy_PassNativeStructWithAttachments_Message::kMessageTag = {};

void NativeTypeTesterProxy::PassNativeStructWithAttachments(
    ::mojo::test::TestNativeStructWithAttachments in_s, PassNativeStructWithAttachmentsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "mojo::test::NativeTypeTester::PassNativeStructWithAttachments", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type ::mojo::test::TestNativeStructWithAttachments>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = NativeTypeTesterProxy_PassNativeStructWithAttachments_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NativeTypeTester::Name_);
  message.set_method_name("PassNativeStructWithAttachments");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NativeTypeTester_PassNativeStructWithAttachments_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class NativeTypeTester_PassNativeStruct_ProxyToResponder {
 public:
  static NativeTypeTester::PassNativeStructCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<NativeTypeTester_PassNativeStruct_ProxyToResponder> proxy(
        new NativeTypeTester_PassNativeStruct_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&NativeTypeTester_PassNativeStruct_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NativeTypeTester_PassNativeStruct_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  NativeTypeTester_PassNativeStruct_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NativeTypeTester::PassNativeStructCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::mojo::test::TestNativeStruct& in_passed);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(NativeTypeTester_PassNativeStruct_ProxyToResponder);
};
class NativeTypeTester_PassNativeStruct_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit NativeTypeTester_PassNativeStruct_Response_Message(
      uint32_t message_flags
      , const ::mojo::test::TestNativeStruct& param_passed
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kNativeTypeTester_PassNativeStruct_Name,
          message_flags)
      , param_passed_(std::move(param_passed)){}
  ~NativeTypeTester_PassNativeStruct_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      const ::mojo::test::TestNativeStruct& param_passed) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<NativeTypeTester_PassNativeStruct_Response_Message>(
          kFlags
          , std::move(param_passed)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kNativeTypeTester_PassNativeStruct_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::NativeTypeTester_PassNativeStruct_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TestNativeStructMojomDataView>(
      param_passed, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in NativeTypeTester.PassNativeStruct response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                NativeTypeTester::PassNativeStructCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_passed_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::NativeTypeTester_PassNativeStruct_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->passed)::BaseType> passed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TestNativeStructMojomDataView>(
      param_passed_, passed_fragment);
  params->passed.Set(
      passed_fragment.is_null() ? nullptr : passed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->passed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null passed in NativeTypeTester.PassNativeStruct response");
  }
  ::mojo::test::TestNativeStruct param_passed_;

  DISALLOW_COPY_AND_ASSIGN(NativeTypeTester_PassNativeStruct_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
NativeTypeTester_PassNativeStruct_Response_Message::kMessageTag = {};

bool NativeTypeTester_PassNativeStruct_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::NativeTypeTester::PassNativeStructCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<NativeTypeTester_PassNativeStruct_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::NativeTypeTester_PassNativeStruct_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NativeTypeTester_PassNativeStruct_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::test::TestNativeStruct p_passed{};
  NativeTypeTester_PassNativeStruct_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPassed(&p_passed))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NativeTypeTester::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_passed));
  return true;
}

void NativeTypeTester_PassNativeStruct_ProxyToResponder::Run(
    const ::mojo::test::TestNativeStruct& in_passed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::NativeTypeTester::PassNativeStructCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("passed"), in_passed, 
                        "<value of type const ::mojo::test::TestNativeStruct&>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = NativeTypeTester_PassNativeStruct_Response_Message::Build(kSerialize, is_sync_, std::move(in_passed));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::NativeTypeTester::PassNativeStructCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NativeTypeTester::Name_);
  message.set_method_name("PassNativeStruct");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder {
 public:
  static NativeTypeTester::PassNativeStructWithAttachmentsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder> proxy(
        new NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NativeTypeTester::PassNativeStructWithAttachmentsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::test::TestNativeStructWithAttachments in_s);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder);
};
class NativeTypeTester_PassNativeStructWithAttachments_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit NativeTypeTester_PassNativeStructWithAttachments_Response_Message(
      uint32_t message_flags
      , ::mojo::test::TestNativeStructWithAttachments param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kNativeTypeTester_PassNativeStructWithAttachments_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~NativeTypeTester_PassNativeStructWithAttachments_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      ::mojo::test::TestNativeStructWithAttachments param_s) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<NativeTypeTester_PassNativeStructWithAttachments_Response_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kNativeTypeTester_PassNativeStructWithAttachments_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::mojo::test::internal::NativeTypeTester_PassNativeStructWithAttachments_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TestNativeStructWithAttachmentsMojomDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in NativeTypeTester.PassNativeStructWithAttachments response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                NativeTypeTester::PassNativeStructWithAttachmentsCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_s_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::mojo::test::internal::NativeTypeTester_PassNativeStructWithAttachments_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::mojo::test::TestNativeStructWithAttachmentsMojomDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in NativeTypeTester.PassNativeStructWithAttachments response");
  }
  ::mojo::test::TestNativeStructWithAttachments param_s_;

  DISALLOW_COPY_AND_ASSIGN(NativeTypeTester_PassNativeStructWithAttachments_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
NativeTypeTester_PassNativeStructWithAttachments_Response_Message::kMessageTag = {};

bool NativeTypeTester_PassNativeStructWithAttachments_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "mojo::test::NativeTypeTester::PassNativeStructWithAttachmentsCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<NativeTypeTester_PassNativeStructWithAttachments_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::NativeTypeTester_PassNativeStructWithAttachments_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NativeTypeTester_PassNativeStructWithAttachments_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::test::TestNativeStructWithAttachments p_s{};
  NativeTypeTester_PassNativeStructWithAttachments_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadS(&p_s))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NativeTypeTester::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_s));
  return true;
}

void NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder::Run(
    ::mojo::test::TestNativeStructWithAttachments in_s) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)mojo::test::NativeTypeTester::PassNativeStructWithAttachmentsCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type ::mojo::test::TestNativeStructWithAttachments>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = NativeTypeTester_PassNativeStructWithAttachments_Response_Message::Build(kSerialize, is_sync_, std::move(in_s));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)mojo::test::NativeTypeTester::PassNativeStructWithAttachmentsCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NativeTypeTester::Name_);
  message.set_method_name("PassNativeStructWithAttachments");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool NativeTypeTesterStubDispatch::Accept(
    NativeTypeTester* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kNativeTypeTester_PassNativeStruct_Name: {
      break;
    }
    case internal::kNativeTypeTester_PassNativeStructWithAttachments_Name: {
      break;
    }
  }
  return false;
}

// static
bool NativeTypeTesterStubDispatch::AcceptWithResponder(
    NativeTypeTester* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kNativeTypeTester_PassNativeStruct_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::NativeTypeTester::PassNativeStruct",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::NativeTypeTester::PassNativeStruct");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            NativeTypeTesterProxy_PassNativeStruct_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          NativeTypeTester::PassNativeStructCallback callback =
              NativeTypeTester_PassNativeStruct_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::NativeTypeTester_PassNativeStruct_Params_Data* params =
          reinterpret_cast<
              internal::NativeTypeTester_PassNativeStruct_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::test::TestNativeStruct p_s{};
      NativeTypeTester_PassNativeStruct_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NativeTypeTester::Name_, 0, false);
        return false;
      }
      NativeTypeTester::PassNativeStructCallback callback =
          NativeTypeTester_PassNativeStruct_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassNativeStruct(
std::move(p_s), std::move(callback));
      return true;
    }
    case internal::kNativeTypeTester_PassNativeStructWithAttachments_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)mojo::test::NativeTypeTester::PassNativeStructWithAttachments",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)mojo::test::NativeTypeTester::PassNativeStructWithAttachments");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            NativeTypeTesterProxy_PassNativeStructWithAttachments_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          NativeTypeTester::PassNativeStructWithAttachmentsCallback callback =
              NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::NativeTypeTester_PassNativeStructWithAttachments_Params_Data* params =
          reinterpret_cast<
              internal::NativeTypeTester_PassNativeStructWithAttachments_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::test::TestNativeStructWithAttachments p_s{};
      NativeTypeTester_PassNativeStructWithAttachments_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NativeTypeTester::Name_, 1, false);
        return false;
      }
      NativeTypeTester::PassNativeStructWithAttachmentsCallback callback =
          NativeTypeTester_PassNativeStructWithAttachments_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PassNativeStructWithAttachments(
std::move(p_s), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kNativeTypeTesterValidationInfo[] = {
    {&internal::NativeTypeTester_PassNativeStruct_Params_Data::Validate,
     &internal::NativeTypeTester_PassNativeStruct_ResponseParams_Data::Validate},
    {&internal::NativeTypeTester_PassNativeStructWithAttachments_Params_Data::Validate,
     &internal::NativeTypeTester_PassNativeStructWithAttachments_ResponseParams_Data::Validate},
};

bool NativeTypeTesterRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::NativeTypeTester::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kNativeTypeTesterValidationInfo);
}

bool NativeTypeTesterResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::mojo::test::NativeTypeTester::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kNativeTypeTesterValidationInfo);
}
}  // namespace test
}  // namespace mojo

namespace mojo {


// static
bool StructTraits<::mojo::test::PickleContainer::DataView, ::mojo::test::PickleContainerPtr>::Read(
    ::mojo::test::PickleContainer::DataView input,
    ::mojo::test::PickleContainerPtr* output) {
  bool success = true;
  ::mojo::test::PickleContainerPtr result(::mojo::test::PickleContainer::New());
  
      if (success && !input.ReadFStruct(&result->f_struct))
        success = false;
      if (success && !input.ReadFEnum(&result->f_enum))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif