// mojo/public/interfaces/bindings/tests/regression_tests.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'mojo/public/interfaces/bindings/tests/regression_tests.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('regressionTests');


  var EnumWithReference = {};
  EnumWithReference.k_STEREO_AND_KEYBOARD_MIC = 30;
  EnumWithReference.k_MAX = 30;
  EnumWithReference.MIN_VALUE = 30;
  EnumWithReference.MAX_VALUE = 30;

  EnumWithReference.isKnownEnumValue = function(value) {
    switch (value) {
    case 30:
      return true;
    }
    return false;
  };

  EnumWithReference.toKnownEnumValue = function(value) {
    return value;
  };

  EnumWithReference.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var EnumWithLowercase = {};
  EnumWithLowercase.PlanarF16 = 0;
  EnumWithLowercase.PlanarF32 = 1;
  EnumWithLowercase.MIN_VALUE = 0;
  EnumWithLowercase.MAX_VALUE = 1;

  EnumWithLowercase.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  EnumWithLowercase.toKnownEnumValue = function(value) {
    return value;
  };

  EnumWithLowercase.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var EnumWithNumbers = {};
  EnumWithNumbers.k_2_1 = 4;
  EnumWithNumbers.MIN_VALUE = 4;
  EnumWithNumbers.MAX_VALUE = 4;

  EnumWithNumbers.isKnownEnumValue = function(value) {
    switch (value) {
    case 4:
      return true;
    }
    return false;
  };

  EnumWithNumbers.toKnownEnumValue = function(value) {
    return value;
  };

  EnumWithNumbers.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var EnumWithK = {};
  EnumWithK.K = 0;
  EnumWithK.MIN_VALUE = 0;
  EnumWithK.MAX_VALUE = 0;

  EnumWithK.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
      return true;
    }
    return false;
  };

  EnumWithK.toKnownEnumValue = function(value) {
    return value;
  };

  EnumWithK.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function Edge(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Edge.prototype.initDefaults_ = function() {
    this.v = null;
  };
  Edge.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Edge.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Edge.v
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, Vertex, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Edge.encodedSize = codec.kStructHeaderSize + 8;

  Edge.decode = function(decoder) {
    var packed;
    var val = new Edge();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.v =
        decoder.decodeStructPointer(Vertex);
    return val;
  };

  Edge.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Edge.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(Vertex, val.v);
  };
  function Vertex(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Vertex.prototype.initDefaults_ = function() {
    this.e = null;
  };
  Vertex.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Vertex.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Vertex.e
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, EmptyStruct, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Vertex.encodedSize = codec.kStructHeaderSize + 8;

  Vertex.decode = function(decoder) {
    var packed;
    var val = new Vertex();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.e =
        decoder.decodeStructPointer(EmptyStruct);
    return val;
  };

  Vertex.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Vertex.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(EmptyStruct, val.e);
  };
  function EmptyStruct(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  EmptyStruct.prototype.initDefaults_ = function() {
  };
  EmptyStruct.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  EmptyStruct.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  EmptyStruct.encodedSize = codec.kStructHeaderSize + 0;

  EmptyStruct.decode = function(decoder) {
    var packed;
    var val = new EmptyStruct();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  EmptyStruct.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(EmptyStruct.encodedSize);
    encoder.writeUint32(0);
  };
  function A(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  A.prototype.initDefaults_ = function() {
    this.b = null;
  };
  A.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  A.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate A.b
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, B, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  A.encodedSize = codec.kStructHeaderSize + 8;

  A.decode = function(decoder) {
    var packed;
    var val = new A();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.b =
        decoder.decodeStructPointer(B);
    return val;
  };

  A.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(A.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(B, val.b);
  };
  function B(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  B.prototype.initDefaults_ = function() {
    this.a = null;
  };
  B.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  B.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate B.a
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, A, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  B.encodedSize = codec.kStructHeaderSize + 8;

  B.decode = function(decoder) {
    var packed;
    var val = new B();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.a =
        decoder.decodeStructPointer(A);
    return val;
  };

  B.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(B.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(A, val.a);
  };
  function HandlesNameCollisionStruct(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  HandlesNameCollisionStruct.prototype.initDefaults_ = function() {
    this.handles = null;
  };
  HandlesNameCollisionStruct.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  HandlesNameCollisionStruct.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate HandlesNameCollisionStruct.handles
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, EmptyStruct, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  HandlesNameCollisionStruct.encodedSize = codec.kStructHeaderSize + 8;

  HandlesNameCollisionStruct.decode = function(decoder) {
    var packed;
    var val = new HandlesNameCollisionStruct();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.handles =
        decoder.decodeStructPointer(EmptyStruct);
    return val;
  };

  HandlesNameCollisionStruct.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(HandlesNameCollisionStruct.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(EmptyStruct, val.handles);
  };
  function HandlesHandleNameCollisionStruct(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  HandlesHandleNameCollisionStruct.prototype.initDefaults_ = function() {
    this.handles = null;
  };
  HandlesHandleNameCollisionStruct.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  HandlesHandleNameCollisionStruct.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate HandlesHandleNameCollisionStruct.handles
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  HandlesHandleNameCollisionStruct.encodedSize = codec.kStructHeaderSize + 8;

  HandlesHandleNameCollisionStruct.decode = function(decoder) {
    var packed;
    var val = new HandlesHandleNameCollisionStruct();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.handles =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  HandlesHandleNameCollisionStruct.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(HandlesHandleNameCollisionStruct.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Handle, val.handles);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function HandlesUnionNameCollisionStruct(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  HandlesUnionNameCollisionStruct.prototype.initDefaults_ = function() {
    this.handles = null;
  };
  HandlesUnionNameCollisionStruct.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  HandlesUnionNameCollisionStruct.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate HandlesUnionNameCollisionStruct.handles
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, HandlesNameCollisionUnion, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  HandlesUnionNameCollisionStruct.encodedSize = codec.kStructHeaderSize + 16;

  HandlesUnionNameCollisionStruct.decode = function(decoder) {
    var packed;
    var val = new HandlesUnionNameCollisionStruct();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.handles =
        decoder.decodeStruct(HandlesNameCollisionUnion);
    return val;
  };

  HandlesUnionNameCollisionStruct.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(HandlesUnionNameCollisionStruct.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(HandlesNameCollisionUnion, val.handles);
  };
  function CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.prototype.initDefaults_ = function() {
  };
  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encodedSize = codec.kStructHeaderSize + 0;

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.decode = function(decoder) {
    var packed;
    var val = new CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.prototype.initDefaults_ = function() {
  };
  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.prototype.initDefaults_ = function() {
    this.b = false;
  };
  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encodedSize = codec.kStructHeaderSize + 8;

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.decode = function(decoder) {
    var packed;
    var val = new CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.b = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.b & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.prototype.initDefaults_ = function() {
  };
  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function CheckNameCollision_WithNameCollision_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckNameCollision_WithNameCollision_Params.prototype.initDefaults_ = function() {
    this.message = false;
    this.response = false;
  };
  CheckNameCollision_WithNameCollision_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckNameCollision_WithNameCollision_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  CheckNameCollision_WithNameCollision_Params.encodedSize = codec.kStructHeaderSize + 8;

  CheckNameCollision_WithNameCollision_Params.decode = function(decoder) {
    var packed;
    var val = new CheckNameCollision_WithNameCollision_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.message = (packed >> 0) & 1 ? true : false;
    val.response = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  CheckNameCollision_WithNameCollision_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckNameCollision_WithNameCollision_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.message & 1) << 0
    packed |= (val.response & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function CheckNameCollision_WithNameCollision_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckNameCollision_WithNameCollision_ResponseParams.prototype.initDefaults_ = function() {
    this.message = false;
    this.response = false;
  };
  CheckNameCollision_WithNameCollision_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckNameCollision_WithNameCollision_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  CheckNameCollision_WithNameCollision_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  CheckNameCollision_WithNameCollision_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new CheckNameCollision_WithNameCollision_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.message = (packed >> 0) & 1 ? true : false;
    val.response = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  CheckNameCollision_WithNameCollision_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckNameCollision_WithNameCollision_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.message & 1) << 0
    packed |= (val.response & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function HandlesNameCollisionInterface_Method_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  HandlesNameCollisionInterface_Method_Params.prototype.initDefaults_ = function() {
    this.handles = null;
  };
  HandlesNameCollisionInterface_Method_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  HandlesNameCollisionInterface_Method_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate HandlesNameCollisionInterface_Method_Params.handles
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, EmptyStruct, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  HandlesNameCollisionInterface_Method_Params.encodedSize = codec.kStructHeaderSize + 8;

  HandlesNameCollisionInterface_Method_Params.decode = function(decoder) {
    var packed;
    var val = new HandlesNameCollisionInterface_Method_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.handles =
        decoder.decodeStructPointer(EmptyStruct);
    return val;
  };

  HandlesNameCollisionInterface_Method_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(HandlesNameCollisionInterface_Method_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(EmptyStruct, val.handles);
  };
  function HandlesNameCollisionInterface_Method_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  HandlesNameCollisionInterface_Method_ResponseParams.prototype.initDefaults_ = function() {
    this.handles = null;
  };
  HandlesNameCollisionInterface_Method_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  HandlesNameCollisionInterface_Method_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate HandlesNameCollisionInterface_Method_ResponseParams.handles
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  HandlesNameCollisionInterface_Method_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  HandlesNameCollisionInterface_Method_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new HandlesNameCollisionInterface_Method_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.handles =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  HandlesNameCollisionInterface_Method_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(HandlesNameCollisionInterface_Method_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Handle, val.handles);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function HandlesNameCollisionUnion(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  HandlesNameCollisionUnion.Tags = {
    handles: 0,
  };

  HandlesNameCollisionUnion.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  HandlesNameCollisionUnion.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "handles",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a HandlesNameCollisionUnion member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(HandlesNameCollisionUnion.prototype, "handles", {
    get: function() {
      if (this.$tag != HandlesNameCollisionUnion.Tags.handles) {
        throw new ReferenceError(
            "HandlesNameCollisionUnion.handles is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = HandlesNameCollisionUnion.Tags.handles;
      this.$data = value;
    }
  });


    HandlesNameCollisionUnion.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case HandlesNameCollisionUnion.Tags.handles:
          encoder.encodeStruct(codec.Int32, val.handles);
          break;
      }
      encoder.align();
    };


    HandlesNameCollisionUnion.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new HandlesNameCollisionUnion();
      var tag = decoder.readUint32();
      switch (tag) {
        case HandlesNameCollisionUnion.Tags.handles:
          result.handles = decoder.decodeStruct(codec.Int32);
          break;
      }
      decoder.align();

      return result;
    };


    HandlesNameCollisionUnion.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case HandlesNameCollisionUnion.Tags.handles:
          

          break;
      }

      return validator.validationError.NONE;
    };

  HandlesNameCollisionUnion.encodedSize = 16;
  var kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name = 0;
  var kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name = 1;

  function CheckMethodWithEmptyResponsePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(CheckMethodWithEmptyResponse,
                                                   handleOrPtrInfo);
  }

  function CheckMethodWithEmptyResponseAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        CheckMethodWithEmptyResponse, associatedInterfacePtrInfo);
  }

  CheckMethodWithEmptyResponseAssociatedPtr.prototype =
      Object.create(CheckMethodWithEmptyResponsePtr.prototype);
  CheckMethodWithEmptyResponseAssociatedPtr.prototype.constructor =
      CheckMethodWithEmptyResponseAssociatedPtr;

  function CheckMethodWithEmptyResponseProxy(receiver) {
    this.receiver_ = receiver;
  }
  CheckMethodWithEmptyResponsePtr.prototype.withouParameterAndEmptyResponse = function() {
    return CheckMethodWithEmptyResponseProxy.prototype.withouParameterAndEmptyResponse
        .apply(this.ptr.getProxy(), arguments);
  };

  CheckMethodWithEmptyResponseProxy.prototype.withouParameterAndEmptyResponse = function() {
    var params_ = new CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name,
          codec.align(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  CheckMethodWithEmptyResponsePtr.prototype.withParameterAndEmptyResponse = function() {
    return CheckMethodWithEmptyResponseProxy.prototype.withParameterAndEmptyResponse
        .apply(this.ptr.getProxy(), arguments);
  };

  CheckMethodWithEmptyResponseProxy.prototype.withParameterAndEmptyResponse = function(b) {
    var params_ = new CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params();
    params_.b = b;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name,
          codec.align(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function CheckMethodWithEmptyResponseStub(delegate) {
    this.delegate_ = delegate;
  }
  CheckMethodWithEmptyResponseStub.prototype.withouParameterAndEmptyResponse = function() {
    return this.delegate_ && this.delegate_.withouParameterAndEmptyResponse && this.delegate_.withouParameterAndEmptyResponse();
  }
  CheckMethodWithEmptyResponseStub.prototype.withParameterAndEmptyResponse = function(b) {
    return this.delegate_ && this.delegate_.withParameterAndEmptyResponse && this.delegate_.withParameterAndEmptyResponse(b);
  }

  CheckMethodWithEmptyResponseStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  CheckMethodWithEmptyResponseStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name:
      var params = reader.decodeStruct(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params);
      this.withouParameterAndEmptyResponse().then(function(response) {
        var responseParams =
            new CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name,
            codec.align(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name:
      var params = reader.decodeStruct(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params);
      this.withParameterAndEmptyResponse(params.b).then(function(response) {
        var responseParams =
            new CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name,
            codec.align(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateCheckMethodWithEmptyResponseRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name:
        if (message.expectsResponse())
          paramsClass = CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params;
      break;
      case kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name:
        if (message.expectsResponse())
          paramsClass = CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateCheckMethodWithEmptyResponseResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name:
        if (message.isResponse())
          paramsClass = CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams;
        break;
      case kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name:
        if (message.isResponse())
          paramsClass = CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var CheckMethodWithEmptyResponse = {
    name: 'regression_tests.CheckMethodWithEmptyResponse',
    kVersion: 0,
    ptrClass: CheckMethodWithEmptyResponsePtr,
    proxyClass: CheckMethodWithEmptyResponseProxy,
    stubClass: CheckMethodWithEmptyResponseStub,
    validateRequest: validateCheckMethodWithEmptyResponseRequest,
    validateResponse: validateCheckMethodWithEmptyResponseResponse,
  };
  CheckMethodWithEmptyResponseStub.prototype.validator = validateCheckMethodWithEmptyResponseRequest;
  CheckMethodWithEmptyResponseProxy.prototype.validator = validateCheckMethodWithEmptyResponseResponse;
  var kCheckNameCollision_WithNameCollision_Name = 0;

  function CheckNameCollisionPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(CheckNameCollision,
                                                   handleOrPtrInfo);
  }

  function CheckNameCollisionAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        CheckNameCollision, associatedInterfacePtrInfo);
  }

  CheckNameCollisionAssociatedPtr.prototype =
      Object.create(CheckNameCollisionPtr.prototype);
  CheckNameCollisionAssociatedPtr.prototype.constructor =
      CheckNameCollisionAssociatedPtr;

  function CheckNameCollisionProxy(receiver) {
    this.receiver_ = receiver;
  }
  CheckNameCollisionPtr.prototype.withNameCollision = function() {
    return CheckNameCollisionProxy.prototype.withNameCollision
        .apply(this.ptr.getProxy(), arguments);
  };

  CheckNameCollisionProxy.prototype.withNameCollision = function(message, response) {
    var params_ = new CheckNameCollision_WithNameCollision_Params();
    params_.message = message;
    params_.response = response;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kCheckNameCollision_WithNameCollision_Name,
          codec.align(CheckNameCollision_WithNameCollision_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(CheckNameCollision_WithNameCollision_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(CheckNameCollision_WithNameCollision_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function CheckNameCollisionStub(delegate) {
    this.delegate_ = delegate;
  }
  CheckNameCollisionStub.prototype.withNameCollision = function(message, response) {
    return this.delegate_ && this.delegate_.withNameCollision && this.delegate_.withNameCollision(message, response);
  }

  CheckNameCollisionStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  CheckNameCollisionStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kCheckNameCollision_WithNameCollision_Name:
      var params = reader.decodeStruct(CheckNameCollision_WithNameCollision_Params);
      this.withNameCollision(params.message, params.response).then(function(response) {
        var responseParams =
            new CheckNameCollision_WithNameCollision_ResponseParams();
        responseParams.message = response.message;
        responseParams.response = response.response;
        var builder = new codec.MessageV1Builder(
            kCheckNameCollision_WithNameCollision_Name,
            codec.align(CheckNameCollision_WithNameCollision_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(CheckNameCollision_WithNameCollision_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateCheckNameCollisionRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kCheckNameCollision_WithNameCollision_Name:
        if (message.expectsResponse())
          paramsClass = CheckNameCollision_WithNameCollision_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateCheckNameCollisionResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kCheckNameCollision_WithNameCollision_Name:
        if (message.isResponse())
          paramsClass = CheckNameCollision_WithNameCollision_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var CheckNameCollision = {
    name: 'regression_tests.CheckNameCollision',
    kVersion: 0,
    ptrClass: CheckNameCollisionPtr,
    proxyClass: CheckNameCollisionProxy,
    stubClass: CheckNameCollisionStub,
    validateRequest: validateCheckNameCollisionRequest,
    validateResponse: validateCheckNameCollisionResponse,
  };
  CheckNameCollisionStub.prototype.validator = validateCheckNameCollisionRequest;
  CheckNameCollisionProxy.prototype.validator = validateCheckNameCollisionResponse;
  var kHandlesNameCollisionInterface_Method_Name = 0;

  function HandlesNameCollisionInterfacePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(HandlesNameCollisionInterface,
                                                   handleOrPtrInfo);
  }

  function HandlesNameCollisionInterfaceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        HandlesNameCollisionInterface, associatedInterfacePtrInfo);
  }

  HandlesNameCollisionInterfaceAssociatedPtr.prototype =
      Object.create(HandlesNameCollisionInterfacePtr.prototype);
  HandlesNameCollisionInterfaceAssociatedPtr.prototype.constructor =
      HandlesNameCollisionInterfaceAssociatedPtr;

  function HandlesNameCollisionInterfaceProxy(receiver) {
    this.receiver_ = receiver;
  }
  HandlesNameCollisionInterfacePtr.prototype.method = function() {
    return HandlesNameCollisionInterfaceProxy.prototype.method
        .apply(this.ptr.getProxy(), arguments);
  };

  HandlesNameCollisionInterfaceProxy.prototype.method = function(handles) {
    var params_ = new HandlesNameCollisionInterface_Method_Params();
    params_.handles = handles;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kHandlesNameCollisionInterface_Method_Name,
          codec.align(HandlesNameCollisionInterface_Method_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(HandlesNameCollisionInterface_Method_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(HandlesNameCollisionInterface_Method_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function HandlesNameCollisionInterfaceStub(delegate) {
    this.delegate_ = delegate;
  }
  HandlesNameCollisionInterfaceStub.prototype.method = function(handles) {
    return this.delegate_ && this.delegate_.method && this.delegate_.method(handles);
  }

  HandlesNameCollisionInterfaceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  HandlesNameCollisionInterfaceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kHandlesNameCollisionInterface_Method_Name:
      var params = reader.decodeStruct(HandlesNameCollisionInterface_Method_Params);
      this.method(params.handles).then(function(response) {
        var responseParams =
            new HandlesNameCollisionInterface_Method_ResponseParams();
        responseParams.handles = response.handles;
        var builder = new codec.MessageV1Builder(
            kHandlesNameCollisionInterface_Method_Name,
            codec.align(HandlesNameCollisionInterface_Method_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(HandlesNameCollisionInterface_Method_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateHandlesNameCollisionInterfaceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kHandlesNameCollisionInterface_Method_Name:
        if (message.expectsResponse())
          paramsClass = HandlesNameCollisionInterface_Method_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateHandlesNameCollisionInterfaceResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kHandlesNameCollisionInterface_Method_Name:
        if (message.isResponse())
          paramsClass = HandlesNameCollisionInterface_Method_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var HandlesNameCollisionInterface = {
    name: 'regression_tests.HandlesNameCollisionInterface',
    kVersion: 0,
    ptrClass: HandlesNameCollisionInterfacePtr,
    proxyClass: HandlesNameCollisionInterfaceProxy,
    stubClass: HandlesNameCollisionInterfaceStub,
    validateRequest: validateHandlesNameCollisionInterfaceRequest,
    validateResponse: validateHandlesNameCollisionInterfaceResponse,
  };
  HandlesNameCollisionInterfaceStub.prototype.validator = validateHandlesNameCollisionInterfaceRequest;
  HandlesNameCollisionInterfaceProxy.prototype.validator = validateHandlesNameCollisionInterfaceResponse;
  exports.EnumWithReference = EnumWithReference;
  exports.EnumWithLowercase = EnumWithLowercase;
  exports.EnumWithNumbers = EnumWithNumbers;
  exports.EnumWithK = EnumWithK;
  exports.Edge = Edge;
  exports.Vertex = Vertex;
  exports.EmptyStruct = EmptyStruct;
  exports.A = A;
  exports.B = B;
  exports.HandlesNameCollisionStruct = HandlesNameCollisionStruct;
  exports.HandlesHandleNameCollisionStruct = HandlesHandleNameCollisionStruct;
  exports.HandlesUnionNameCollisionStruct = HandlesUnionNameCollisionStruct;
  exports.HandlesNameCollisionUnion = HandlesNameCollisionUnion;
  exports.CheckMethodWithEmptyResponse = CheckMethodWithEmptyResponse;
  exports.CheckMethodWithEmptyResponsePtr = CheckMethodWithEmptyResponsePtr;
  exports.CheckMethodWithEmptyResponseAssociatedPtr = CheckMethodWithEmptyResponseAssociatedPtr;
  exports.CheckNameCollision = CheckNameCollision;
  exports.CheckNameCollisionPtr = CheckNameCollisionPtr;
  exports.CheckNameCollisionAssociatedPtr = CheckNameCollisionAssociatedPtr;
  exports.HandlesNameCollisionInterface = HandlesNameCollisionInterface;
  exports.HandlesNameCollisionInterfacePtr = HandlesNameCollisionInterfacePtr;
  exports.HandlesNameCollisionInterfaceAssociatedPtr = HandlesNameCollisionInterfaceAssociatedPtr;
})();