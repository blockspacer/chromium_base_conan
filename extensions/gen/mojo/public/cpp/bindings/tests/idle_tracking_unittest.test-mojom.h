// mojo/public/cpp/bindings/tests/idle_tracking_unittest.test-mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MOJO_PUBLIC_CPP_BINDINGS_TESTS_IDLE_TRACKING_UNITTEST_TEST_MOJOM_H_
#define MOJO_PUBLIC_CPP_BINDINGS_TESTS_IDLE_TRACKING_UNITTEST_TEST_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
#include "mojo/public/cpp/bindings/tests/idle_tracking_unittest.test-mojom-shared.h"
#include "mojo/public/cpp/bindings/tests/idle_tracking_unittest.test-mojom-forward.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"



#ifdef KYTHE_IS_RUNNING
#pragma kythe_inline_metadata "Metadata comment"
#endif


namespace mojo {
namespace test {
namespace idle_tracking_unittest {
namespace mojom {

class TestServiceProxy;

template <typename ImplRefTraits>
class TestServiceStub;

class TestServiceRequestValidator;
class TestServiceResponseValidator;


// @generated_from: mojo.test.idle_tracking_unittest.mojom.TestService
class  TestService
    : public TestServiceInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = TestServiceInterfaceBase;
  using Proxy_ = TestServiceProxy;

  template <typename ImplRefTraits>
  using Stub_ = TestServiceStub<ImplRefTraits>;

  using RequestValidator_ = TestServiceRequestValidator;
  using ResponseValidator_ = TestServiceResponseValidator;
  enum MethodMinVersions : uint32_t {
    kPingMinVersion = 0,
    kPingPongMinVersion = 0,
    kBindKeepAliveMinVersion = 0,
  };
  virtual ~TestService() {}

  
// @generated_from: mojo.test.idle_tracking_unittest.mojom.TestService.Ping
  virtual void Ping() = 0;


  using PingPongCallback = base::OnceCallback<void()>;
  
// @generated_from: mojo.test.idle_tracking_unittest.mojom.TestService.PingPong
  virtual void PingPong(PingPongCallback callback) = 0;

  
// @generated_from: mojo.test.idle_tracking_unittest.mojom.TestService.BindKeepAlive
  virtual void BindKeepAlive(::mojo::PendingReceiver<KeepAlive> receiver) = 0;
};

class KeepAliveProxy;

template <typename ImplRefTraits>
class KeepAliveStub;

class KeepAliveRequestValidator;


// @generated_from: mojo.test.idle_tracking_unittest.mojom.KeepAlive
class  KeepAlive
    : public KeepAliveInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = KeepAliveInterfaceBase;
  using Proxy_ = KeepAliveProxy;

  template <typename ImplRefTraits>
  using Stub_ = KeepAliveStub<ImplRefTraits>;

  using RequestValidator_ = KeepAliveRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
  };
  virtual ~KeepAlive() {}
};



// @generated_from: mojo.test.idle_tracking_unittest.mojom.TestService
class  TestServiceProxy
    : public TestService {
 public:
  using InterfaceType = TestService;

  explicit TestServiceProxy(mojo::MessageReceiverWithResponder* receiver);
  
// @generated_from: mojo.test.idle_tracking_unittest.mojom.TestService.Ping
  void Ping() final;
  
// @generated_from: mojo.test.idle_tracking_unittest.mojom.TestService.PingPong
  void PingPong(PingPongCallback callback) final;
  
// @generated_from: mojo.test.idle_tracking_unittest.mojom.TestService.BindKeepAlive
  void BindKeepAlive(::mojo::PendingReceiver<KeepAlive> receiver) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



// @generated_from: mojo.test.idle_tracking_unittest.mojom.KeepAlive
class  KeepAliveProxy
    : public KeepAlive {
 public:
  using InterfaceType = KeepAlive;

  explicit KeepAliveProxy(mojo::MessageReceiverWithResponder* receiver);

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  TestServiceStubDispatch {
 public:
  static bool Accept(TestService* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      TestService* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<TestService>>
class TestServiceStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  TestServiceStub() {}
  ~TestServiceStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TestServiceStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TestServiceStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  KeepAliveStubDispatch {
 public:
  static bool Accept(KeepAlive* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      KeepAlive* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<KeepAlive>>
class KeepAliveStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  KeepAliveStub() {}
  ~KeepAliveStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return KeepAliveStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return KeepAliveStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  TestServiceRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  KeepAliveRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  TestServiceResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};





}  // namespace mojom
}  // namespace idle_tracking_unittest
}  // namespace test
}  // namespace mojo

namespace mojo {

}  // namespace mojo

#endif  // MOJO_PUBLIC_CPP_BINDINGS_TESTS_IDLE_TRACKING_UNITTEST_TEST_MOJOM_H_

/* Metadata comment
eyJtZXRhIjogW3siZW5kIjogMjAwMiwgImJlZ2luIjogMTk5MSwgImVkZ2UiOiAiJS9reXRoZS9l
ZGdlL2dlbmVyYXRlcyIsICJ0eXBlIjogImFuY2hvcl9kZWZpbmVzIiwgInZuYW1lIjogeyJjb3Jw
dXMiOiAiY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMiLCAibGFuZ3VhZ2Ui
OiAibW9qb20iLCAic2lnbmF0dXJlIjogIm1vam8udGVzdC5pZGxlX3RyYWNraW5nX3VuaXR0ZXN0
Lm1vam9tLlRlc3RTZXJ2aWNlIn19LCB7ImVuZCI6IDI3NjYsICJiZWdpbiI6IDI3NjIsICJlZGdl
IjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2
bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3Jj
IiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuaWRsZV90cmFj
a2luZ191bml0dGVzdC5tb2pvbS5UZXN0U2VydmljZS5QaW5nIn19LCB7ImVuZCI6IDI5MzcsICJi
ZWdpbiI6IDI5MjksICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6ICJh
bmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNvdXJj
ZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6ICJt
b2pvLnRlc3QuaWRsZV90cmFja2luZ191bml0dGVzdC5tb2pvbS5UZXN0U2VydmljZS5QaW5nUG9u
ZyJ9fSwgeyJlbmQiOiAzMDg3LCAiYmVnaW4iOiAzMDc0LCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2Uv
Z2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6
ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJt
b2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LmlkbGVfdHJhY2tpbmdfdW5pdHRlc3QubW9q
b20uVGVzdFNlcnZpY2UuQmluZEtlZXBBbGl2ZSJ9fSwgeyJlbmQiOiAzMzQxLCAiYmVnaW4iOiAz
MzMyLCAiZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2Rl
ZmluZXMiLCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2No
cm9taXVtL3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0
LmlkbGVfdHJhY2tpbmdfdW5pdHRlc3QubW9qb20uS2VlcEFsaXZlIn19LCB7ImVuZCI6IDQyNDEs
ICJiZWdpbiI6IDQyMzcsICJlZGdlIjogIiUva3l0aGUvZWRnZS9nZW5lcmF0ZXMiLCAidHlwZSI6
ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjogImNocm9taXVtLmdvb2dsZXNv
dXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1vam9tIiwgInNpZ25hdHVyZSI6
ICJtb2pvLnRlc3QuaWRsZV90cmFja2luZ191bml0dGVzdC5tb2pvbS5UZXN0U2VydmljZS5QaW5n
In19LCB7ImVuZCI6IDQzNDksICJiZWdpbiI6IDQzNDEsICJlZGdlIjogIiUva3l0aGUvZWRnZS9n
ZW5lcmF0ZXMiLCAidHlwZSI6ICJhbmNob3JfZGVmaW5lcyIsICJ2bmFtZSI6IHsiY29ycHVzIjog
ImNocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjIiwgImxhbmd1YWdlIjogIm1v
am9tIiwgInNpZ25hdHVyZSI6ICJtb2pvLnRlc3QuaWRsZV90cmFja2luZ191bml0dGVzdC5tb2pv
bS5UZXN0U2VydmljZS5QaW5nUG9uZyJ9fSwgeyJlbmQiOiA0NDkyLCAiYmVnaW4iOiA0NDc5LCAi
ZWRnZSI6ICIlL2t5dGhlL2VkZ2UvZ2VuZXJhdGVzIiwgInR5cGUiOiAiYW5jaG9yX2RlZmluZXMi
LCAidm5hbWUiOiB7ImNvcnB1cyI6ICJjaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVt
L3NyYyIsICJsYW5ndWFnZSI6ICJtb2pvbSIsICJzaWduYXR1cmUiOiAibW9qby50ZXN0LmlkbGVf
dHJhY2tpbmdfdW5pdHRlc3QubW9qb20uVGVzdFNlcnZpY2UuQmluZEtlZXBBbGl2ZSJ9fV0sICJ0
eXBlIjogImt5dGhlMCJ9
*/