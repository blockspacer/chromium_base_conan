// ipc/ipc_test.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "ipc/ipc_test.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/common/task_annotator.h"
#include "base/trace_event/trace_event.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "ipc/ipc_test.mojom-params-data.h"
#include "ipc/ipc_test.mojom-shared-message-ids.h"

#include "ipc/ipc_test.mojom-import-headers.h"


#ifndef IPC_IPC_TEST_MOJOM_JUMBO_H_
#define IPC_IPC_TEST_MOJOM_JUMBO_H_
#endif
namespace IPC {
namespace mojom {
TestStruct::TestStruct() {}

TestStruct::~TestStruct() = default;
size_t TestStruct::Hash(size_t seed) const {
  return seed;
}

void TestStruct::WriteIntoTracedValue(perfetto::TracedValue context) const {
  auto dict = std::move(context).WriteDictionary();
}

bool TestStruct::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char SimpleTestDriver::Name_[] = "IPC.mojom.SimpleTestDriver";
bool SimpleTestDriver::GetExpectedValue(int32_t* out_value) {
  NOTREACHED();
  return false;
}
bool SimpleTestDriver::RequestValue(int32_t* out_value) {
  NOTREACHED();
  return false;
}
class SimpleTestDriver_GetExpectedValue_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  SimpleTestDriver_GetExpectedValue_HandleSyncResponse(
      bool* result, int32_t* out_value)
      : result_(result), out_value_(out_value) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  int32_t* out_value_;DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_GetExpectedValue_HandleSyncResponse);
};

class SimpleTestDriver_GetExpectedValue_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleTestDriver_GetExpectedValue_ForwardToCallback(
      SimpleTestDriver::GetExpectedValueCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  SimpleTestDriver::GetExpectedValueCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_GetExpectedValue_ForwardToCallback);
};
class SimpleTestDriver_RequestValue_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  SimpleTestDriver_RequestValue_HandleSyncResponse(
      bool* result, int32_t* out_value)
      : result_(result), out_value_(out_value) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  int32_t* out_value_;DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_RequestValue_HandleSyncResponse);
};

class SimpleTestDriver_RequestValue_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleTestDriver_RequestValue_ForwardToCallback(
      SimpleTestDriver::RequestValueCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  SimpleTestDriver::RequestValueCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_RequestValue_ForwardToCallback);
};

class SimpleTestDriver_RequestQuit_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleTestDriver_RequestQuit_ForwardToCallback(
      SimpleTestDriver::RequestQuitCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  SimpleTestDriver::RequestQuitCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_RequestQuit_ForwardToCallback);
};

SimpleTestDriverProxy::SimpleTestDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class SimpleTestDriverProxy_ExpectValue_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestDriverProxy_ExpectValue_Message(
      uint32_t message_flags
      , int32_t param_value
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestDriver_ExpectValue_Name,
          message_flags)
      , param_value_(std::move(param_value)){}
  ~SimpleTestDriverProxy_ExpectValue_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      int32_t param_value) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestDriverProxy_ExpectValue_Message>(
          kFlags
          , std::move(param_value)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestDriver_ExpectValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestDriver_ExpectValue_Params_Data> params(
          message);
  params.Allocate();
  params->value = param_value;
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      SimpleTestDriver* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->ExpectValue(
        std::move(param_value_));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestDriver_ExpectValue_Params_Data> params(
            message);
    params.Allocate();
  params->value = param_value_;
  }
  int32_t param_value_;

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriverProxy_ExpectValue_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestDriverProxy_ExpectValue_Message::kMessageTag = {};

void SimpleTestDriverProxy::ExpectValue(
    int32_t in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "IPC::mojom::SimpleTestDriver::ExpectValue", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value, 
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = SimpleTestDriverProxy_ExpectValue_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_value));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("ExpectValue");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class SimpleTestDriverProxy_GetExpectedValue_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestDriverProxy_GetExpectedValue_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestDriver_GetExpectedValue_Name,
          message_flags){}
  ~SimpleTestDriverProxy_GetExpectedValue_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestDriverProxy_GetExpectedValue_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestDriver_GetExpectedValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestDriver_GetExpectedValue_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      SimpleTestDriver* impl, SimpleTestDriver::GetExpectedValueCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->GetExpectedValue(std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestDriver_GetExpectedValue_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriverProxy_GetExpectedValue_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestDriverProxy_GetExpectedValue_Message::kMessageTag = {};
bool SimpleTestDriverProxy::GetExpectedValue(
    int32_t* out_param_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "IPC::mojom::SimpleTestDriver::GetExpectedValue");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = SimpleTestDriverProxy_GetExpectedValue_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("GetExpectedValue");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleTestDriver_GetExpectedValue_HandleSyncResponse(
          &result, out_param_value));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "IPC::mojom::SimpleTestDriver::GetExpectedValue", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), out_param_value, 
                        "<value of type int32_t>");
   });
#endif
  return result;
}

void SimpleTestDriverProxy::GetExpectedValue(
    GetExpectedValueCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "IPC::mojom::SimpleTestDriver::GetExpectedValue");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = SimpleTestDriverProxy_GetExpectedValue_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("GetExpectedValue");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleTestDriver_GetExpectedValue_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class SimpleTestDriverProxy_RequestValue_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestDriverProxy_RequestValue_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestDriver_RequestValue_Name,
          message_flags){}
  ~SimpleTestDriverProxy_RequestValue_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestDriverProxy_RequestValue_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestDriver_RequestValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestDriver_RequestValue_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      SimpleTestDriver* impl, SimpleTestDriver::RequestValueCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->RequestValue(std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestDriver_RequestValue_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriverProxy_RequestValue_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestDriverProxy_RequestValue_Message::kMessageTag = {};
bool SimpleTestDriverProxy::RequestValue(
    int32_t* out_param_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "IPC::mojom::SimpleTestDriver::RequestValue");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = SimpleTestDriverProxy_RequestValue_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("RequestValue");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleTestDriver_RequestValue_HandleSyncResponse(
          &result, out_param_value));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "IPC::mojom::SimpleTestDriver::RequestValue", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), out_param_value, 
                        "<value of type int32_t>");
   });
#endif
  return result;
}

void SimpleTestDriverProxy::RequestValue(
    RequestValueCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "IPC::mojom::SimpleTestDriver::RequestValue");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = SimpleTestDriverProxy_RequestValue_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("RequestValue");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleTestDriver_RequestValue_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class SimpleTestDriverProxy_RequestQuit_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestDriverProxy_RequestQuit_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestDriver_RequestQuit_Name,
          message_flags){}
  ~SimpleTestDriverProxy_RequestQuit_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestDriverProxy_RequestQuit_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestDriver_RequestQuit_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestDriver_RequestQuit_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      SimpleTestDriver* impl, SimpleTestDriver::RequestQuitCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->RequestQuit(std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestDriver_RequestQuit_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriverProxy_RequestQuit_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestDriverProxy_RequestQuit_Message::kMessageTag = {};

void SimpleTestDriverProxy::RequestQuit(
    RequestQuitCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "IPC::mojom::SimpleTestDriver::RequestQuit");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = SimpleTestDriverProxy_RequestQuit_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("RequestQuit");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleTestDriver_RequestQuit_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class SimpleTestDriver_GetExpectedValue_ProxyToResponder {
 public:
  static SimpleTestDriver::GetExpectedValueCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<SimpleTestDriver_GetExpectedValue_ProxyToResponder> proxy(
        new SimpleTestDriver_GetExpectedValue_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&SimpleTestDriver_GetExpectedValue_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleTestDriver_GetExpectedValue_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  SimpleTestDriver_GetExpectedValue_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleTestDriver::GetExpectedValueCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_value);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_GetExpectedValue_ProxyToResponder);
};
class SimpleTestDriver_GetExpectedValue_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestDriver_GetExpectedValue_Response_Message(
      uint32_t message_flags
      , int32_t param_value
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestDriver_GetExpectedValue_Name,
          message_flags)
      , param_value_(std::move(param_value)){}
  ~SimpleTestDriver_GetExpectedValue_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      int32_t param_value) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestDriver_GetExpectedValue_Response_Message>(
          kFlags
          , std::move(param_value)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestDriver_GetExpectedValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestDriver_GetExpectedValue_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->value = param_value;
    return message;
  }


  void Dispatch(mojo::Message* message,
                SimpleTestDriver::GetExpectedValueCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_value_));
  }


  void HandleSyncResponse(
      mojo::Message* message
,
      int32_t* out_value) {

    if (message->receiver_connection_group()) {
    }


    *out_value = std::move(param_value_);

  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestDriver_GetExpectedValue_ResponseParams_Data> params(
            message);
    params.Allocate();
  params->value = param_value_;
  }
  int32_t param_value_;

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_GetExpectedValue_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestDriver_GetExpectedValue_Response_Message::kMessageTag = {};

bool SimpleTestDriver_GetExpectedValue_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::SimpleTestDriver::GetExpectedValueCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<SimpleTestDriver_GetExpectedValue_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::SimpleTestDriver_GetExpectedValue_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleTestDriver_GetExpectedValue_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_value{};
  SimpleTestDriver_GetExpectedValue_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_value = input_data_view.value();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleTestDriver::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_value));
  return true;
}

void SimpleTestDriver_GetExpectedValue_ProxyToResponder::Run(
    int32_t in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)IPC::mojom::SimpleTestDriver::GetExpectedValueCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value, 
                        "<value of type int32_t>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = SimpleTestDriver_GetExpectedValue_Response_Message::Build(kSerialize, is_sync_, std::move(in_value));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::SimpleTestDriver::GetExpectedValueCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("GetExpectedValue");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool SimpleTestDriver_GetExpectedValue_HandleSyncResponse::Accept(
    mojo::Message* message) {
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<SimpleTestDriver_GetExpectedValue_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was built using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      context->HandleSyncResponse(
          message,
          out_value_);
      *result_ = true;
      mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
          message);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::SimpleTestDriver_GetExpectedValue_ResponseParams_Data* params =
      reinterpret_cast<internal::SimpleTestDriver_GetExpectedValue_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  int32_t p_value{};
  SimpleTestDriver_GetExpectedValue_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_value = input_data_view.value();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleTestDriver::Name_, 1, true);
    return false;
  }
  *out_value_ = std::move(p_value);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}
class SimpleTestDriver_RequestValue_ProxyToResponder {
 public:
  static SimpleTestDriver::RequestValueCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<SimpleTestDriver_RequestValue_ProxyToResponder> proxy(
        new SimpleTestDriver_RequestValue_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&SimpleTestDriver_RequestValue_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleTestDriver_RequestValue_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  SimpleTestDriver_RequestValue_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleTestDriver::RequestValueCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_value);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_RequestValue_ProxyToResponder);
};
class SimpleTestDriver_RequestValue_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestDriver_RequestValue_Response_Message(
      uint32_t message_flags
      , int32_t param_value
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestDriver_RequestValue_Name,
          message_flags)
      , param_value_(std::move(param_value)){}
  ~SimpleTestDriver_RequestValue_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      int32_t param_value) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestDriver_RequestValue_Response_Message>(
          kFlags
          , std::move(param_value)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestDriver_RequestValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestDriver_RequestValue_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->value = param_value;
    return message;
  }


  void Dispatch(mojo::Message* message,
                SimpleTestDriver::RequestValueCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_value_));
  }


  void HandleSyncResponse(
      mojo::Message* message
,
      int32_t* out_value) {

    if (message->receiver_connection_group()) {
    }


    *out_value = std::move(param_value_);

  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestDriver_RequestValue_ResponseParams_Data> params(
            message);
    params.Allocate();
  params->value = param_value_;
  }
  int32_t param_value_;

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_RequestValue_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestDriver_RequestValue_Response_Message::kMessageTag = {};

bool SimpleTestDriver_RequestValue_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::SimpleTestDriver::RequestValueCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<SimpleTestDriver_RequestValue_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::SimpleTestDriver_RequestValue_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleTestDriver_RequestValue_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_value{};
  SimpleTestDriver_RequestValue_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_value = input_data_view.value();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleTestDriver::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_value));
  return true;
}

void SimpleTestDriver_RequestValue_ProxyToResponder::Run(
    int32_t in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)IPC::mojom::SimpleTestDriver::RequestValueCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value, 
                        "<value of type int32_t>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = SimpleTestDriver_RequestValue_Response_Message::Build(kSerialize, is_sync_, std::move(in_value));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::SimpleTestDriver::RequestValueCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("RequestValue");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool SimpleTestDriver_RequestValue_HandleSyncResponse::Accept(
    mojo::Message* message) {
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<SimpleTestDriver_RequestValue_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was built using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      context->HandleSyncResponse(
          message,
          out_value_);
      *result_ = true;
      mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
          message);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::SimpleTestDriver_RequestValue_ResponseParams_Data* params =
      reinterpret_cast<internal::SimpleTestDriver_RequestValue_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  int32_t p_value{};
  SimpleTestDriver_RequestValue_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_value = input_data_view.value();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleTestDriver::Name_, 2, true);
    return false;
  }
  *out_value_ = std::move(p_value);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}
class SimpleTestDriver_RequestQuit_ProxyToResponder {
 public:
  static SimpleTestDriver::RequestQuitCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<SimpleTestDriver_RequestQuit_ProxyToResponder> proxy(
        new SimpleTestDriver_RequestQuit_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&SimpleTestDriver_RequestQuit_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleTestDriver_RequestQuit_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  SimpleTestDriver_RequestQuit_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleTestDriver::RequestQuitCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_RequestQuit_ProxyToResponder);
};
class SimpleTestDriver_RequestQuit_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestDriver_RequestQuit_Response_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestDriver_RequestQuit_Name,
          message_flags){}
  ~SimpleTestDriver_RequestQuit_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestDriver_RequestQuit_Response_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestDriver_RequestQuit_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestDriver_RequestQuit_ResponseParams_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(mojo::Message* message,
                SimpleTestDriver::RequestQuitCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run();
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestDriver_RequestQuit_ResponseParams_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(SimpleTestDriver_RequestQuit_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestDriver_RequestQuit_Response_Message::kMessageTag = {};

bool SimpleTestDriver_RequestQuit_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::SimpleTestDriver::RequestQuitCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<SimpleTestDriver_RequestQuit_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::SimpleTestDriver_RequestQuit_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleTestDriver_RequestQuit_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  SimpleTestDriver_RequestQuit_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleTestDriver::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void SimpleTestDriver_RequestQuit_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "(Impl)IPC::mojom::SimpleTestDriver::RequestQuitCallback");
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = SimpleTestDriver_RequestQuit_Response_Message::Build(kSerialize, is_sync_);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::SimpleTestDriver::RequestQuitCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestDriver::Name_);
  message.set_method_name("RequestQuit");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool SimpleTestDriverStubDispatch::Accept(
    SimpleTestDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSimpleTestDriver_ExpectValue_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::SimpleTestDriver::ExpectValue",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::SimpleTestDriver::ExpectValue");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            SimpleTestDriverProxy_ExpectValue_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::SimpleTestDriver_ExpectValue_Params_Data* params =
          reinterpret_cast<internal::SimpleTestDriver_ExpectValue_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_value{};
      SimpleTestDriver_ExpectValue_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_value = input_data_view.value();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleTestDriver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExpectValue(
std::move(p_value));
      return true;
    }
    case internal::kSimpleTestDriver_GetExpectedValue_Name: {
      break;
    }
    case internal::kSimpleTestDriver_RequestValue_Name: {
      break;
    }
    case internal::kSimpleTestDriver_RequestQuit_Name: {
      break;
    }
  }
  return false;
}

// static
bool SimpleTestDriverStubDispatch::AcceptWithResponder(
    SimpleTestDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kSimpleTestDriver_ExpectValue_Name: {
      break;
    }
    case internal::kSimpleTestDriver_GetExpectedValue_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::SimpleTestDriver::GetExpectedValue",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::SimpleTestDriver::GetExpectedValue");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            SimpleTestDriverProxy_GetExpectedValue_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          SimpleTestDriver::GetExpectedValueCallback callback =
              SimpleTestDriver_GetExpectedValue_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::SimpleTestDriver_GetExpectedValue_Params_Data* params =
          reinterpret_cast<
              internal::SimpleTestDriver_GetExpectedValue_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SimpleTestDriver_GetExpectedValue_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleTestDriver::Name_, 1, false);
        return false;
      }
      SimpleTestDriver::GetExpectedValueCallback callback =
          SimpleTestDriver_GetExpectedValue_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetExpectedValue(std::move(callback));
      return true;
    }
    case internal::kSimpleTestDriver_RequestValue_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::SimpleTestDriver::RequestValue",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::SimpleTestDriver::RequestValue");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            SimpleTestDriverProxy_RequestValue_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          SimpleTestDriver::RequestValueCallback callback =
              SimpleTestDriver_RequestValue_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::SimpleTestDriver_RequestValue_Params_Data* params =
          reinterpret_cast<
              internal::SimpleTestDriver_RequestValue_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SimpleTestDriver_RequestValue_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleTestDriver::Name_, 2, false);
        return false;
      }
      SimpleTestDriver::RequestValueCallback callback =
          SimpleTestDriver_RequestValue_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestValue(std::move(callback));
      return true;
    }
    case internal::kSimpleTestDriver_RequestQuit_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::SimpleTestDriver::RequestQuit",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::SimpleTestDriver::RequestQuit");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            SimpleTestDriverProxy_RequestQuit_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          SimpleTestDriver::RequestQuitCallback callback =
              SimpleTestDriver_RequestQuit_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::SimpleTestDriver_RequestQuit_Params_Data* params =
          reinterpret_cast<
              internal::SimpleTestDriver_RequestQuit_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SimpleTestDriver_RequestQuit_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleTestDriver::Name_, 3, false);
        return false;
      }
      SimpleTestDriver::RequestQuitCallback callback =
          SimpleTestDriver_RequestQuit_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestQuit(std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kSimpleTestDriverValidationInfo[] = {
    {internal::kSimpleTestDriver_ExpectValue_Name,
     {&internal::SimpleTestDriver_ExpectValue_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kSimpleTestDriver_GetExpectedValue_Name,
     {&internal::SimpleTestDriver_GetExpectedValue_Params_Data::Validate,
      &internal::SimpleTestDriver_GetExpectedValue_ResponseParams_Data::Validate}},
    {internal::kSimpleTestDriver_RequestValue_Name,
     {&internal::SimpleTestDriver_RequestValue_Params_Data::Validate,
      &internal::SimpleTestDriver_RequestValue_ResponseParams_Data::Validate}},
    {internal::kSimpleTestDriver_RequestQuit_Name,
     {&internal::SimpleTestDriver_RequestQuit_Params_Data::Validate,
      &internal::SimpleTestDriver_RequestQuit_ResponseParams_Data::Validate}},
};

bool SimpleTestDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::SimpleTestDriver::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kSimpleTestDriverValidationInfo);
}

bool SimpleTestDriverResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::SimpleTestDriver::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kSimpleTestDriverValidationInfo);

}
const char SimpleTestClient::Name_[] = "IPC.mojom.SimpleTestClient";
bool SimpleTestClient::RequestValue(int32_t* out_value) {
  NOTREACHED();
  return false;
}
class SimpleTestClient_RequestValue_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  SimpleTestClient_RequestValue_HandleSyncResponse(
      bool* result, int32_t* out_value)
      : result_(result), out_value_(out_value) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  int32_t* out_value_;DISALLOW_COPY_AND_ASSIGN(SimpleTestClient_RequestValue_HandleSyncResponse);
};

class SimpleTestClient_RequestValue_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleTestClient_RequestValue_ForwardToCallback(
      SimpleTestClient::RequestValueCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  SimpleTestClient::RequestValueCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(SimpleTestClient_RequestValue_ForwardToCallback);
};

SimpleTestClientProxy::SimpleTestClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class SimpleTestClientProxy_RequestValue_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestClientProxy_RequestValue_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestClient_RequestValue_Name,
          message_flags){}
  ~SimpleTestClientProxy_RequestValue_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestClientProxy_RequestValue_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestClient_RequestValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestClient_RequestValue_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      SimpleTestClient* impl, SimpleTestClient::RequestValueCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->RequestValue(std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestClient_RequestValue_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(SimpleTestClientProxy_RequestValue_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestClientProxy_RequestValue_Message::kMessageTag = {};
bool SimpleTestClientProxy::RequestValue(
    int32_t* out_param_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "IPC::mojom::SimpleTestClient::RequestValue");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = SimpleTestClientProxy_RequestValue_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestClient::Name_);
  message.set_method_name("RequestValue");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleTestClient_RequestValue_HandleSyncResponse(
          &result, out_param_value));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "IPC::mojom::SimpleTestClient::RequestValue", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), out_param_value, 
                        "<value of type int32_t>");
   });
#endif
  return result;
}

void SimpleTestClientProxy::RequestValue(
    RequestValueCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "IPC::mojom::SimpleTestClient::RequestValue");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = SimpleTestClientProxy_RequestValue_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestClient::Name_);
  message.set_method_name("RequestValue");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleTestClient_RequestValue_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class SimpleTestClient_RequestValue_ProxyToResponder {
 public:
  static SimpleTestClient::RequestValueCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<SimpleTestClient_RequestValue_ProxyToResponder> proxy(
        new SimpleTestClient_RequestValue_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&SimpleTestClient_RequestValue_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleTestClient_RequestValue_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  SimpleTestClient_RequestValue_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleTestClient::RequestValueCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_value);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(SimpleTestClient_RequestValue_ProxyToResponder);
};
class SimpleTestClient_RequestValue_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit SimpleTestClient_RequestValue_Response_Message(
      uint32_t message_flags
      , int32_t param_value
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kSimpleTestClient_RequestValue_Name,
          message_flags)
      , param_value_(std::move(param_value)){}
  ~SimpleTestClient_RequestValue_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      int32_t param_value) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<SimpleTestClient_RequestValue_Response_Message>(
          kFlags
          , std::move(param_value)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kSimpleTestClient_RequestValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::SimpleTestClient_RequestValue_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->value = param_value;
    return message;
  }


  void Dispatch(mojo::Message* message,
                SimpleTestClient::RequestValueCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_value_));
  }


  void HandleSyncResponse(
      mojo::Message* message
,
      int32_t* out_value) {

    if (message->receiver_connection_group()) {
    }


    *out_value = std::move(param_value_);

  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::SimpleTestClient_RequestValue_ResponseParams_Data> params(
            message);
    params.Allocate();
  params->value = param_value_;
  }
  int32_t param_value_;

  DISALLOW_COPY_AND_ASSIGN(SimpleTestClient_RequestValue_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
SimpleTestClient_RequestValue_Response_Message::kMessageTag = {};

bool SimpleTestClient_RequestValue_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::SimpleTestClient::RequestValueCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<SimpleTestClient_RequestValue_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::SimpleTestClient_RequestValue_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleTestClient_RequestValue_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_value{};
  SimpleTestClient_RequestValue_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_value = input_data_view.value();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleTestClient::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_value));
  return true;
}

void SimpleTestClient_RequestValue_ProxyToResponder::Run(
    int32_t in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)IPC::mojom::SimpleTestClient::RequestValueCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value, 
                        "<value of type int32_t>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = SimpleTestClient_RequestValue_Response_Message::Build(kSerialize, is_sync_, std::move(in_value));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::SimpleTestClient::RequestValueCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleTestClient::Name_);
  message.set_method_name("RequestValue");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool SimpleTestClient_RequestValue_HandleSyncResponse::Accept(
    mojo::Message* message) {
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<SimpleTestClient_RequestValue_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was built using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      context->HandleSyncResponse(
          message,
          out_value_);
      *result_ = true;
      mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
          message);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::SimpleTestClient_RequestValue_ResponseParams_Data* params =
      reinterpret_cast<internal::SimpleTestClient_RequestValue_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  int32_t p_value{};
  SimpleTestClient_RequestValue_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_value = input_data_view.value();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleTestClient::Name_, 0, true);
    return false;
  }
  *out_value_ = std::move(p_value);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}

// static
bool SimpleTestClientStubDispatch::Accept(
    SimpleTestClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSimpleTestClient_RequestValue_Name: {
      break;
    }
  }
  return false;
}

// static
bool SimpleTestClientStubDispatch::AcceptWithResponder(
    SimpleTestClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kSimpleTestClient_RequestValue_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::SimpleTestClient::RequestValue",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::SimpleTestClient::RequestValue");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            SimpleTestClientProxy_RequestValue_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          SimpleTestClient::RequestValueCallback callback =
              SimpleTestClient_RequestValue_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::SimpleTestClient_RequestValue_Params_Data* params =
          reinterpret_cast<
              internal::SimpleTestClient_RequestValue_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SimpleTestClient_RequestValue_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleTestClient::Name_, 0, false);
        return false;
      }
      SimpleTestClient::RequestValueCallback callback =
          SimpleTestClient_RequestValue_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestValue(std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kSimpleTestClientValidationInfo[] = {
    {internal::kSimpleTestClient_RequestValue_Name,
     {&internal::SimpleTestClient_RequestValue_Params_Data::Validate,
      &internal::SimpleTestClient_RequestValue_ResponseParams_Data::Validate}},
};

bool SimpleTestClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::SimpleTestClient::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kSimpleTestClientValidationInfo);
}

bool SimpleTestClientResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::SimpleTestClient::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kSimpleTestClientValidationInfo);

}
const char PingReceiver::Name_[] = "IPC.mojom.PingReceiver";

class PingReceiver_Ping_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PingReceiver_Ping_ForwardToCallback(
      PingReceiver::PingCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PingReceiver::PingCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PingReceiver_Ping_ForwardToCallback);
};

PingReceiverProxy::PingReceiverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class PingReceiverProxy_Ping_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PingReceiverProxy_Ping_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPingReceiver_Ping_Name,
          message_flags){}
  ~PingReceiverProxy_Ping_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PingReceiverProxy_Ping_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPingReceiver_Ping_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::PingReceiver_Ping_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      PingReceiver* impl, PingReceiver::PingCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->Ping(std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::PingReceiver_Ping_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(PingReceiverProxy_Ping_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PingReceiverProxy_Ping_Message::kMessageTag = {};

void PingReceiverProxy::Ping(
    PingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "IPC::mojom::PingReceiver::Ping");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = PingReceiverProxy_Ping_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PingReceiver::Name_);
  message.set_method_name("Ping");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PingReceiver_Ping_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class PingReceiver_Ping_ProxyToResponder {
 public:
  static PingReceiver::PingCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PingReceiver_Ping_ProxyToResponder> proxy(
        new PingReceiver_Ping_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PingReceiver_Ping_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PingReceiver_Ping_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PingReceiver_Ping_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PingReceiver::PingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PingReceiver_Ping_ProxyToResponder);
};
class PingReceiver_Ping_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit PingReceiver_Ping_Response_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kPingReceiver_Ping_Name,
          message_flags){}
  ~PingReceiver_Ping_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<PingReceiver_Ping_Response_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kPingReceiver_Ping_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::PingReceiver_Ping_ResponseParams_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(mojo::Message* message,
                PingReceiver::PingCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run();
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::PingReceiver_Ping_ResponseParams_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(PingReceiver_Ping_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
PingReceiver_Ping_Response_Message::kMessageTag = {};

bool PingReceiver_Ping_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::PingReceiver::PingCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<PingReceiver_Ping_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::PingReceiver_Ping_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PingReceiver_Ping_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  PingReceiver_Ping_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PingReceiver::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void PingReceiver_Ping_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "(Impl)IPC::mojom::PingReceiver::PingCallback");
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = PingReceiver_Ping_Response_Message::Build(kSerialize, is_sync_);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::PingReceiver::PingCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PingReceiver::Name_);
  message.set_method_name("Ping");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PingReceiverStubDispatch::Accept(
    PingReceiver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPingReceiver_Ping_Name: {
      break;
    }
  }
  return false;
}

// static
bool PingReceiverStubDispatch::AcceptWithResponder(
    PingReceiver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPingReceiver_Ping_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::PingReceiver::Ping",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::PingReceiver::Ping");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            PingReceiverProxy_Ping_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          PingReceiver::PingCallback callback =
              PingReceiver_Ping_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::PingReceiver_Ping_Params_Data* params =
          reinterpret_cast<
              internal::PingReceiver_Ping_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PingReceiver_Ping_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PingReceiver::Name_, 0, false);
        return false;
      }
      PingReceiver::PingCallback callback =
          PingReceiver_Ping_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Ping(std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPingReceiverValidationInfo[] = {
    {internal::kPingReceiver_Ping_Name,
     {&internal::PingReceiver_Ping_Params_Data::Validate,
      &internal::PingReceiver_Ping_ResponseParams_Data::Validate}},
};

bool PingReceiverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::PingReceiver::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPingReceiverValidationInfo);
}

bool PingReceiverResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::PingReceiver::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kPingReceiverValidationInfo);

}
const char TestStructPasser::Name_[] = "IPC.mojom.TestStructPasser";

TestStructPasserProxy::TestStructPasserProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class TestStructPasserProxy_Pass_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit TestStructPasserProxy_Pass_Message(
      uint32_t message_flags
      , TestStructPtr param_s
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kTestStructPasser_Pass_Name,
          message_flags)
      , param_s_(std::move(param_s)){}
  ~TestStructPasserProxy_Pass_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      TestStructPtr param_s) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<TestStructPasserProxy_Pass_Message>(
          kFlags
          , std::move(param_s)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kTestStructPasser_Pass_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::TestStructPasser_Pass_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::IPC::mojom::TestStructDataView>(
      param_s, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TestStructPasser.Pass request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      TestStructPasser* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->Pass(
        std::move(param_s_));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::TestStructPasser_Pass_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->s)::BaseType> s_fragment(
          params.message());
  mojo::internal::Serialize<::IPC::mojom::TestStructDataView>(
      param_s_, s_fragment);
  params->s.Set(
      s_fragment.is_null() ? nullptr : s_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->s.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null s in TestStructPasser.Pass request");
  }
  TestStructPtr param_s_;

  DISALLOW_COPY_AND_ASSIGN(TestStructPasserProxy_Pass_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
TestStructPasserProxy_Pass_Message::kMessageTag = {};

void TestStructPasserProxy::Pass(
    TestStructPtr in_s) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "IPC::mojom::TestStructPasser::Pass", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("s"), in_s, 
                        "<value of type TestStructPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = TestStructPasserProxy_Pass_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_s));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TestStructPasser::Name_);
  message.set_method_name("Pass");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool TestStructPasserStubDispatch::Accept(
    TestStructPasser* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kTestStructPasser_Pass_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::TestStructPasser::Pass",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::TestStructPasser::Pass");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            TestStructPasserProxy_Pass_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::TestStructPasser_Pass_Params_Data* params =
          reinterpret_cast<internal::TestStructPasser_Pass_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      TestStructPtr p_s{};
      TestStructPasser_Pass_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadS(&p_s))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TestStructPasser::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Pass(
std::move(p_s));
      return true;
    }
  }
  return false;
}

// static
bool TestStructPasserStubDispatch::AcceptWithResponder(
    TestStructPasser* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kTestStructPasser_Pass_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kTestStructPasserValidationInfo[] = {
    {internal::kTestStructPasser_Pass_Name,
     {&internal::TestStructPasser_Pass_Params_Data::Validate,
      nullptr /* no response */}},
};

bool TestStructPasserRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::TestStructPasser::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kTestStructPasserValidationInfo);
}

const char IndirectTestDriver::Name_[] = "IPC.mojom.IndirectTestDriver";

IndirectTestDriverProxy::IndirectTestDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void IndirectTestDriverProxy::GetPingReceiver(
    ::mojo::PendingAssociatedReceiver<PingReceiver> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "IPC::mojom::IndirectTestDriver::GetPingReceiver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver, 
                        "<value of type ::mojo::PendingAssociatedReceiver<PingReceiver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kIndirectTestDriver_GetPingReceiver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::IndirectTestDriver_GetPingReceiver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::IPC::mojom::PingReceiverAssociatedRequestDataView>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid receiver in IndirectTestDriver.GetPingReceiver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IndirectTestDriver::Name_);
  message.set_method_name("GetPingReceiver");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool IndirectTestDriverStubDispatch::Accept(
    IndirectTestDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kIndirectTestDriver_GetPingReceiver_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::IndirectTestDriver::GetPingReceiver",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::IndirectTestDriver::GetPingReceiver");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::IndirectTestDriver_GetPingReceiver_Params_Data* params =
          reinterpret_cast<internal::IndirectTestDriver_GetPingReceiver_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<PingReceiver> p_receiver{};
      IndirectTestDriver_GetPingReceiver_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IndirectTestDriver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetPingReceiver(
std::move(p_receiver));
      return true;
    }
  }
  return false;
}

// static
bool IndirectTestDriverStubDispatch::AcceptWithResponder(
    IndirectTestDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kIndirectTestDriver_GetPingReceiver_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kIndirectTestDriverValidationInfo[] = {
    {internal::kIndirectTestDriver_GetPingReceiver_Name,
     {&internal::IndirectTestDriver_GetPingReceiver_Params_Data::Validate,
      nullptr /* no response */}},
};

bool IndirectTestDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::IndirectTestDriver::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kIndirectTestDriverValidationInfo);
}

const char Reflector::Name_[] = "IPC.mojom.Reflector";
bool Reflector::SyncPing(const std::string& value, std::string* out_response) {
  NOTREACHED();
  return false;
}

class Reflector_Ping_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Reflector_Ping_ForwardToCallback(
      Reflector::PingCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Reflector::PingCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Reflector_Ping_ForwardToCallback);
};
class Reflector_SyncPing_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  Reflector_SyncPing_HandleSyncResponse(
      bool* result, std::string* out_response)
      : result_(result), out_response_(out_response) {
    DCHECK(!*result_);
  }
  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  std::string* out_response_;DISALLOW_COPY_AND_ASSIGN(Reflector_SyncPing_HandleSyncResponse);
};

class Reflector_SyncPing_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Reflector_SyncPing_ForwardToCallback(
      Reflector::SyncPingCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Reflector::SyncPingCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Reflector_SyncPing_ForwardToCallback);
};

ReflectorProxy::ReflectorProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class ReflectorProxy_Ping_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ReflectorProxy_Ping_Message(
      uint32_t message_flags
      , const std::string& param_value
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kReflector_Ping_Name,
          message_flags)
      , param_value_(std::move(param_value)){}
  ~ReflectorProxy_Ping_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      const std::string& param_value) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ReflectorProxy_Ping_Message>(
          kFlags
          , std::move(param_value)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kReflector_Ping_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::Reflector_Ping_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in Reflector.Ping request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      Reflector* impl, Reflector::PingCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->Ping(
        std::move(param_value_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::Reflector_Ping_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_value_, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in Reflector.Ping request");
  }
  std::string param_value_;

  DISALLOW_COPY_AND_ASSIGN(ReflectorProxy_Ping_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ReflectorProxy_Ping_Message::kMessageTag = {};

void ReflectorProxy::Ping(
    const std::string& in_value, PingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "IPC::mojom::Reflector::Ping", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value, 
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = ReflectorProxy_Ping_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_value));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Reflector::Name_);
  message.set_method_name("Ping");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Reflector_Ping_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class ReflectorProxy_SyncPing_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ReflectorProxy_SyncPing_Message(
      uint32_t message_flags
      , const std::string& param_value
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kReflector_SyncPing_Name,
          message_flags)
      , param_value_(std::move(param_value)){}
  ~ReflectorProxy_SyncPing_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      const std::string& param_value) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ReflectorProxy_SyncPing_Message>(
          kFlags
          , std::move(param_value)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kReflector_SyncPing_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::Reflector_SyncPing_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in Reflector.SyncPing request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      Reflector* impl, Reflector::SyncPingCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->SyncPing(
        std::move(param_value_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::Reflector_SyncPing_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_value_, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in Reflector.SyncPing request");
  }
  std::string param_value_;

  DISALLOW_COPY_AND_ASSIGN(ReflectorProxy_SyncPing_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ReflectorProxy_SyncPing_Message::kMessageTag = {};
bool ReflectorProxy::SyncPing(
    const std::string& param_value, std::string* out_param_response) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "IPC::mojom::Reflector::SyncPing", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), param_value, 
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = ReflectorProxy_SyncPing_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(param_value));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Reflector::Name_);
  message.set_method_name("SyncPing");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Reflector_SyncPing_HandleSyncResponse(
          &result, out_param_response));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "IPC::mojom::Reflector::SyncPing", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("response"), out_param_response, 
                        "<value of type const std::string&>");
   });
#endif
  return result;
}

void ReflectorProxy::SyncPing(
    const std::string& in_value, SyncPingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "IPC::mojom::Reflector::SyncPing", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value, 
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = ReflectorProxy_SyncPing_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_value));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Reflector::Name_);
  message.set_method_name("SyncPing");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Reflector_SyncPing_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class ReflectorProxy_Quit_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit ReflectorProxy_Quit_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kReflector_Quit_Name,
          message_flags){}
  ~ReflectorProxy_Quit_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<ReflectorProxy_Quit_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kReflector_Quit_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::Reflector_Quit_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      Reflector* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->Quit();
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::Reflector_Quit_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(ReflectorProxy_Quit_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
ReflectorProxy_Quit_Message::kMessageTag = {};

void ReflectorProxy::Quit(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "IPC::mojom::Reflector::Quit");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = ReflectorProxy_Quit_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Reflector::Name_);
  message.set_method_name("Quit");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class Reflector_Ping_ProxyToResponder {
 public:
  static Reflector::PingCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<Reflector_Ping_ProxyToResponder> proxy(
        new Reflector_Ping_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&Reflector_Ping_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Reflector_Ping_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Reflector_Ping_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Reflector::PingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const std::string& in_value);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Reflector_Ping_ProxyToResponder);
};
class Reflector_Ping_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit Reflector_Ping_Response_Message(
      uint32_t message_flags
      , const std::string& param_value
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kReflector_Ping_Name,
          message_flags)
      , param_value_(std::move(param_value)){}
  ~Reflector_Ping_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      const std::string& param_value) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<Reflector_Ping_Response_Message>(
          kFlags
          , std::move(param_value)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kReflector_Ping_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::Reflector_Ping_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in Reflector.Ping response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                Reflector::PingCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_value_));
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::Reflector_Ping_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_value_, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in Reflector.Ping response");
  }
  std::string param_value_;

  DISALLOW_COPY_AND_ASSIGN(Reflector_Ping_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
Reflector_Ping_Response_Message::kMessageTag = {};

bool Reflector_Ping_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::Reflector::PingCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<Reflector_Ping_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::Reflector_Ping_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Reflector_Ping_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::string p_value{};
  Reflector_Ping_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadValue(&p_value))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Reflector::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_value));
  return true;
}

void Reflector_Ping_ProxyToResponder::Run(
    const std::string& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)IPC::mojom::Reflector::PingCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value, 
                        "<value of type const std::string&>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = Reflector_Ping_Response_Message::Build(kSerialize, is_sync_, std::move(in_value));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::Reflector::PingCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Reflector::Name_);
  message.set_method_name("Ping");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Reflector_SyncPing_ProxyToResponder {
 public:
  static Reflector::SyncPingCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<Reflector_SyncPing_ProxyToResponder> proxy(
        new Reflector_SyncPing_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&Reflector_SyncPing_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Reflector_SyncPing_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Reflector_SyncPing_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Reflector::SyncPingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const std::string& in_response);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Reflector_SyncPing_ProxyToResponder);
};
class Reflector_SyncPing_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit Reflector_SyncPing_Response_Message(
      uint32_t message_flags
      , const std::string& param_response
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kReflector_SyncPing_Name,
          message_flags)
      , param_response_(std::move(param_response)){}
  ~Reflector_SyncPing_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync,
      const std::string& param_response) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<Reflector_SyncPing_Response_Message>(
          kFlags
          , std::move(param_response)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kReflector_SyncPing_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::Reflector_SyncPing_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->response)::BaseType> response_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_response, response_fragment);
  params->response.Set(
      response_fragment.is_null() ? nullptr : response_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->response.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null response in Reflector.SyncPing response");
    return message;
  }


  void Dispatch(mojo::Message* message,
                Reflector::SyncPingCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run(
        std::move(param_response_));
  }


  void HandleSyncResponse(
      mojo::Message* message
,
      std::string* out_response) {

    if (message->receiver_connection_group()) {
    }


    *out_response = std::move(param_response_);

  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::Reflector_SyncPing_ResponseParams_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->response)::BaseType> response_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_response_, response_fragment);
  params->response.Set(
      response_fragment.is_null() ? nullptr : response_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->response.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null response in Reflector.SyncPing response");
  }
  std::string param_response_;

  DISALLOW_COPY_AND_ASSIGN(Reflector_SyncPing_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
Reflector_SyncPing_Response_Message::kMessageTag = {};

bool Reflector_SyncPing_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::Reflector::SyncPingCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<Reflector_SyncPing_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::Reflector_SyncPing_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Reflector_SyncPing_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::string p_response{};
  Reflector_SyncPing_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResponse(&p_response))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Reflector::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_response));
  return true;
}

void Reflector_SyncPing_ProxyToResponder::Run(
    const std::string& in_response) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "(Impl)IPC::mojom::Reflector::SyncPingCallback", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("response"), in_response, 
                        "<value of type const std::string&>");
   });
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = Reflector_SyncPing_Response_Message::Build(kSerialize, is_sync_, std::move(in_response));

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::Reflector::SyncPingCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Reflector::Name_);
  message.set_method_name("SyncPing");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool Reflector_SyncPing_HandleSyncResponse::Accept(
    mojo::Message* message) {
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<Reflector_SyncPing_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was built using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      context->HandleSyncResponse(
          message,
          out_response_);
      *result_ = true;
      mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
          message);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::Reflector_SyncPing_ResponseParams_Data* params =
      reinterpret_cast<internal::Reflector_SyncPing_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  std::string p_response{};
  Reflector_SyncPing_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResponse(&p_response))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Reflector::Name_, 1, true);
    return false;
  }
  *out_response_ = std::move(p_response);
  mojo::internal::SyncMessageResponseSetup::SetCurrentSyncResponseMessage(
      message);
  *result_ = true;
  return true;
}

// static
bool ReflectorStubDispatch::Accept(
    Reflector* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kReflector_Ping_Name: {
      break;
    }
    case internal::kReflector_SyncPing_Name: {
      break;
    }
    case internal::kReflector_Quit_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::Reflector::Quit",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::Reflector::Quit");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            ReflectorProxy_Quit_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::Reflector_Quit_Params_Data* params =
          reinterpret_cast<internal::Reflector_Quit_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      Reflector_Quit_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Reflector::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Quit();
      return true;
    }
  }
  return false;
}

// static
bool ReflectorStubDispatch::AcceptWithResponder(
    Reflector* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kReflector_Ping_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::Reflector::Ping",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::Reflector::Ping");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            ReflectorProxy_Ping_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          Reflector::PingCallback callback =
              Reflector_Ping_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::Reflector_Ping_Params_Data* params =
          reinterpret_cast<
              internal::Reflector_Ping_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_value{};
      Reflector_Ping_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Reflector::Name_, 0, false);
        return false;
      }
      Reflector::PingCallback callback =
          Reflector_Ping_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Ping(
std::move(p_value), std::move(callback));
      return true;
    }
    case internal::kReflector_SyncPing_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::Reflector::SyncPing",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::Reflector::SyncPing");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            ReflectorProxy_SyncPing_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          Reflector::SyncPingCallback callback =
              Reflector_SyncPing_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::Reflector_SyncPing_Params_Data* params =
          reinterpret_cast<
              internal::Reflector_SyncPing_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_value{};
      Reflector_SyncPing_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Reflector::Name_, 1, false);
        return false;
      }
      Reflector::SyncPingCallback callback =
          Reflector_SyncPing_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SyncPing(
std::move(p_value), std::move(callback));
      return true;
    }
    case internal::kReflector_Quit_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kReflectorValidationInfo[] = {
    {internal::kReflector_Ping_Name,
     {&internal::Reflector_Ping_Params_Data::Validate,
      &internal::Reflector_Ping_ResponseParams_Data::Validate}},
    {internal::kReflector_SyncPing_Name,
     {&internal::Reflector_SyncPing_Params_Data::Validate,
      &internal::Reflector_SyncPing_ResponseParams_Data::Validate}},
    {internal::kReflector_Quit_Name,
     {&internal::Reflector_Quit_Params_Data::Validate,
      nullptr /* no response */}},
};

bool ReflectorRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::Reflector::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kReflectorValidationInfo);
}

bool ReflectorResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::Reflector::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kReflectorValidationInfo);

}
const char AssociatedInterfaceVendor::Name_[] = "IPC.mojom.AssociatedInterfaceVendor";

AssociatedInterfaceVendorProxy::AssociatedInterfaceVendorProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void AssociatedInterfaceVendorProxy::GetTestInterface(
    ::mojo::PendingAssociatedReceiver<SimpleTestDriver> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "IPC::mojom::AssociatedInterfaceVendor::GetTestInterface", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver, 
                        "<value of type ::mojo::PendingAssociatedReceiver<SimpleTestDriver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAssociatedInterfaceVendor_GetTestInterface_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::AssociatedInterfaceVendor_GetTestInterface_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::IPC::mojom::SimpleTestDriverAssociatedRequestDataView>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid receiver in AssociatedInterfaceVendor.GetTestInterface request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AssociatedInterfaceVendor::Name_);
  message.set_method_name("GetTestInterface");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool AssociatedInterfaceVendorStubDispatch::Accept(
    AssociatedInterfaceVendor* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kAssociatedInterfaceVendor_GetTestInterface_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::AssociatedInterfaceVendor::GetTestInterface",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::AssociatedInterfaceVendor::GetTestInterface");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::AssociatedInterfaceVendor_GetTestInterface_Params_Data* params =
          reinterpret_cast<internal::AssociatedInterfaceVendor_GetTestInterface_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<SimpleTestDriver> p_receiver{};
      AssociatedInterfaceVendor_GetTestInterface_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AssociatedInterfaceVendor::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetTestInterface(
std::move(p_receiver));
      return true;
    }
  }
  return false;
}

// static
bool AssociatedInterfaceVendorStubDispatch::AcceptWithResponder(
    AssociatedInterfaceVendor* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kAssociatedInterfaceVendor_GetTestInterface_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kAssociatedInterfaceVendorValidationInfo[] = {
    {internal::kAssociatedInterfaceVendor_GetTestInterface_Name,
     {&internal::AssociatedInterfaceVendor_GetTestInterface_Params_Data::Validate,
      nullptr /* no response */}},
};

bool AssociatedInterfaceVendorRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::AssociatedInterfaceVendor::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kAssociatedInterfaceVendorValidationInfo);
}

const char InterfacePassingTestDriver::Name_[] = "IPC.mojom.InterfacePassingTestDriver";

class InterfacePassingTestDriver_Init_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  InterfacePassingTestDriver_Init_ForwardToCallback(
      InterfacePassingTestDriver::InitCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  InterfacePassingTestDriver::InitCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriver_Init_ForwardToCallback);
};

class InterfacePassingTestDriver_GetPingReceiver_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  InterfacePassingTestDriver_GetPingReceiver_ForwardToCallback(
      InterfacePassingTestDriver::GetPingReceiverCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  InterfacePassingTestDriver::GetPingReceiverCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriver_GetPingReceiver_ForwardToCallback);
};

class InterfacePassingTestDriver_GetAssociatedPingReceiver_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  InterfacePassingTestDriver_GetAssociatedPingReceiver_ForwardToCallback(
      InterfacePassingTestDriver::GetAssociatedPingReceiverCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  InterfacePassingTestDriver::GetAssociatedPingReceiverCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriver_GetAssociatedPingReceiver_ForwardToCallback);
};

InterfacePassingTestDriverProxy::InterfacePassingTestDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
class InterfacePassingTestDriverProxy_Init_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit InterfacePassingTestDriverProxy_Init_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kInterfacePassingTestDriver_Init_Name,
          message_flags){}
  ~InterfacePassingTestDriverProxy_Init_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<InterfacePassingTestDriverProxy_Init_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kInterfacePassingTestDriver_Init_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::InterfacePassingTestDriver_Init_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      InterfacePassingTestDriver* impl, InterfacePassingTestDriver::InitCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->Init(std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::InterfacePassingTestDriver_Init_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriverProxy_Init_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
InterfacePassingTestDriverProxy_Init_Message::kMessageTag = {};

void InterfacePassingTestDriverProxy::Init(
    InitCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "IPC::mojom::InterfacePassingTestDriver::Init");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = InterfacePassingTestDriverProxy_Init_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(InterfacePassingTestDriver::Name_);
  message.set_method_name("Init");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new InterfacePassingTestDriver_Init_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class InterfacePassingTestDriverProxy_GetPingReceiver_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit InterfacePassingTestDriverProxy_GetPingReceiver_Message(
      uint32_t message_flags
      , std::vector<::mojo::PendingReceiver<PingReceiver>> param_receiver
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kInterfacePassingTestDriver_GetPingReceiver_Name,
          message_flags)
      , param_receiver_(std::move(param_receiver)){}
  ~InterfacePassingTestDriverProxy_GetPingReceiver_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync,
      std::vector<::mojo::PendingReceiver<PingReceiver>> param_receiver) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<InterfacePassingTestDriverProxy_GetPingReceiver_Message>(
          kFlags
          , std::move(param_receiver)
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kInterfacePassingTestDriver_GetPingReceiver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::InterfacePassingTestDriver_GetPingReceiver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->receiver)::BaseType>
      receiver_fragment(params.message());
  const mojo::internal::ContainerValidateParams receiver_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::InterfaceRequestDataView<::IPC::mojom::PingReceiverInterfaceBase>>>(
      param_receiver, receiver_fragment, &receiver_validate_params);
  params->receiver.Set(
      receiver_fragment.is_null() ? nullptr : receiver_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->receiver.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null receiver in InterfacePassingTestDriver.GetPingReceiver request");
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      InterfacePassingTestDriver* impl, InterfacePassingTestDriver::GetPingReceiverCallback callback) {
    if (message->receiver_connection_group()) {
    }

    impl->GetPingReceiver(
        std::move(param_receiver_), std::move(callback));
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::InterfacePassingTestDriver_GetPingReceiver_Params_Data> params(
            message);
    params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->receiver)::BaseType>
      receiver_fragment(params.message());
  const mojo::internal::ContainerValidateParams receiver_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::InterfaceRequestDataView<::IPC::mojom::PingReceiverInterfaceBase>>>(
      param_receiver_, receiver_fragment, &receiver_validate_params);
  params->receiver.Set(
      receiver_fragment.is_null() ? nullptr : receiver_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->receiver.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null receiver in InterfacePassingTestDriver.GetPingReceiver request");
  }
  std::vector<::mojo::PendingReceiver<PingReceiver>> param_receiver_;

  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriverProxy_GetPingReceiver_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
InterfacePassingTestDriverProxy_GetPingReceiver_Message::kMessageTag = {};

void InterfacePassingTestDriverProxy::GetPingReceiver(
    std::vector<::mojo::PendingReceiver<PingReceiver>> in_receiver, GetPingReceiverCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "IPC::mojom::InterfacePassingTestDriver::GetPingReceiver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver, 
                        "<value of type std::vector<::mojo::PendingReceiver<PingReceiver>>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = InterfacePassingTestDriverProxy_GetPingReceiver_Message::Build(
      kSerialize, kExpectsResponse, kIsSync, std::move(in_receiver));

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(InterfacePassingTestDriver::Name_);
  message.set_method_name("GetPingReceiver");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new InterfacePassingTestDriver_GetPingReceiver_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void InterfacePassingTestDriverProxy::GetAssociatedPingReceiver(
    std::vector<::mojo::PendingAssociatedReceiver<PingReceiver>> in_receiver, GetAssociatedPingReceiverCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "IPC::mojom::InterfacePassingTestDriver::GetAssociatedPingReceiver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver, 
                        "<value of type std::vector<::mojo::PendingAssociatedReceiver<PingReceiver>>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kInterfacePassingTestDriver_GetAssociatedPingReceiver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::InterfacePassingTestDriver_GetAssociatedPingReceiver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->receiver)::BaseType>
      receiver_fragment(params.message());
  const mojo::internal::ContainerValidateParams receiver_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::IPC::mojom::PingReceiverAssociatedRequestDataView>>(
      in_receiver, receiver_fragment, &receiver_validate_params);
  params->receiver.Set(
      receiver_fragment.is_null() ? nullptr : receiver_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->receiver.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null receiver in InterfacePassingTestDriver.GetAssociatedPingReceiver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(InterfacePassingTestDriver::Name_);
  message.set_method_name("GetAssociatedPingReceiver");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new InterfacePassingTestDriver_GetAssociatedPingReceiver_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class InterfacePassingTestDriverProxy_Quit_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit InterfacePassingTestDriverProxy_Quit_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kInterfacePassingTestDriver_Quit_Name,
          message_flags){}
  ~InterfacePassingTestDriverProxy_Quit_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool expects_response,
      bool is_sync) {

    
  const uint32_t kFlags =
      ((expects_response) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<InterfacePassingTestDriverProxy_Quit_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kInterfacePassingTestDriver_Quit_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::InterfacePassingTestDriver_Quit_Params_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(
      mojo::Message* message,
      InterfacePassingTestDriver* impl) {
    if (message->receiver_connection_group()) {
    }

    impl->Quit();
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::InterfacePassingTestDriver_Quit_Params_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriverProxy_Quit_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
InterfacePassingTestDriverProxy_Quit_Message::kMessageTag = {};

void InterfacePassingTestDriverProxy::Quit(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "IPC::mojom::InterfacePassingTestDriver::Quit");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kSerialize = receiver_->PrefersSerializedMessages();
  auto message = InterfacePassingTestDriverProxy_Quit_Message::Build(
      kSerialize, kExpectsResponse, kIsSync);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(InterfacePassingTestDriver::Name_);
  message.set_method_name("Quit");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class InterfacePassingTestDriver_Init_ProxyToResponder {
 public:
  static InterfacePassingTestDriver::InitCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<InterfacePassingTestDriver_Init_ProxyToResponder> proxy(
        new InterfacePassingTestDriver_Init_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&InterfacePassingTestDriver_Init_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~InterfacePassingTestDriver_Init_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  InterfacePassingTestDriver_Init_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "InterfacePassingTestDriver::InitCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriver_Init_ProxyToResponder);
};
class InterfacePassingTestDriver_Init_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit InterfacePassingTestDriver_Init_Response_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kInterfacePassingTestDriver_Init_Name,
          message_flags){}
  ~InterfacePassingTestDriver_Init_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<InterfacePassingTestDriver_Init_Response_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kInterfacePassingTestDriver_Init_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::InterfacePassingTestDriver_Init_ResponseParams_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(mojo::Message* message,
                InterfacePassingTestDriver::InitCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run();
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::InterfacePassingTestDriver_Init_ResponseParams_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriver_Init_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
InterfacePassingTestDriver_Init_Response_Message::kMessageTag = {};

bool InterfacePassingTestDriver_Init_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::InterfacePassingTestDriver::InitCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<InterfacePassingTestDriver_Init_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::InterfacePassingTestDriver_Init_ResponseParams_Data* params =
      reinterpret_cast<
          internal::InterfacePassingTestDriver_Init_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  InterfacePassingTestDriver_Init_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        InterfacePassingTestDriver::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void InterfacePassingTestDriver_Init_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "(Impl)IPC::mojom::InterfacePassingTestDriver::InitCallback");
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = InterfacePassingTestDriver_Init_Response_Message::Build(kSerialize, is_sync_);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::InterfacePassingTestDriver::InitCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(InterfacePassingTestDriver::Name_);
  message.set_method_name("Init");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder {
 public:
  static InterfacePassingTestDriver::GetPingReceiverCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder> proxy(
        new InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "InterfacePassingTestDriver::GetPingReceiverCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder);
};
class InterfacePassingTestDriver_GetPingReceiver_Response_Message
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  explicit InterfacePassingTestDriver_GetPingReceiver_Response_Message(
      uint32_t message_flags
  )
      : mojo::internal::UnserializedMessageContext(
          &kMessageTag,
          internal::kInterfacePassingTestDriver_GetPingReceiver_Name,
          message_flags){}
  ~InterfacePassingTestDriver_GetPingReceiver_Response_Message() override = default;

  static mojo::Message Build(
      bool serialize,
      bool is_sync) {

    
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync) ? mojo::Message::kFlagIsSync : 0);

    if (!serialize) {
      return mojo::Message(std::make_unique<InterfacePassingTestDriver_GetPingReceiver_Response_Message>(
          kFlags
          ),
          MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    DCHECK(serialize);
    
  mojo::Message message(
      internal::kInterfacePassingTestDriver_GetPingReceiver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::InterfacePassingTestDriver_GetPingReceiver_ResponseParams_Data> params(
          message);
  params.Allocate();
    return message;
  }


  void Dispatch(mojo::Message* message,
                InterfacePassingTestDriver::GetPingReceiverCallback* callback) {
    if (message->receiver_connection_group()) {
    }

    std::move(*callback).Run();
  }



 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<
        ::IPC::mojom::internal::InterfacePassingTestDriver_GetPingReceiver_ResponseParams_Data> params(
            message);
    params.Allocate();
  }

  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriver_GetPingReceiver_Response_Message);
};

const mojo::internal::UnserializedMessageContext::Tag
InterfacePassingTestDriver_GetPingReceiver_Response_Message::kMessageTag = {};

bool InterfacePassingTestDriver_GetPingReceiver_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::InterfacePassingTestDriver::GetPingReceiverCallback",
               "message", message->name());
#endif
  if (!message->is_serialized()) {
    auto context =
        message->TakeUnserializedContext<InterfacePassingTestDriver_GetPingReceiver_Response_Message>();
    if (!context) {
      // The Message was not of the expected type. It may be a valid message
      // which was build using a different variant of these bindings. Force
      // serialization before dispatch in this case.
      message->SerializeIfNecessary();
    } else {
      if (!callback_.is_null())
        context->Dispatch(message, &callback_);
      return true;
    }
  }

  DCHECK(message->is_serialized());
  internal::InterfacePassingTestDriver_GetPingReceiver_ResponseParams_Data* params =
      reinterpret_cast<
          internal::InterfacePassingTestDriver_GetPingReceiver_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  InterfacePassingTestDriver_GetPingReceiver_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        InterfacePassingTestDriver::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "(Impl)IPC::mojom::InterfacePassingTestDriver::GetPingReceiverCallback");
#endif
  const bool kSerialize = responder_->PrefersSerializedMessages();
  auto message = InterfacePassingTestDriver_GetPingReceiver_Response_Message::Build(kSerialize, is_sync_);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::InterfacePassingTestDriver::GetPingReceiverCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(InterfacePassingTestDriver::Name_);
  message.set_method_name("GetPingReceiver");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder {
 public:
  static InterfacePassingTestDriver::GetAssociatedPingReceiverCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder> proxy(
        new InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "InterfacePassingTestDriver::GetAssociatedPingReceiverCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder);
};

bool InterfacePassingTestDriver_GetAssociatedPingReceiver_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "IPC::mojom::InterfacePassingTestDriver::GetAssociatedPingReceiverCallback",
               "message", message->name());
#endif

  DCHECK(message->is_serialized());
  internal::InterfacePassingTestDriver_GetAssociatedPingReceiver_ResponseParams_Data* params =
      reinterpret_cast<
          internal::InterfacePassingTestDriver_GetAssociatedPingReceiver_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  InterfacePassingTestDriver_GetAssociatedPingReceiver_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        InterfacePassingTestDriver::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "(Impl)IPC::mojom::InterfacePassingTestDriver::GetAssociatedPingReceiverCallback");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kInterfacePassingTestDriver_GetAssociatedPingReceiver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::IPC::mojom::internal::InterfacePassingTestDriver_GetAssociatedPingReceiver_ResponseParams_Data> params(
          message);
  params.Allocate();

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1("mojom", "(Impl)IPC::mojom::InterfacePassingTestDriver::GetAssociatedPingReceiverCallback", "message",
                   message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(InterfacePassingTestDriver::Name_);
  message.set_method_name("GetAssociatedPingReceiver");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool InterfacePassingTestDriverStubDispatch::Accept(
    InterfacePassingTestDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kInterfacePassingTestDriver_Init_Name: {
      break;
    }
    case internal::kInterfacePassingTestDriver_GetPingReceiver_Name: {
      break;
    }
    case internal::kInterfacePassingTestDriver_GetAssociatedPingReceiver_Name: {
      break;
    }
    case internal::kInterfacePassingTestDriver_Quit_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::InterfacePassingTestDriver::Quit",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::InterfacePassingTestDriver::Quit");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            InterfacePassingTestDriverProxy_Quit_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was serialized using a different variant of these bindings.
          // Force serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          context->Dispatch(message, impl);
          return true;
        }
      }

      DCHECK(message->is_serialized());
      internal::InterfacePassingTestDriver_Quit_Params_Data* params =
          reinterpret_cast<internal::InterfacePassingTestDriver_Quit_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      InterfacePassingTestDriver_Quit_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            InterfacePassingTestDriver::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Quit();
      return true;
    }
  }
  return false;
}

// static
bool InterfacePassingTestDriverStubDispatch::AcceptWithResponder(
    InterfacePassingTestDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kInterfacePassingTestDriver_Init_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::InterfacePassingTestDriver::Init",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::InterfacePassingTestDriver::Init");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            InterfacePassingTestDriverProxy_Init_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          InterfacePassingTestDriver::InitCallback callback =
              InterfacePassingTestDriver_Init_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::InterfacePassingTestDriver_Init_Params_Data* params =
          reinterpret_cast<
              internal::InterfacePassingTestDriver_Init_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      InterfacePassingTestDriver_Init_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            InterfacePassingTestDriver::Name_, 0, false);
        return false;
      }
      InterfacePassingTestDriver::InitCallback callback =
          InterfacePassingTestDriver_Init_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Init(std::move(callback));
      return true;
    }
    case internal::kInterfacePassingTestDriver_GetPingReceiver_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::InterfacePassingTestDriver::GetPingReceiver",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::InterfacePassingTestDriver::GetPingReceiver");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);
      if (!message->is_serialized()) {
        auto context = message->TakeUnserializedContext<
            InterfacePassingTestDriverProxy_GetPingReceiver_Message>();
        if (!context) {
          // The Message was not of the expected type. It may be a valid message
          // which was built using a different variant of these bindings. Force
          // serialization before dispatch in this case.
          message->SerializeIfNecessary();
        } else {
          InterfacePassingTestDriver::GetPingReceiverCallback callback =
              InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder::CreateCallback(
                  message->request_id(), message_is_sync, &responder);
          context->Dispatch(message, impl, std::move(callback));
          return true;
        }
      }

      internal::InterfacePassingTestDriver_GetPingReceiver_Params_Data* params =
          reinterpret_cast<
              internal::InterfacePassingTestDriver_GetPingReceiver_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<::mojo::PendingReceiver<PingReceiver>> p_receiver{};
      InterfacePassingTestDriver_GetPingReceiver_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReceiver(&p_receiver))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            InterfacePassingTestDriver::Name_, 1, false);
        return false;
      }
      InterfacePassingTestDriver::GetPingReceiverCallback callback =
          InterfacePassingTestDriver_GetPingReceiver_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetPingReceiver(
std::move(p_receiver), std::move(callback));
      return true;
    }
    case internal::kInterfacePassingTestDriver_GetAssociatedPingReceiver_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)IPC::mojom::InterfacePassingTestDriver::GetAssociatedPingReceiver",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)IPC::mojom::InterfacePassingTestDriver::GetAssociatedPingReceiver");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::InterfacePassingTestDriver_GetAssociatedPingReceiver_Params_Data* params =
          reinterpret_cast<
              internal::InterfacePassingTestDriver_GetAssociatedPingReceiver_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<::mojo::PendingAssociatedReceiver<PingReceiver>> p_receiver{};
      InterfacePassingTestDriver_GetAssociatedPingReceiver_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReceiver(&p_receiver))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            InterfacePassingTestDriver::Name_, 2, false);
        return false;
      }
      InterfacePassingTestDriver::GetAssociatedPingReceiverCallback callback =
          InterfacePassingTestDriver_GetAssociatedPingReceiver_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetAssociatedPingReceiver(
std::move(p_receiver), std::move(callback));
      return true;
    }
    case internal::kInterfacePassingTestDriver_Quit_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kInterfacePassingTestDriverValidationInfo[] = {
    {internal::kInterfacePassingTestDriver_Init_Name,
     {&internal::InterfacePassingTestDriver_Init_Params_Data::Validate,
      &internal::InterfacePassingTestDriver_Init_ResponseParams_Data::Validate}},
    {internal::kInterfacePassingTestDriver_GetPingReceiver_Name,
     {&internal::InterfacePassingTestDriver_GetPingReceiver_Params_Data::Validate,
      &internal::InterfacePassingTestDriver_GetPingReceiver_ResponseParams_Data::Validate}},
    {internal::kInterfacePassingTestDriver_GetAssociatedPingReceiver_Name,
     {&internal::InterfacePassingTestDriver_GetAssociatedPingReceiver_Params_Data::Validate,
      &internal::InterfacePassingTestDriver_GetAssociatedPingReceiver_ResponseParams_Data::Validate}},
    {internal::kInterfacePassingTestDriver_Quit_Name,
     {&internal::InterfacePassingTestDriver_Quit_Params_Data::Validate,
      nullptr /* no response */}},
};

bool InterfacePassingTestDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::InterfacePassingTestDriver::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kInterfacePassingTestDriverValidationInfo);
}

bool InterfacePassingTestDriverResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::IPC::mojom::InterfacePassingTestDriver::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kInterfacePassingTestDriverValidationInfo);

}
}  // namespace mojom
}  // namespace IPC

namespace mojo {


// static
bool StructTraits<::IPC::mojom::TestStruct::DataView, ::IPC::mojom::TestStructPtr>::Read(
    ::IPC::mojom::TestStruct::DataView input,
    ::IPC::mojom::TestStructPtr* output) {
  bool success = true;
  ::IPC::mojom::TestStructPtr result(::IPC::mojom::TestStruct::New());
  
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif