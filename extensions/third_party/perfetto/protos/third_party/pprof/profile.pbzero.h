// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_THIRD_PARTY_PERFTOOLS_PROFILES_PROTOS_THIRD_PARTY_PPROF_PROFILE_PROTO_H_
#define PERFETTO_THIRD_PARTY_PERFTOOLS_PROFILES_PROTOS_THIRD_PARTY_PPROF_PROFILE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace third_party {
namespace perftools {
namespace profiles {
namespace pbzero {

class Function;
class Label;
class Line;
class Location;
class Mapping;
class Sample;
class ValueType;

class Function_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Function_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Function_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Function_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  int64_t name() const { return at<2>().as_int64(); }
  bool has_system_name() const { return at<3>().valid(); }
  int64_t system_name() const { return at<3>().as_int64(); }
  bool has_filename() const { return at<4>().valid(); }
  int64_t filename() const { return at<4>().as_int64(); }
  bool has_start_line() const { return at<5>().valid(); }
  int64_t start_line() const { return at<5>().as_int64(); }
};

class Function : public ::protozero::Message {
 public:
  using Decoder = Function_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSystemNameFieldNumber = 3,
    kFilenameFieldNumber = 4,
    kStartLineFieldNumber = 5,
  };
  void set_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_system_name(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_filename(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_start_line(int64_t value) {
    AppendVarInt(5, value);
  }
};

class Line_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Line_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Line_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Line_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_function_id() const { return at<1>().valid(); }
  uint64_t function_id() const { return at<1>().as_uint64(); }
  bool has_line() const { return at<2>().valid(); }
  int64_t line() const { return at<2>().as_int64(); }
};

class Line : public ::protozero::Message {
 public:
  using Decoder = Line_Decoder;
  enum : int32_t {
    kFunctionIdFieldNumber = 1,
    kLineFieldNumber = 2,
  };
  void set_function_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_line(int64_t value) {
    AppendVarInt(2, value);
  }
};

class Location_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Location_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Location_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Location_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_mapping_id() const { return at<2>().valid(); }
  uint64_t mapping_id() const { return at<2>().as_uint64(); }
  bool has_address() const { return at<3>().valid(); }
  uint64_t address() const { return at<3>().as_uint64(); }
  bool has_line() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> line() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_is_folded() const { return at<5>().valid(); }
  bool is_folded() const { return at<5>().as_bool(); }
};

class Location : public ::protozero::Message {
 public:
  using Decoder = Location_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kMappingIdFieldNumber = 2,
    kAddressFieldNumber = 3,
    kLineFieldNumber = 4,
    kIsFoldedFieldNumber = 5,
  };
  void set_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_mapping_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_address(uint64_t value) {
    AppendVarInt(3, value);
  }
  template <typename T = Line> T* add_line() {
    return BeginNestedMessage<T>(4);
  }

  void set_is_folded(bool value) {
    AppendTinyVarInt(5, value);
  }
};

class Mapping_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Mapping_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Mapping_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Mapping_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_memory_start() const { return at<2>().valid(); }
  uint64_t memory_start() const { return at<2>().as_uint64(); }
  bool has_memory_limit() const { return at<3>().valid(); }
  uint64_t memory_limit() const { return at<3>().as_uint64(); }
  bool has_file_offset() const { return at<4>().valid(); }
  uint64_t file_offset() const { return at<4>().as_uint64(); }
  bool has_filename() const { return at<5>().valid(); }
  int64_t filename() const { return at<5>().as_int64(); }
  bool has_build_id() const { return at<6>().valid(); }
  int64_t build_id() const { return at<6>().as_int64(); }
  bool has_has_functions() const { return at<7>().valid(); }
  bool has_functions() const { return at<7>().as_bool(); }
  bool has_has_filenames() const { return at<8>().valid(); }
  bool has_filenames() const { return at<8>().as_bool(); }
  bool has_has_line_numbers() const { return at<9>().valid(); }
  bool has_line_numbers() const { return at<9>().as_bool(); }
  bool has_has_inline_frames() const { return at<10>().valid(); }
  bool has_inline_frames() const { return at<10>().as_bool(); }
};

class Mapping : public ::protozero::Message {
 public:
  using Decoder = Mapping_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kMemoryStartFieldNumber = 2,
    kMemoryLimitFieldNumber = 3,
    kFileOffsetFieldNumber = 4,
    kFilenameFieldNumber = 5,
    kBuildIdFieldNumber = 6,
    kHasFunctionsFieldNumber = 7,
    kHasFilenamesFieldNumber = 8,
    kHasLineNumbersFieldNumber = 9,
    kHasInlineFramesFieldNumber = 10,
  };
  void set_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_memory_start(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_memory_limit(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_file_offset(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_filename(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_build_id(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_has_functions(bool value) {
    AppendTinyVarInt(7, value);
  }
  void set_has_filenames(bool value) {
    AppendTinyVarInt(8, value);
  }
  void set_has_line_numbers(bool value) {
    AppendTinyVarInt(9, value);
  }
  void set_has_inline_frames(bool value) {
    AppendTinyVarInt(10, value);
  }
};

class Label_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Label_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Label_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Label_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_key() const { return at<1>().valid(); }
  int64_t key() const { return at<1>().as_int64(); }
  bool has_str() const { return at<2>().valid(); }
  int64_t str() const { return at<2>().as_int64(); }
  bool has_num() const { return at<3>().valid(); }
  int64_t num() const { return at<3>().as_int64(); }
  bool has_num_unit() const { return at<4>().valid(); }
  int64_t num_unit() const { return at<4>().as_int64(); }
};

class Label : public ::protozero::Message {
 public:
  using Decoder = Label_Decoder;
  enum : int32_t {
    kKeyFieldNumber = 1,
    kStrFieldNumber = 2,
    kNumFieldNumber = 3,
    kNumUnitFieldNumber = 4,
  };
  void set_key(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_str(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_num(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_num_unit(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Sample_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Sample_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Sample_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Sample_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_location_id() const { return at<1>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> location_id(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t>(1, parse_error_ptr); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t> value(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t>(2, parse_error_ptr); }
  bool has_label() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> label() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class Sample : public ::protozero::Message {
 public:
  using Decoder = Sample_Decoder;
  enum : int32_t {
    kLocationIdFieldNumber = 1,
    kValueFieldNumber = 2,
    kLabelFieldNumber = 3,
  };
  void set_location_id(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(1, packed_buffer.data(), packed_buffer.size());
  }
  void set_value(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(2, packed_buffer.data(), packed_buffer.size());
  }
  template <typename T = Label> T* add_label() {
    return BeginNestedMessage<T>(3);
  }

};

class ValueType_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ValueType_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ValueType_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ValueType_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_type() const { return at<1>().valid(); }
  int64_t type() const { return at<1>().as_int64(); }
  bool has_unit() const { return at<2>().valid(); }
  int64_t unit() const { return at<2>().as_int64(); }
};

class ValueType : public ::protozero::Message {
 public:
  using Decoder = ValueType_Decoder;
  enum : int32_t {
    kTypeFieldNumber = 1,
    kUnitFieldNumber = 2,
  };
  void set_type(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_unit(int64_t value) {
    AppendVarInt(2, value);
  }
};

class Profile_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/14, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Profile_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Profile_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Profile_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sample_type() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> sample_type() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_sample() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> sample() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_mapping() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mapping() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_location() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> location() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_function() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> function() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_string_table() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> string_table() const { return GetRepeated<::protozero::ConstChars>(6); }
  bool has_drop_frames() const { return at<7>().valid(); }
  int64_t drop_frames() const { return at<7>().as_int64(); }
  bool has_keep_frames() const { return at<8>().valid(); }
  int64_t keep_frames() const { return at<8>().as_int64(); }
  bool has_time_nanos() const { return at<9>().valid(); }
  int64_t time_nanos() const { return at<9>().as_int64(); }
  bool has_duration_nanos() const { return at<10>().valid(); }
  int64_t duration_nanos() const { return at<10>().as_int64(); }
  bool has_period_type() const { return at<11>().valid(); }
  ::protozero::ConstBytes period_type() const { return at<11>().as_bytes(); }
  bool has_period() const { return at<12>().valid(); }
  int64_t period() const { return at<12>().as_int64(); }
  bool has_comment() const { return at<13>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t> comment(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t>(13, parse_error_ptr); }
  bool has_default_sample_type() const { return at<14>().valid(); }
  int64_t default_sample_type() const { return at<14>().as_int64(); }
};

class Profile : public ::protozero::Message {
 public:
  using Decoder = Profile_Decoder;
  enum : int32_t {
    kSampleTypeFieldNumber = 1,
    kSampleFieldNumber = 2,
    kMappingFieldNumber = 3,
    kLocationFieldNumber = 4,
    kFunctionFieldNumber = 5,
    kStringTableFieldNumber = 6,
    kDropFramesFieldNumber = 7,
    kKeepFramesFieldNumber = 8,
    kTimeNanosFieldNumber = 9,
    kDurationNanosFieldNumber = 10,
    kPeriodTypeFieldNumber = 11,
    kPeriodFieldNumber = 12,
    kCommentFieldNumber = 13,
    kDefaultSampleTypeFieldNumber = 14,
  };
  template <typename T = ValueType> T* add_sample_type() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = Sample> T* add_sample() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = Mapping> T* add_mapping() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = Location> T* add_location() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = Function> T* add_function() {
    return BeginNestedMessage<T>(5);
  }

  void add_string_table(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void add_string_table(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
  void set_drop_frames(int64_t value) {
    AppendVarInt(7, value);
  }
  void set_keep_frames(int64_t value) {
    AppendVarInt(8, value);
  }
  void set_time_nanos(int64_t value) {
    AppendVarInt(9, value);
  }
  void set_duration_nanos(int64_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = ValueType> T* set_period_type() {
    return BeginNestedMessage<T>(11);
  }

  void set_period(int64_t value) {
    AppendVarInt(12, value);
  }
  void set_comment(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(13, packed_buffer.data(), packed_buffer.size());
  }
  void set_default_sample_type(int64_t value) {
    AppendVarInt(14, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
