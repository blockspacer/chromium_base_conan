#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/profiling/profile_packet.gen.h"
#include "protos/perfetto/trace/profiling/profile_common.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

PerfSample::PerfSample() = default;
PerfSample::~PerfSample() = default;
PerfSample::PerfSample(const PerfSample&) = default;
PerfSample& PerfSample::operator=(const PerfSample&) = default;
PerfSample::PerfSample(PerfSample&&) noexcept = default;
PerfSample& PerfSample::operator=(PerfSample&&) = default;

bool PerfSample::operator==(const PerfSample& other) const {
  return unknown_fields_ == other.unknown_fields_
   && cpu_ == other.cpu_
   && pid_ == other.pid_
   && tid_ == other.tid_
   && cpu_mode_ == other.cpu_mode_
   && timebase_count_ == other.timebase_count_
   && callstack_iid_ == other.callstack_iid_
   && unwind_error_ == other.unwind_error_
   && kernel_records_lost_ == other.kernel_records_lost_
   && sample_skipped_reason_ == other.sample_skipped_reason_
   && producer_event_ == other.producer_event_;
}

bool PerfSample::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* cpu */:
        field.get(&cpu_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* tid */:
        field.get(&tid_);
        break;
      case 5 /* cpu_mode */:
        field.get(&cpu_mode_);
        break;
      case 6 /* timebase_count */:
        field.get(&timebase_count_);
        break;
      case 4 /* callstack_iid */:
        field.get(&callstack_iid_);
        break;
      case 16 /* unwind_error */:
        field.get(&unwind_error_);
        break;
      case 17 /* kernel_records_lost */:
        field.get(&kernel_records_lost_);
        break;
      case 18 /* sample_skipped_reason */:
        field.get(&sample_skipped_reason_);
        break;
      case 19 /* producer_event */:
        (*producer_event_).ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string PerfSample::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> PerfSample::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void PerfSample::Serialize(::protozero::Message* msg) const {
  // Field 1: cpu
  if (_has_field_[1]) {
    msg->AppendVarInt(1, cpu_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  // Field 3: tid
  if (_has_field_[3]) {
    msg->AppendVarInt(3, tid_);
  }

  // Field 5: cpu_mode
  if (_has_field_[5]) {
    msg->AppendVarInt(5, cpu_mode_);
  }

  // Field 6: timebase_count
  if (_has_field_[6]) {
    msg->AppendVarInt(6, timebase_count_);
  }

  // Field 4: callstack_iid
  if (_has_field_[4]) {
    msg->AppendVarInt(4, callstack_iid_);
  }

  // Field 16: unwind_error
  if (_has_field_[16]) {
    msg->AppendVarInt(16, unwind_error_);
  }

  // Field 17: kernel_records_lost
  if (_has_field_[17]) {
    msg->AppendVarInt(17, kernel_records_lost_);
  }

  // Field 18: sample_skipped_reason
  if (_has_field_[18]) {
    msg->AppendVarInt(18, sample_skipped_reason_);
  }

  // Field 19: producer_event
  if (_has_field_[19]) {
    (*producer_event_).Serialize(msg->BeginNestedMessage<::protozero::Message>(19));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


PerfSample_ProducerEvent::PerfSample_ProducerEvent() = default;
PerfSample_ProducerEvent::~PerfSample_ProducerEvent() = default;
PerfSample_ProducerEvent::PerfSample_ProducerEvent(const PerfSample_ProducerEvent&) = default;
PerfSample_ProducerEvent& PerfSample_ProducerEvent::operator=(const PerfSample_ProducerEvent&) = default;
PerfSample_ProducerEvent::PerfSample_ProducerEvent(PerfSample_ProducerEvent&&) noexcept = default;
PerfSample_ProducerEvent& PerfSample_ProducerEvent::operator=(PerfSample_ProducerEvent&&) = default;

bool PerfSample_ProducerEvent::operator==(const PerfSample_ProducerEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && source_stop_reason_ == other.source_stop_reason_;
}

bool PerfSample_ProducerEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* source_stop_reason */:
        field.get(&source_stop_reason_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string PerfSample_ProducerEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> PerfSample_ProducerEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void PerfSample_ProducerEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: source_stop_reason
  if (_has_field_[1]) {
    msg->AppendVarInt(1, source_stop_reason_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Profiling::Profiling() = default;
Profiling::~Profiling() = default;
Profiling::Profiling(const Profiling&) = default;
Profiling& Profiling::operator=(const Profiling&) = default;
Profiling::Profiling(Profiling&&) noexcept = default;
Profiling& Profiling::operator=(Profiling&&) = default;

bool Profiling::operator==(const Profiling& other) const {
  return unknown_fields_ == other.unknown_fields_;
}

bool Profiling::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Profiling::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Profiling::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Profiling::Serialize(::protozero::Message* msg) const {
  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


StreamingProfilePacket::StreamingProfilePacket() = default;
StreamingProfilePacket::~StreamingProfilePacket() = default;
StreamingProfilePacket::StreamingProfilePacket(const StreamingProfilePacket&) = default;
StreamingProfilePacket& StreamingProfilePacket::operator=(const StreamingProfilePacket&) = default;
StreamingProfilePacket::StreamingProfilePacket(StreamingProfilePacket&&) noexcept = default;
StreamingProfilePacket& StreamingProfilePacket::operator=(StreamingProfilePacket&&) = default;

bool StreamingProfilePacket::operator==(const StreamingProfilePacket& other) const {
  return unknown_fields_ == other.unknown_fields_
   && callstack_iid_ == other.callstack_iid_
   && timestamp_delta_us_ == other.timestamp_delta_us_
   && process_priority_ == other.process_priority_;
}

bool StreamingProfilePacket::ParseFromArray(const void* raw, size_t size) {
  callstack_iid_.clear();
  timestamp_delta_us_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* callstack_iid */:
        callstack_iid_.emplace_back();
        field.get(&callstack_iid_.back());
        break;
      case 2 /* timestamp_delta_us */:
        timestamp_delta_us_.emplace_back();
        field.get(&timestamp_delta_us_.back());
        break;
      case 3 /* process_priority */:
        field.get(&process_priority_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string StreamingProfilePacket::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> StreamingProfilePacket::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void StreamingProfilePacket::Serialize(::protozero::Message* msg) const {
  // Field 1: callstack_iid
  for (auto& it : callstack_iid_) {
    msg->AppendVarInt(1, it);
  }

  // Field 2: timestamp_delta_us
  for (auto& it : timestamp_delta_us_) {
    msg->AppendVarInt(2, it);
  }

  // Field 3: process_priority
  if (_has_field_[3]) {
    msg->AppendVarInt(3, process_priority_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


StreamingFree::StreamingFree() = default;
StreamingFree::~StreamingFree() = default;
StreamingFree::StreamingFree(const StreamingFree&) = default;
StreamingFree& StreamingFree::operator=(const StreamingFree&) = default;
StreamingFree::StreamingFree(StreamingFree&&) noexcept = default;
StreamingFree& StreamingFree::operator=(StreamingFree&&) = default;

bool StreamingFree::operator==(const StreamingFree& other) const {
  return unknown_fields_ == other.unknown_fields_
   && address_ == other.address_
   && heap_id_ == other.heap_id_
   && sequence_number_ == other.sequence_number_;
}

bool StreamingFree::ParseFromArray(const void* raw, size_t size) {
  address_.clear();
  heap_id_.clear();
  sequence_number_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* address */:
        address_.emplace_back();
        field.get(&address_.back());
        break;
      case 2 /* heap_id */:
        heap_id_.emplace_back();
        field.get(&heap_id_.back());
        break;
      case 3 /* sequence_number */:
        sequence_number_.emplace_back();
        field.get(&sequence_number_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string StreamingFree::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> StreamingFree::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void StreamingFree::Serialize(::protozero::Message* msg) const {
  // Field 1: address
  for (auto& it : address_) {
    msg->AppendVarInt(1, it);
  }

  // Field 2: heap_id
  for (auto& it : heap_id_) {
    msg->AppendVarInt(2, it);
  }

  // Field 3: sequence_number
  for (auto& it : sequence_number_) {
    msg->AppendVarInt(3, it);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


StreamingAllocation::StreamingAllocation() = default;
StreamingAllocation::~StreamingAllocation() = default;
StreamingAllocation::StreamingAllocation(const StreamingAllocation&) = default;
StreamingAllocation& StreamingAllocation::operator=(const StreamingAllocation&) = default;
StreamingAllocation::StreamingAllocation(StreamingAllocation&&) noexcept = default;
StreamingAllocation& StreamingAllocation::operator=(StreamingAllocation&&) = default;

bool StreamingAllocation::operator==(const StreamingAllocation& other) const {
  return unknown_fields_ == other.unknown_fields_
   && address_ == other.address_
   && size_ == other.size_
   && sample_size_ == other.sample_size_
   && clock_monotonic_coarse_timestamp_ == other.clock_monotonic_coarse_timestamp_
   && heap_id_ == other.heap_id_
   && sequence_number_ == other.sequence_number_;
}

bool StreamingAllocation::ParseFromArray(const void* raw, size_t size) {
  address_.clear();
  size_.clear();
  sample_size_.clear();
  clock_monotonic_coarse_timestamp_.clear();
  heap_id_.clear();
  sequence_number_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* address */:
        address_.emplace_back();
        field.get(&address_.back());
        break;
      case 2 /* size */:
        size_.emplace_back();
        field.get(&size_.back());
        break;
      case 3 /* sample_size */:
        sample_size_.emplace_back();
        field.get(&sample_size_.back());
        break;
      case 4 /* clock_monotonic_coarse_timestamp */:
        clock_monotonic_coarse_timestamp_.emplace_back();
        field.get(&clock_monotonic_coarse_timestamp_.back());
        break;
      case 5 /* heap_id */:
        heap_id_.emplace_back();
        field.get(&heap_id_.back());
        break;
      case 6 /* sequence_number */:
        sequence_number_.emplace_back();
        field.get(&sequence_number_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string StreamingAllocation::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> StreamingAllocation::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void StreamingAllocation::Serialize(::protozero::Message* msg) const {
  // Field 1: address
  for (auto& it : address_) {
    msg->AppendVarInt(1, it);
  }

  // Field 2: size
  for (auto& it : size_) {
    msg->AppendVarInt(2, it);
  }

  // Field 3: sample_size
  for (auto& it : sample_size_) {
    msg->AppendVarInt(3, it);
  }

  // Field 4: clock_monotonic_coarse_timestamp
  for (auto& it : clock_monotonic_coarse_timestamp_) {
    msg->AppendVarInt(4, it);
  }

  // Field 5: heap_id
  for (auto& it : heap_id_) {
    msg->AppendVarInt(5, it);
  }

  // Field 6: sequence_number
  for (auto& it : sequence_number_) {
    msg->AppendVarInt(6, it);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ProfilePacket::ProfilePacket() = default;
ProfilePacket::~ProfilePacket() = default;
ProfilePacket::ProfilePacket(const ProfilePacket&) = default;
ProfilePacket& ProfilePacket::operator=(const ProfilePacket&) = default;
ProfilePacket::ProfilePacket(ProfilePacket&&) noexcept = default;
ProfilePacket& ProfilePacket::operator=(ProfilePacket&&) = default;

bool ProfilePacket::operator==(const ProfilePacket& other) const {
  return unknown_fields_ == other.unknown_fields_
   && strings_ == other.strings_
   && mappings_ == other.mappings_
   && frames_ == other.frames_
   && callstacks_ == other.callstacks_
   && process_dumps_ == other.process_dumps_
   && continued_ == other.continued_
   && index_ == other.index_;
}

int ProfilePacket::strings_size() const { return static_cast<int>(strings_.size()); }
void ProfilePacket::clear_strings() { strings_.clear(); }
InternedString* ProfilePacket::add_strings() { strings_.emplace_back(); return &strings_.back(); }
int ProfilePacket::mappings_size() const { return static_cast<int>(mappings_.size()); }
void ProfilePacket::clear_mappings() { mappings_.clear(); }
Mapping* ProfilePacket::add_mappings() { mappings_.emplace_back(); return &mappings_.back(); }
int ProfilePacket::frames_size() const { return static_cast<int>(frames_.size()); }
void ProfilePacket::clear_frames() { frames_.clear(); }
Frame* ProfilePacket::add_frames() { frames_.emplace_back(); return &frames_.back(); }
int ProfilePacket::callstacks_size() const { return static_cast<int>(callstacks_.size()); }
void ProfilePacket::clear_callstacks() { callstacks_.clear(); }
Callstack* ProfilePacket::add_callstacks() { callstacks_.emplace_back(); return &callstacks_.back(); }
int ProfilePacket::process_dumps_size() const { return static_cast<int>(process_dumps_.size()); }
void ProfilePacket::clear_process_dumps() { process_dumps_.clear(); }
ProfilePacket_ProcessHeapSamples* ProfilePacket::add_process_dumps() { process_dumps_.emplace_back(); return &process_dumps_.back(); }
bool ProfilePacket::ParseFromArray(const void* raw, size_t size) {
  strings_.clear();
  mappings_.clear();
  frames_.clear();
  callstacks_.clear();
  process_dumps_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* strings */:
        strings_.emplace_back();
        strings_.back().ParseFromArray(field.data(), field.size());
        break;
      case 4 /* mappings */:
        mappings_.emplace_back();
        mappings_.back().ParseFromArray(field.data(), field.size());
        break;
      case 2 /* frames */:
        frames_.emplace_back();
        frames_.back().ParseFromArray(field.data(), field.size());
        break;
      case 3 /* callstacks */:
        callstacks_.emplace_back();
        callstacks_.back().ParseFromArray(field.data(), field.size());
        break;
      case 5 /* process_dumps */:
        process_dumps_.emplace_back();
        process_dumps_.back().ParseFromArray(field.data(), field.size());
        break;
      case 6 /* continued */:
        field.get(&continued_);
        break;
      case 7 /* index */:
        field.get(&index_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket::Serialize(::protozero::Message* msg) const {
  // Field 1: strings
  for (auto& it : strings_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  // Field 4: mappings
  for (auto& it : mappings_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  // Field 2: frames
  for (auto& it : frames_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  // Field 3: callstacks
  for (auto& it : callstacks_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  // Field 5: process_dumps
  for (auto& it : process_dumps_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(5));
  }

  // Field 6: continued
  if (_has_field_[6]) {
    msg->AppendTinyVarInt(6, continued_);
  }

  // Field 7: index
  if (_has_field_[7]) {
    msg->AppendVarInt(7, index_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ProfilePacket_ProcessHeapSamples::ProfilePacket_ProcessHeapSamples() = default;
ProfilePacket_ProcessHeapSamples::~ProfilePacket_ProcessHeapSamples() = default;
ProfilePacket_ProcessHeapSamples::ProfilePacket_ProcessHeapSamples(const ProfilePacket_ProcessHeapSamples&) = default;
ProfilePacket_ProcessHeapSamples& ProfilePacket_ProcessHeapSamples::operator=(const ProfilePacket_ProcessHeapSamples&) = default;
ProfilePacket_ProcessHeapSamples::ProfilePacket_ProcessHeapSamples(ProfilePacket_ProcessHeapSamples&&) noexcept = default;
ProfilePacket_ProcessHeapSamples& ProfilePacket_ProcessHeapSamples::operator=(ProfilePacket_ProcessHeapSamples&&) = default;

bool ProfilePacket_ProcessHeapSamples::operator==(const ProfilePacket_ProcessHeapSamples& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pid_ == other.pid_
   && from_startup_ == other.from_startup_
   && rejected_concurrent_ == other.rejected_concurrent_
   && disconnected_ == other.disconnected_
   && buffer_overran_ == other.buffer_overran_
   && client_error_ == other.client_error_
   && buffer_corrupted_ == other.buffer_corrupted_
   && hit_guardrail_ == other.hit_guardrail_
   && heap_name_ == other.heap_name_
   && sampling_interval_bytes_ == other.sampling_interval_bytes_
   && orig_sampling_interval_bytes_ == other.orig_sampling_interval_bytes_
   && timestamp_ == other.timestamp_
   && stats_ == other.stats_
   && samples_ == other.samples_;
}

int ProfilePacket_ProcessHeapSamples::samples_size() const { return static_cast<int>(samples_.size()); }
void ProfilePacket_ProcessHeapSamples::clear_samples() { samples_.clear(); }
ProfilePacket_HeapSample* ProfilePacket_ProcessHeapSamples::add_samples() { samples_.emplace_back(); return &samples_.back(); }
bool ProfilePacket_ProcessHeapSamples::ParseFromArray(const void* raw, size_t size) {
  samples_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* from_startup */:
        field.get(&from_startup_);
        break;
      case 4 /* rejected_concurrent */:
        field.get(&rejected_concurrent_);
        break;
      case 6 /* disconnected */:
        field.get(&disconnected_);
        break;
      case 7 /* buffer_overran */:
        field.get(&buffer_overran_);
        break;
      case 14 /* client_error */:
        field.get(&client_error_);
        break;
      case 8 /* buffer_corrupted */:
        field.get(&buffer_corrupted_);
        break;
      case 10 /* hit_guardrail */:
        field.get(&hit_guardrail_);
        break;
      case 11 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 12 /* sampling_interval_bytes */:
        field.get(&sampling_interval_bytes_);
        break;
      case 13 /* orig_sampling_interval_bytes */:
        field.get(&orig_sampling_interval_bytes_);
        break;
      case 9 /* timestamp */:
        field.get(&timestamp_);
        break;
      case 5 /* stats */:
        (*stats_).ParseFromArray(field.data(), field.size());
        break;
      case 2 /* samples */:
        samples_.emplace_back();
        samples_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_ProcessHeapSamples::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_ProcessHeapSamples::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_ProcessHeapSamples::Serialize(::protozero::Message* msg) const {
  // Field 1: pid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pid_);
  }

  // Field 3: from_startup
  if (_has_field_[3]) {
    msg->AppendTinyVarInt(3, from_startup_);
  }

  // Field 4: rejected_concurrent
  if (_has_field_[4]) {
    msg->AppendTinyVarInt(4, rejected_concurrent_);
  }

  // Field 6: disconnected
  if (_has_field_[6]) {
    msg->AppendTinyVarInt(6, disconnected_);
  }

  // Field 7: buffer_overran
  if (_has_field_[7]) {
    msg->AppendTinyVarInt(7, buffer_overran_);
  }

  // Field 14: client_error
  if (_has_field_[14]) {
    msg->AppendVarInt(14, client_error_);
  }

  // Field 8: buffer_corrupted
  if (_has_field_[8]) {
    msg->AppendTinyVarInt(8, buffer_corrupted_);
  }

  // Field 10: hit_guardrail
  if (_has_field_[10]) {
    msg->AppendTinyVarInt(10, hit_guardrail_);
  }

  // Field 11: heap_name
  if (_has_field_[11]) {
    msg->AppendString(11, heap_name_);
  }

  // Field 12: sampling_interval_bytes
  if (_has_field_[12]) {
    msg->AppendVarInt(12, sampling_interval_bytes_);
  }

  // Field 13: orig_sampling_interval_bytes
  if (_has_field_[13]) {
    msg->AppendVarInt(13, orig_sampling_interval_bytes_);
  }

  // Field 9: timestamp
  if (_has_field_[9]) {
    msg->AppendVarInt(9, timestamp_);
  }

  // Field 5: stats
  if (_has_field_[5]) {
    (*stats_).Serialize(msg->BeginNestedMessage<::protozero::Message>(5));
  }

  // Field 2: samples
  for (auto& it : samples_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ProfilePacket_HeapSample::ProfilePacket_HeapSample() = default;
ProfilePacket_HeapSample::~ProfilePacket_HeapSample() = default;
ProfilePacket_HeapSample::ProfilePacket_HeapSample(const ProfilePacket_HeapSample&) = default;
ProfilePacket_HeapSample& ProfilePacket_HeapSample::operator=(const ProfilePacket_HeapSample&) = default;
ProfilePacket_HeapSample::ProfilePacket_HeapSample(ProfilePacket_HeapSample&&) noexcept = default;
ProfilePacket_HeapSample& ProfilePacket_HeapSample::operator=(ProfilePacket_HeapSample&&) = default;

bool ProfilePacket_HeapSample::operator==(const ProfilePacket_HeapSample& other) const {
  return unknown_fields_ == other.unknown_fields_
   && callstack_id_ == other.callstack_id_
   && self_allocated_ == other.self_allocated_
   && self_freed_ == other.self_freed_
   && self_max_ == other.self_max_
   && self_max_count_ == other.self_max_count_
   && timestamp_ == other.timestamp_
   && alloc_count_ == other.alloc_count_
   && free_count_ == other.free_count_;
}

bool ProfilePacket_HeapSample::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* callstack_id */:
        field.get(&callstack_id_);
        break;
      case 2 /* self_allocated */:
        field.get(&self_allocated_);
        break;
      case 3 /* self_freed */:
        field.get(&self_freed_);
        break;
      case 8 /* self_max */:
        field.get(&self_max_);
        break;
      case 9 /* self_max_count */:
        field.get(&self_max_count_);
        break;
      case 4 /* timestamp */:
        field.get(&timestamp_);
        break;
      case 5 /* alloc_count */:
        field.get(&alloc_count_);
        break;
      case 6 /* free_count */:
        field.get(&free_count_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_HeapSample::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_HeapSample::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_HeapSample::Serialize(::protozero::Message* msg) const {
  // Field 1: callstack_id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, callstack_id_);
  }

  // Field 2: self_allocated
  if (_has_field_[2]) {
    msg->AppendVarInt(2, self_allocated_);
  }

  // Field 3: self_freed
  if (_has_field_[3]) {
    msg->AppendVarInt(3, self_freed_);
  }

  // Field 8: self_max
  if (_has_field_[8]) {
    msg->AppendVarInt(8, self_max_);
  }

  // Field 9: self_max_count
  if (_has_field_[9]) {
    msg->AppendVarInt(9, self_max_count_);
  }

  // Field 4: timestamp
  if (_has_field_[4]) {
    msg->AppendVarInt(4, timestamp_);
  }

  // Field 5: alloc_count
  if (_has_field_[5]) {
    msg->AppendVarInt(5, alloc_count_);
  }

  // Field 6: free_count
  if (_has_field_[6]) {
    msg->AppendVarInt(6, free_count_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ProfilePacket_ProcessStats::ProfilePacket_ProcessStats() = default;
ProfilePacket_ProcessStats::~ProfilePacket_ProcessStats() = default;
ProfilePacket_ProcessStats::ProfilePacket_ProcessStats(const ProfilePacket_ProcessStats&) = default;
ProfilePacket_ProcessStats& ProfilePacket_ProcessStats::operator=(const ProfilePacket_ProcessStats&) = default;
ProfilePacket_ProcessStats::ProfilePacket_ProcessStats(ProfilePacket_ProcessStats&&) noexcept = default;
ProfilePacket_ProcessStats& ProfilePacket_ProcessStats::operator=(ProfilePacket_ProcessStats&&) = default;

bool ProfilePacket_ProcessStats::operator==(const ProfilePacket_ProcessStats& other) const {
  return unknown_fields_ == other.unknown_fields_
   && unwinding_errors_ == other.unwinding_errors_
   && heap_samples_ == other.heap_samples_
   && map_reparses_ == other.map_reparses_
   && unwinding_time_us_ == other.unwinding_time_us_
   && total_unwinding_time_us_ == other.total_unwinding_time_us_
   && client_spinlock_blocked_us_ == other.client_spinlock_blocked_us_;
}

bool ProfilePacket_ProcessStats::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* unwinding_errors */:
        field.get(&unwinding_errors_);
        break;
      case 2 /* heap_samples */:
        field.get(&heap_samples_);
        break;
      case 3 /* map_reparses */:
        field.get(&map_reparses_);
        break;
      case 4 /* unwinding_time_us */:
        (*unwinding_time_us_).ParseFromArray(field.data(), field.size());
        break;
      case 5 /* total_unwinding_time_us */:
        field.get(&total_unwinding_time_us_);
        break;
      case 6 /* client_spinlock_blocked_us */:
        field.get(&client_spinlock_blocked_us_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_ProcessStats::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_ProcessStats::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_ProcessStats::Serialize(::protozero::Message* msg) const {
  // Field 1: unwinding_errors
  if (_has_field_[1]) {
    msg->AppendVarInt(1, unwinding_errors_);
  }

  // Field 2: heap_samples
  if (_has_field_[2]) {
    msg->AppendVarInt(2, heap_samples_);
  }

  // Field 3: map_reparses
  if (_has_field_[3]) {
    msg->AppendVarInt(3, map_reparses_);
  }

  // Field 4: unwinding_time_us
  if (_has_field_[4]) {
    (*unwinding_time_us_).Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  // Field 5: total_unwinding_time_us
  if (_has_field_[5]) {
    msg->AppendVarInt(5, total_unwinding_time_us_);
  }

  // Field 6: client_spinlock_blocked_us
  if (_has_field_[6]) {
    msg->AppendVarInt(6, client_spinlock_blocked_us_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ProfilePacket_Histogram::ProfilePacket_Histogram() = default;
ProfilePacket_Histogram::~ProfilePacket_Histogram() = default;
ProfilePacket_Histogram::ProfilePacket_Histogram(const ProfilePacket_Histogram&) = default;
ProfilePacket_Histogram& ProfilePacket_Histogram::operator=(const ProfilePacket_Histogram&) = default;
ProfilePacket_Histogram::ProfilePacket_Histogram(ProfilePacket_Histogram&&) noexcept = default;
ProfilePacket_Histogram& ProfilePacket_Histogram::operator=(ProfilePacket_Histogram&&) = default;

bool ProfilePacket_Histogram::operator==(const ProfilePacket_Histogram& other) const {
  return unknown_fields_ == other.unknown_fields_
   && buckets_ == other.buckets_;
}

int ProfilePacket_Histogram::buckets_size() const { return static_cast<int>(buckets_.size()); }
void ProfilePacket_Histogram::clear_buckets() { buckets_.clear(); }
ProfilePacket_Histogram_Bucket* ProfilePacket_Histogram::add_buckets() { buckets_.emplace_back(); return &buckets_.back(); }
bool ProfilePacket_Histogram::ParseFromArray(const void* raw, size_t size) {
  buckets_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* buckets */:
        buckets_.emplace_back();
        buckets_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_Histogram::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_Histogram::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_Histogram::Serialize(::protozero::Message* msg) const {
  // Field 1: buckets
  for (auto& it : buckets_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ProfilePacket_Histogram_Bucket::ProfilePacket_Histogram_Bucket() = default;
ProfilePacket_Histogram_Bucket::~ProfilePacket_Histogram_Bucket() = default;
ProfilePacket_Histogram_Bucket::ProfilePacket_Histogram_Bucket(const ProfilePacket_Histogram_Bucket&) = default;
ProfilePacket_Histogram_Bucket& ProfilePacket_Histogram_Bucket::operator=(const ProfilePacket_Histogram_Bucket&) = default;
ProfilePacket_Histogram_Bucket::ProfilePacket_Histogram_Bucket(ProfilePacket_Histogram_Bucket&&) noexcept = default;
ProfilePacket_Histogram_Bucket& ProfilePacket_Histogram_Bucket::operator=(ProfilePacket_Histogram_Bucket&&) = default;

bool ProfilePacket_Histogram_Bucket::operator==(const ProfilePacket_Histogram_Bucket& other) const {
  return unknown_fields_ == other.unknown_fields_
   && upper_limit_ == other.upper_limit_
   && max_bucket_ == other.max_bucket_
   && count_ == other.count_;
}

bool ProfilePacket_Histogram_Bucket::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* upper_limit */:
        field.get(&upper_limit_);
        break;
      case 2 /* max_bucket */:
        field.get(&max_bucket_);
        break;
      case 3 /* count */:
        field.get(&count_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_Histogram_Bucket::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_Histogram_Bucket::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_Histogram_Bucket::Serialize(::protozero::Message* msg) const {
  // Field 1: upper_limit
  if (_has_field_[1]) {
    msg->AppendVarInt(1, upper_limit_);
  }

  // Field 2: max_bucket
  if (_has_field_[2]) {
    msg->AppendTinyVarInt(2, max_bucket_);
  }

  // Field 3: count
  if (_has_field_[3]) {
    msg->AppendVarInt(3, count_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
