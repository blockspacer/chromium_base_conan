// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_COMMON_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_COMMON_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class Callstack;
class Frame;
class Mapping;
class ModuleSymbols;
class AddressSymbols;
class Line;
class ProfiledFrameSymbols;
class InternedString;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT Callstack : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kFrameIdsFieldNumber = 2,
  };

  Callstack();
  ~Callstack() override;
  Callstack(Callstack&&) noexcept;
  Callstack& operator=(Callstack&&);
  Callstack(const Callstack&);
  Callstack& operator=(const Callstack&);
  bool operator==(const Callstack&) const;
  bool operator!=(const Callstack& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  const std::vector<uint64_t>& frame_ids() const { return frame_ids_; }
  std::vector<uint64_t>* mutable_frame_ids() { return &frame_ids_; }
  int frame_ids_size() const { return static_cast<int>(frame_ids_.size()); }
  void clear_frame_ids() { frame_ids_.clear(); }
  void add_frame_ids(uint64_t value) { frame_ids_.emplace_back(value); }
  uint64_t* add_frame_ids() { frame_ids_.emplace_back(); return &frame_ids_.back(); }

 private:
  uint64_t iid_{};
  std::vector<uint64_t> frame_ids_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Frame : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kFunctionNameIdFieldNumber = 2,
    kMappingIdFieldNumber = 3,
    kRelPcFieldNumber = 4,
  };

  Frame();
  ~Frame() override;
  Frame(Frame&&) noexcept;
  Frame& operator=(Frame&&);
  Frame(const Frame&);
  Frame& operator=(const Frame&);
  bool operator==(const Frame&) const;
  bool operator!=(const Frame& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  bool has_function_name_id() const { return _has_field_[2]; }
  uint64_t function_name_id() const { return function_name_id_; }
  void set_function_name_id(uint64_t value) { function_name_id_ = value; _has_field_.set(2); }

  bool has_mapping_id() const { return _has_field_[3]; }
  uint64_t mapping_id() const { return mapping_id_; }
  void set_mapping_id(uint64_t value) { mapping_id_ = value; _has_field_.set(3); }

  bool has_rel_pc() const { return _has_field_[4]; }
  uint64_t rel_pc() const { return rel_pc_; }
  void set_rel_pc(uint64_t value) { rel_pc_ = value; _has_field_.set(4); }

 private:
  uint64_t iid_{};
  uint64_t function_name_id_{};
  uint64_t mapping_id_{};
  uint64_t rel_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Mapping : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kBuildIdFieldNumber = 2,
    kExactOffsetFieldNumber = 8,
    kStartOffsetFieldNumber = 3,
    kStartFieldNumber = 4,
    kEndFieldNumber = 5,
    kLoadBiasFieldNumber = 6,
    kPathStringIdsFieldNumber = 7,
  };

  Mapping();
  ~Mapping() override;
  Mapping(Mapping&&) noexcept;
  Mapping& operator=(Mapping&&);
  Mapping(const Mapping&);
  Mapping& operator=(const Mapping&);
  bool operator==(const Mapping&) const;
  bool operator!=(const Mapping& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  bool has_build_id() const { return _has_field_[2]; }
  uint64_t build_id() const { return build_id_; }
  void set_build_id(uint64_t value) { build_id_ = value; _has_field_.set(2); }

  bool has_exact_offset() const { return _has_field_[8]; }
  uint64_t exact_offset() const { return exact_offset_; }
  void set_exact_offset(uint64_t value) { exact_offset_ = value; _has_field_.set(8); }

  bool has_start_offset() const { return _has_field_[3]; }
  uint64_t start_offset() const { return start_offset_; }
  void set_start_offset(uint64_t value) { start_offset_ = value; _has_field_.set(3); }

  bool has_start() const { return _has_field_[4]; }
  uint64_t start() const { return start_; }
  void set_start(uint64_t value) { start_ = value; _has_field_.set(4); }

  bool has_end() const { return _has_field_[5]; }
  uint64_t end() const { return end_; }
  void set_end(uint64_t value) { end_ = value; _has_field_.set(5); }

  bool has_load_bias() const { return _has_field_[6]; }
  uint64_t load_bias() const { return load_bias_; }
  void set_load_bias(uint64_t value) { load_bias_ = value; _has_field_.set(6); }

  const std::vector<uint64_t>& path_string_ids() const { return path_string_ids_; }
  std::vector<uint64_t>* mutable_path_string_ids() { return &path_string_ids_; }
  int path_string_ids_size() const { return static_cast<int>(path_string_ids_.size()); }
  void clear_path_string_ids() { path_string_ids_.clear(); }
  void add_path_string_ids(uint64_t value) { path_string_ids_.emplace_back(value); }
  uint64_t* add_path_string_ids() { path_string_ids_.emplace_back(); return &path_string_ids_.back(); }

 private:
  uint64_t iid_{};
  uint64_t build_id_{};
  uint64_t exact_offset_{};
  uint64_t start_offset_{};
  uint64_t start_{};
  uint64_t end_{};
  uint64_t load_bias_{};
  std::vector<uint64_t> path_string_ids_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT ModuleSymbols : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPathFieldNumber = 1,
    kBuildIdFieldNumber = 2,
    kAddressSymbolsFieldNumber = 3,
  };

  ModuleSymbols();
  ~ModuleSymbols() override;
  ModuleSymbols(ModuleSymbols&&) noexcept;
  ModuleSymbols& operator=(ModuleSymbols&&);
  ModuleSymbols(const ModuleSymbols&);
  ModuleSymbols& operator=(const ModuleSymbols&);
  bool operator==(const ModuleSymbols&) const;
  bool operator!=(const ModuleSymbols& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_path() const { return _has_field_[1]; }
  const std::string& path() const { return path_; }
  void set_path(const std::string& value) { path_ = value; _has_field_.set(1); }

  bool has_build_id() const { return _has_field_[2]; }
  const std::string& build_id() const { return build_id_; }
  void set_build_id(const std::string& value) { build_id_ = value; _has_field_.set(2); }

  const std::vector<AddressSymbols>& address_symbols() const { return address_symbols_; }
  std::vector<AddressSymbols>* mutable_address_symbols() { return &address_symbols_; }
  int address_symbols_size() const;
  void clear_address_symbols();
  AddressSymbols* add_address_symbols();

 private:
  std::string path_{};
  std::string build_id_{};
  std::vector<AddressSymbols> address_symbols_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT AddressSymbols : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAddressFieldNumber = 1,
    kLinesFieldNumber = 2,
  };

  AddressSymbols();
  ~AddressSymbols() override;
  AddressSymbols(AddressSymbols&&) noexcept;
  AddressSymbols& operator=(AddressSymbols&&);
  AddressSymbols(const AddressSymbols&);
  AddressSymbols& operator=(const AddressSymbols&);
  bool operator==(const AddressSymbols&) const;
  bool operator!=(const AddressSymbols& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_address() const { return _has_field_[1]; }
  uint64_t address() const { return address_; }
  void set_address(uint64_t value) { address_ = value; _has_field_.set(1); }

  const std::vector<Line>& lines() const { return lines_; }
  std::vector<Line>* mutable_lines() { return &lines_; }
  int lines_size() const;
  void clear_lines();
  Line* add_lines();

 private:
  uint64_t address_{};
  std::vector<Line> lines_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Line : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFunctionNameFieldNumber = 1,
    kSourceFileNameFieldNumber = 2,
    kLineNumberFieldNumber = 3,
  };

  Line();
  ~Line() override;
  Line(Line&&) noexcept;
  Line& operator=(Line&&);
  Line(const Line&);
  Line& operator=(const Line&);
  bool operator==(const Line&) const;
  bool operator!=(const Line& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_function_name() const { return _has_field_[1]; }
  const std::string& function_name() const { return function_name_; }
  void set_function_name(const std::string& value) { function_name_ = value; _has_field_.set(1); }

  bool has_source_file_name() const { return _has_field_[2]; }
  const std::string& source_file_name() const { return source_file_name_; }
  void set_source_file_name(const std::string& value) { source_file_name_ = value; _has_field_.set(2); }

  bool has_line_number() const { return _has_field_[3]; }
  uint32_t line_number() const { return line_number_; }
  void set_line_number(uint32_t value) { line_number_ = value; _has_field_.set(3); }

 private:
  std::string function_name_{};
  std::string source_file_name_{};
  uint32_t line_number_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT ProfiledFrameSymbols : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFrameIidFieldNumber = 1,
    kFunctionNameIdFieldNumber = 2,
    kFileNameIdFieldNumber = 3,
    kLineNumberFieldNumber = 4,
  };

  ProfiledFrameSymbols();
  ~ProfiledFrameSymbols() override;
  ProfiledFrameSymbols(ProfiledFrameSymbols&&) noexcept;
  ProfiledFrameSymbols& operator=(ProfiledFrameSymbols&&);
  ProfiledFrameSymbols(const ProfiledFrameSymbols&);
  ProfiledFrameSymbols& operator=(const ProfiledFrameSymbols&);
  bool operator==(const ProfiledFrameSymbols&) const;
  bool operator!=(const ProfiledFrameSymbols& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_frame_iid() const { return _has_field_[1]; }
  uint64_t frame_iid() const { return frame_iid_; }
  void set_frame_iid(uint64_t value) { frame_iid_ = value; _has_field_.set(1); }

  const std::vector<uint64_t>& function_name_id() const { return function_name_id_; }
  std::vector<uint64_t>* mutable_function_name_id() { return &function_name_id_; }
  int function_name_id_size() const { return static_cast<int>(function_name_id_.size()); }
  void clear_function_name_id() { function_name_id_.clear(); }
  void add_function_name_id(uint64_t value) { function_name_id_.emplace_back(value); }
  uint64_t* add_function_name_id() { function_name_id_.emplace_back(); return &function_name_id_.back(); }

  const std::vector<uint64_t>& file_name_id() const { return file_name_id_; }
  std::vector<uint64_t>* mutable_file_name_id() { return &file_name_id_; }
  int file_name_id_size() const { return static_cast<int>(file_name_id_.size()); }
  void clear_file_name_id() { file_name_id_.clear(); }
  void add_file_name_id(uint64_t value) { file_name_id_.emplace_back(value); }
  uint64_t* add_file_name_id() { file_name_id_.emplace_back(); return &file_name_id_.back(); }

  const std::vector<uint32_t>& line_number() const { return line_number_; }
  std::vector<uint32_t>* mutable_line_number() { return &line_number_; }
  int line_number_size() const { return static_cast<int>(line_number_.size()); }
  void clear_line_number() { line_number_.clear(); }
  void add_line_number(uint32_t value) { line_number_.emplace_back(value); }
  uint32_t* add_line_number() { line_number_.emplace_back(); return &line_number_.back(); }

 private:
  uint64_t frame_iid_{};
  std::vector<uint64_t> function_name_id_;
  std::vector<uint64_t> file_name_id_;
  std::vector<uint32_t> line_number_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT InternedString : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kStrFieldNumber = 2,
  };

  InternedString();
  ~InternedString() override;
  InternedString(InternedString&&) noexcept;
  InternedString& operator=(InternedString&&);
  InternedString(const InternedString&);
  InternedString& operator=(const InternedString&);
  bool operator==(const InternedString&) const;
  bool operator!=(const InternedString& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  bool has_str() const { return _has_field_[2]; }
  const std::string& str() const { return str_; }
  void set_str(const std::string& value) { str_ = value; _has_field_.set(2); }
  void set_str(const void* p, size_t s) { str_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(2); }

 private:
  uint64_t iid_{};
  std::string str_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_COMMON_PROTO_CPP_H_
