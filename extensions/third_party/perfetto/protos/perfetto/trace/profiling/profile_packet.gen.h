// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class PerfSample;
class PerfSample_ProducerEvent;
class Profiling;
class StreamingProfilePacket;
class StreamingFree;
class StreamingAllocation;
class ProfilePacket;
class ProfilePacket_ProcessHeapSamples;
class ProfilePacket_HeapSample;
class ProfilePacket_ProcessStats;
class ProfilePacket_Histogram;
class ProfilePacket_Histogram_Bucket;
class Callstack;
class Frame;
class Mapping;
class InternedString;
enum PerfSample_SampleSkipReason : int;
enum Profiling_CpuMode : int;
enum Profiling_StackUnwindError : int;
enum PerfSample_ProducerEvent_DataSourceStopReason : int;
enum ProfilePacket_ProcessHeapSamples_ClientError : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum PerfSample_SampleSkipReason : int {
  PerfSample_SampleSkipReason_PROFILER_SKIP_UNKNOWN = 0,
  PerfSample_SampleSkipReason_PROFILER_SKIP_READ_STAGE = 1,
  PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_STAGE = 2,
  PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_ENQUEUE = 3,
};
enum Profiling_CpuMode : int {
  Profiling_CpuMode_MODE_UNKNOWN = 0,
  Profiling_CpuMode_MODE_KERNEL = 1,
  Profiling_CpuMode_MODE_USER = 2,
  Profiling_CpuMode_MODE_HYPERVISOR = 3,
  Profiling_CpuMode_MODE_GUEST_KERNEL = 4,
  Profiling_CpuMode_MODE_GUEST_USER = 5,
};
enum Profiling_StackUnwindError : int {
  Profiling_StackUnwindError_UNWIND_ERROR_UNKNOWN = 0,
  Profiling_StackUnwindError_UNWIND_ERROR_NONE = 1,
  Profiling_StackUnwindError_UNWIND_ERROR_MEMORY_INVALID = 2,
  Profiling_StackUnwindError_UNWIND_ERROR_UNWIND_INFO = 3,
  Profiling_StackUnwindError_UNWIND_ERROR_UNSUPPORTED = 4,
  Profiling_StackUnwindError_UNWIND_ERROR_INVALID_MAP = 5,
  Profiling_StackUnwindError_UNWIND_ERROR_MAX_FRAMES_EXCEEDED = 6,
  Profiling_StackUnwindError_UNWIND_ERROR_REPEATED_FRAME = 7,
  Profiling_StackUnwindError_UNWIND_ERROR_INVALID_ELF = 8,
  Profiling_StackUnwindError_UNWIND_ERROR_SYSTEM_CALL = 9,
  Profiling_StackUnwindError_UNWIND_ERROR_THREAD_TIMEOUT = 10,
  Profiling_StackUnwindError_UNWIND_ERROR_THREAD_DOES_NOT_EXIST = 11,
};
enum PerfSample_ProducerEvent_DataSourceStopReason : int {
  PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_UNKNOWN = 0,
  PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_GUARDRAIL = 1,
};
enum ProfilePacket_ProcessHeapSamples_ClientError : int {
  ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_NONE = 0,
  ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_HIT_TIMEOUT = 1,
  ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_INVALID_STACK_BOUNDS = 2,
};

class PERFETTO_EXPORT PerfSample : public ::protozero::CppMessageObj {
 public:
  using ProducerEvent = PerfSample_ProducerEvent;
  using SampleSkipReason = PerfSample_SampleSkipReason;
  static constexpr auto PROFILER_SKIP_UNKNOWN = PerfSample_SampleSkipReason_PROFILER_SKIP_UNKNOWN;
  static constexpr auto PROFILER_SKIP_READ_STAGE = PerfSample_SampleSkipReason_PROFILER_SKIP_READ_STAGE;
  static constexpr auto PROFILER_SKIP_UNWIND_STAGE = PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_STAGE;
  static constexpr auto PROFILER_SKIP_UNWIND_ENQUEUE = PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_ENQUEUE;
  static constexpr auto SampleSkipReason_MIN = PerfSample_SampleSkipReason_PROFILER_SKIP_UNKNOWN;
  static constexpr auto SampleSkipReason_MAX = PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_ENQUEUE;
  enum FieldNumbers {
    kCpuFieldNumber = 1,
    kPidFieldNumber = 2,
    kTidFieldNumber = 3,
    kCpuModeFieldNumber = 5,
    kTimebaseCountFieldNumber = 6,
    kCallstackIidFieldNumber = 4,
    kUnwindErrorFieldNumber = 16,
    kKernelRecordsLostFieldNumber = 17,
    kSampleSkippedReasonFieldNumber = 18,
    kProducerEventFieldNumber = 19,
  };

  PerfSample();
  ~PerfSample() override;
  PerfSample(PerfSample&&) noexcept;
  PerfSample& operator=(PerfSample&&);
  PerfSample(const PerfSample&);
  PerfSample& operator=(const PerfSample&);
  bool operator==(const PerfSample&) const;
  bool operator!=(const PerfSample& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cpu() const { return _has_field_[1]; }
  uint32_t cpu() const { return cpu_; }
  void set_cpu(uint32_t value) { cpu_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  uint32_t pid() const { return pid_; }
  void set_pid(uint32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_tid() const { return _has_field_[3]; }
  uint32_t tid() const { return tid_; }
  void set_tid(uint32_t value) { tid_ = value; _has_field_.set(3); }

  bool has_cpu_mode() const { return _has_field_[5]; }
  Profiling_CpuMode cpu_mode() const { return cpu_mode_; }
  void set_cpu_mode(Profiling_CpuMode value) { cpu_mode_ = value; _has_field_.set(5); }

  bool has_timebase_count() const { return _has_field_[6]; }
  uint64_t timebase_count() const { return timebase_count_; }
  void set_timebase_count(uint64_t value) { timebase_count_ = value; _has_field_.set(6); }

  bool has_callstack_iid() const { return _has_field_[4]; }
  uint64_t callstack_iid() const { return callstack_iid_; }
  void set_callstack_iid(uint64_t value) { callstack_iid_ = value; _has_field_.set(4); }

  bool has_unwind_error() const { return _has_field_[16]; }
  Profiling_StackUnwindError unwind_error() const { return unwind_error_; }
  void set_unwind_error(Profiling_StackUnwindError value) { unwind_error_ = value; _has_field_.set(16); }

  bool has_kernel_records_lost() const { return _has_field_[17]; }
  uint64_t kernel_records_lost() const { return kernel_records_lost_; }
  void set_kernel_records_lost(uint64_t value) { kernel_records_lost_ = value; _has_field_.set(17); }

  bool has_sample_skipped_reason() const { return _has_field_[18]; }
  PerfSample_SampleSkipReason sample_skipped_reason() const { return sample_skipped_reason_; }
  void set_sample_skipped_reason(PerfSample_SampleSkipReason value) { sample_skipped_reason_ = value; _has_field_.set(18); }

  bool has_producer_event() const { return _has_field_[19]; }
  const PerfSample_ProducerEvent& producer_event() const { return *producer_event_; }
  PerfSample_ProducerEvent* mutable_producer_event() { _has_field_.set(19); return producer_event_.get(); }

 private:
  uint32_t cpu_{};
  uint32_t pid_{};
  uint32_t tid_{};
  Profiling_CpuMode cpu_mode_{};
  uint64_t timebase_count_{};
  uint64_t callstack_iid_{};
  Profiling_StackUnwindError unwind_error_{};
  uint64_t kernel_records_lost_{};
  PerfSample_SampleSkipReason sample_skipped_reason_{};
  ::protozero::CopyablePtr<PerfSample_ProducerEvent> producer_event_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<20> _has_field_{};
};


class PERFETTO_EXPORT PerfSample_ProducerEvent : public ::protozero::CppMessageObj {
 public:
  using DataSourceStopReason = PerfSample_ProducerEvent_DataSourceStopReason;
  static constexpr auto PROFILER_STOP_UNKNOWN = PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_UNKNOWN;
  static constexpr auto PROFILER_STOP_GUARDRAIL = PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_GUARDRAIL;
  static constexpr auto DataSourceStopReason_MIN = PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_UNKNOWN;
  static constexpr auto DataSourceStopReason_MAX = PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_GUARDRAIL;
  enum FieldNumbers {
    kSourceStopReasonFieldNumber = 1,
  };

  PerfSample_ProducerEvent();
  ~PerfSample_ProducerEvent() override;
  PerfSample_ProducerEvent(PerfSample_ProducerEvent&&) noexcept;
  PerfSample_ProducerEvent& operator=(PerfSample_ProducerEvent&&);
  PerfSample_ProducerEvent(const PerfSample_ProducerEvent&);
  PerfSample_ProducerEvent& operator=(const PerfSample_ProducerEvent&);
  bool operator==(const PerfSample_ProducerEvent&) const;
  bool operator!=(const PerfSample_ProducerEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_source_stop_reason() const { return _has_field_[1]; }
  PerfSample_ProducerEvent_DataSourceStopReason source_stop_reason() const { return source_stop_reason_; }
  void set_source_stop_reason(PerfSample_ProducerEvent_DataSourceStopReason value) { source_stop_reason_ = value; _has_field_.set(1); }

 private:
  PerfSample_ProducerEvent_DataSourceStopReason source_stop_reason_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT Profiling : public ::protozero::CppMessageObj {
 public:
  using CpuMode = Profiling_CpuMode;
  static constexpr auto MODE_UNKNOWN = Profiling_CpuMode_MODE_UNKNOWN;
  static constexpr auto MODE_KERNEL = Profiling_CpuMode_MODE_KERNEL;
  static constexpr auto MODE_USER = Profiling_CpuMode_MODE_USER;
  static constexpr auto MODE_HYPERVISOR = Profiling_CpuMode_MODE_HYPERVISOR;
  static constexpr auto MODE_GUEST_KERNEL = Profiling_CpuMode_MODE_GUEST_KERNEL;
  static constexpr auto MODE_GUEST_USER = Profiling_CpuMode_MODE_GUEST_USER;
  static constexpr auto CpuMode_MIN = Profiling_CpuMode_MODE_UNKNOWN;
  static constexpr auto CpuMode_MAX = Profiling_CpuMode_MODE_GUEST_USER;
  using StackUnwindError = Profiling_StackUnwindError;
  static constexpr auto UNWIND_ERROR_UNKNOWN = Profiling_StackUnwindError_UNWIND_ERROR_UNKNOWN;
  static constexpr auto UNWIND_ERROR_NONE = Profiling_StackUnwindError_UNWIND_ERROR_NONE;
  static constexpr auto UNWIND_ERROR_MEMORY_INVALID = Profiling_StackUnwindError_UNWIND_ERROR_MEMORY_INVALID;
  static constexpr auto UNWIND_ERROR_UNWIND_INFO = Profiling_StackUnwindError_UNWIND_ERROR_UNWIND_INFO;
  static constexpr auto UNWIND_ERROR_UNSUPPORTED = Profiling_StackUnwindError_UNWIND_ERROR_UNSUPPORTED;
  static constexpr auto UNWIND_ERROR_INVALID_MAP = Profiling_StackUnwindError_UNWIND_ERROR_INVALID_MAP;
  static constexpr auto UNWIND_ERROR_MAX_FRAMES_EXCEEDED = Profiling_StackUnwindError_UNWIND_ERROR_MAX_FRAMES_EXCEEDED;
  static constexpr auto UNWIND_ERROR_REPEATED_FRAME = Profiling_StackUnwindError_UNWIND_ERROR_REPEATED_FRAME;
  static constexpr auto UNWIND_ERROR_INVALID_ELF = Profiling_StackUnwindError_UNWIND_ERROR_INVALID_ELF;
  static constexpr auto UNWIND_ERROR_SYSTEM_CALL = Profiling_StackUnwindError_UNWIND_ERROR_SYSTEM_CALL;
  static constexpr auto UNWIND_ERROR_THREAD_TIMEOUT = Profiling_StackUnwindError_UNWIND_ERROR_THREAD_TIMEOUT;
  static constexpr auto UNWIND_ERROR_THREAD_DOES_NOT_EXIST = Profiling_StackUnwindError_UNWIND_ERROR_THREAD_DOES_NOT_EXIST;
  static constexpr auto StackUnwindError_MIN = Profiling_StackUnwindError_UNWIND_ERROR_UNKNOWN;
  static constexpr auto StackUnwindError_MAX = Profiling_StackUnwindError_UNWIND_ERROR_THREAD_DOES_NOT_EXIST;
  enum FieldNumbers {
  };

  Profiling();
  ~Profiling() override;
  Profiling(Profiling&&) noexcept;
  Profiling& operator=(Profiling&&);
  Profiling(const Profiling&);
  Profiling& operator=(const Profiling&);
  bool operator==(const Profiling&) const;
  bool operator!=(const Profiling& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

 private:

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT StreamingProfilePacket : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCallstackIidFieldNumber = 1,
    kTimestampDeltaUsFieldNumber = 2,
    kProcessPriorityFieldNumber = 3,
  };

  StreamingProfilePacket();
  ~StreamingProfilePacket() override;
  StreamingProfilePacket(StreamingProfilePacket&&) noexcept;
  StreamingProfilePacket& operator=(StreamingProfilePacket&&);
  StreamingProfilePacket(const StreamingProfilePacket&);
  StreamingProfilePacket& operator=(const StreamingProfilePacket&);
  bool operator==(const StreamingProfilePacket&) const;
  bool operator!=(const StreamingProfilePacket& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<uint64_t>& callstack_iid() const { return callstack_iid_; }
  std::vector<uint64_t>* mutable_callstack_iid() { return &callstack_iid_; }
  int callstack_iid_size() const { return static_cast<int>(callstack_iid_.size()); }
  void clear_callstack_iid() { callstack_iid_.clear(); }
  void add_callstack_iid(uint64_t value) { callstack_iid_.emplace_back(value); }
  uint64_t* add_callstack_iid() { callstack_iid_.emplace_back(); return &callstack_iid_.back(); }

  const std::vector<int64_t>& timestamp_delta_us() const { return timestamp_delta_us_; }
  std::vector<int64_t>* mutable_timestamp_delta_us() { return &timestamp_delta_us_; }
  int timestamp_delta_us_size() const { return static_cast<int>(timestamp_delta_us_.size()); }
  void clear_timestamp_delta_us() { timestamp_delta_us_.clear(); }
  void add_timestamp_delta_us(int64_t value) { timestamp_delta_us_.emplace_back(value); }
  int64_t* add_timestamp_delta_us() { timestamp_delta_us_.emplace_back(); return &timestamp_delta_us_.back(); }

  bool has_process_priority() const { return _has_field_[3]; }
  int32_t process_priority() const { return process_priority_; }
  void set_process_priority(int32_t value) { process_priority_ = value; _has_field_.set(3); }

 private:
  std::vector<uint64_t> callstack_iid_;
  std::vector<int64_t> timestamp_delta_us_;
  int32_t process_priority_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT StreamingFree : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAddressFieldNumber = 1,
    kHeapIdFieldNumber = 2,
    kSequenceNumberFieldNumber = 3,
  };

  StreamingFree();
  ~StreamingFree() override;
  StreamingFree(StreamingFree&&) noexcept;
  StreamingFree& operator=(StreamingFree&&);
  StreamingFree(const StreamingFree&);
  StreamingFree& operator=(const StreamingFree&);
  bool operator==(const StreamingFree&) const;
  bool operator!=(const StreamingFree& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<uint64_t>& address() const { return address_; }
  std::vector<uint64_t>* mutable_address() { return &address_; }
  int address_size() const { return static_cast<int>(address_.size()); }
  void clear_address() { address_.clear(); }
  void add_address(uint64_t value) { address_.emplace_back(value); }
  uint64_t* add_address() { address_.emplace_back(); return &address_.back(); }

  const std::vector<uint32_t>& heap_id() const { return heap_id_; }
  std::vector<uint32_t>* mutable_heap_id() { return &heap_id_; }
  int heap_id_size() const { return static_cast<int>(heap_id_.size()); }
  void clear_heap_id() { heap_id_.clear(); }
  void add_heap_id(uint32_t value) { heap_id_.emplace_back(value); }
  uint32_t* add_heap_id() { heap_id_.emplace_back(); return &heap_id_.back(); }

  const std::vector<uint64_t>& sequence_number() const { return sequence_number_; }
  std::vector<uint64_t>* mutable_sequence_number() { return &sequence_number_; }
  int sequence_number_size() const { return static_cast<int>(sequence_number_.size()); }
  void clear_sequence_number() { sequence_number_.clear(); }
  void add_sequence_number(uint64_t value) { sequence_number_.emplace_back(value); }
  uint64_t* add_sequence_number() { sequence_number_.emplace_back(); return &sequence_number_.back(); }

 private:
  std::vector<uint64_t> address_;
  std::vector<uint32_t> heap_id_;
  std::vector<uint64_t> sequence_number_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT StreamingAllocation : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAddressFieldNumber = 1,
    kSizeFieldNumber = 2,
    kSampleSizeFieldNumber = 3,
    kClockMonotonicCoarseTimestampFieldNumber = 4,
    kHeapIdFieldNumber = 5,
    kSequenceNumberFieldNumber = 6,
  };

  StreamingAllocation();
  ~StreamingAllocation() override;
  StreamingAllocation(StreamingAllocation&&) noexcept;
  StreamingAllocation& operator=(StreamingAllocation&&);
  StreamingAllocation(const StreamingAllocation&);
  StreamingAllocation& operator=(const StreamingAllocation&);
  bool operator==(const StreamingAllocation&) const;
  bool operator!=(const StreamingAllocation& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<uint64_t>& address() const { return address_; }
  std::vector<uint64_t>* mutable_address() { return &address_; }
  int address_size() const { return static_cast<int>(address_.size()); }
  void clear_address() { address_.clear(); }
  void add_address(uint64_t value) { address_.emplace_back(value); }
  uint64_t* add_address() { address_.emplace_back(); return &address_.back(); }

  const std::vector<uint64_t>& size() const { return size_; }
  std::vector<uint64_t>* mutable_size() { return &size_; }
  int size_size() const { return static_cast<int>(size_.size()); }
  void clear_size() { size_.clear(); }
  void add_size(uint64_t value) { size_.emplace_back(value); }
  uint64_t* add_size() { size_.emplace_back(); return &size_.back(); }

  const std::vector<uint64_t>& sample_size() const { return sample_size_; }
  std::vector<uint64_t>* mutable_sample_size() { return &sample_size_; }
  int sample_size_size() const { return static_cast<int>(sample_size_.size()); }
  void clear_sample_size() { sample_size_.clear(); }
  void add_sample_size(uint64_t value) { sample_size_.emplace_back(value); }
  uint64_t* add_sample_size() { sample_size_.emplace_back(); return &sample_size_.back(); }

  const std::vector<uint64_t>& clock_monotonic_coarse_timestamp() const { return clock_monotonic_coarse_timestamp_; }
  std::vector<uint64_t>* mutable_clock_monotonic_coarse_timestamp() { return &clock_monotonic_coarse_timestamp_; }
  int clock_monotonic_coarse_timestamp_size() const { return static_cast<int>(clock_monotonic_coarse_timestamp_.size()); }
  void clear_clock_monotonic_coarse_timestamp() { clock_monotonic_coarse_timestamp_.clear(); }
  void add_clock_monotonic_coarse_timestamp(uint64_t value) { clock_monotonic_coarse_timestamp_.emplace_back(value); }
  uint64_t* add_clock_monotonic_coarse_timestamp() { clock_monotonic_coarse_timestamp_.emplace_back(); return &clock_monotonic_coarse_timestamp_.back(); }

  const std::vector<uint32_t>& heap_id() const { return heap_id_; }
  std::vector<uint32_t>* mutable_heap_id() { return &heap_id_; }
  int heap_id_size() const { return static_cast<int>(heap_id_.size()); }
  void clear_heap_id() { heap_id_.clear(); }
  void add_heap_id(uint32_t value) { heap_id_.emplace_back(value); }
  uint32_t* add_heap_id() { heap_id_.emplace_back(); return &heap_id_.back(); }

  const std::vector<uint64_t>& sequence_number() const { return sequence_number_; }
  std::vector<uint64_t>* mutable_sequence_number() { return &sequence_number_; }
  int sequence_number_size() const { return static_cast<int>(sequence_number_.size()); }
  void clear_sequence_number() { sequence_number_.clear(); }
  void add_sequence_number(uint64_t value) { sequence_number_.emplace_back(value); }
  uint64_t* add_sequence_number() { sequence_number_.emplace_back(); return &sequence_number_.back(); }

 private:
  std::vector<uint64_t> address_;
  std::vector<uint64_t> size_;
  std::vector<uint64_t> sample_size_;
  std::vector<uint64_t> clock_monotonic_coarse_timestamp_;
  std::vector<uint32_t> heap_id_;
  std::vector<uint64_t> sequence_number_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT ProfilePacket : public ::protozero::CppMessageObj {
 public:
  using HeapSample = ProfilePacket_HeapSample;
  using Histogram = ProfilePacket_Histogram;
  using ProcessStats = ProfilePacket_ProcessStats;
  using ProcessHeapSamples = ProfilePacket_ProcessHeapSamples;
  enum FieldNumbers {
    kStringsFieldNumber = 1,
    kMappingsFieldNumber = 4,
    kFramesFieldNumber = 2,
    kCallstacksFieldNumber = 3,
    kProcessDumpsFieldNumber = 5,
    kContinuedFieldNumber = 6,
    kIndexFieldNumber = 7,
  };

  ProfilePacket();
  ~ProfilePacket() override;
  ProfilePacket(ProfilePacket&&) noexcept;
  ProfilePacket& operator=(ProfilePacket&&);
  ProfilePacket(const ProfilePacket&);
  ProfilePacket& operator=(const ProfilePacket&);
  bool operator==(const ProfilePacket&) const;
  bool operator!=(const ProfilePacket& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<InternedString>& strings() const { return strings_; }
  std::vector<InternedString>* mutable_strings() { return &strings_; }
  int strings_size() const;
  void clear_strings();
  InternedString* add_strings();

  const std::vector<Mapping>& mappings() const { return mappings_; }
  std::vector<Mapping>* mutable_mappings() { return &mappings_; }
  int mappings_size() const;
  void clear_mappings();
  Mapping* add_mappings();

  const std::vector<Frame>& frames() const { return frames_; }
  std::vector<Frame>* mutable_frames() { return &frames_; }
  int frames_size() const;
  void clear_frames();
  Frame* add_frames();

  const std::vector<Callstack>& callstacks() const { return callstacks_; }
  std::vector<Callstack>* mutable_callstacks() { return &callstacks_; }
  int callstacks_size() const;
  void clear_callstacks();
  Callstack* add_callstacks();

  const std::vector<ProfilePacket_ProcessHeapSamples>& process_dumps() const { return process_dumps_; }
  std::vector<ProfilePacket_ProcessHeapSamples>* mutable_process_dumps() { return &process_dumps_; }
  int process_dumps_size() const;
  void clear_process_dumps();
  ProfilePacket_ProcessHeapSamples* add_process_dumps();

  bool has_continued() const { return _has_field_[6]; }
  bool continued() const { return continued_; }
  void set_continued(bool value) { continued_ = value; _has_field_.set(6); }

  bool has_index() const { return _has_field_[7]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(7); }

 private:
  std::vector<InternedString> strings_;
  std::vector<Mapping> mappings_;
  std::vector<Frame> frames_;
  std::vector<Callstack> callstacks_;
  std::vector<ProfilePacket_ProcessHeapSamples> process_dumps_;
  bool continued_{};
  uint64_t index_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT ProfilePacket_ProcessHeapSamples : public ::protozero::CppMessageObj {
 public:
  using ClientError = ProfilePacket_ProcessHeapSamples_ClientError;
  static constexpr auto CLIENT_ERROR_NONE = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_NONE;
  static constexpr auto CLIENT_ERROR_HIT_TIMEOUT = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_HIT_TIMEOUT;
  static constexpr auto CLIENT_ERROR_INVALID_STACK_BOUNDS = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_INVALID_STACK_BOUNDS;
  static constexpr auto ClientError_MIN = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_NONE;
  static constexpr auto ClientError_MAX = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_INVALID_STACK_BOUNDS;
  enum FieldNumbers {
    kPidFieldNumber = 1,
    kFromStartupFieldNumber = 3,
    kRejectedConcurrentFieldNumber = 4,
    kDisconnectedFieldNumber = 6,
    kBufferOverranFieldNumber = 7,
    kClientErrorFieldNumber = 14,
    kBufferCorruptedFieldNumber = 8,
    kHitGuardrailFieldNumber = 10,
    kHeapNameFieldNumber = 11,
    kSamplingIntervalBytesFieldNumber = 12,
    kOrigSamplingIntervalBytesFieldNumber = 13,
    kTimestampFieldNumber = 9,
    kStatsFieldNumber = 5,
    kSamplesFieldNumber = 2,
  };

  ProfilePacket_ProcessHeapSamples();
  ~ProfilePacket_ProcessHeapSamples() override;
  ProfilePacket_ProcessHeapSamples(ProfilePacket_ProcessHeapSamples&&) noexcept;
  ProfilePacket_ProcessHeapSamples& operator=(ProfilePacket_ProcessHeapSamples&&);
  ProfilePacket_ProcessHeapSamples(const ProfilePacket_ProcessHeapSamples&);
  ProfilePacket_ProcessHeapSamples& operator=(const ProfilePacket_ProcessHeapSamples&);
  bool operator==(const ProfilePacket_ProcessHeapSamples&) const;
  bool operator!=(const ProfilePacket_ProcessHeapSamples& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pid() const { return _has_field_[1]; }
  uint64_t pid() const { return pid_; }
  void set_pid(uint64_t value) { pid_ = value; _has_field_.set(1); }

  bool has_from_startup() const { return _has_field_[3]; }
  bool from_startup() const { return from_startup_; }
  void set_from_startup(bool value) { from_startup_ = value; _has_field_.set(3); }

  bool has_rejected_concurrent() const { return _has_field_[4]; }
  bool rejected_concurrent() const { return rejected_concurrent_; }
  void set_rejected_concurrent(bool value) { rejected_concurrent_ = value; _has_field_.set(4); }

  bool has_disconnected() const { return _has_field_[6]; }
  bool disconnected() const { return disconnected_; }
  void set_disconnected(bool value) { disconnected_ = value; _has_field_.set(6); }

  bool has_buffer_overran() const { return _has_field_[7]; }
  bool buffer_overran() const { return buffer_overran_; }
  void set_buffer_overran(bool value) { buffer_overran_ = value; _has_field_.set(7); }

  bool has_client_error() const { return _has_field_[14]; }
  ProfilePacket_ProcessHeapSamples_ClientError client_error() const { return client_error_; }
  void set_client_error(ProfilePacket_ProcessHeapSamples_ClientError value) { client_error_ = value; _has_field_.set(14); }

  bool has_buffer_corrupted() const { return _has_field_[8]; }
  bool buffer_corrupted() const { return buffer_corrupted_; }
  void set_buffer_corrupted(bool value) { buffer_corrupted_ = value; _has_field_.set(8); }

  bool has_hit_guardrail() const { return _has_field_[10]; }
  bool hit_guardrail() const { return hit_guardrail_; }
  void set_hit_guardrail(bool value) { hit_guardrail_ = value; _has_field_.set(10); }

  bool has_heap_name() const { return _has_field_[11]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(11); }

  bool has_sampling_interval_bytes() const { return _has_field_[12]; }
  uint64_t sampling_interval_bytes() const { return sampling_interval_bytes_; }
  void set_sampling_interval_bytes(uint64_t value) { sampling_interval_bytes_ = value; _has_field_.set(12); }

  bool has_orig_sampling_interval_bytes() const { return _has_field_[13]; }
  uint64_t orig_sampling_interval_bytes() const { return orig_sampling_interval_bytes_; }
  void set_orig_sampling_interval_bytes(uint64_t value) { orig_sampling_interval_bytes_ = value; _has_field_.set(13); }

  bool has_timestamp() const { return _has_field_[9]; }
  uint64_t timestamp() const { return timestamp_; }
  void set_timestamp(uint64_t value) { timestamp_ = value; _has_field_.set(9); }

  bool has_stats() const { return _has_field_[5]; }
  const ProfilePacket_ProcessStats& stats() const { return *stats_; }
  ProfilePacket_ProcessStats* mutable_stats() { _has_field_.set(5); return stats_.get(); }

  const std::vector<ProfilePacket_HeapSample>& samples() const { return samples_; }
  std::vector<ProfilePacket_HeapSample>* mutable_samples() { return &samples_; }
  int samples_size() const;
  void clear_samples();
  ProfilePacket_HeapSample* add_samples();

 private:
  uint64_t pid_{};
  bool from_startup_{};
  bool rejected_concurrent_{};
  bool disconnected_{};
  bool buffer_overran_{};
  ProfilePacket_ProcessHeapSamples_ClientError client_error_{};
  bool buffer_corrupted_{};
  bool hit_guardrail_{};
  std::string heap_name_{};
  uint64_t sampling_interval_bytes_{};
  uint64_t orig_sampling_interval_bytes_{};
  uint64_t timestamp_{};
  ::protozero::CopyablePtr<ProfilePacket_ProcessStats> stats_;
  std::vector<ProfilePacket_HeapSample> samples_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<15> _has_field_{};
};


class PERFETTO_EXPORT ProfilePacket_HeapSample : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCallstackIdFieldNumber = 1,
    kSelfAllocatedFieldNumber = 2,
    kSelfFreedFieldNumber = 3,
    kSelfMaxFieldNumber = 8,
    kSelfMaxCountFieldNumber = 9,
    kTimestampFieldNumber = 4,
    kAllocCountFieldNumber = 5,
    kFreeCountFieldNumber = 6,
  };

  ProfilePacket_HeapSample();
  ~ProfilePacket_HeapSample() override;
  ProfilePacket_HeapSample(ProfilePacket_HeapSample&&) noexcept;
  ProfilePacket_HeapSample& operator=(ProfilePacket_HeapSample&&);
  ProfilePacket_HeapSample(const ProfilePacket_HeapSample&);
  ProfilePacket_HeapSample& operator=(const ProfilePacket_HeapSample&);
  bool operator==(const ProfilePacket_HeapSample&) const;
  bool operator!=(const ProfilePacket_HeapSample& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_callstack_id() const { return _has_field_[1]; }
  uint64_t callstack_id() const { return callstack_id_; }
  void set_callstack_id(uint64_t value) { callstack_id_ = value; _has_field_.set(1); }

  bool has_self_allocated() const { return _has_field_[2]; }
  uint64_t self_allocated() const { return self_allocated_; }
  void set_self_allocated(uint64_t value) { self_allocated_ = value; _has_field_.set(2); }

  bool has_self_freed() const { return _has_field_[3]; }
  uint64_t self_freed() const { return self_freed_; }
  void set_self_freed(uint64_t value) { self_freed_ = value; _has_field_.set(3); }

  bool has_self_max() const { return _has_field_[8]; }
  uint64_t self_max() const { return self_max_; }
  void set_self_max(uint64_t value) { self_max_ = value; _has_field_.set(8); }

  bool has_self_max_count() const { return _has_field_[9]; }
  uint64_t self_max_count() const { return self_max_count_; }
  void set_self_max_count(uint64_t value) { self_max_count_ = value; _has_field_.set(9); }

  bool has_timestamp() const { return _has_field_[4]; }
  uint64_t timestamp() const { return timestamp_; }
  void set_timestamp(uint64_t value) { timestamp_ = value; _has_field_.set(4); }

  bool has_alloc_count() const { return _has_field_[5]; }
  uint64_t alloc_count() const { return alloc_count_; }
  void set_alloc_count(uint64_t value) { alloc_count_ = value; _has_field_.set(5); }

  bool has_free_count() const { return _has_field_[6]; }
  uint64_t free_count() const { return free_count_; }
  void set_free_count(uint64_t value) { free_count_ = value; _has_field_.set(6); }

 private:
  uint64_t callstack_id_{};
  uint64_t self_allocated_{};
  uint64_t self_freed_{};
  uint64_t self_max_{};
  uint64_t self_max_count_{};
  uint64_t timestamp_{};
  uint64_t alloc_count_{};
  uint64_t free_count_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};


class PERFETTO_EXPORT ProfilePacket_ProcessStats : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kUnwindingErrorsFieldNumber = 1,
    kHeapSamplesFieldNumber = 2,
    kMapReparsesFieldNumber = 3,
    kUnwindingTimeUsFieldNumber = 4,
    kTotalUnwindingTimeUsFieldNumber = 5,
    kClientSpinlockBlockedUsFieldNumber = 6,
  };

  ProfilePacket_ProcessStats();
  ~ProfilePacket_ProcessStats() override;
  ProfilePacket_ProcessStats(ProfilePacket_ProcessStats&&) noexcept;
  ProfilePacket_ProcessStats& operator=(ProfilePacket_ProcessStats&&);
  ProfilePacket_ProcessStats(const ProfilePacket_ProcessStats&);
  ProfilePacket_ProcessStats& operator=(const ProfilePacket_ProcessStats&);
  bool operator==(const ProfilePacket_ProcessStats&) const;
  bool operator!=(const ProfilePacket_ProcessStats& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_unwinding_errors() const { return _has_field_[1]; }
  uint64_t unwinding_errors() const { return unwinding_errors_; }
  void set_unwinding_errors(uint64_t value) { unwinding_errors_ = value; _has_field_.set(1); }

  bool has_heap_samples() const { return _has_field_[2]; }
  uint64_t heap_samples() const { return heap_samples_; }
  void set_heap_samples(uint64_t value) { heap_samples_ = value; _has_field_.set(2); }

  bool has_map_reparses() const { return _has_field_[3]; }
  uint64_t map_reparses() const { return map_reparses_; }
  void set_map_reparses(uint64_t value) { map_reparses_ = value; _has_field_.set(3); }

  bool has_unwinding_time_us() const { return _has_field_[4]; }
  const ProfilePacket_Histogram& unwinding_time_us() const { return *unwinding_time_us_; }
  ProfilePacket_Histogram* mutable_unwinding_time_us() { _has_field_.set(4); return unwinding_time_us_.get(); }

  bool has_total_unwinding_time_us() const { return _has_field_[5]; }
  uint64_t total_unwinding_time_us() const { return total_unwinding_time_us_; }
  void set_total_unwinding_time_us(uint64_t value) { total_unwinding_time_us_ = value; _has_field_.set(5); }

  bool has_client_spinlock_blocked_us() const { return _has_field_[6]; }
  uint64_t client_spinlock_blocked_us() const { return client_spinlock_blocked_us_; }
  void set_client_spinlock_blocked_us(uint64_t value) { client_spinlock_blocked_us_ = value; _has_field_.set(6); }

 private:
  uint64_t unwinding_errors_{};
  uint64_t heap_samples_{};
  uint64_t map_reparses_{};
  ::protozero::CopyablePtr<ProfilePacket_Histogram> unwinding_time_us_;
  uint64_t total_unwinding_time_us_{};
  uint64_t client_spinlock_blocked_us_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT ProfilePacket_Histogram : public ::protozero::CppMessageObj {
 public:
  using Bucket = ProfilePacket_Histogram_Bucket;
  enum FieldNumbers {
    kBucketsFieldNumber = 1,
  };

  ProfilePacket_Histogram();
  ~ProfilePacket_Histogram() override;
  ProfilePacket_Histogram(ProfilePacket_Histogram&&) noexcept;
  ProfilePacket_Histogram& operator=(ProfilePacket_Histogram&&);
  ProfilePacket_Histogram(const ProfilePacket_Histogram&);
  ProfilePacket_Histogram& operator=(const ProfilePacket_Histogram&);
  bool operator==(const ProfilePacket_Histogram&) const;
  bool operator!=(const ProfilePacket_Histogram& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<ProfilePacket_Histogram_Bucket>& buckets() const { return buckets_; }
  std::vector<ProfilePacket_Histogram_Bucket>* mutable_buckets() { return &buckets_; }
  int buckets_size() const;
  void clear_buckets();
  ProfilePacket_Histogram_Bucket* add_buckets();

 private:
  std::vector<ProfilePacket_Histogram_Bucket> buckets_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT ProfilePacket_Histogram_Bucket : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kUpperLimitFieldNumber = 1,
    kMaxBucketFieldNumber = 2,
    kCountFieldNumber = 3,
  };

  ProfilePacket_Histogram_Bucket();
  ~ProfilePacket_Histogram_Bucket() override;
  ProfilePacket_Histogram_Bucket(ProfilePacket_Histogram_Bucket&&) noexcept;
  ProfilePacket_Histogram_Bucket& operator=(ProfilePacket_Histogram_Bucket&&);
  ProfilePacket_Histogram_Bucket(const ProfilePacket_Histogram_Bucket&);
  ProfilePacket_Histogram_Bucket& operator=(const ProfilePacket_Histogram_Bucket&);
  bool operator==(const ProfilePacket_Histogram_Bucket&) const;
  bool operator!=(const ProfilePacket_Histogram_Bucket& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_upper_limit() const { return _has_field_[1]; }
  uint64_t upper_limit() const { return upper_limit_; }
  void set_upper_limit(uint64_t value) { upper_limit_ = value; _has_field_.set(1); }

  bool has_max_bucket() const { return _has_field_[2]; }
  bool max_bucket() const { return max_bucket_; }
  void set_max_bucket(bool value) { max_bucket_ = value; _has_field_.set(2); }

  bool has_count() const { return _has_field_[3]; }
  uint64_t count() const { return count_; }
  void set_count(uint64_t value) { count_ = value; _has_field_.set(3); }

 private:
  uint64_t upper_limit_{};
  bool max_bucket_{};
  uint64_t count_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_CPP_H_
