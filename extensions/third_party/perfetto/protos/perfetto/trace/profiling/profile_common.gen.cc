#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/profiling/profile_common.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

Callstack::Callstack() = default;
Callstack::~Callstack() = default;
Callstack::Callstack(const Callstack&) = default;
Callstack& Callstack::operator=(const Callstack&) = default;
Callstack::Callstack(Callstack&&) noexcept = default;
Callstack& Callstack::operator=(Callstack&&) = default;

bool Callstack::operator==(const Callstack& other) const {
  return unknown_fields_ == other.unknown_fields_
   && iid_ == other.iid_
   && frame_ids_ == other.frame_ids_;
}

bool Callstack::ParseFromArray(const void* raw, size_t size) {
  frame_ids_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* frame_ids */:
        frame_ids_.emplace_back();
        field.get(&frame_ids_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Callstack::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Callstack::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Callstack::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, iid_);
  }

  // Field 2: frame_ids
  for (auto& it : frame_ids_) {
    msg->AppendVarInt(2, it);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Frame::Frame() = default;
Frame::~Frame() = default;
Frame::Frame(const Frame&) = default;
Frame& Frame::operator=(const Frame&) = default;
Frame::Frame(Frame&&) noexcept = default;
Frame& Frame::operator=(Frame&&) = default;

bool Frame::operator==(const Frame& other) const {
  return unknown_fields_ == other.unknown_fields_
   && iid_ == other.iid_
   && function_name_id_ == other.function_name_id_
   && mapping_id_ == other.mapping_id_
   && rel_pc_ == other.rel_pc_;
}

bool Frame::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* function_name_id */:
        field.get(&function_name_id_);
        break;
      case 3 /* mapping_id */:
        field.get(&mapping_id_);
        break;
      case 4 /* rel_pc */:
        field.get(&rel_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Frame::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Frame::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Frame::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, iid_);
  }

  // Field 2: function_name_id
  if (_has_field_[2]) {
    msg->AppendVarInt(2, function_name_id_);
  }

  // Field 3: mapping_id
  if (_has_field_[3]) {
    msg->AppendVarInt(3, mapping_id_);
  }

  // Field 4: rel_pc
  if (_has_field_[4]) {
    msg->AppendVarInt(4, rel_pc_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Mapping::Mapping() = default;
Mapping::~Mapping() = default;
Mapping::Mapping(const Mapping&) = default;
Mapping& Mapping::operator=(const Mapping&) = default;
Mapping::Mapping(Mapping&&) noexcept = default;
Mapping& Mapping::operator=(Mapping&&) = default;

bool Mapping::operator==(const Mapping& other) const {
  return unknown_fields_ == other.unknown_fields_
   && iid_ == other.iid_
   && build_id_ == other.build_id_
   && exact_offset_ == other.exact_offset_
   && start_offset_ == other.start_offset_
   && start_ == other.start_
   && end_ == other.end_
   && load_bias_ == other.load_bias_
   && path_string_ids_ == other.path_string_ids_;
}

bool Mapping::ParseFromArray(const void* raw, size_t size) {
  path_string_ids_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* build_id */:
        field.get(&build_id_);
        break;
      case 8 /* exact_offset */:
        field.get(&exact_offset_);
        break;
      case 3 /* start_offset */:
        field.get(&start_offset_);
        break;
      case 4 /* start */:
        field.get(&start_);
        break;
      case 5 /* end */:
        field.get(&end_);
        break;
      case 6 /* load_bias */:
        field.get(&load_bias_);
        break;
      case 7 /* path_string_ids */:
        path_string_ids_.emplace_back();
        field.get(&path_string_ids_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Mapping::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Mapping::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Mapping::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, iid_);
  }

  // Field 2: build_id
  if (_has_field_[2]) {
    msg->AppendVarInt(2, build_id_);
  }

  // Field 8: exact_offset
  if (_has_field_[8]) {
    msg->AppendVarInt(8, exact_offset_);
  }

  // Field 3: start_offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, start_offset_);
  }

  // Field 4: start
  if (_has_field_[4]) {
    msg->AppendVarInt(4, start_);
  }

  // Field 5: end
  if (_has_field_[5]) {
    msg->AppendVarInt(5, end_);
  }

  // Field 6: load_bias
  if (_has_field_[6]) {
    msg->AppendVarInt(6, load_bias_);
  }

  // Field 7: path_string_ids
  for (auto& it : path_string_ids_) {
    msg->AppendVarInt(7, it);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ModuleSymbols::ModuleSymbols() = default;
ModuleSymbols::~ModuleSymbols() = default;
ModuleSymbols::ModuleSymbols(const ModuleSymbols&) = default;
ModuleSymbols& ModuleSymbols::operator=(const ModuleSymbols&) = default;
ModuleSymbols::ModuleSymbols(ModuleSymbols&&) noexcept = default;
ModuleSymbols& ModuleSymbols::operator=(ModuleSymbols&&) = default;

bool ModuleSymbols::operator==(const ModuleSymbols& other) const {
  return unknown_fields_ == other.unknown_fields_
   && path_ == other.path_
   && build_id_ == other.build_id_
   && address_symbols_ == other.address_symbols_;
}

int ModuleSymbols::address_symbols_size() const { return static_cast<int>(address_symbols_.size()); }
void ModuleSymbols::clear_address_symbols() { address_symbols_.clear(); }
AddressSymbols* ModuleSymbols::add_address_symbols() { address_symbols_.emplace_back(); return &address_symbols_.back(); }
bool ModuleSymbols::ParseFromArray(const void* raw, size_t size) {
  address_symbols_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* path */:
        field.get(&path_);
        break;
      case 2 /* build_id */:
        field.get(&build_id_);
        break;
      case 3 /* address_symbols */:
        address_symbols_.emplace_back();
        address_symbols_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ModuleSymbols::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ModuleSymbols::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ModuleSymbols::Serialize(::protozero::Message* msg) const {
  // Field 1: path
  if (_has_field_[1]) {
    msg->AppendString(1, path_);
  }

  // Field 2: build_id
  if (_has_field_[2]) {
    msg->AppendString(2, build_id_);
  }

  // Field 3: address_symbols
  for (auto& it : address_symbols_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AddressSymbols::AddressSymbols() = default;
AddressSymbols::~AddressSymbols() = default;
AddressSymbols::AddressSymbols(const AddressSymbols&) = default;
AddressSymbols& AddressSymbols::operator=(const AddressSymbols&) = default;
AddressSymbols::AddressSymbols(AddressSymbols&&) noexcept = default;
AddressSymbols& AddressSymbols::operator=(AddressSymbols&&) = default;

bool AddressSymbols::operator==(const AddressSymbols& other) const {
  return unknown_fields_ == other.unknown_fields_
   && address_ == other.address_
   && lines_ == other.lines_;
}

int AddressSymbols::lines_size() const { return static_cast<int>(lines_.size()); }
void AddressSymbols::clear_lines() { lines_.clear(); }
Line* AddressSymbols::add_lines() { lines_.emplace_back(); return &lines_.back(); }
bool AddressSymbols::ParseFromArray(const void* raw, size_t size) {
  lines_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* address */:
        field.get(&address_);
        break;
      case 2 /* lines */:
        lines_.emplace_back();
        lines_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AddressSymbols::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AddressSymbols::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AddressSymbols::Serialize(::protozero::Message* msg) const {
  // Field 1: address
  if (_has_field_[1]) {
    msg->AppendVarInt(1, address_);
  }

  // Field 2: lines
  for (auto& it : lines_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Line::Line() = default;
Line::~Line() = default;
Line::Line(const Line&) = default;
Line& Line::operator=(const Line&) = default;
Line::Line(Line&&) noexcept = default;
Line& Line::operator=(Line&&) = default;

bool Line::operator==(const Line& other) const {
  return unknown_fields_ == other.unknown_fields_
   && function_name_ == other.function_name_
   && source_file_name_ == other.source_file_name_
   && line_number_ == other.line_number_;
}

bool Line::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* function_name */:
        field.get(&function_name_);
        break;
      case 2 /* source_file_name */:
        field.get(&source_file_name_);
        break;
      case 3 /* line_number */:
        field.get(&line_number_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Line::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Line::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Line::Serialize(::protozero::Message* msg) const {
  // Field 1: function_name
  if (_has_field_[1]) {
    msg->AppendString(1, function_name_);
  }

  // Field 2: source_file_name
  if (_has_field_[2]) {
    msg->AppendString(2, source_file_name_);
  }

  // Field 3: line_number
  if (_has_field_[3]) {
    msg->AppendVarInt(3, line_number_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ProfiledFrameSymbols::ProfiledFrameSymbols() = default;
ProfiledFrameSymbols::~ProfiledFrameSymbols() = default;
ProfiledFrameSymbols::ProfiledFrameSymbols(const ProfiledFrameSymbols&) = default;
ProfiledFrameSymbols& ProfiledFrameSymbols::operator=(const ProfiledFrameSymbols&) = default;
ProfiledFrameSymbols::ProfiledFrameSymbols(ProfiledFrameSymbols&&) noexcept = default;
ProfiledFrameSymbols& ProfiledFrameSymbols::operator=(ProfiledFrameSymbols&&) = default;

bool ProfiledFrameSymbols::operator==(const ProfiledFrameSymbols& other) const {
  return unknown_fields_ == other.unknown_fields_
   && frame_iid_ == other.frame_iid_
   && function_name_id_ == other.function_name_id_
   && file_name_id_ == other.file_name_id_
   && line_number_ == other.line_number_;
}

bool ProfiledFrameSymbols::ParseFromArray(const void* raw, size_t size) {
  function_name_id_.clear();
  file_name_id_.clear();
  line_number_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* frame_iid */:
        field.get(&frame_iid_);
        break;
      case 2 /* function_name_id */:
        function_name_id_.emplace_back();
        field.get(&function_name_id_.back());
        break;
      case 3 /* file_name_id */:
        file_name_id_.emplace_back();
        field.get(&file_name_id_.back());
        break;
      case 4 /* line_number */:
        line_number_.emplace_back();
        field.get(&line_number_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfiledFrameSymbols::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfiledFrameSymbols::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfiledFrameSymbols::Serialize(::protozero::Message* msg) const {
  // Field 1: frame_iid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, frame_iid_);
  }

  // Field 2: function_name_id
  for (auto& it : function_name_id_) {
    msg->AppendVarInt(2, it);
  }

  // Field 3: file_name_id
  for (auto& it : file_name_id_) {
    msg->AppendVarInt(3, it);
  }

  // Field 4: line_number
  for (auto& it : line_number_) {
    msg->AppendVarInt(4, it);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


InternedString::InternedString() = default;
InternedString::~InternedString() = default;
InternedString::InternedString(const InternedString&) = default;
InternedString& InternedString::operator=(const InternedString&) = default;
InternedString::InternedString(InternedString&&) noexcept = default;
InternedString& InternedString::operator=(InternedString&&) = default;

bool InternedString::operator==(const InternedString& other) const {
  return unknown_fields_ == other.unknown_fields_
   && iid_ == other.iid_
   && str_ == other.str_;
}

bool InternedString::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* str */:
        field.get(&str_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string InternedString::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> InternedString::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void InternedString::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, iid_);
  }

  // Field 2: str
  if (_has_field_[2]) {
    msg->AppendString(2, str_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
