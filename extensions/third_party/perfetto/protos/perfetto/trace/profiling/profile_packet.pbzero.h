// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class Callstack;
class Frame;
class InternedString;
class Mapping;
class PerfSample_ProducerEvent;
class ProfilePacket_HeapSample;
class ProfilePacket_Histogram;
class ProfilePacket_Histogram_Bucket;
class ProfilePacket_ProcessHeapSamples;
class ProfilePacket_ProcessStats;
enum PerfSample_ProducerEvent_DataSourceStopReason : int32_t;
enum PerfSample_SampleSkipReason : int32_t;
enum ProfilePacket_ProcessHeapSamples_ClientError : int32_t;
enum Profiling_CpuMode : int32_t;
enum Profiling_StackUnwindError : int32_t;

enum PerfSample_SampleSkipReason : int32_t {
  PerfSample_SampleSkipReason_PROFILER_SKIP_UNKNOWN = 0,
  PerfSample_SampleSkipReason_PROFILER_SKIP_READ_STAGE = 1,
  PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_STAGE = 2,
  PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_ENQUEUE = 3,
};

const PerfSample_SampleSkipReason PerfSample_SampleSkipReason_MIN = PerfSample_SampleSkipReason_PROFILER_SKIP_UNKNOWN;
const PerfSample_SampleSkipReason PerfSample_SampleSkipReason_MAX = PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_ENQUEUE;

enum PerfSample_ProducerEvent_DataSourceStopReason : int32_t {
  PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_UNKNOWN = 0,
  PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_GUARDRAIL = 1,
};

const PerfSample_ProducerEvent_DataSourceStopReason PerfSample_ProducerEvent_DataSourceStopReason_MIN = PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_UNKNOWN;
const PerfSample_ProducerEvent_DataSourceStopReason PerfSample_ProducerEvent_DataSourceStopReason_MAX = PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_GUARDRAIL;

enum Profiling_CpuMode : int32_t {
  Profiling_CpuMode_MODE_UNKNOWN = 0,
  Profiling_CpuMode_MODE_KERNEL = 1,
  Profiling_CpuMode_MODE_USER = 2,
  Profiling_CpuMode_MODE_HYPERVISOR = 3,
  Profiling_CpuMode_MODE_GUEST_KERNEL = 4,
  Profiling_CpuMode_MODE_GUEST_USER = 5,
};

const Profiling_CpuMode Profiling_CpuMode_MIN = Profiling_CpuMode_MODE_UNKNOWN;
const Profiling_CpuMode Profiling_CpuMode_MAX = Profiling_CpuMode_MODE_GUEST_USER;

enum Profiling_StackUnwindError : int32_t {
  Profiling_StackUnwindError_UNWIND_ERROR_UNKNOWN = 0,
  Profiling_StackUnwindError_UNWIND_ERROR_NONE = 1,
  Profiling_StackUnwindError_UNWIND_ERROR_MEMORY_INVALID = 2,
  Profiling_StackUnwindError_UNWIND_ERROR_UNWIND_INFO = 3,
  Profiling_StackUnwindError_UNWIND_ERROR_UNSUPPORTED = 4,
  Profiling_StackUnwindError_UNWIND_ERROR_INVALID_MAP = 5,
  Profiling_StackUnwindError_UNWIND_ERROR_MAX_FRAMES_EXCEEDED = 6,
  Profiling_StackUnwindError_UNWIND_ERROR_REPEATED_FRAME = 7,
  Profiling_StackUnwindError_UNWIND_ERROR_INVALID_ELF = 8,
  Profiling_StackUnwindError_UNWIND_ERROR_SYSTEM_CALL = 9,
  Profiling_StackUnwindError_UNWIND_ERROR_THREAD_TIMEOUT = 10,
  Profiling_StackUnwindError_UNWIND_ERROR_THREAD_DOES_NOT_EXIST = 11,
};

const Profiling_StackUnwindError Profiling_StackUnwindError_MIN = Profiling_StackUnwindError_UNWIND_ERROR_UNKNOWN;
const Profiling_StackUnwindError Profiling_StackUnwindError_MAX = Profiling_StackUnwindError_UNWIND_ERROR_THREAD_DOES_NOT_EXIST;

enum ProfilePacket_ProcessHeapSamples_ClientError : int32_t {
  ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_NONE = 0,
  ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_HIT_TIMEOUT = 1,
  ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_INVALID_STACK_BOUNDS = 2,
};

const ProfilePacket_ProcessHeapSamples_ClientError ProfilePacket_ProcessHeapSamples_ClientError_MIN = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_NONE;
const ProfilePacket_ProcessHeapSamples_ClientError ProfilePacket_ProcessHeapSamples_ClientError_MAX = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_INVALID_STACK_BOUNDS;

class PerfSample_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/19, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PerfSample_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PerfSample_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PerfSample_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cpu() const { return at<1>().valid(); }
  uint32_t cpu() const { return at<1>().as_uint32(); }
  bool has_pid() const { return at<2>().valid(); }
  uint32_t pid() const { return at<2>().as_uint32(); }
  bool has_tid() const { return at<3>().valid(); }
  uint32_t tid() const { return at<3>().as_uint32(); }
  bool has_cpu_mode() const { return at<5>().valid(); }
  int32_t cpu_mode() const { return at<5>().as_int32(); }
  bool has_timebase_count() const { return at<6>().valid(); }
  uint64_t timebase_count() const { return at<6>().as_uint64(); }
  bool has_callstack_iid() const { return at<4>().valid(); }
  uint64_t callstack_iid() const { return at<4>().as_uint64(); }
  bool has_unwind_error() const { return at<16>().valid(); }
  int32_t unwind_error() const { return at<16>().as_int32(); }
  bool has_kernel_records_lost() const { return at<17>().valid(); }
  uint64_t kernel_records_lost() const { return at<17>().as_uint64(); }
  bool has_sample_skipped_reason() const { return at<18>().valid(); }
  int32_t sample_skipped_reason() const { return at<18>().as_int32(); }
  bool has_producer_event() const { return at<19>().valid(); }
  ::protozero::ConstBytes producer_event() const { return at<19>().as_bytes(); }
};

class PerfSample : public ::protozero::Message {
 public:
  using Decoder = PerfSample_Decoder;
  enum : int32_t {
    kCpuFieldNumber = 1,
    kPidFieldNumber = 2,
    kTidFieldNumber = 3,
    kCpuModeFieldNumber = 5,
    kTimebaseCountFieldNumber = 6,
    kCallstackIidFieldNumber = 4,
    kUnwindErrorFieldNumber = 16,
    kKernelRecordsLostFieldNumber = 17,
    kSampleSkippedReasonFieldNumber = 18,
    kProducerEventFieldNumber = 19,
  };
  using ProducerEvent = ::perfetto::protos::pbzero::PerfSample_ProducerEvent;
  using SampleSkipReason = ::perfetto::protos::pbzero::PerfSample_SampleSkipReason;
  static const SampleSkipReason PROFILER_SKIP_UNKNOWN = PerfSample_SampleSkipReason_PROFILER_SKIP_UNKNOWN;
  static const SampleSkipReason PROFILER_SKIP_READ_STAGE = PerfSample_SampleSkipReason_PROFILER_SKIP_READ_STAGE;
  static const SampleSkipReason PROFILER_SKIP_UNWIND_STAGE = PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_STAGE;
  static const SampleSkipReason PROFILER_SKIP_UNWIND_ENQUEUE = PerfSample_SampleSkipReason_PROFILER_SKIP_UNWIND_ENQUEUE;
  void set_cpu(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_pid(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_tid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_cpu_mode(::perfetto::protos::pbzero::Profiling_CpuMode value) {
    AppendTinyVarInt(5, value);
  }
  void set_timebase_count(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_callstack_iid(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_unwind_error(::perfetto::protos::pbzero::Profiling_StackUnwindError value) {
    AppendTinyVarInt(16, value);
  }
  void set_kernel_records_lost(uint64_t value) {
    AppendVarInt(17, value);
  }
  void set_sample_skipped_reason(::perfetto::protos::pbzero::PerfSample_SampleSkipReason value) {
    AppendTinyVarInt(18, value);
  }
  template <typename T = PerfSample_ProducerEvent> T* set_producer_event() {
    return BeginNestedMessage<T>(19);
  }

};

class PerfSample_ProducerEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PerfSample_ProducerEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PerfSample_ProducerEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PerfSample_ProducerEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source_stop_reason() const { return at<1>().valid(); }
  int32_t source_stop_reason() const { return at<1>().as_int32(); }
};

class PerfSample_ProducerEvent : public ::protozero::Message {
 public:
  using Decoder = PerfSample_ProducerEvent_Decoder;
  enum : int32_t {
    kSourceStopReasonFieldNumber = 1,
  };
  using DataSourceStopReason = ::perfetto::protos::pbzero::PerfSample_ProducerEvent_DataSourceStopReason;
  static const DataSourceStopReason PROFILER_STOP_UNKNOWN = PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_UNKNOWN;
  static const DataSourceStopReason PROFILER_STOP_GUARDRAIL = PerfSample_ProducerEvent_DataSourceStopReason_PROFILER_STOP_GUARDRAIL;
  void set_source_stop_reason(::perfetto::protos::pbzero::PerfSample_ProducerEvent_DataSourceStopReason value) {
    AppendTinyVarInt(1, value);
  }
};

class Profiling_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Profiling_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Profiling_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Profiling_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class Profiling : public ::protozero::Message {
 public:
  using Decoder = Profiling_Decoder;
  using CpuMode = ::perfetto::protos::pbzero::Profiling_CpuMode;
  using StackUnwindError = ::perfetto::protos::pbzero::Profiling_StackUnwindError;
  static const CpuMode MODE_UNKNOWN = Profiling_CpuMode_MODE_UNKNOWN;
  static const CpuMode MODE_KERNEL = Profiling_CpuMode_MODE_KERNEL;
  static const CpuMode MODE_USER = Profiling_CpuMode_MODE_USER;
  static const CpuMode MODE_HYPERVISOR = Profiling_CpuMode_MODE_HYPERVISOR;
  static const CpuMode MODE_GUEST_KERNEL = Profiling_CpuMode_MODE_GUEST_KERNEL;
  static const CpuMode MODE_GUEST_USER = Profiling_CpuMode_MODE_GUEST_USER;
  static const StackUnwindError UNWIND_ERROR_UNKNOWN = Profiling_StackUnwindError_UNWIND_ERROR_UNKNOWN;
  static const StackUnwindError UNWIND_ERROR_NONE = Profiling_StackUnwindError_UNWIND_ERROR_NONE;
  static const StackUnwindError UNWIND_ERROR_MEMORY_INVALID = Profiling_StackUnwindError_UNWIND_ERROR_MEMORY_INVALID;
  static const StackUnwindError UNWIND_ERROR_UNWIND_INFO = Profiling_StackUnwindError_UNWIND_ERROR_UNWIND_INFO;
  static const StackUnwindError UNWIND_ERROR_UNSUPPORTED = Profiling_StackUnwindError_UNWIND_ERROR_UNSUPPORTED;
  static const StackUnwindError UNWIND_ERROR_INVALID_MAP = Profiling_StackUnwindError_UNWIND_ERROR_INVALID_MAP;
  static const StackUnwindError UNWIND_ERROR_MAX_FRAMES_EXCEEDED = Profiling_StackUnwindError_UNWIND_ERROR_MAX_FRAMES_EXCEEDED;
  static const StackUnwindError UNWIND_ERROR_REPEATED_FRAME = Profiling_StackUnwindError_UNWIND_ERROR_REPEATED_FRAME;
  static const StackUnwindError UNWIND_ERROR_INVALID_ELF = Profiling_StackUnwindError_UNWIND_ERROR_INVALID_ELF;
  static const StackUnwindError UNWIND_ERROR_SYSTEM_CALL = Profiling_StackUnwindError_UNWIND_ERROR_SYSTEM_CALL;
  static const StackUnwindError UNWIND_ERROR_THREAD_TIMEOUT = Profiling_StackUnwindError_UNWIND_ERROR_THREAD_TIMEOUT;
  static const StackUnwindError UNWIND_ERROR_THREAD_DOES_NOT_EXIST = Profiling_StackUnwindError_UNWIND_ERROR_THREAD_DOES_NOT_EXIST;
};

class StreamingProfilePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  StreamingProfilePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StreamingProfilePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StreamingProfilePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_callstack_iid() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> callstack_iid() const { return GetRepeated<uint64_t>(1); }
  bool has_timestamp_delta_us() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<int64_t> timestamp_delta_us() const { return GetRepeated<int64_t>(2); }
  bool has_process_priority() const { return at<3>().valid(); }
  int32_t process_priority() const { return at<3>().as_int32(); }
};

class StreamingProfilePacket : public ::protozero::Message {
 public:
  using Decoder = StreamingProfilePacket_Decoder;
  enum : int32_t {
    kCallstackIidFieldNumber = 1,
    kTimestampDeltaUsFieldNumber = 2,
    kProcessPriorityFieldNumber = 3,
  };
  void add_callstack_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_timestamp_delta_us(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_process_priority(int32_t value) {
    AppendVarInt(3, value);
  }
};

class StreamingFree_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  StreamingFree_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StreamingFree_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StreamingFree_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_address() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> address() const { return GetRepeated<uint64_t>(1); }
  bool has_heap_id() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<uint32_t> heap_id() const { return GetRepeated<uint32_t>(2); }
  bool has_sequence_number() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> sequence_number() const { return GetRepeated<uint64_t>(3); }
};

class StreamingFree : public ::protozero::Message {
 public:
  using Decoder = StreamingFree_Decoder;
  enum : int32_t {
    kAddressFieldNumber = 1,
    kHeapIdFieldNumber = 2,
    kSequenceNumberFieldNumber = 3,
  };
  void add_address(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_heap_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void add_sequence_number(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class StreamingAllocation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  StreamingAllocation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StreamingAllocation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StreamingAllocation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_address() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> address() const { return GetRepeated<uint64_t>(1); }
  bool has_size() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> size() const { return GetRepeated<uint64_t>(2); }
  bool has_sample_size() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> sample_size() const { return GetRepeated<uint64_t>(3); }
  bool has_clock_monotonic_coarse_timestamp() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> clock_monotonic_coarse_timestamp() const { return GetRepeated<uint64_t>(4); }
  bool has_heap_id() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<uint32_t> heap_id() const { return GetRepeated<uint32_t>(5); }
  bool has_sequence_number() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> sequence_number() const { return GetRepeated<uint64_t>(6); }
};

class StreamingAllocation : public ::protozero::Message {
 public:
  using Decoder = StreamingAllocation_Decoder;
  enum : int32_t {
    kAddressFieldNumber = 1,
    kSizeFieldNumber = 2,
    kSampleSizeFieldNumber = 3,
    kClockMonotonicCoarseTimestampFieldNumber = 4,
    kHeapIdFieldNumber = 5,
    kSequenceNumberFieldNumber = 6,
  };
  void add_address(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_size(uint64_t value) {
    AppendVarInt(2, value);
  }
  void add_sample_size(uint64_t value) {
    AppendVarInt(3, value);
  }
  void add_clock_monotonic_coarse_timestamp(uint64_t value) {
    AppendVarInt(4, value);
  }
  void add_heap_id(uint32_t value) {
    AppendVarInt(5, value);
  }
  void add_sequence_number(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class ProfilePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_strings() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> strings() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_mappings() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mappings() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_frames() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> frames() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_callstacks() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> callstacks() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_process_dumps() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> process_dumps() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_continued() const { return at<6>().valid(); }
  bool continued() const { return at<6>().as_bool(); }
  bool has_index() const { return at<7>().valid(); }
  uint64_t index() const { return at<7>().as_uint64(); }
};

class ProfilePacket : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Decoder;
  enum : int32_t {
    kStringsFieldNumber = 1,
    kMappingsFieldNumber = 4,
    kFramesFieldNumber = 2,
    kCallstacksFieldNumber = 3,
    kProcessDumpsFieldNumber = 5,
    kContinuedFieldNumber = 6,
    kIndexFieldNumber = 7,
  };
  using HeapSample = ::perfetto::protos::pbzero::ProfilePacket_HeapSample;
  using Histogram = ::perfetto::protos::pbzero::ProfilePacket_Histogram;
  using ProcessStats = ::perfetto::protos::pbzero::ProfilePacket_ProcessStats;
  using ProcessHeapSamples = ::perfetto::protos::pbzero::ProfilePacket_ProcessHeapSamples;
  template <typename T = InternedString> T* add_strings() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = Mapping> T* add_mappings() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = Frame> T* add_frames() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = Callstack> T* add_callstacks() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = ProfilePacket_ProcessHeapSamples> T* add_process_dumps() {
    return BeginNestedMessage<T>(5);
  }

  void set_continued(bool value) {
    AppendTinyVarInt(6, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class ProfilePacket_ProcessHeapSamples_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/14, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_ProcessHeapSamples_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_ProcessHeapSamples_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_ProcessHeapSamples_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  uint64_t pid() const { return at<1>().as_uint64(); }
  bool has_from_startup() const { return at<3>().valid(); }
  bool from_startup() const { return at<3>().as_bool(); }
  bool has_rejected_concurrent() const { return at<4>().valid(); }
  bool rejected_concurrent() const { return at<4>().as_bool(); }
  bool has_disconnected() const { return at<6>().valid(); }
  bool disconnected() const { return at<6>().as_bool(); }
  bool has_buffer_overran() const { return at<7>().valid(); }
  bool buffer_overran() const { return at<7>().as_bool(); }
  bool has_client_error() const { return at<14>().valid(); }
  int32_t client_error() const { return at<14>().as_int32(); }
  bool has_buffer_corrupted() const { return at<8>().valid(); }
  bool buffer_corrupted() const { return at<8>().as_bool(); }
  bool has_hit_guardrail() const { return at<10>().valid(); }
  bool hit_guardrail() const { return at<10>().as_bool(); }
  bool has_heap_name() const { return at<11>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<11>().as_string(); }
  bool has_sampling_interval_bytes() const { return at<12>().valid(); }
  uint64_t sampling_interval_bytes() const { return at<12>().as_uint64(); }
  bool has_orig_sampling_interval_bytes() const { return at<13>().valid(); }
  uint64_t orig_sampling_interval_bytes() const { return at<13>().as_uint64(); }
  bool has_timestamp() const { return at<9>().valid(); }
  uint64_t timestamp() const { return at<9>().as_uint64(); }
  bool has_stats() const { return at<5>().valid(); }
  ::protozero::ConstBytes stats() const { return at<5>().as_bytes(); }
  bool has_samples() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> samples() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class ProfilePacket_ProcessHeapSamples : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_ProcessHeapSamples_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kFromStartupFieldNumber = 3,
    kRejectedConcurrentFieldNumber = 4,
    kDisconnectedFieldNumber = 6,
    kBufferOverranFieldNumber = 7,
    kClientErrorFieldNumber = 14,
    kBufferCorruptedFieldNumber = 8,
    kHitGuardrailFieldNumber = 10,
    kHeapNameFieldNumber = 11,
    kSamplingIntervalBytesFieldNumber = 12,
    kOrigSamplingIntervalBytesFieldNumber = 13,
    kTimestampFieldNumber = 9,
    kStatsFieldNumber = 5,
    kSamplesFieldNumber = 2,
  };
  using ClientError = ::perfetto::protos::pbzero::ProfilePacket_ProcessHeapSamples_ClientError;
  static const ClientError CLIENT_ERROR_NONE = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_NONE;
  static const ClientError CLIENT_ERROR_HIT_TIMEOUT = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_HIT_TIMEOUT;
  static const ClientError CLIENT_ERROR_INVALID_STACK_BOUNDS = ProfilePacket_ProcessHeapSamples_ClientError_CLIENT_ERROR_INVALID_STACK_BOUNDS;
  void set_pid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_from_startup(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_rejected_concurrent(bool value) {
    AppendTinyVarInt(4, value);
  }
  void set_disconnected(bool value) {
    AppendTinyVarInt(6, value);
  }
  void set_buffer_overran(bool value) {
    AppendTinyVarInt(7, value);
  }
  void set_client_error(::perfetto::protos::pbzero::ProfilePacket_ProcessHeapSamples_ClientError value) {
    AppendTinyVarInt(14, value);
  }
  void set_buffer_corrupted(bool value) {
    AppendTinyVarInt(8, value);
  }
  void set_hit_guardrail(bool value) {
    AppendTinyVarInt(10, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(11, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(11, data, size);
  }
  void set_sampling_interval_bytes(uint64_t value) {
    AppendVarInt(12, value);
  }
  void set_orig_sampling_interval_bytes(uint64_t value) {
    AppendVarInt(13, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(9, value);
  }
  template <typename T = ProfilePacket_ProcessStats> T* set_stats() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ProfilePacket_HeapSample> T* add_samples() {
    return BeginNestedMessage<T>(2);
  }

};

class ProfilePacket_ProcessStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_ProcessStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_ProcessStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_ProcessStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_unwinding_errors() const { return at<1>().valid(); }
  uint64_t unwinding_errors() const { return at<1>().as_uint64(); }
  bool has_heap_samples() const { return at<2>().valid(); }
  uint64_t heap_samples() const { return at<2>().as_uint64(); }
  bool has_map_reparses() const { return at<3>().valid(); }
  uint64_t map_reparses() const { return at<3>().as_uint64(); }
  bool has_unwinding_time_us() const { return at<4>().valid(); }
  ::protozero::ConstBytes unwinding_time_us() const { return at<4>().as_bytes(); }
  bool has_total_unwinding_time_us() const { return at<5>().valid(); }
  uint64_t total_unwinding_time_us() const { return at<5>().as_uint64(); }
  bool has_client_spinlock_blocked_us() const { return at<6>().valid(); }
  uint64_t client_spinlock_blocked_us() const { return at<6>().as_uint64(); }
};

class ProfilePacket_ProcessStats : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_ProcessStats_Decoder;
  enum : int32_t {
    kUnwindingErrorsFieldNumber = 1,
    kHeapSamplesFieldNumber = 2,
    kMapReparsesFieldNumber = 3,
    kUnwindingTimeUsFieldNumber = 4,
    kTotalUnwindingTimeUsFieldNumber = 5,
    kClientSpinlockBlockedUsFieldNumber = 6,
  };
  void set_unwinding_errors(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_heap_samples(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_map_reparses(uint64_t value) {
    AppendVarInt(3, value);
  }
  template <typename T = ProfilePacket_Histogram> T* set_unwinding_time_us() {
    return BeginNestedMessage<T>(4);
  }

  void set_total_unwinding_time_us(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_client_spinlock_blocked_us(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class ProfilePacket_Histogram_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_Histogram_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Histogram_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Histogram_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buckets() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> buckets() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class ProfilePacket_Histogram : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Histogram_Decoder;
  enum : int32_t {
    kBucketsFieldNumber = 1,
  };
  using Bucket = ::perfetto::protos::pbzero::ProfilePacket_Histogram_Bucket;
  template <typename T = ProfilePacket_Histogram_Bucket> T* add_buckets() {
    return BeginNestedMessage<T>(1);
  }

};

class ProfilePacket_Histogram_Bucket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_Histogram_Bucket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Histogram_Bucket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Histogram_Bucket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_upper_limit() const { return at<1>().valid(); }
  uint64_t upper_limit() const { return at<1>().as_uint64(); }
  bool has_max_bucket() const { return at<2>().valid(); }
  bool max_bucket() const { return at<2>().as_bool(); }
  bool has_count() const { return at<3>().valid(); }
  uint64_t count() const { return at<3>().as_uint64(); }
};

class ProfilePacket_Histogram_Bucket : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Histogram_Bucket_Decoder;
  enum : int32_t {
    kUpperLimitFieldNumber = 1,
    kMaxBucketFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  void set_upper_limit(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_max_bucket(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ProfilePacket_HeapSample_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_HeapSample_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_HeapSample_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_HeapSample_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_callstack_id() const { return at<1>().valid(); }
  uint64_t callstack_id() const { return at<1>().as_uint64(); }
  bool has_self_allocated() const { return at<2>().valid(); }
  uint64_t self_allocated() const { return at<2>().as_uint64(); }
  bool has_self_freed() const { return at<3>().valid(); }
  uint64_t self_freed() const { return at<3>().as_uint64(); }
  bool has_self_max() const { return at<8>().valid(); }
  uint64_t self_max() const { return at<8>().as_uint64(); }
  bool has_self_max_count() const { return at<9>().valid(); }
  uint64_t self_max_count() const { return at<9>().as_uint64(); }
  bool has_timestamp() const { return at<4>().valid(); }
  uint64_t timestamp() const { return at<4>().as_uint64(); }
  bool has_alloc_count() const { return at<5>().valid(); }
  uint64_t alloc_count() const { return at<5>().as_uint64(); }
  bool has_free_count() const { return at<6>().valid(); }
  uint64_t free_count() const { return at<6>().as_uint64(); }
};

class ProfilePacket_HeapSample : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_HeapSample_Decoder;
  enum : int32_t {
    kCallstackIdFieldNumber = 1,
    kSelfAllocatedFieldNumber = 2,
    kSelfFreedFieldNumber = 3,
    kSelfMaxFieldNumber = 8,
    kSelfMaxCountFieldNumber = 9,
    kTimestampFieldNumber = 4,
    kAllocCountFieldNumber = 5,
    kFreeCountFieldNumber = 6,
  };
  void set_callstack_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_self_allocated(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_self_freed(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_self_max(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_self_max_count(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_alloc_count(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_free_count(uint64_t value) {
    AppendVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
