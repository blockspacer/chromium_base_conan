#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/profiling/heap_graph.gen.h"
#include "protos/perfetto/trace/profiling/profile_common.gen.h"
#include "protos/perfetto/trace/profiling/deobfuscation.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

HeapGraph::HeapGraph() = default;
HeapGraph::~HeapGraph() = default;
HeapGraph::HeapGraph(const HeapGraph&) = default;
HeapGraph& HeapGraph::operator=(const HeapGraph&) = default;
HeapGraph::HeapGraph(HeapGraph&&) noexcept = default;
HeapGraph& HeapGraph::operator=(HeapGraph&&) = default;

bool HeapGraph::operator==(const HeapGraph& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pid_ == other.pid_
   && objects_ == other.objects_
   && roots_ == other.roots_
   && types_ == other.types_
   && field_names_ == other.field_names_
   && location_names_ == other.location_names_
   && continued_ == other.continued_
   && index_ == other.index_;
}

int HeapGraph::objects_size() const { return static_cast<int>(objects_.size()); }
void HeapGraph::clear_objects() { objects_.clear(); }
HeapGraphObject* HeapGraph::add_objects() { objects_.emplace_back(); return &objects_.back(); }
int HeapGraph::roots_size() const { return static_cast<int>(roots_.size()); }
void HeapGraph::clear_roots() { roots_.clear(); }
HeapGraphRoot* HeapGraph::add_roots() { roots_.emplace_back(); return &roots_.back(); }
int HeapGraph::types_size() const { return static_cast<int>(types_.size()); }
void HeapGraph::clear_types() { types_.clear(); }
HeapGraphType* HeapGraph::add_types() { types_.emplace_back(); return &types_.back(); }
int HeapGraph::field_names_size() const { return static_cast<int>(field_names_.size()); }
void HeapGraph::clear_field_names() { field_names_.clear(); }
InternedString* HeapGraph::add_field_names() { field_names_.emplace_back(); return &field_names_.back(); }
int HeapGraph::location_names_size() const { return static_cast<int>(location_names_.size()); }
void HeapGraph::clear_location_names() { location_names_.clear(); }
InternedString* HeapGraph::add_location_names() { location_names_.emplace_back(); return &location_names_.back(); }
bool HeapGraph::ParseFromArray(const void* raw, size_t size) {
  objects_.clear();
  roots_.clear();
  types_.clear();
  field_names_.clear();
  location_names_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pid */:
        field.get(&pid_);
        break;
      case 2 /* objects */:
        objects_.emplace_back();
        objects_.back().ParseFromArray(field.data(), field.size());
        break;
      case 7 /* roots */:
        roots_.emplace_back();
        roots_.back().ParseFromArray(field.data(), field.size());
        break;
      case 9 /* types */:
        types_.emplace_back();
        types_.back().ParseFromArray(field.data(), field.size());
        break;
      case 4 /* field_names */:
        field_names_.emplace_back();
        field_names_.back().ParseFromArray(field.data(), field.size());
        break;
      case 8 /* location_names */:
        location_names_.emplace_back();
        location_names_.back().ParseFromArray(field.data(), field.size());
        break;
      case 5 /* continued */:
        field.get(&continued_);
        break;
      case 6 /* index */:
        field.get(&index_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string HeapGraph::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> HeapGraph::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void HeapGraph::Serialize(::protozero::Message* msg) const {
  // Field 1: pid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pid_);
  }

  // Field 2: objects
  for (auto& it : objects_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  // Field 7: roots
  for (auto& it : roots_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(7));
  }

  // Field 9: types
  for (auto& it : types_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(9));
  }

  // Field 4: field_names
  for (auto& it : field_names_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  // Field 8: location_names
  for (auto& it : location_names_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(8));
  }

  // Field 5: continued
  if (_has_field_[5]) {
    msg->AppendTinyVarInt(5, continued_);
  }

  // Field 6: index
  if (_has_field_[6]) {
    msg->AppendVarInt(6, index_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


HeapGraphType::HeapGraphType() = default;
HeapGraphType::~HeapGraphType() = default;
HeapGraphType::HeapGraphType(const HeapGraphType&) = default;
HeapGraphType& HeapGraphType::operator=(const HeapGraphType&) = default;
HeapGraphType::HeapGraphType(HeapGraphType&&) noexcept = default;
HeapGraphType& HeapGraphType::operator=(HeapGraphType&&) = default;

bool HeapGraphType::operator==(const HeapGraphType& other) const {
  return unknown_fields_ == other.unknown_fields_
   && id_ == other.id_
   && location_id_ == other.location_id_
   && class_name_ == other.class_name_
   && object_size_ == other.object_size_
   && superclass_id_ == other.superclass_id_
   && reference_field_id_ == other.reference_field_id_
   && kind_ == other.kind_
   && classloader_id_ == other.classloader_id_;
}

bool HeapGraphType::ParseFromArray(const void* raw, size_t size) {
  reference_field_id_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* id */:
        field.get(&id_);
        break;
      case 2 /* location_id */:
        field.get(&location_id_);
        break;
      case 3 /* class_name */:
        field.get(&class_name_);
        break;
      case 4 /* object_size */:
        field.get(&object_size_);
        break;
      case 5 /* superclass_id */:
        field.get(&superclass_id_);
        break;
      case 6 /* reference_field_id */:
        for (::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> rep(field.data(), field.size(), &packed_error); rep; ++rep) {
          reference_field_id_.emplace_back(*rep);
        }
        break;
      case 7 /* kind */:
        field.get(&kind_);
        break;
      case 8 /* classloader_id */:
        field.get(&classloader_id_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string HeapGraphType::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> HeapGraphType::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void HeapGraphType::Serialize(::protozero::Message* msg) const {
  // Field 1: id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, id_);
  }

  // Field 2: location_id
  if (_has_field_[2]) {
    msg->AppendVarInt(2, location_id_);
  }

  // Field 3: class_name
  if (_has_field_[3]) {
    msg->AppendString(3, class_name_);
  }

  // Field 4: object_size
  if (_has_field_[4]) {
    msg->AppendVarInt(4, object_size_);
  }

  // Field 5: superclass_id
  if (_has_field_[5]) {
    msg->AppendVarInt(5, superclass_id_);
  }

  // Field 6: reference_field_id
  {
    ::protozero::PackedVarInt pack;
    for (auto& it : reference_field_id_)
      pack.Append(it);
    msg->AppendBytes(6, pack.data(), pack.size());
  }

  // Field 7: kind
  if (_has_field_[7]) {
    msg->AppendVarInt(7, kind_);
  }

  // Field 8: classloader_id
  if (_has_field_[8]) {
    msg->AppendVarInt(8, classloader_id_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


HeapGraphRoot::HeapGraphRoot() = default;
HeapGraphRoot::~HeapGraphRoot() = default;
HeapGraphRoot::HeapGraphRoot(const HeapGraphRoot&) = default;
HeapGraphRoot& HeapGraphRoot::operator=(const HeapGraphRoot&) = default;
HeapGraphRoot::HeapGraphRoot(HeapGraphRoot&&) noexcept = default;
HeapGraphRoot& HeapGraphRoot::operator=(HeapGraphRoot&&) = default;

bool HeapGraphRoot::operator==(const HeapGraphRoot& other) const {
  return unknown_fields_ == other.unknown_fields_
   && object_ids_ == other.object_ids_
   && root_type_ == other.root_type_;
}

bool HeapGraphRoot::ParseFromArray(const void* raw, size_t size) {
  object_ids_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* object_ids */:
        for (::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> rep(field.data(), field.size(), &packed_error); rep; ++rep) {
          object_ids_.emplace_back(*rep);
        }
        break;
      case 2 /* root_type */:
        field.get(&root_type_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string HeapGraphRoot::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> HeapGraphRoot::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void HeapGraphRoot::Serialize(::protozero::Message* msg) const {
  // Field 1: object_ids
  {
    ::protozero::PackedVarInt pack;
    for (auto& it : object_ids_)
      pack.Append(it);
    msg->AppendBytes(1, pack.data(), pack.size());
  }

  // Field 2: root_type
  if (_has_field_[2]) {
    msg->AppendVarInt(2, root_type_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


HeapGraphObject::HeapGraphObject() = default;
HeapGraphObject::~HeapGraphObject() = default;
HeapGraphObject::HeapGraphObject(const HeapGraphObject&) = default;
HeapGraphObject& HeapGraphObject::operator=(const HeapGraphObject&) = default;
HeapGraphObject::HeapGraphObject(HeapGraphObject&&) noexcept = default;
HeapGraphObject& HeapGraphObject::operator=(HeapGraphObject&&) = default;

bool HeapGraphObject::operator==(const HeapGraphObject& other) const {
  return unknown_fields_ == other.unknown_fields_
   && id_ == other.id_
   && type_id_ == other.type_id_
   && self_size_ == other.self_size_
   && reference_field_id_base_ == other.reference_field_id_base_
   && reference_field_id_ == other.reference_field_id_
   && reference_object_id_ == other.reference_object_id_;
}

bool HeapGraphObject::ParseFromArray(const void* raw, size_t size) {
  reference_field_id_.clear();
  reference_object_id_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* id */:
        field.get(&id_);
        break;
      case 2 /* type_id */:
        field.get(&type_id_);
        break;
      case 3 /* self_size */:
        field.get(&self_size_);
        break;
      case 6 /* reference_field_id_base */:
        field.get(&reference_field_id_base_);
        break;
      case 4 /* reference_field_id */:
        for (::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> rep(field.data(), field.size(), &packed_error); rep; ++rep) {
          reference_field_id_.emplace_back(*rep);
        }
        break;
      case 5 /* reference_object_id */:
        for (::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> rep(field.data(), field.size(), &packed_error); rep; ++rep) {
          reference_object_id_.emplace_back(*rep);
        }
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string HeapGraphObject::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> HeapGraphObject::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void HeapGraphObject::Serialize(::protozero::Message* msg) const {
  // Field 1: id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, id_);
  }

  // Field 2: type_id
  if (_has_field_[2]) {
    msg->AppendVarInt(2, type_id_);
  }

  // Field 3: self_size
  if (_has_field_[3]) {
    msg->AppendVarInt(3, self_size_);
  }

  // Field 6: reference_field_id_base
  if (_has_field_[6]) {
    msg->AppendVarInt(6, reference_field_id_base_);
  }

  // Field 4: reference_field_id
  {
    ::protozero::PackedVarInt pack;
    for (auto& it : reference_field_id_)
      pack.Append(it);
    msg->AppendBytes(4, pack.data(), pack.size());
  }

  // Field 5: reference_object_id
  {
    ::protozero::PackedVarInt pack;
    for (auto& it : reference_object_id_)
      pack.Append(it);
    msg->AppendBytes(5, pack.data(), pack.size());
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
