// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class IonBufferDestroyFtraceEvent;
class IonBufferCreateFtraceEvent;
class IonHeapGrowFtraceEvent;
class IonHeapShrinkFtraceEvent;
class RssStatFtraceEvent;
class MmPagePcpuDrainFtraceEvent;
class MmPageFreeBatchedFtraceEvent;
class MmPageFreeFtraceEvent;
class MmPageAllocZoneLockedFtraceEvent;
class MmPageAllocExtfragFtraceEvent;
class MmPageAllocFtraceEvent;
class MigrateRetryFtraceEvent;
class MigratePagesStartFtraceEvent;
class MigratePagesEndFtraceEvent;
class KmemCacheFreeFtraceEvent;
class KmemCacheAllocNodeFtraceEvent;
class KmemCacheAllocFtraceEvent;
class KmallocNodeFtraceEvent;
class KmallocFtraceEvent;
class KfreeFtraceEvent;
class IonSecureCmaShrinkPoolStartFtraceEvent;
class IonSecureCmaShrinkPoolEndFtraceEvent;
class IonSecureCmaAllocateStartFtraceEvent;
class IonSecureCmaAllocateEndFtraceEvent;
class IonSecureCmaAddToPoolStartFtraceEvent;
class IonSecureCmaAddToPoolEndFtraceEvent;
class IonPrefetchingFtraceEvent;
class IonCpSecureBufferStartFtraceEvent;
class IonCpSecureBufferEndFtraceEvent;
class IonCpAllocRetryFtraceEvent;
class IonAllocBufferStartFtraceEvent;
class IonAllocBufferFallbackFtraceEvent;
class IonAllocBufferFailFtraceEvent;
class IonAllocBufferEndFtraceEvent;
class IommuSecPtblMapRangeStartFtraceEvent;
class IommuSecPtblMapRangeEndFtraceEvent;
class IommuMapRangeFtraceEvent;
class DmaAllocContiguousRetryFtraceEvent;
class AllocPagesSysStartFtraceEvent;
class AllocPagesSysFailFtraceEvent;
class AllocPagesSysEndFtraceEvent;
class AllocPagesIommuStartFtraceEvent;
class AllocPagesIommuFailFtraceEvent;
class AllocPagesIommuEndFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT IonBufferDestroyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };

  IonBufferDestroyFtraceEvent();
  ~IonBufferDestroyFtraceEvent() override;
  IonBufferDestroyFtraceEvent(IonBufferDestroyFtraceEvent&&) noexcept;
  IonBufferDestroyFtraceEvent& operator=(IonBufferDestroyFtraceEvent&&);
  IonBufferDestroyFtraceEvent(const IonBufferDestroyFtraceEvent&);
  IonBufferDestroyFtraceEvent& operator=(const IonBufferDestroyFtraceEvent&);
  bool operator==(const IonBufferDestroyFtraceEvent&) const;
  bool operator!=(const IonBufferDestroyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_addr() const { return _has_field_[1]; }
  uint64_t addr() const { return addr_; }
  void set_addr(uint64_t value) { addr_ = value; _has_field_.set(1); }

  bool has_len() const { return _has_field_[2]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(2); }

 private:
  uint64_t addr_{};
  uint64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT IonBufferCreateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };

  IonBufferCreateFtraceEvent();
  ~IonBufferCreateFtraceEvent() override;
  IonBufferCreateFtraceEvent(IonBufferCreateFtraceEvent&&) noexcept;
  IonBufferCreateFtraceEvent& operator=(IonBufferCreateFtraceEvent&&);
  IonBufferCreateFtraceEvent(const IonBufferCreateFtraceEvent&);
  IonBufferCreateFtraceEvent& operator=(const IonBufferCreateFtraceEvent&);
  bool operator==(const IonBufferCreateFtraceEvent&) const;
  bool operator!=(const IonBufferCreateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_addr() const { return _has_field_[1]; }
  uint64_t addr() const { return addr_; }
  void set_addr(uint64_t value) { addr_ = value; _has_field_.set(1); }

  bool has_len() const { return _has_field_[2]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(2); }

 private:
  uint64_t addr_{};
  uint64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT IonHeapGrowFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };

  IonHeapGrowFtraceEvent();
  ~IonHeapGrowFtraceEvent() override;
  IonHeapGrowFtraceEvent(IonHeapGrowFtraceEvent&&) noexcept;
  IonHeapGrowFtraceEvent& operator=(IonHeapGrowFtraceEvent&&);
  IonHeapGrowFtraceEvent(const IonHeapGrowFtraceEvent&);
  IonHeapGrowFtraceEvent& operator=(const IonHeapGrowFtraceEvent&);
  bool operator==(const IonHeapGrowFtraceEvent&) const;
  bool operator!=(const IonHeapGrowFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_heap_name() const { return _has_field_[1]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(1); }

  bool has_len() const { return _has_field_[2]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(2); }

  bool has_total_allocated() const { return _has_field_[3]; }
  int64_t total_allocated() const { return total_allocated_; }
  void set_total_allocated(int64_t value) { total_allocated_ = value; _has_field_.set(3); }

 private:
  std::string heap_name_{};
  uint64_t len_{};
  int64_t total_allocated_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT IonHeapShrinkFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };

  IonHeapShrinkFtraceEvent();
  ~IonHeapShrinkFtraceEvent() override;
  IonHeapShrinkFtraceEvent(IonHeapShrinkFtraceEvent&&) noexcept;
  IonHeapShrinkFtraceEvent& operator=(IonHeapShrinkFtraceEvent&&);
  IonHeapShrinkFtraceEvent(const IonHeapShrinkFtraceEvent&);
  IonHeapShrinkFtraceEvent& operator=(const IonHeapShrinkFtraceEvent&);
  bool operator==(const IonHeapShrinkFtraceEvent&) const;
  bool operator!=(const IonHeapShrinkFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_heap_name() const { return _has_field_[1]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(1); }

  bool has_len() const { return _has_field_[2]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(2); }

  bool has_total_allocated() const { return _has_field_[3]; }
  int64_t total_allocated() const { return total_allocated_; }
  void set_total_allocated(int64_t value) { total_allocated_ = value; _has_field_.set(3); }

 private:
  std::string heap_name_{};
  uint64_t len_{};
  int64_t total_allocated_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT RssStatFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kMemberFieldNumber = 1,
    kSizeFieldNumber = 2,
    kCurrFieldNumber = 3,
    kMmIdFieldNumber = 4,
  };

  RssStatFtraceEvent();
  ~RssStatFtraceEvent() override;
  RssStatFtraceEvent(RssStatFtraceEvent&&) noexcept;
  RssStatFtraceEvent& operator=(RssStatFtraceEvent&&);
  RssStatFtraceEvent(const RssStatFtraceEvent&);
  RssStatFtraceEvent& operator=(const RssStatFtraceEvent&);
  bool operator==(const RssStatFtraceEvent&) const;
  bool operator!=(const RssStatFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_member() const { return _has_field_[1]; }
  int32_t member() const { return member_; }
  void set_member(int32_t value) { member_ = value; _has_field_.set(1); }

  bool has_size() const { return _has_field_[2]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(2); }

  bool has_curr() const { return _has_field_[3]; }
  uint32_t curr() const { return curr_; }
  void set_curr(uint32_t value) { curr_ = value; _has_field_.set(3); }

  bool has_mm_id() const { return _has_field_[4]; }
  uint32_t mm_id() const { return mm_id_; }
  void set_mm_id(uint32_t value) { mm_id_ = value; _has_field_.set(4); }

 private:
  int32_t member_{};
  int64_t size_{};
  uint32_t curr_{};
  uint32_t mm_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT MmPagePcpuDrainFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };

  MmPagePcpuDrainFtraceEvent();
  ~MmPagePcpuDrainFtraceEvent() override;
  MmPagePcpuDrainFtraceEvent(MmPagePcpuDrainFtraceEvent&&) noexcept;
  MmPagePcpuDrainFtraceEvent& operator=(MmPagePcpuDrainFtraceEvent&&);
  MmPagePcpuDrainFtraceEvent(const MmPagePcpuDrainFtraceEvent&);
  MmPagePcpuDrainFtraceEvent& operator=(const MmPagePcpuDrainFtraceEvent&);
  bool operator==(const MmPagePcpuDrainFtraceEvent&) const;
  bool operator!=(const MmPagePcpuDrainFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_migratetype() const { return _has_field_[1]; }
  int32_t migratetype() const { return migratetype_; }
  void set_migratetype(int32_t value) { migratetype_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(2); }

  bool has_page() const { return _has_field_[3]; }
  uint64_t page() const { return page_; }
  void set_page(uint64_t value) { page_ = value; _has_field_.set(3); }

  bool has_pfn() const { return _has_field_[4]; }
  uint64_t pfn() const { return pfn_; }
  void set_pfn(uint64_t value) { pfn_ = value; _has_field_.set(4); }

 private:
  int32_t migratetype_{};
  uint32_t order_{};
  uint64_t page_{};
  uint64_t pfn_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT MmPageFreeBatchedFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kColdFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };

  MmPageFreeBatchedFtraceEvent();
  ~MmPageFreeBatchedFtraceEvent() override;
  MmPageFreeBatchedFtraceEvent(MmPageFreeBatchedFtraceEvent&&) noexcept;
  MmPageFreeBatchedFtraceEvent& operator=(MmPageFreeBatchedFtraceEvent&&);
  MmPageFreeBatchedFtraceEvent(const MmPageFreeBatchedFtraceEvent&);
  MmPageFreeBatchedFtraceEvent& operator=(const MmPageFreeBatchedFtraceEvent&);
  bool operator==(const MmPageFreeBatchedFtraceEvent&) const;
  bool operator!=(const MmPageFreeBatchedFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cold() const { return _has_field_[1]; }
  int32_t cold() const { return cold_; }
  void set_cold(int32_t value) { cold_ = value; _has_field_.set(1); }

  bool has_page() const { return _has_field_[2]; }
  uint64_t page() const { return page_; }
  void set_page(uint64_t value) { page_ = value; _has_field_.set(2); }

  bool has_pfn() const { return _has_field_[3]; }
  uint64_t pfn() const { return pfn_; }
  void set_pfn(uint64_t value) { pfn_ = value; _has_field_.set(3); }

 private:
  int32_t cold_{};
  uint64_t page_{};
  uint64_t pfn_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT MmPageFreeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kOrderFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };

  MmPageFreeFtraceEvent();
  ~MmPageFreeFtraceEvent() override;
  MmPageFreeFtraceEvent(MmPageFreeFtraceEvent&&) noexcept;
  MmPageFreeFtraceEvent& operator=(MmPageFreeFtraceEvent&&);
  MmPageFreeFtraceEvent(const MmPageFreeFtraceEvent&);
  MmPageFreeFtraceEvent& operator=(const MmPageFreeFtraceEvent&);
  bool operator==(const MmPageFreeFtraceEvent&) const;
  bool operator!=(const MmPageFreeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_order() const { return _has_field_[1]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(1); }

  bool has_page() const { return _has_field_[2]; }
  uint64_t page() const { return page_; }
  void set_page(uint64_t value) { page_ = value; _has_field_.set(2); }

  bool has_pfn() const { return _has_field_[3]; }
  uint64_t pfn() const { return pfn_; }
  void set_pfn(uint64_t value) { pfn_ = value; _has_field_.set(3); }

 private:
  uint32_t order_{};
  uint64_t page_{};
  uint64_t pfn_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT MmPageAllocZoneLockedFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };

  MmPageAllocZoneLockedFtraceEvent();
  ~MmPageAllocZoneLockedFtraceEvent() override;
  MmPageAllocZoneLockedFtraceEvent(MmPageAllocZoneLockedFtraceEvent&&) noexcept;
  MmPageAllocZoneLockedFtraceEvent& operator=(MmPageAllocZoneLockedFtraceEvent&&);
  MmPageAllocZoneLockedFtraceEvent(const MmPageAllocZoneLockedFtraceEvent&);
  MmPageAllocZoneLockedFtraceEvent& operator=(const MmPageAllocZoneLockedFtraceEvent&);
  bool operator==(const MmPageAllocZoneLockedFtraceEvent&) const;
  bool operator!=(const MmPageAllocZoneLockedFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_migratetype() const { return _has_field_[1]; }
  int32_t migratetype() const { return migratetype_; }
  void set_migratetype(int32_t value) { migratetype_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(2); }

  bool has_page() const { return _has_field_[3]; }
  uint64_t page() const { return page_; }
  void set_page(uint64_t value) { page_ = value; _has_field_.set(3); }

  bool has_pfn() const { return _has_field_[4]; }
  uint64_t pfn() const { return pfn_; }
  void set_pfn(uint64_t value) { pfn_ = value; _has_field_.set(4); }

 private:
  int32_t migratetype_{};
  uint32_t order_{};
  uint64_t page_{};
  uint64_t pfn_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT MmPageAllocExtfragFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAllocMigratetypeFieldNumber = 1,
    kAllocOrderFieldNumber = 2,
    kFallbackMigratetypeFieldNumber = 3,
    kFallbackOrderFieldNumber = 4,
    kPageFieldNumber = 5,
    kChangeOwnershipFieldNumber = 6,
    kPfnFieldNumber = 7,
  };

  MmPageAllocExtfragFtraceEvent();
  ~MmPageAllocExtfragFtraceEvent() override;
  MmPageAllocExtfragFtraceEvent(MmPageAllocExtfragFtraceEvent&&) noexcept;
  MmPageAllocExtfragFtraceEvent& operator=(MmPageAllocExtfragFtraceEvent&&);
  MmPageAllocExtfragFtraceEvent(const MmPageAllocExtfragFtraceEvent&);
  MmPageAllocExtfragFtraceEvent& operator=(const MmPageAllocExtfragFtraceEvent&);
  bool operator==(const MmPageAllocExtfragFtraceEvent&) const;
  bool operator!=(const MmPageAllocExtfragFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_alloc_migratetype() const { return _has_field_[1]; }
  int32_t alloc_migratetype() const { return alloc_migratetype_; }
  void set_alloc_migratetype(int32_t value) { alloc_migratetype_ = value; _has_field_.set(1); }

  bool has_alloc_order() const { return _has_field_[2]; }
  int32_t alloc_order() const { return alloc_order_; }
  void set_alloc_order(int32_t value) { alloc_order_ = value; _has_field_.set(2); }

  bool has_fallback_migratetype() const { return _has_field_[3]; }
  int32_t fallback_migratetype() const { return fallback_migratetype_; }
  void set_fallback_migratetype(int32_t value) { fallback_migratetype_ = value; _has_field_.set(3); }

  bool has_fallback_order() const { return _has_field_[4]; }
  int32_t fallback_order() const { return fallback_order_; }
  void set_fallback_order(int32_t value) { fallback_order_ = value; _has_field_.set(4); }

  bool has_page() const { return _has_field_[5]; }
  uint64_t page() const { return page_; }
  void set_page(uint64_t value) { page_ = value; _has_field_.set(5); }

  bool has_change_ownership() const { return _has_field_[6]; }
  int32_t change_ownership() const { return change_ownership_; }
  void set_change_ownership(int32_t value) { change_ownership_ = value; _has_field_.set(6); }

  bool has_pfn() const { return _has_field_[7]; }
  uint64_t pfn() const { return pfn_; }
  void set_pfn(uint64_t value) { pfn_ = value; _has_field_.set(7); }

 private:
  int32_t alloc_migratetype_{};
  int32_t alloc_order_{};
  int32_t fallback_migratetype_{};
  int32_t fallback_order_{};
  uint64_t page_{};
  int32_t change_ownership_{};
  uint64_t pfn_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT MmPageAllocFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGfpFlagsFieldNumber = 1,
    kMigratetypeFieldNumber = 2,
    kOrderFieldNumber = 3,
    kPageFieldNumber = 4,
    kPfnFieldNumber = 5,
  };

  MmPageAllocFtraceEvent();
  ~MmPageAllocFtraceEvent() override;
  MmPageAllocFtraceEvent(MmPageAllocFtraceEvent&&) noexcept;
  MmPageAllocFtraceEvent& operator=(MmPageAllocFtraceEvent&&);
  MmPageAllocFtraceEvent(const MmPageAllocFtraceEvent&);
  MmPageAllocFtraceEvent& operator=(const MmPageAllocFtraceEvent&);
  bool operator==(const MmPageAllocFtraceEvent&) const;
  bool operator!=(const MmPageAllocFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gfp_flags() const { return _has_field_[1]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(1); }

  bool has_migratetype() const { return _has_field_[2]; }
  int32_t migratetype() const { return migratetype_; }
  void set_migratetype(int32_t value) { migratetype_ = value; _has_field_.set(2); }

  bool has_order() const { return _has_field_[3]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(3); }

  bool has_page() const { return _has_field_[4]; }
  uint64_t page() const { return page_; }
  void set_page(uint64_t value) { page_ = value; _has_field_.set(4); }

  bool has_pfn() const { return _has_field_[5]; }
  uint64_t pfn() const { return pfn_; }
  void set_pfn(uint64_t value) { pfn_ = value; _has_field_.set(5); }

 private:
  uint32_t gfp_flags_{};
  int32_t migratetype_{};
  uint32_t order_{};
  uint64_t page_{};
  uint64_t pfn_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT MigrateRetryFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kTriesFieldNumber = 1,
  };

  MigrateRetryFtraceEvent();
  ~MigrateRetryFtraceEvent() override;
  MigrateRetryFtraceEvent(MigrateRetryFtraceEvent&&) noexcept;
  MigrateRetryFtraceEvent& operator=(MigrateRetryFtraceEvent&&);
  MigrateRetryFtraceEvent(const MigrateRetryFtraceEvent&);
  MigrateRetryFtraceEvent& operator=(const MigrateRetryFtraceEvent&);
  bool operator==(const MigrateRetryFtraceEvent&) const;
  bool operator!=(const MigrateRetryFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_tries() const { return _has_field_[1]; }
  int32_t tries() const { return tries_; }
  void set_tries(int32_t value) { tries_ = value; _has_field_.set(1); }

 private:
  int32_t tries_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT MigratePagesStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kModeFieldNumber = 1,
  };

  MigratePagesStartFtraceEvent();
  ~MigratePagesStartFtraceEvent() override;
  MigratePagesStartFtraceEvent(MigratePagesStartFtraceEvent&&) noexcept;
  MigratePagesStartFtraceEvent& operator=(MigratePagesStartFtraceEvent&&);
  MigratePagesStartFtraceEvent(const MigratePagesStartFtraceEvent&);
  MigratePagesStartFtraceEvent& operator=(const MigratePagesStartFtraceEvent&);
  bool operator==(const MigratePagesStartFtraceEvent&) const;
  bool operator!=(const MigratePagesStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_mode() const { return _has_field_[1]; }
  int32_t mode() const { return mode_; }
  void set_mode(int32_t value) { mode_ = value; _has_field_.set(1); }

 private:
  int32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT MigratePagesEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kModeFieldNumber = 1,
  };

  MigratePagesEndFtraceEvent();
  ~MigratePagesEndFtraceEvent() override;
  MigratePagesEndFtraceEvent(MigratePagesEndFtraceEvent&&) noexcept;
  MigratePagesEndFtraceEvent& operator=(MigratePagesEndFtraceEvent&&);
  MigratePagesEndFtraceEvent(const MigratePagesEndFtraceEvent&);
  MigratePagesEndFtraceEvent& operator=(const MigratePagesEndFtraceEvent&);
  bool operator==(const MigratePagesEndFtraceEvent&) const;
  bool operator!=(const MigratePagesEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_mode() const { return _has_field_[1]; }
  int32_t mode() const { return mode_; }
  void set_mode(int32_t value) { mode_ = value; _has_field_.set(1); }

 private:
  int32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT KmemCacheFreeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };

  KmemCacheFreeFtraceEvent();
  ~KmemCacheFreeFtraceEvent() override;
  KmemCacheFreeFtraceEvent(KmemCacheFreeFtraceEvent&&) noexcept;
  KmemCacheFreeFtraceEvent& operator=(KmemCacheFreeFtraceEvent&&);
  KmemCacheFreeFtraceEvent(const KmemCacheFreeFtraceEvent&);
  KmemCacheFreeFtraceEvent& operator=(const KmemCacheFreeFtraceEvent&);
  bool operator==(const KmemCacheFreeFtraceEvent&) const;
  bool operator!=(const KmemCacheFreeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_call_site() const { return _has_field_[1]; }
  uint64_t call_site() const { return call_site_; }
  void set_call_site(uint64_t value) { call_site_ = value; _has_field_.set(1); }

  bool has_ptr() const { return _has_field_[2]; }
  uint64_t ptr() const { return ptr_; }
  void set_ptr(uint64_t value) { ptr_ = value; _has_field_.set(2); }

 private:
  uint64_t call_site_{};
  uint64_t ptr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT KmemCacheAllocNodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };

  KmemCacheAllocNodeFtraceEvent();
  ~KmemCacheAllocNodeFtraceEvent() override;
  KmemCacheAllocNodeFtraceEvent(KmemCacheAllocNodeFtraceEvent&&) noexcept;
  KmemCacheAllocNodeFtraceEvent& operator=(KmemCacheAllocNodeFtraceEvent&&);
  KmemCacheAllocNodeFtraceEvent(const KmemCacheAllocNodeFtraceEvent&);
  KmemCacheAllocNodeFtraceEvent& operator=(const KmemCacheAllocNodeFtraceEvent&);
  bool operator==(const KmemCacheAllocNodeFtraceEvent&) const;
  bool operator!=(const KmemCacheAllocNodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_bytes_alloc() const { return _has_field_[1]; }
  uint64_t bytes_alloc() const { return bytes_alloc_; }
  void set_bytes_alloc(uint64_t value) { bytes_alloc_ = value; _has_field_.set(1); }

  bool has_bytes_req() const { return _has_field_[2]; }
  uint64_t bytes_req() const { return bytes_req_; }
  void set_bytes_req(uint64_t value) { bytes_req_ = value; _has_field_.set(2); }

  bool has_call_site() const { return _has_field_[3]; }
  uint64_t call_site() const { return call_site_; }
  void set_call_site(uint64_t value) { call_site_ = value; _has_field_.set(3); }

  bool has_gfp_flags() const { return _has_field_[4]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(4); }

  bool has_node() const { return _has_field_[5]; }
  int32_t node() const { return node_; }
  void set_node(int32_t value) { node_ = value; _has_field_.set(5); }

  bool has_ptr() const { return _has_field_[6]; }
  uint64_t ptr() const { return ptr_; }
  void set_ptr(uint64_t value) { ptr_ = value; _has_field_.set(6); }

 private:
  uint64_t bytes_alloc_{};
  uint64_t bytes_req_{};
  uint64_t call_site_{};
  uint32_t gfp_flags_{};
  int32_t node_{};
  uint64_t ptr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT KmemCacheAllocFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };

  KmemCacheAllocFtraceEvent();
  ~KmemCacheAllocFtraceEvent() override;
  KmemCacheAllocFtraceEvent(KmemCacheAllocFtraceEvent&&) noexcept;
  KmemCacheAllocFtraceEvent& operator=(KmemCacheAllocFtraceEvent&&);
  KmemCacheAllocFtraceEvent(const KmemCacheAllocFtraceEvent&);
  KmemCacheAllocFtraceEvent& operator=(const KmemCacheAllocFtraceEvent&);
  bool operator==(const KmemCacheAllocFtraceEvent&) const;
  bool operator!=(const KmemCacheAllocFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_bytes_alloc() const { return _has_field_[1]; }
  uint64_t bytes_alloc() const { return bytes_alloc_; }
  void set_bytes_alloc(uint64_t value) { bytes_alloc_ = value; _has_field_.set(1); }

  bool has_bytes_req() const { return _has_field_[2]; }
  uint64_t bytes_req() const { return bytes_req_; }
  void set_bytes_req(uint64_t value) { bytes_req_ = value; _has_field_.set(2); }

  bool has_call_site() const { return _has_field_[3]; }
  uint64_t call_site() const { return call_site_; }
  void set_call_site(uint64_t value) { call_site_ = value; _has_field_.set(3); }

  bool has_gfp_flags() const { return _has_field_[4]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(4); }

  bool has_ptr() const { return _has_field_[5]; }
  uint64_t ptr() const { return ptr_; }
  void set_ptr(uint64_t value) { ptr_ = value; _has_field_.set(5); }

 private:
  uint64_t bytes_alloc_{};
  uint64_t bytes_req_{};
  uint64_t call_site_{};
  uint32_t gfp_flags_{};
  uint64_t ptr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT KmallocNodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };

  KmallocNodeFtraceEvent();
  ~KmallocNodeFtraceEvent() override;
  KmallocNodeFtraceEvent(KmallocNodeFtraceEvent&&) noexcept;
  KmallocNodeFtraceEvent& operator=(KmallocNodeFtraceEvent&&);
  KmallocNodeFtraceEvent(const KmallocNodeFtraceEvent&);
  KmallocNodeFtraceEvent& operator=(const KmallocNodeFtraceEvent&);
  bool operator==(const KmallocNodeFtraceEvent&) const;
  bool operator!=(const KmallocNodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_bytes_alloc() const { return _has_field_[1]; }
  uint64_t bytes_alloc() const { return bytes_alloc_; }
  void set_bytes_alloc(uint64_t value) { bytes_alloc_ = value; _has_field_.set(1); }

  bool has_bytes_req() const { return _has_field_[2]; }
  uint64_t bytes_req() const { return bytes_req_; }
  void set_bytes_req(uint64_t value) { bytes_req_ = value; _has_field_.set(2); }

  bool has_call_site() const { return _has_field_[3]; }
  uint64_t call_site() const { return call_site_; }
  void set_call_site(uint64_t value) { call_site_ = value; _has_field_.set(3); }

  bool has_gfp_flags() const { return _has_field_[4]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(4); }

  bool has_node() const { return _has_field_[5]; }
  int32_t node() const { return node_; }
  void set_node(int32_t value) { node_ = value; _has_field_.set(5); }

  bool has_ptr() const { return _has_field_[6]; }
  uint64_t ptr() const { return ptr_; }
  void set_ptr(uint64_t value) { ptr_ = value; _has_field_.set(6); }

 private:
  uint64_t bytes_alloc_{};
  uint64_t bytes_req_{};
  uint64_t call_site_{};
  uint32_t gfp_flags_{};
  int32_t node_{};
  uint64_t ptr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT KmallocFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };

  KmallocFtraceEvent();
  ~KmallocFtraceEvent() override;
  KmallocFtraceEvent(KmallocFtraceEvent&&) noexcept;
  KmallocFtraceEvent& operator=(KmallocFtraceEvent&&);
  KmallocFtraceEvent(const KmallocFtraceEvent&);
  KmallocFtraceEvent& operator=(const KmallocFtraceEvent&);
  bool operator==(const KmallocFtraceEvent&) const;
  bool operator!=(const KmallocFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_bytes_alloc() const { return _has_field_[1]; }
  uint64_t bytes_alloc() const { return bytes_alloc_; }
  void set_bytes_alloc(uint64_t value) { bytes_alloc_ = value; _has_field_.set(1); }

  bool has_bytes_req() const { return _has_field_[2]; }
  uint64_t bytes_req() const { return bytes_req_; }
  void set_bytes_req(uint64_t value) { bytes_req_ = value; _has_field_.set(2); }

  bool has_call_site() const { return _has_field_[3]; }
  uint64_t call_site() const { return call_site_; }
  void set_call_site(uint64_t value) { call_site_ = value; _has_field_.set(3); }

  bool has_gfp_flags() const { return _has_field_[4]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(4); }

  bool has_ptr() const { return _has_field_[5]; }
  uint64_t ptr() const { return ptr_; }
  void set_ptr(uint64_t value) { ptr_ = value; _has_field_.set(5); }

 private:
  uint64_t bytes_alloc_{};
  uint64_t bytes_req_{};
  uint64_t call_site_{};
  uint32_t gfp_flags_{};
  uint64_t ptr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT KfreeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };

  KfreeFtraceEvent();
  ~KfreeFtraceEvent() override;
  KfreeFtraceEvent(KfreeFtraceEvent&&) noexcept;
  KfreeFtraceEvent& operator=(KfreeFtraceEvent&&);
  KfreeFtraceEvent(const KfreeFtraceEvent&);
  KfreeFtraceEvent& operator=(const KfreeFtraceEvent&);
  bool operator==(const KfreeFtraceEvent&) const;
  bool operator!=(const KfreeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_call_site() const { return _has_field_[1]; }
  uint64_t call_site() const { return call_site_; }
  void set_call_site(uint64_t value) { call_site_ = value; _has_field_.set(1); }

  bool has_ptr() const { return _has_field_[2]; }
  uint64_t ptr() const { return ptr_; }
  void set_ptr(uint64_t value) { ptr_ = value; _has_field_.set(2); }

 private:
  uint64_t call_site_{};
  uint64_t ptr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT IonSecureCmaShrinkPoolStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };

  IonSecureCmaShrinkPoolStartFtraceEvent();
  ~IonSecureCmaShrinkPoolStartFtraceEvent() override;
  IonSecureCmaShrinkPoolStartFtraceEvent(IonSecureCmaShrinkPoolStartFtraceEvent&&) noexcept;
  IonSecureCmaShrinkPoolStartFtraceEvent& operator=(IonSecureCmaShrinkPoolStartFtraceEvent&&);
  IonSecureCmaShrinkPoolStartFtraceEvent(const IonSecureCmaShrinkPoolStartFtraceEvent&);
  IonSecureCmaShrinkPoolStartFtraceEvent& operator=(const IonSecureCmaShrinkPoolStartFtraceEvent&);
  bool operator==(const IonSecureCmaShrinkPoolStartFtraceEvent&) const;
  bool operator!=(const IonSecureCmaShrinkPoolStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_drained_size() const { return _has_field_[1]; }
  uint64_t drained_size() const { return drained_size_; }
  void set_drained_size(uint64_t value) { drained_size_ = value; _has_field_.set(1); }

  bool has_skipped_size() const { return _has_field_[2]; }
  uint64_t skipped_size() const { return skipped_size_; }
  void set_skipped_size(uint64_t value) { skipped_size_ = value; _has_field_.set(2); }

 private:
  uint64_t drained_size_{};
  uint64_t skipped_size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT IonSecureCmaShrinkPoolEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };

  IonSecureCmaShrinkPoolEndFtraceEvent();
  ~IonSecureCmaShrinkPoolEndFtraceEvent() override;
  IonSecureCmaShrinkPoolEndFtraceEvent(IonSecureCmaShrinkPoolEndFtraceEvent&&) noexcept;
  IonSecureCmaShrinkPoolEndFtraceEvent& operator=(IonSecureCmaShrinkPoolEndFtraceEvent&&);
  IonSecureCmaShrinkPoolEndFtraceEvent(const IonSecureCmaShrinkPoolEndFtraceEvent&);
  IonSecureCmaShrinkPoolEndFtraceEvent& operator=(const IonSecureCmaShrinkPoolEndFtraceEvent&);
  bool operator==(const IonSecureCmaShrinkPoolEndFtraceEvent&) const;
  bool operator!=(const IonSecureCmaShrinkPoolEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_drained_size() const { return _has_field_[1]; }
  uint64_t drained_size() const { return drained_size_; }
  void set_drained_size(uint64_t value) { drained_size_ = value; _has_field_.set(1); }

  bool has_skipped_size() const { return _has_field_[2]; }
  uint64_t skipped_size() const { return skipped_size_; }
  void set_skipped_size(uint64_t value) { skipped_size_ = value; _has_field_.set(2); }

 private:
  uint64_t drained_size_{};
  uint64_t skipped_size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT IonSecureCmaAllocateStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };

  IonSecureCmaAllocateStartFtraceEvent();
  ~IonSecureCmaAllocateStartFtraceEvent() override;
  IonSecureCmaAllocateStartFtraceEvent(IonSecureCmaAllocateStartFtraceEvent&&) noexcept;
  IonSecureCmaAllocateStartFtraceEvent& operator=(IonSecureCmaAllocateStartFtraceEvent&&);
  IonSecureCmaAllocateStartFtraceEvent(const IonSecureCmaAllocateStartFtraceEvent&);
  IonSecureCmaAllocateStartFtraceEvent& operator=(const IonSecureCmaAllocateStartFtraceEvent&);
  bool operator==(const IonSecureCmaAllocateStartFtraceEvent&) const;
  bool operator!=(const IonSecureCmaAllocateStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_align() const { return _has_field_[1]; }
  uint64_t align() const { return align_; }
  void set_align(uint64_t value) { align_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint64_t flags() const { return flags_; }
  void set_flags(uint64_t value) { flags_ = value; _has_field_.set(2); }

  bool has_heap_name() const { return _has_field_[3]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(4); }

 private:
  uint64_t align_{};
  uint64_t flags_{};
  std::string heap_name_{};
  uint64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT IonSecureCmaAllocateEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };

  IonSecureCmaAllocateEndFtraceEvent();
  ~IonSecureCmaAllocateEndFtraceEvent() override;
  IonSecureCmaAllocateEndFtraceEvent(IonSecureCmaAllocateEndFtraceEvent&&) noexcept;
  IonSecureCmaAllocateEndFtraceEvent& operator=(IonSecureCmaAllocateEndFtraceEvent&&);
  IonSecureCmaAllocateEndFtraceEvent(const IonSecureCmaAllocateEndFtraceEvent&);
  IonSecureCmaAllocateEndFtraceEvent& operator=(const IonSecureCmaAllocateEndFtraceEvent&);
  bool operator==(const IonSecureCmaAllocateEndFtraceEvent&) const;
  bool operator!=(const IonSecureCmaAllocateEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_align() const { return _has_field_[1]; }
  uint64_t align() const { return align_; }
  void set_align(uint64_t value) { align_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint64_t flags() const { return flags_; }
  void set_flags(uint64_t value) { flags_ = value; _has_field_.set(2); }

  bool has_heap_name() const { return _has_field_[3]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(4); }

 private:
  uint64_t align_{};
  uint64_t flags_{};
  std::string heap_name_{};
  uint64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT IonSecureCmaAddToPoolStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };

  IonSecureCmaAddToPoolStartFtraceEvent();
  ~IonSecureCmaAddToPoolStartFtraceEvent() override;
  IonSecureCmaAddToPoolStartFtraceEvent(IonSecureCmaAddToPoolStartFtraceEvent&&) noexcept;
  IonSecureCmaAddToPoolStartFtraceEvent& operator=(IonSecureCmaAddToPoolStartFtraceEvent&&);
  IonSecureCmaAddToPoolStartFtraceEvent(const IonSecureCmaAddToPoolStartFtraceEvent&);
  IonSecureCmaAddToPoolStartFtraceEvent& operator=(const IonSecureCmaAddToPoolStartFtraceEvent&);
  bool operator==(const IonSecureCmaAddToPoolStartFtraceEvent&) const;
  bool operator!=(const IonSecureCmaAddToPoolStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_is_prefetch() const { return _has_field_[1]; }
  uint32_t is_prefetch() const { return is_prefetch_; }
  void set_is_prefetch(uint32_t value) { is_prefetch_ = value; _has_field_.set(1); }

  bool has_len() const { return _has_field_[2]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(2); }

  bool has_pool_total() const { return _has_field_[3]; }
  int32_t pool_total() const { return pool_total_; }
  void set_pool_total(int32_t value) { pool_total_ = value; _has_field_.set(3); }

 private:
  uint32_t is_prefetch_{};
  uint64_t len_{};
  int32_t pool_total_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT IonSecureCmaAddToPoolEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };

  IonSecureCmaAddToPoolEndFtraceEvent();
  ~IonSecureCmaAddToPoolEndFtraceEvent() override;
  IonSecureCmaAddToPoolEndFtraceEvent(IonSecureCmaAddToPoolEndFtraceEvent&&) noexcept;
  IonSecureCmaAddToPoolEndFtraceEvent& operator=(IonSecureCmaAddToPoolEndFtraceEvent&&);
  IonSecureCmaAddToPoolEndFtraceEvent(const IonSecureCmaAddToPoolEndFtraceEvent&);
  IonSecureCmaAddToPoolEndFtraceEvent& operator=(const IonSecureCmaAddToPoolEndFtraceEvent&);
  bool operator==(const IonSecureCmaAddToPoolEndFtraceEvent&) const;
  bool operator!=(const IonSecureCmaAddToPoolEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_is_prefetch() const { return _has_field_[1]; }
  uint32_t is_prefetch() const { return is_prefetch_; }
  void set_is_prefetch(uint32_t value) { is_prefetch_ = value; _has_field_.set(1); }

  bool has_len() const { return _has_field_[2]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(2); }

  bool has_pool_total() const { return _has_field_[3]; }
  int32_t pool_total() const { return pool_total_; }
  void set_pool_total(int32_t value) { pool_total_ = value; _has_field_.set(3); }

 private:
  uint32_t is_prefetch_{};
  uint64_t len_{};
  int32_t pool_total_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT IonPrefetchingFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLenFieldNumber = 1,
  };

  IonPrefetchingFtraceEvent();
  ~IonPrefetchingFtraceEvent() override;
  IonPrefetchingFtraceEvent(IonPrefetchingFtraceEvent&&) noexcept;
  IonPrefetchingFtraceEvent& operator=(IonPrefetchingFtraceEvent&&);
  IonPrefetchingFtraceEvent(const IonPrefetchingFtraceEvent&);
  IonPrefetchingFtraceEvent& operator=(const IonPrefetchingFtraceEvent&);
  bool operator==(const IonPrefetchingFtraceEvent&) const;
  bool operator!=(const IonPrefetchingFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_len() const { return _has_field_[1]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(1); }

 private:
  uint64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT IonCpSecureBufferStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };

  IonCpSecureBufferStartFtraceEvent();
  ~IonCpSecureBufferStartFtraceEvent() override;
  IonCpSecureBufferStartFtraceEvent(IonCpSecureBufferStartFtraceEvent&&) noexcept;
  IonCpSecureBufferStartFtraceEvent& operator=(IonCpSecureBufferStartFtraceEvent&&);
  IonCpSecureBufferStartFtraceEvent(const IonCpSecureBufferStartFtraceEvent&);
  IonCpSecureBufferStartFtraceEvent& operator=(const IonCpSecureBufferStartFtraceEvent&);
  bool operator==(const IonCpSecureBufferStartFtraceEvent&) const;
  bool operator!=(const IonCpSecureBufferStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_align() const { return _has_field_[1]; }
  uint64_t align() const { return align_; }
  void set_align(uint64_t value) { align_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint64_t flags() const { return flags_; }
  void set_flags(uint64_t value) { flags_ = value; _has_field_.set(2); }

  bool has_heap_name() const { return _has_field_[3]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(4); }

 private:
  uint64_t align_{};
  uint64_t flags_{};
  std::string heap_name_{};
  uint64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT IonCpSecureBufferEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };

  IonCpSecureBufferEndFtraceEvent();
  ~IonCpSecureBufferEndFtraceEvent() override;
  IonCpSecureBufferEndFtraceEvent(IonCpSecureBufferEndFtraceEvent&&) noexcept;
  IonCpSecureBufferEndFtraceEvent& operator=(IonCpSecureBufferEndFtraceEvent&&);
  IonCpSecureBufferEndFtraceEvent(const IonCpSecureBufferEndFtraceEvent&);
  IonCpSecureBufferEndFtraceEvent& operator=(const IonCpSecureBufferEndFtraceEvent&);
  bool operator==(const IonCpSecureBufferEndFtraceEvent&) const;
  bool operator!=(const IonCpSecureBufferEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_align() const { return _has_field_[1]; }
  uint64_t align() const { return align_; }
  void set_align(uint64_t value) { align_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint64_t flags() const { return flags_; }
  void set_flags(uint64_t value) { flags_ = value; _has_field_.set(2); }

  bool has_heap_name() const { return _has_field_[3]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(4); }

 private:
  uint64_t align_{};
  uint64_t flags_{};
  std::string heap_name_{};
  uint64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT IonCpAllocRetryFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kTriesFieldNumber = 1,
  };

  IonCpAllocRetryFtraceEvent();
  ~IonCpAllocRetryFtraceEvent() override;
  IonCpAllocRetryFtraceEvent(IonCpAllocRetryFtraceEvent&&) noexcept;
  IonCpAllocRetryFtraceEvent& operator=(IonCpAllocRetryFtraceEvent&&);
  IonCpAllocRetryFtraceEvent(const IonCpAllocRetryFtraceEvent&);
  IonCpAllocRetryFtraceEvent& operator=(const IonCpAllocRetryFtraceEvent&);
  bool operator==(const IonCpAllocRetryFtraceEvent&) const;
  bool operator!=(const IonCpAllocRetryFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_tries() const { return _has_field_[1]; }
  int32_t tries() const { return tries_; }
  void set_tries(int32_t value) { tries_ = value; _has_field_.set(1); }

 private:
  int32_t tries_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT IonAllocBufferStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };

  IonAllocBufferStartFtraceEvent();
  ~IonAllocBufferStartFtraceEvent() override;
  IonAllocBufferStartFtraceEvent(IonAllocBufferStartFtraceEvent&&) noexcept;
  IonAllocBufferStartFtraceEvent& operator=(IonAllocBufferStartFtraceEvent&&);
  IonAllocBufferStartFtraceEvent(const IonAllocBufferStartFtraceEvent&);
  IonAllocBufferStartFtraceEvent& operator=(const IonAllocBufferStartFtraceEvent&);
  bool operator==(const IonAllocBufferStartFtraceEvent&) const;
  bool operator!=(const IonAllocBufferStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_client_name() const { return _has_field_[1]; }
  const std::string& client_name() const { return client_name_; }
  void set_client_name(const std::string& value) { client_name_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(2); }

  bool has_heap_name() const { return _has_field_[3]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(4); }

  bool has_mask() const { return _has_field_[5]; }
  uint32_t mask() const { return mask_; }
  void set_mask(uint32_t value) { mask_ = value; _has_field_.set(5); }

 private:
  std::string client_name_{};
  uint32_t flags_{};
  std::string heap_name_{};
  uint64_t len_{};
  uint32_t mask_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT IonAllocBufferFallbackFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };

  IonAllocBufferFallbackFtraceEvent();
  ~IonAllocBufferFallbackFtraceEvent() override;
  IonAllocBufferFallbackFtraceEvent(IonAllocBufferFallbackFtraceEvent&&) noexcept;
  IonAllocBufferFallbackFtraceEvent& operator=(IonAllocBufferFallbackFtraceEvent&&);
  IonAllocBufferFallbackFtraceEvent(const IonAllocBufferFallbackFtraceEvent&);
  IonAllocBufferFallbackFtraceEvent& operator=(const IonAllocBufferFallbackFtraceEvent&);
  bool operator==(const IonAllocBufferFallbackFtraceEvent&) const;
  bool operator!=(const IonAllocBufferFallbackFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_client_name() const { return _has_field_[1]; }
  const std::string& client_name() const { return client_name_; }
  void set_client_name(const std::string& value) { client_name_ = value; _has_field_.set(1); }

  bool has_error() const { return _has_field_[2]; }
  int64_t error() const { return error_; }
  void set_error(int64_t value) { error_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_heap_name() const { return _has_field_[4]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(5); }

  bool has_mask() const { return _has_field_[6]; }
  uint32_t mask() const { return mask_; }
  void set_mask(uint32_t value) { mask_ = value; _has_field_.set(6); }

 private:
  std::string client_name_{};
  int64_t error_{};
  uint32_t flags_{};
  std::string heap_name_{};
  uint64_t len_{};
  uint32_t mask_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT IonAllocBufferFailFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };

  IonAllocBufferFailFtraceEvent();
  ~IonAllocBufferFailFtraceEvent() override;
  IonAllocBufferFailFtraceEvent(IonAllocBufferFailFtraceEvent&&) noexcept;
  IonAllocBufferFailFtraceEvent& operator=(IonAllocBufferFailFtraceEvent&&);
  IonAllocBufferFailFtraceEvent(const IonAllocBufferFailFtraceEvent&);
  IonAllocBufferFailFtraceEvent& operator=(const IonAllocBufferFailFtraceEvent&);
  bool operator==(const IonAllocBufferFailFtraceEvent&) const;
  bool operator!=(const IonAllocBufferFailFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_client_name() const { return _has_field_[1]; }
  const std::string& client_name() const { return client_name_; }
  void set_client_name(const std::string& value) { client_name_ = value; _has_field_.set(1); }

  bool has_error() const { return _has_field_[2]; }
  int64_t error() const { return error_; }
  void set_error(int64_t value) { error_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_heap_name() const { return _has_field_[4]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(5); }

  bool has_mask() const { return _has_field_[6]; }
  uint32_t mask() const { return mask_; }
  void set_mask(uint32_t value) { mask_ = value; _has_field_.set(6); }

 private:
  std::string client_name_{};
  int64_t error_{};
  uint32_t flags_{};
  std::string heap_name_{};
  uint64_t len_{};
  uint32_t mask_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT IonAllocBufferEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };

  IonAllocBufferEndFtraceEvent();
  ~IonAllocBufferEndFtraceEvent() override;
  IonAllocBufferEndFtraceEvent(IonAllocBufferEndFtraceEvent&&) noexcept;
  IonAllocBufferEndFtraceEvent& operator=(IonAllocBufferEndFtraceEvent&&);
  IonAllocBufferEndFtraceEvent(const IonAllocBufferEndFtraceEvent&);
  IonAllocBufferEndFtraceEvent& operator=(const IonAllocBufferEndFtraceEvent&);
  bool operator==(const IonAllocBufferEndFtraceEvent&) const;
  bool operator!=(const IonAllocBufferEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_client_name() const { return _has_field_[1]; }
  const std::string& client_name() const { return client_name_; }
  void set_client_name(const std::string& value) { client_name_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(2); }

  bool has_heap_name() const { return _has_field_[3]; }
  const std::string& heap_name() const { return heap_name_; }
  void set_heap_name(const std::string& value) { heap_name_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(4); }

  bool has_mask() const { return _has_field_[5]; }
  uint32_t mask() const { return mask_; }
  void set_mask(uint32_t value) { mask_ = value; _has_field_.set(5); }

 private:
  std::string client_name_{};
  uint32_t flags_{};
  std::string heap_name_{};
  uint64_t len_{};
  uint32_t mask_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT IommuSecPtblMapRangeStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };

  IommuSecPtblMapRangeStartFtraceEvent();
  ~IommuSecPtblMapRangeStartFtraceEvent() override;
  IommuSecPtblMapRangeStartFtraceEvent(IommuSecPtblMapRangeStartFtraceEvent&&) noexcept;
  IommuSecPtblMapRangeStartFtraceEvent& operator=(IommuSecPtblMapRangeStartFtraceEvent&&);
  IommuSecPtblMapRangeStartFtraceEvent(const IommuSecPtblMapRangeStartFtraceEvent&);
  IommuSecPtblMapRangeStartFtraceEvent& operator=(const IommuSecPtblMapRangeStartFtraceEvent&);
  bool operator==(const IommuSecPtblMapRangeStartFtraceEvent&) const;
  bool operator!=(const IommuSecPtblMapRangeStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_len() const { return _has_field_[1]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(1); }

  bool has_num() const { return _has_field_[2]; }
  int32_t num() const { return num_; }
  void set_num(int32_t value) { num_ = value; _has_field_.set(2); }

  bool has_pa() const { return _has_field_[3]; }
  uint32_t pa() const { return pa_; }
  void set_pa(uint32_t value) { pa_ = value; _has_field_.set(3); }

  bool has_sec_id() const { return _has_field_[4]; }
  int32_t sec_id() const { return sec_id_; }
  void set_sec_id(int32_t value) { sec_id_ = value; _has_field_.set(4); }

  bool has_va() const { return _has_field_[5]; }
  uint64_t va() const { return va_; }
  void set_va(uint64_t value) { va_ = value; _has_field_.set(5); }

 private:
  uint64_t len_{};
  int32_t num_{};
  uint32_t pa_{};
  int32_t sec_id_{};
  uint64_t va_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT IommuSecPtblMapRangeEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };

  IommuSecPtblMapRangeEndFtraceEvent();
  ~IommuSecPtblMapRangeEndFtraceEvent() override;
  IommuSecPtblMapRangeEndFtraceEvent(IommuSecPtblMapRangeEndFtraceEvent&&) noexcept;
  IommuSecPtblMapRangeEndFtraceEvent& operator=(IommuSecPtblMapRangeEndFtraceEvent&&);
  IommuSecPtblMapRangeEndFtraceEvent(const IommuSecPtblMapRangeEndFtraceEvent&);
  IommuSecPtblMapRangeEndFtraceEvent& operator=(const IommuSecPtblMapRangeEndFtraceEvent&);
  bool operator==(const IommuSecPtblMapRangeEndFtraceEvent&) const;
  bool operator!=(const IommuSecPtblMapRangeEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_len() const { return _has_field_[1]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(1); }

  bool has_num() const { return _has_field_[2]; }
  int32_t num() const { return num_; }
  void set_num(int32_t value) { num_ = value; _has_field_.set(2); }

  bool has_pa() const { return _has_field_[3]; }
  uint32_t pa() const { return pa_; }
  void set_pa(uint32_t value) { pa_ = value; _has_field_.set(3); }

  bool has_sec_id() const { return _has_field_[4]; }
  int32_t sec_id() const { return sec_id_; }
  void set_sec_id(int32_t value) { sec_id_ = value; _has_field_.set(4); }

  bool has_va() const { return _has_field_[5]; }
  uint64_t va() const { return va_; }
  void set_va(uint64_t value) { va_ = value; _has_field_.set(5); }

 private:
  uint64_t len_{};
  int32_t num_{};
  uint32_t pa_{};
  int32_t sec_id_{};
  uint64_t va_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT IommuMapRangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kChunkSizeFieldNumber = 1,
    kLenFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 4,
  };

  IommuMapRangeFtraceEvent();
  ~IommuMapRangeFtraceEvent() override;
  IommuMapRangeFtraceEvent(IommuMapRangeFtraceEvent&&) noexcept;
  IommuMapRangeFtraceEvent& operator=(IommuMapRangeFtraceEvent&&);
  IommuMapRangeFtraceEvent(const IommuMapRangeFtraceEvent&);
  IommuMapRangeFtraceEvent& operator=(const IommuMapRangeFtraceEvent&);
  bool operator==(const IommuMapRangeFtraceEvent&) const;
  bool operator!=(const IommuMapRangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_chunk_size() const { return _has_field_[1]; }
  uint64_t chunk_size() const { return chunk_size_; }
  void set_chunk_size(uint64_t value) { chunk_size_ = value; _has_field_.set(1); }

  bool has_len() const { return _has_field_[2]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(2); }

  bool has_pa() const { return _has_field_[3]; }
  uint64_t pa() const { return pa_; }
  void set_pa(uint64_t value) { pa_ = value; _has_field_.set(3); }

  bool has_va() const { return _has_field_[4]; }
  uint64_t va() const { return va_; }
  void set_va(uint64_t value) { va_ = value; _has_field_.set(4); }

 private:
  uint64_t chunk_size_{};
  uint64_t len_{};
  uint64_t pa_{};
  uint64_t va_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT DmaAllocContiguousRetryFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kTriesFieldNumber = 1,
  };

  DmaAllocContiguousRetryFtraceEvent();
  ~DmaAllocContiguousRetryFtraceEvent() override;
  DmaAllocContiguousRetryFtraceEvent(DmaAllocContiguousRetryFtraceEvent&&) noexcept;
  DmaAllocContiguousRetryFtraceEvent& operator=(DmaAllocContiguousRetryFtraceEvent&&);
  DmaAllocContiguousRetryFtraceEvent(const DmaAllocContiguousRetryFtraceEvent&);
  DmaAllocContiguousRetryFtraceEvent& operator=(const DmaAllocContiguousRetryFtraceEvent&);
  bool operator==(const DmaAllocContiguousRetryFtraceEvent&) const;
  bool operator!=(const DmaAllocContiguousRetryFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_tries() const { return _has_field_[1]; }
  int32_t tries() const { return tries_; }
  void set_tries(int32_t value) { tries_ = value; _has_field_.set(1); }

 private:
  int32_t tries_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT AllocPagesSysStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };

  AllocPagesSysStartFtraceEvent();
  ~AllocPagesSysStartFtraceEvent() override;
  AllocPagesSysStartFtraceEvent(AllocPagesSysStartFtraceEvent&&) noexcept;
  AllocPagesSysStartFtraceEvent& operator=(AllocPagesSysStartFtraceEvent&&);
  AllocPagesSysStartFtraceEvent(const AllocPagesSysStartFtraceEvent&);
  AllocPagesSysStartFtraceEvent& operator=(const AllocPagesSysStartFtraceEvent&);
  bool operator==(const AllocPagesSysStartFtraceEvent&) const;
  bool operator!=(const AllocPagesSysStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gfp_flags() const { return _has_field_[1]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(2); }

 private:
  uint32_t gfp_flags_{};
  uint32_t order_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT AllocPagesSysFailFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };

  AllocPagesSysFailFtraceEvent();
  ~AllocPagesSysFailFtraceEvent() override;
  AllocPagesSysFailFtraceEvent(AllocPagesSysFailFtraceEvent&&) noexcept;
  AllocPagesSysFailFtraceEvent& operator=(AllocPagesSysFailFtraceEvent&&);
  AllocPagesSysFailFtraceEvent(const AllocPagesSysFailFtraceEvent&);
  AllocPagesSysFailFtraceEvent& operator=(const AllocPagesSysFailFtraceEvent&);
  bool operator==(const AllocPagesSysFailFtraceEvent&) const;
  bool operator!=(const AllocPagesSysFailFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gfp_flags() const { return _has_field_[1]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(2); }

 private:
  uint32_t gfp_flags_{};
  uint32_t order_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT AllocPagesSysEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };

  AllocPagesSysEndFtraceEvent();
  ~AllocPagesSysEndFtraceEvent() override;
  AllocPagesSysEndFtraceEvent(AllocPagesSysEndFtraceEvent&&) noexcept;
  AllocPagesSysEndFtraceEvent& operator=(AllocPagesSysEndFtraceEvent&&);
  AllocPagesSysEndFtraceEvent(const AllocPagesSysEndFtraceEvent&);
  AllocPagesSysEndFtraceEvent& operator=(const AllocPagesSysEndFtraceEvent&);
  bool operator==(const AllocPagesSysEndFtraceEvent&) const;
  bool operator!=(const AllocPagesSysEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gfp_flags() const { return _has_field_[1]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(2); }

 private:
  uint32_t gfp_flags_{};
  uint32_t order_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT AllocPagesIommuStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };

  AllocPagesIommuStartFtraceEvent();
  ~AllocPagesIommuStartFtraceEvent() override;
  AllocPagesIommuStartFtraceEvent(AllocPagesIommuStartFtraceEvent&&) noexcept;
  AllocPagesIommuStartFtraceEvent& operator=(AllocPagesIommuStartFtraceEvent&&);
  AllocPagesIommuStartFtraceEvent(const AllocPagesIommuStartFtraceEvent&);
  AllocPagesIommuStartFtraceEvent& operator=(const AllocPagesIommuStartFtraceEvent&);
  bool operator==(const AllocPagesIommuStartFtraceEvent&) const;
  bool operator!=(const AllocPagesIommuStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gfp_flags() const { return _has_field_[1]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(2); }

 private:
  uint32_t gfp_flags_{};
  uint32_t order_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT AllocPagesIommuFailFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };

  AllocPagesIommuFailFtraceEvent();
  ~AllocPagesIommuFailFtraceEvent() override;
  AllocPagesIommuFailFtraceEvent(AllocPagesIommuFailFtraceEvent&&) noexcept;
  AllocPagesIommuFailFtraceEvent& operator=(AllocPagesIommuFailFtraceEvent&&);
  AllocPagesIommuFailFtraceEvent(const AllocPagesIommuFailFtraceEvent&);
  AllocPagesIommuFailFtraceEvent& operator=(const AllocPagesIommuFailFtraceEvent&);
  bool operator==(const AllocPagesIommuFailFtraceEvent&) const;
  bool operator!=(const AllocPagesIommuFailFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gfp_flags() const { return _has_field_[1]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(2); }

 private:
  uint32_t gfp_flags_{};
  uint32_t order_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT AllocPagesIommuEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };

  AllocPagesIommuEndFtraceEvent();
  ~AllocPagesIommuEndFtraceEvent() override;
  AllocPagesIommuEndFtraceEvent(AllocPagesIommuEndFtraceEvent&&) noexcept;
  AllocPagesIommuEndFtraceEvent& operator=(AllocPagesIommuEndFtraceEvent&&);
  AllocPagesIommuEndFtraceEvent(const AllocPagesIommuEndFtraceEvent&);
  AllocPagesIommuEndFtraceEvent& operator=(const AllocPagesIommuEndFtraceEvent&);
  bool operator==(const AllocPagesIommuEndFtraceEvent&) const;
  bool operator!=(const AllocPagesIommuEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gfp_flags() const { return _has_field_[1]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  uint32_t order() const { return order_; }
  void set_order(uint32_t value) { order_ = value; _has_field_.set(2); }

 private:
  uint32_t gfp_flags_{};
  uint32_t order_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_CPP_H_
