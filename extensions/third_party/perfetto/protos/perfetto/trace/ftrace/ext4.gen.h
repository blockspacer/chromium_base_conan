// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class Ext4ZeroRangeFtraceEvent;
class Ext4WritepagesResultFtraceEvent;
class Ext4WritepagesFtraceEvent;
class Ext4WritepageFtraceEvent;
class Ext4WriteEndFtraceEvent;
class Ext4WriteBeginFtraceEvent;
class Ext4UnlinkExitFtraceEvent;
class Ext4UnlinkEnterFtraceEvent;
class Ext4TruncateExitFtraceEvent;
class Ext4TruncateEnterFtraceEvent;
class Ext4TrimExtentFtraceEvent;
class Ext4TrimAllFreeFtraceEvent;
class Ext4SyncFsFtraceEvent;
class Ext4RequestInodeFtraceEvent;
class Ext4RequestBlocksFtraceEvent;
class Ext4RemoveBlocksFtraceEvent;
class Ext4ReleasepageFtraceEvent;
class Ext4ReadpageFtraceEvent;
class Ext4ReadBlockBitmapLoadFtraceEvent;
class Ext4PunchHoleFtraceEvent;
class Ext4OtherInodeUpdateTimeFtraceEvent;
class Ext4MballocPreallocFtraceEvent;
class Ext4MballocFreeFtraceEvent;
class Ext4MballocDiscardFtraceEvent;
class Ext4MballocAllocFtraceEvent;
class Ext4MbReleaseInodePaFtraceEvent;
class Ext4MbReleaseGroupPaFtraceEvent;
class Ext4MbNewInodePaFtraceEvent;
class Ext4MbNewGroupPaFtraceEvent;
class Ext4MbDiscardPreallocationsFtraceEvent;
class Ext4MbBuddyBitmapLoadFtraceEvent;
class Ext4MbBitmapLoadFtraceEvent;
class Ext4MarkInodeDirtyFtraceEvent;
class Ext4LoadInodeBitmapFtraceEvent;
class Ext4LoadInodeFtraceEvent;
class Ext4JournalledWriteEndFtraceEvent;
class Ext4JournalledInvalidatepageFtraceEvent;
class Ext4JournalStartReservedFtraceEvent;
class Ext4JournalStartFtraceEvent;
class Ext4InvalidatepageFtraceEvent;
class Ext4InsertRangeFtraceEvent;
class Ext4IndMapBlocksExitFtraceEvent;
class Ext4IndMapBlocksEnterFtraceEvent;
class Ext4GetReservedClusterAllocFtraceEvent;
class Ext4GetImpliedClusterAllocExitFtraceEvent;
class Ext4FreeInodeFtraceEvent;
class Ext4FreeBlocksFtraceEvent;
class Ext4ForgetFtraceEvent;
class Ext4FindDelallocRangeFtraceEvent;
class Ext4FallocateExitFtraceEvent;
class Ext4FallocateEnterFtraceEvent;
class Ext4ExtShowExtentFtraceEvent;
class Ext4ExtRmLeafFtraceEvent;
class Ext4ExtRmIdxFtraceEvent;
class Ext4ExtRemoveSpaceDoneFtraceEvent;
class Ext4ExtRemoveSpaceFtraceEvent;
class Ext4ExtPutInCacheFtraceEvent;
class Ext4ExtMapBlocksExitFtraceEvent;
class Ext4ExtMapBlocksEnterFtraceEvent;
class Ext4ExtLoadExtentFtraceEvent;
class Ext4ExtInCacheFtraceEvent;
class Ext4ExtHandleUnwrittenExtentsFtraceEvent;
class Ext4ExtConvertToInitializedFastpathFtraceEvent;
class Ext4ExtConvertToInitializedEnterFtraceEvent;
class Ext4EvictInodeFtraceEvent;
class Ext4EsShrinkScanExitFtraceEvent;
class Ext4EsShrinkScanEnterFtraceEvent;
class Ext4EsShrinkCountFtraceEvent;
class Ext4EsShrinkFtraceEvent;
class Ext4EsRemoveExtentFtraceEvent;
class Ext4EsLookupExtentExitFtraceEvent;
class Ext4EsLookupExtentEnterFtraceEvent;
class Ext4EsInsertExtentFtraceEvent;
class Ext4EsFindDelayedExtentRangeExitFtraceEvent;
class Ext4EsFindDelayedExtentRangeEnterFtraceEvent;
class Ext4EsCacheExtentFtraceEvent;
class Ext4DropInodeFtraceEvent;
class Ext4DiscardPreallocationsFtraceEvent;
class Ext4DiscardBlocksFtraceEvent;
class Ext4DirectIOExitFtraceEvent;
class Ext4DirectIOEnterFtraceEvent;
class Ext4DaWritePagesExtentFtraceEvent;
class Ext4DaWritePagesFtraceEvent;
class Ext4DaUpdateReserveSpaceFtraceEvent;
class Ext4DaReserveSpaceFtraceEvent;
class Ext4DaReleaseSpaceFtraceEvent;
class Ext4CollapseRangeFtraceEvent;
class Ext4BeginOrderedTruncateFtraceEvent;
class Ext4AllocateInodeFtraceEvent;
class Ext4AllocateBlocksFtraceEvent;
class Ext4AllocDaBlocksFtraceEvent;
class Ext4SyncFileExitFtraceEvent;
class Ext4SyncFileEnterFtraceEvent;
class Ext4DaWriteEndFtraceEvent;
class Ext4DaWriteBeginFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT Ext4ZeroRangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
  };

  Ext4ZeroRangeFtraceEvent();
  ~Ext4ZeroRangeFtraceEvent() override;
  Ext4ZeroRangeFtraceEvent(Ext4ZeroRangeFtraceEvent&&) noexcept;
  Ext4ZeroRangeFtraceEvent& operator=(Ext4ZeroRangeFtraceEvent&&);
  Ext4ZeroRangeFtraceEvent(const Ext4ZeroRangeFtraceEvent&);
  Ext4ZeroRangeFtraceEvent& operator=(const Ext4ZeroRangeFtraceEvent&);
  bool operator==(const Ext4ZeroRangeFtraceEvent&) const;
  bool operator!=(const Ext4ZeroRangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_offset() const { return _has_field_[3]; }
  int64_t offset() const { return offset_; }
  void set_offset(int64_t value) { offset_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  int64_t len() const { return len_; }
  void set_len(int64_t value) { len_ = value; _has_field_.set(4); }

  bool has_mode() const { return _has_field_[5]; }
  int32_t mode() const { return mode_; }
  void set_mode(int32_t value) { mode_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t offset_{};
  int64_t len_{};
  int32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4WritepagesResultFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
    kPagesWrittenFieldNumber = 4,
    kPagesSkippedFieldNumber = 5,
    kWritebackIndexFieldNumber = 6,
    kSyncModeFieldNumber = 7,
  };

  Ext4WritepagesResultFtraceEvent();
  ~Ext4WritepagesResultFtraceEvent() override;
  Ext4WritepagesResultFtraceEvent(Ext4WritepagesResultFtraceEvent&&) noexcept;
  Ext4WritepagesResultFtraceEvent& operator=(Ext4WritepagesResultFtraceEvent&&);
  Ext4WritepagesResultFtraceEvent(const Ext4WritepagesResultFtraceEvent&);
  Ext4WritepagesResultFtraceEvent& operator=(const Ext4WritepagesResultFtraceEvent&);
  bool operator==(const Ext4WritepagesResultFtraceEvent&) const;
  bool operator!=(const Ext4WritepagesResultFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

  bool has_pages_written() const { return _has_field_[4]; }
  int32_t pages_written() const { return pages_written_; }
  void set_pages_written(int32_t value) { pages_written_ = value; _has_field_.set(4); }

  bool has_pages_skipped() const { return _has_field_[5]; }
  int64_t pages_skipped() const { return pages_skipped_; }
  void set_pages_skipped(int64_t value) { pages_skipped_ = value; _has_field_.set(5); }

  bool has_writeback_index() const { return _has_field_[6]; }
  uint64_t writeback_index() const { return writeback_index_; }
  void set_writeback_index(uint64_t value) { writeback_index_ = value; _has_field_.set(6); }

  bool has_sync_mode() const { return _has_field_[7]; }
  int32_t sync_mode() const { return sync_mode_; }
  void set_sync_mode(int32_t value) { sync_mode_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};
  int32_t pages_written_{};
  int64_t pages_skipped_{};
  uint64_t writeback_index_{};
  int32_t sync_mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT Ext4WritepagesFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNrToWriteFieldNumber = 3,
    kPagesSkippedFieldNumber = 4,
    kRangeStartFieldNumber = 5,
    kRangeEndFieldNumber = 6,
    kWritebackIndexFieldNumber = 7,
    kSyncModeFieldNumber = 8,
    kForKupdateFieldNumber = 9,
    kRangeCyclicFieldNumber = 10,
  };

  Ext4WritepagesFtraceEvent();
  ~Ext4WritepagesFtraceEvent() override;
  Ext4WritepagesFtraceEvent(Ext4WritepagesFtraceEvent&&) noexcept;
  Ext4WritepagesFtraceEvent& operator=(Ext4WritepagesFtraceEvent&&);
  Ext4WritepagesFtraceEvent(const Ext4WritepagesFtraceEvent&);
  Ext4WritepagesFtraceEvent& operator=(const Ext4WritepagesFtraceEvent&);
  bool operator==(const Ext4WritepagesFtraceEvent&) const;
  bool operator!=(const Ext4WritepagesFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nr_to_write() const { return _has_field_[3]; }
  int64_t nr_to_write() const { return nr_to_write_; }
  void set_nr_to_write(int64_t value) { nr_to_write_ = value; _has_field_.set(3); }

  bool has_pages_skipped() const { return _has_field_[4]; }
  int64_t pages_skipped() const { return pages_skipped_; }
  void set_pages_skipped(int64_t value) { pages_skipped_ = value; _has_field_.set(4); }

  bool has_range_start() const { return _has_field_[5]; }
  int64_t range_start() const { return range_start_; }
  void set_range_start(int64_t value) { range_start_ = value; _has_field_.set(5); }

  bool has_range_end() const { return _has_field_[6]; }
  int64_t range_end() const { return range_end_; }
  void set_range_end(int64_t value) { range_end_ = value; _has_field_.set(6); }

  bool has_writeback_index() const { return _has_field_[7]; }
  uint64_t writeback_index() const { return writeback_index_; }
  void set_writeback_index(uint64_t value) { writeback_index_ = value; _has_field_.set(7); }

  bool has_sync_mode() const { return _has_field_[8]; }
  int32_t sync_mode() const { return sync_mode_; }
  void set_sync_mode(int32_t value) { sync_mode_ = value; _has_field_.set(8); }

  bool has_for_kupdate() const { return _has_field_[9]; }
  uint32_t for_kupdate() const { return for_kupdate_; }
  void set_for_kupdate(uint32_t value) { for_kupdate_ = value; _has_field_.set(9); }

  bool has_range_cyclic() const { return _has_field_[10]; }
  uint32_t range_cyclic() const { return range_cyclic_; }
  void set_range_cyclic(uint32_t value) { range_cyclic_ = value; _has_field_.set(10); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t nr_to_write_{};
  int64_t pages_skipped_{};
  int64_t range_start_{};
  int64_t range_end_{};
  uint64_t writeback_index_{};
  int32_t sync_mode_{};
  uint32_t for_kupdate_{};
  uint32_t range_cyclic_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT Ext4WritepageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };

  Ext4WritepageFtraceEvent();
  ~Ext4WritepageFtraceEvent() override;
  Ext4WritepageFtraceEvent(Ext4WritepageFtraceEvent&&) noexcept;
  Ext4WritepageFtraceEvent& operator=(Ext4WritepageFtraceEvent&&);
  Ext4WritepageFtraceEvent(const Ext4WritepageFtraceEvent&);
  Ext4WritepageFtraceEvent& operator=(const Ext4WritepageFtraceEvent&);
  bool operator==(const Ext4WritepageFtraceEvent&) const;
  bool operator!=(const Ext4WritepageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_index() const { return _has_field_[3]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t index_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4WriteEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };

  Ext4WriteEndFtraceEvent();
  ~Ext4WriteEndFtraceEvent() override;
  Ext4WriteEndFtraceEvent(Ext4WriteEndFtraceEvent&&) noexcept;
  Ext4WriteEndFtraceEvent& operator=(Ext4WriteEndFtraceEvent&&);
  Ext4WriteEndFtraceEvent(const Ext4WriteEndFtraceEvent&);
  Ext4WriteEndFtraceEvent& operator=(const Ext4WriteEndFtraceEvent&);
  bool operator==(const Ext4WriteEndFtraceEvent&) const;
  bool operator!=(const Ext4WriteEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_copied() const { return _has_field_[5]; }
  uint32_t copied() const { return copied_; }
  void set_copied(uint32_t value) { copied_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t copied_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4WriteBeginFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };

  Ext4WriteBeginFtraceEvent();
  ~Ext4WriteBeginFtraceEvent() override;
  Ext4WriteBeginFtraceEvent(Ext4WriteBeginFtraceEvent&&) noexcept;
  Ext4WriteBeginFtraceEvent& operator=(Ext4WriteBeginFtraceEvent&&);
  Ext4WriteBeginFtraceEvent(const Ext4WriteBeginFtraceEvent&);
  Ext4WriteBeginFtraceEvent& operator=(const Ext4WriteBeginFtraceEvent&);
  bool operator==(const Ext4WriteBeginFtraceEvent&) const;
  bool operator!=(const Ext4WriteBeginFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4UnlinkExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  Ext4UnlinkExitFtraceEvent();
  ~Ext4UnlinkExitFtraceEvent() override;
  Ext4UnlinkExitFtraceEvent(Ext4UnlinkExitFtraceEvent&&) noexcept;
  Ext4UnlinkExitFtraceEvent& operator=(Ext4UnlinkExitFtraceEvent&&);
  Ext4UnlinkExitFtraceEvent(const Ext4UnlinkExitFtraceEvent&);
  Ext4UnlinkExitFtraceEvent& operator=(const Ext4UnlinkExitFtraceEvent&);
  bool operator==(const Ext4UnlinkExitFtraceEvent&) const;
  bool operator!=(const Ext4UnlinkExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4UnlinkEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kParentFieldNumber = 3,
    kSizeFieldNumber = 4,
  };

  Ext4UnlinkEnterFtraceEvent();
  ~Ext4UnlinkEnterFtraceEvent() override;
  Ext4UnlinkEnterFtraceEvent(Ext4UnlinkEnterFtraceEvent&&) noexcept;
  Ext4UnlinkEnterFtraceEvent& operator=(Ext4UnlinkEnterFtraceEvent&&);
  Ext4UnlinkEnterFtraceEvent(const Ext4UnlinkEnterFtraceEvent&);
  Ext4UnlinkEnterFtraceEvent& operator=(const Ext4UnlinkEnterFtraceEvent&);
  bool operator==(const Ext4UnlinkEnterFtraceEvent&) const;
  bool operator!=(const Ext4UnlinkEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_parent() const { return _has_field_[3]; }
  uint64_t parent() const { return parent_; }
  void set_parent(uint64_t value) { parent_ = value; _has_field_.set(3); }

  bool has_size() const { return _has_field_[4]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t parent_{};
  int64_t size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4TruncateExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };

  Ext4TruncateExitFtraceEvent();
  ~Ext4TruncateExitFtraceEvent() override;
  Ext4TruncateExitFtraceEvent(Ext4TruncateExitFtraceEvent&&) noexcept;
  Ext4TruncateExitFtraceEvent& operator=(Ext4TruncateExitFtraceEvent&&);
  Ext4TruncateExitFtraceEvent(const Ext4TruncateExitFtraceEvent&);
  Ext4TruncateExitFtraceEvent& operator=(const Ext4TruncateExitFtraceEvent&);
  bool operator==(const Ext4TruncateExitFtraceEvent&) const;
  bool operator!=(const Ext4TruncateExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_blocks() const { return _has_field_[3]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t blocks_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4TruncateEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };

  Ext4TruncateEnterFtraceEvent();
  ~Ext4TruncateEnterFtraceEvent() override;
  Ext4TruncateEnterFtraceEvent(Ext4TruncateEnterFtraceEvent&&) noexcept;
  Ext4TruncateEnterFtraceEvent& operator=(Ext4TruncateEnterFtraceEvent&&);
  Ext4TruncateEnterFtraceEvent(const Ext4TruncateEnterFtraceEvent&);
  Ext4TruncateEnterFtraceEvent& operator=(const Ext4TruncateEnterFtraceEvent&);
  bool operator==(const Ext4TruncateEnterFtraceEvent&) const;
  bool operator!=(const Ext4TruncateEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_blocks() const { return _has_field_[3]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t blocks_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4TrimExtentFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevMajorFieldNumber = 1,
    kDevMinorFieldNumber = 2,
    kGroupFieldNumber = 3,
    kStartFieldNumber = 4,
    kLenFieldNumber = 5,
  };

  Ext4TrimExtentFtraceEvent();
  ~Ext4TrimExtentFtraceEvent() override;
  Ext4TrimExtentFtraceEvent(Ext4TrimExtentFtraceEvent&&) noexcept;
  Ext4TrimExtentFtraceEvent& operator=(Ext4TrimExtentFtraceEvent&&);
  Ext4TrimExtentFtraceEvent(const Ext4TrimExtentFtraceEvent&);
  Ext4TrimExtentFtraceEvent& operator=(const Ext4TrimExtentFtraceEvent&);
  bool operator==(const Ext4TrimExtentFtraceEvent&) const;
  bool operator!=(const Ext4TrimExtentFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev_major() const { return _has_field_[1]; }
  int32_t dev_major() const { return dev_major_; }
  void set_dev_major(int32_t value) { dev_major_ = value; _has_field_.set(1); }

  bool has_dev_minor() const { return _has_field_[2]; }
  int32_t dev_minor() const { return dev_minor_; }
  void set_dev_minor(int32_t value) { dev_minor_ = value; _has_field_.set(2); }

  bool has_group() const { return _has_field_[3]; }
  uint32_t group() const { return group_; }
  void set_group(uint32_t value) { group_ = value; _has_field_.set(3); }

  bool has_start() const { return _has_field_[4]; }
  int32_t start() const { return start_; }
  void set_start(int32_t value) { start_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  int32_t len() const { return len_; }
  void set_len(int32_t value) { len_ = value; _has_field_.set(5); }

 private:
  int32_t dev_major_{};
  int32_t dev_minor_{};
  uint32_t group_{};
  int32_t start_{};
  int32_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4TrimAllFreeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevMajorFieldNumber = 1,
    kDevMinorFieldNumber = 2,
    kGroupFieldNumber = 3,
    kStartFieldNumber = 4,
    kLenFieldNumber = 5,
  };

  Ext4TrimAllFreeFtraceEvent();
  ~Ext4TrimAllFreeFtraceEvent() override;
  Ext4TrimAllFreeFtraceEvent(Ext4TrimAllFreeFtraceEvent&&) noexcept;
  Ext4TrimAllFreeFtraceEvent& operator=(Ext4TrimAllFreeFtraceEvent&&);
  Ext4TrimAllFreeFtraceEvent(const Ext4TrimAllFreeFtraceEvent&);
  Ext4TrimAllFreeFtraceEvent& operator=(const Ext4TrimAllFreeFtraceEvent&);
  bool operator==(const Ext4TrimAllFreeFtraceEvent&) const;
  bool operator!=(const Ext4TrimAllFreeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev_major() const { return _has_field_[1]; }
  int32_t dev_major() const { return dev_major_; }
  void set_dev_major(int32_t value) { dev_major_ = value; _has_field_.set(1); }

  bool has_dev_minor() const { return _has_field_[2]; }
  int32_t dev_minor() const { return dev_minor_; }
  void set_dev_minor(int32_t value) { dev_minor_ = value; _has_field_.set(2); }

  bool has_group() const { return _has_field_[3]; }
  uint32_t group() const { return group_; }
  void set_group(uint32_t value) { group_ = value; _has_field_.set(3); }

  bool has_start() const { return _has_field_[4]; }
  int32_t start() const { return start_; }
  void set_start(int32_t value) { start_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  int32_t len() const { return len_; }
  void set_len(int32_t value) { len_ = value; _has_field_.set(5); }

 private:
  int32_t dev_major_{};
  int32_t dev_minor_{};
  uint32_t group_{};
  int32_t start_{};
  int32_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4SyncFsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kWaitFieldNumber = 2,
  };

  Ext4SyncFsFtraceEvent();
  ~Ext4SyncFsFtraceEvent() override;
  Ext4SyncFsFtraceEvent(Ext4SyncFsFtraceEvent&&) noexcept;
  Ext4SyncFsFtraceEvent& operator=(Ext4SyncFsFtraceEvent&&);
  Ext4SyncFsFtraceEvent(const Ext4SyncFsFtraceEvent&);
  Ext4SyncFsFtraceEvent& operator=(const Ext4SyncFsFtraceEvent&);
  bool operator==(const Ext4SyncFsFtraceEvent&) const;
  bool operator!=(const Ext4SyncFsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_wait() const { return _has_field_[2]; }
  int32_t wait() const { return wait_; }
  void set_wait(int32_t value) { wait_ = value; _has_field_.set(2); }

 private:
  uint64_t dev_{};
  int32_t wait_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Ext4RequestInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kDirFieldNumber = 2,
    kModeFieldNumber = 3,
  };

  Ext4RequestInodeFtraceEvent();
  ~Ext4RequestInodeFtraceEvent() override;
  Ext4RequestInodeFtraceEvent(Ext4RequestInodeFtraceEvent&&) noexcept;
  Ext4RequestInodeFtraceEvent& operator=(Ext4RequestInodeFtraceEvent&&);
  Ext4RequestInodeFtraceEvent(const Ext4RequestInodeFtraceEvent&);
  Ext4RequestInodeFtraceEvent& operator=(const Ext4RequestInodeFtraceEvent&);
  bool operator==(const Ext4RequestInodeFtraceEvent&) const;
  bool operator!=(const Ext4RequestInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_dir() const { return _has_field_[2]; }
  uint64_t dir() const { return dir_; }
  void set_dir(uint64_t value) { dir_ = value; _has_field_.set(2); }

  bool has_mode() const { return _has_field_[3]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t dir_{};
  uint32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4RequestBlocksFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLenFieldNumber = 3,
    kLogicalFieldNumber = 4,
    kLleftFieldNumber = 5,
    kLrightFieldNumber = 6,
    kGoalFieldNumber = 7,
    kPleftFieldNumber = 8,
    kPrightFieldNumber = 9,
    kFlagsFieldNumber = 10,
  };

  Ext4RequestBlocksFtraceEvent();
  ~Ext4RequestBlocksFtraceEvent() override;
  Ext4RequestBlocksFtraceEvent(Ext4RequestBlocksFtraceEvent&&) noexcept;
  Ext4RequestBlocksFtraceEvent& operator=(Ext4RequestBlocksFtraceEvent&&);
  Ext4RequestBlocksFtraceEvent(const Ext4RequestBlocksFtraceEvent&);
  Ext4RequestBlocksFtraceEvent& operator=(const Ext4RequestBlocksFtraceEvent&);
  bool operator==(const Ext4RequestBlocksFtraceEvent&) const;
  bool operator!=(const Ext4RequestBlocksFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_len() const { return _has_field_[3]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(3); }

  bool has_logical() const { return _has_field_[4]; }
  uint32_t logical() const { return logical_; }
  void set_logical(uint32_t value) { logical_ = value; _has_field_.set(4); }

  bool has_lleft() const { return _has_field_[5]; }
  uint32_t lleft() const { return lleft_; }
  void set_lleft(uint32_t value) { lleft_ = value; _has_field_.set(5); }

  bool has_lright() const { return _has_field_[6]; }
  uint32_t lright() const { return lright_; }
  void set_lright(uint32_t value) { lright_ = value; _has_field_.set(6); }

  bool has_goal() const { return _has_field_[7]; }
  uint64_t goal() const { return goal_; }
  void set_goal(uint64_t value) { goal_ = value; _has_field_.set(7); }

  bool has_pleft() const { return _has_field_[8]; }
  uint64_t pleft() const { return pleft_; }
  void set_pleft(uint64_t value) { pleft_ = value; _has_field_.set(8); }

  bool has_pright() const { return _has_field_[9]; }
  uint64_t pright() const { return pright_; }
  void set_pright(uint64_t value) { pright_ = value; _has_field_.set(9); }

  bool has_flags() const { return _has_field_[10]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(10); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t len_{};
  uint32_t logical_{};
  uint32_t lleft_{};
  uint32_t lright_{};
  uint64_t goal_{};
  uint64_t pleft_{};
  uint64_t pright_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT Ext4RemoveBlocksFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kPartialFieldNumber = 5,
    kEePblkFieldNumber = 6,
    kEeLblkFieldNumber = 7,
    kEeLenFieldNumber = 8,
  };

  Ext4RemoveBlocksFtraceEvent();
  ~Ext4RemoveBlocksFtraceEvent() override;
  Ext4RemoveBlocksFtraceEvent(Ext4RemoveBlocksFtraceEvent&&) noexcept;
  Ext4RemoveBlocksFtraceEvent& operator=(Ext4RemoveBlocksFtraceEvent&&);
  Ext4RemoveBlocksFtraceEvent(const Ext4RemoveBlocksFtraceEvent&);
  Ext4RemoveBlocksFtraceEvent& operator=(const Ext4RemoveBlocksFtraceEvent&);
  bool operator==(const Ext4RemoveBlocksFtraceEvent&) const;
  bool operator!=(const Ext4RemoveBlocksFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_from() const { return _has_field_[3]; }
  uint32_t from() const { return from_; }
  void set_from(uint32_t value) { from_ = value; _has_field_.set(3); }

  bool has_to() const { return _has_field_[4]; }
  uint32_t to() const { return to_; }
  void set_to(uint32_t value) { to_ = value; _has_field_.set(4); }

  bool has_partial() const { return _has_field_[5]; }
  int64_t partial() const { return partial_; }
  void set_partial(int64_t value) { partial_ = value; _has_field_.set(5); }

  bool has_ee_pblk() const { return _has_field_[6]; }
  uint64_t ee_pblk() const { return ee_pblk_; }
  void set_ee_pblk(uint64_t value) { ee_pblk_ = value; _has_field_.set(6); }

  bool has_ee_lblk() const { return _has_field_[7]; }
  uint32_t ee_lblk() const { return ee_lblk_; }
  void set_ee_lblk(uint32_t value) { ee_lblk_ = value; _has_field_.set(7); }

  bool has_ee_len() const { return _has_field_[8]; }
  uint32_t ee_len() const { return ee_len_; }
  void set_ee_len(uint32_t value) { ee_len_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t from_{};
  uint32_t to_{};
  int64_t partial_{};
  uint64_t ee_pblk_{};
  uint32_t ee_lblk_{};
  uint32_t ee_len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT Ext4ReleasepageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };

  Ext4ReleasepageFtraceEvent();
  ~Ext4ReleasepageFtraceEvent() override;
  Ext4ReleasepageFtraceEvent(Ext4ReleasepageFtraceEvent&&) noexcept;
  Ext4ReleasepageFtraceEvent& operator=(Ext4ReleasepageFtraceEvent&&);
  Ext4ReleasepageFtraceEvent(const Ext4ReleasepageFtraceEvent&);
  Ext4ReleasepageFtraceEvent& operator=(const Ext4ReleasepageFtraceEvent&);
  bool operator==(const Ext4ReleasepageFtraceEvent&) const;
  bool operator!=(const Ext4ReleasepageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_index() const { return _has_field_[3]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t index_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4ReadpageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };

  Ext4ReadpageFtraceEvent();
  ~Ext4ReadpageFtraceEvent() override;
  Ext4ReadpageFtraceEvent(Ext4ReadpageFtraceEvent&&) noexcept;
  Ext4ReadpageFtraceEvent& operator=(Ext4ReadpageFtraceEvent&&);
  Ext4ReadpageFtraceEvent(const Ext4ReadpageFtraceEvent&);
  Ext4ReadpageFtraceEvent& operator=(const Ext4ReadpageFtraceEvent&);
  bool operator==(const Ext4ReadpageFtraceEvent&) const;
  bool operator!=(const Ext4ReadpageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_index() const { return _has_field_[3]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t index_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4ReadBlockBitmapLoadFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };

  Ext4ReadBlockBitmapLoadFtraceEvent();
  ~Ext4ReadBlockBitmapLoadFtraceEvent() override;
  Ext4ReadBlockBitmapLoadFtraceEvent(Ext4ReadBlockBitmapLoadFtraceEvent&&) noexcept;
  Ext4ReadBlockBitmapLoadFtraceEvent& operator=(Ext4ReadBlockBitmapLoadFtraceEvent&&);
  Ext4ReadBlockBitmapLoadFtraceEvent(const Ext4ReadBlockBitmapLoadFtraceEvent&);
  Ext4ReadBlockBitmapLoadFtraceEvent& operator=(const Ext4ReadBlockBitmapLoadFtraceEvent&);
  bool operator==(const Ext4ReadBlockBitmapLoadFtraceEvent&) const;
  bool operator!=(const Ext4ReadBlockBitmapLoadFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_group() const { return _has_field_[2]; }
  uint32_t group() const { return group_; }
  void set_group(uint32_t value) { group_ = value; _has_field_.set(2); }

 private:
  uint64_t dev_{};
  uint32_t group_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Ext4PunchHoleFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
  };

  Ext4PunchHoleFtraceEvent();
  ~Ext4PunchHoleFtraceEvent() override;
  Ext4PunchHoleFtraceEvent(Ext4PunchHoleFtraceEvent&&) noexcept;
  Ext4PunchHoleFtraceEvent& operator=(Ext4PunchHoleFtraceEvent&&);
  Ext4PunchHoleFtraceEvent(const Ext4PunchHoleFtraceEvent&);
  Ext4PunchHoleFtraceEvent& operator=(const Ext4PunchHoleFtraceEvent&);
  bool operator==(const Ext4PunchHoleFtraceEvent&) const;
  bool operator!=(const Ext4PunchHoleFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_offset() const { return _has_field_[3]; }
  int64_t offset() const { return offset_; }
  void set_offset(int64_t value) { offset_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  int64_t len() const { return len_; }
  void set_len(int64_t value) { len_ = value; _has_field_.set(4); }

  bool has_mode() const { return _has_field_[5]; }
  int32_t mode() const { return mode_; }
  void set_mode(int32_t value) { mode_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t offset_{};
  int64_t len_{};
  int32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4OtherInodeUpdateTimeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigInoFieldNumber = 3,
    kUidFieldNumber = 4,
    kGidFieldNumber = 5,
    kModeFieldNumber = 6,
  };

  Ext4OtherInodeUpdateTimeFtraceEvent();
  ~Ext4OtherInodeUpdateTimeFtraceEvent() override;
  Ext4OtherInodeUpdateTimeFtraceEvent(Ext4OtherInodeUpdateTimeFtraceEvent&&) noexcept;
  Ext4OtherInodeUpdateTimeFtraceEvent& operator=(Ext4OtherInodeUpdateTimeFtraceEvent&&);
  Ext4OtherInodeUpdateTimeFtraceEvent(const Ext4OtherInodeUpdateTimeFtraceEvent&);
  Ext4OtherInodeUpdateTimeFtraceEvent& operator=(const Ext4OtherInodeUpdateTimeFtraceEvent&);
  bool operator==(const Ext4OtherInodeUpdateTimeFtraceEvent&) const;
  bool operator!=(const Ext4OtherInodeUpdateTimeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_orig_ino() const { return _has_field_[3]; }
  uint64_t orig_ino() const { return orig_ino_; }
  void set_orig_ino(uint64_t value) { orig_ino_ = value; _has_field_.set(3); }

  bool has_uid() const { return _has_field_[4]; }
  uint32_t uid() const { return uid_; }
  void set_uid(uint32_t value) { uid_ = value; _has_field_.set(4); }

  bool has_gid() const { return _has_field_[5]; }
  uint32_t gid() const { return gid_; }
  void set_gid(uint32_t value) { gid_ = value; _has_field_.set(5); }

  bool has_mode() const { return _has_field_[6]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t orig_ino_{};
  uint32_t uid_{};
  uint32_t gid_{};
  uint32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4MballocPreallocFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigLogicalFieldNumber = 3,
    kOrigStartFieldNumber = 4,
    kOrigGroupFieldNumber = 5,
    kOrigLenFieldNumber = 6,
    kResultLogicalFieldNumber = 7,
    kResultStartFieldNumber = 8,
    kResultGroupFieldNumber = 9,
    kResultLenFieldNumber = 10,
  };

  Ext4MballocPreallocFtraceEvent();
  ~Ext4MballocPreallocFtraceEvent() override;
  Ext4MballocPreallocFtraceEvent(Ext4MballocPreallocFtraceEvent&&) noexcept;
  Ext4MballocPreallocFtraceEvent& operator=(Ext4MballocPreallocFtraceEvent&&);
  Ext4MballocPreallocFtraceEvent(const Ext4MballocPreallocFtraceEvent&);
  Ext4MballocPreallocFtraceEvent& operator=(const Ext4MballocPreallocFtraceEvent&);
  bool operator==(const Ext4MballocPreallocFtraceEvent&) const;
  bool operator!=(const Ext4MballocPreallocFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_orig_logical() const { return _has_field_[3]; }
  uint32_t orig_logical() const { return orig_logical_; }
  void set_orig_logical(uint32_t value) { orig_logical_ = value; _has_field_.set(3); }

  bool has_orig_start() const { return _has_field_[4]; }
  int32_t orig_start() const { return orig_start_; }
  void set_orig_start(int32_t value) { orig_start_ = value; _has_field_.set(4); }

  bool has_orig_group() const { return _has_field_[5]; }
  uint32_t orig_group() const { return orig_group_; }
  void set_orig_group(uint32_t value) { orig_group_ = value; _has_field_.set(5); }

  bool has_orig_len() const { return _has_field_[6]; }
  int32_t orig_len() const { return orig_len_; }
  void set_orig_len(int32_t value) { orig_len_ = value; _has_field_.set(6); }

  bool has_result_logical() const { return _has_field_[7]; }
  uint32_t result_logical() const { return result_logical_; }
  void set_result_logical(uint32_t value) { result_logical_ = value; _has_field_.set(7); }

  bool has_result_start() const { return _has_field_[8]; }
  int32_t result_start() const { return result_start_; }
  void set_result_start(int32_t value) { result_start_ = value; _has_field_.set(8); }

  bool has_result_group() const { return _has_field_[9]; }
  uint32_t result_group() const { return result_group_; }
  void set_result_group(uint32_t value) { result_group_ = value; _has_field_.set(9); }

  bool has_result_len() const { return _has_field_[10]; }
  int32_t result_len() const { return result_len_; }
  void set_result_len(int32_t value) { result_len_ = value; _has_field_.set(10); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t orig_logical_{};
  int32_t orig_start_{};
  uint32_t orig_group_{};
  int32_t orig_len_{};
  uint32_t result_logical_{};
  int32_t result_start_{};
  uint32_t result_group_{};
  int32_t result_len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT Ext4MballocFreeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kResultStartFieldNumber = 3,
    kResultGroupFieldNumber = 4,
    kResultLenFieldNumber = 5,
  };

  Ext4MballocFreeFtraceEvent();
  ~Ext4MballocFreeFtraceEvent() override;
  Ext4MballocFreeFtraceEvent(Ext4MballocFreeFtraceEvent&&) noexcept;
  Ext4MballocFreeFtraceEvent& operator=(Ext4MballocFreeFtraceEvent&&);
  Ext4MballocFreeFtraceEvent(const Ext4MballocFreeFtraceEvent&);
  Ext4MballocFreeFtraceEvent& operator=(const Ext4MballocFreeFtraceEvent&);
  bool operator==(const Ext4MballocFreeFtraceEvent&) const;
  bool operator!=(const Ext4MballocFreeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_result_start() const { return _has_field_[3]; }
  int32_t result_start() const { return result_start_; }
  void set_result_start(int32_t value) { result_start_ = value; _has_field_.set(3); }

  bool has_result_group() const { return _has_field_[4]; }
  uint32_t result_group() const { return result_group_; }
  void set_result_group(uint32_t value) { result_group_ = value; _has_field_.set(4); }

  bool has_result_len() const { return _has_field_[5]; }
  int32_t result_len() const { return result_len_; }
  void set_result_len(int32_t value) { result_len_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t result_start_{};
  uint32_t result_group_{};
  int32_t result_len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4MballocDiscardFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kResultStartFieldNumber = 3,
    kResultGroupFieldNumber = 4,
    kResultLenFieldNumber = 5,
  };

  Ext4MballocDiscardFtraceEvent();
  ~Ext4MballocDiscardFtraceEvent() override;
  Ext4MballocDiscardFtraceEvent(Ext4MballocDiscardFtraceEvent&&) noexcept;
  Ext4MballocDiscardFtraceEvent& operator=(Ext4MballocDiscardFtraceEvent&&);
  Ext4MballocDiscardFtraceEvent(const Ext4MballocDiscardFtraceEvent&);
  Ext4MballocDiscardFtraceEvent& operator=(const Ext4MballocDiscardFtraceEvent&);
  bool operator==(const Ext4MballocDiscardFtraceEvent&) const;
  bool operator!=(const Ext4MballocDiscardFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_result_start() const { return _has_field_[3]; }
  int32_t result_start() const { return result_start_; }
  void set_result_start(int32_t value) { result_start_ = value; _has_field_.set(3); }

  bool has_result_group() const { return _has_field_[4]; }
  uint32_t result_group() const { return result_group_; }
  void set_result_group(uint32_t value) { result_group_ = value; _has_field_.set(4); }

  bool has_result_len() const { return _has_field_[5]; }
  int32_t result_len() const { return result_len_; }
  void set_result_len(int32_t value) { result_len_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t result_start_{};
  uint32_t result_group_{};
  int32_t result_len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4MballocAllocFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigLogicalFieldNumber = 3,
    kOrigStartFieldNumber = 4,
    kOrigGroupFieldNumber = 5,
    kOrigLenFieldNumber = 6,
    kGoalLogicalFieldNumber = 7,
    kGoalStartFieldNumber = 8,
    kGoalGroupFieldNumber = 9,
    kGoalLenFieldNumber = 10,
    kResultLogicalFieldNumber = 11,
    kResultStartFieldNumber = 12,
    kResultGroupFieldNumber = 13,
    kResultLenFieldNumber = 14,
    kFoundFieldNumber = 15,
    kGroupsFieldNumber = 16,
    kBuddyFieldNumber = 17,
    kFlagsFieldNumber = 18,
    kTailFieldNumber = 19,
    kCrFieldNumber = 20,
  };

  Ext4MballocAllocFtraceEvent();
  ~Ext4MballocAllocFtraceEvent() override;
  Ext4MballocAllocFtraceEvent(Ext4MballocAllocFtraceEvent&&) noexcept;
  Ext4MballocAllocFtraceEvent& operator=(Ext4MballocAllocFtraceEvent&&);
  Ext4MballocAllocFtraceEvent(const Ext4MballocAllocFtraceEvent&);
  Ext4MballocAllocFtraceEvent& operator=(const Ext4MballocAllocFtraceEvent&);
  bool operator==(const Ext4MballocAllocFtraceEvent&) const;
  bool operator!=(const Ext4MballocAllocFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_orig_logical() const { return _has_field_[3]; }
  uint32_t orig_logical() const { return orig_logical_; }
  void set_orig_logical(uint32_t value) { orig_logical_ = value; _has_field_.set(3); }

  bool has_orig_start() const { return _has_field_[4]; }
  int32_t orig_start() const { return orig_start_; }
  void set_orig_start(int32_t value) { orig_start_ = value; _has_field_.set(4); }

  bool has_orig_group() const { return _has_field_[5]; }
  uint32_t orig_group() const { return orig_group_; }
  void set_orig_group(uint32_t value) { orig_group_ = value; _has_field_.set(5); }

  bool has_orig_len() const { return _has_field_[6]; }
  int32_t orig_len() const { return orig_len_; }
  void set_orig_len(int32_t value) { orig_len_ = value; _has_field_.set(6); }

  bool has_goal_logical() const { return _has_field_[7]; }
  uint32_t goal_logical() const { return goal_logical_; }
  void set_goal_logical(uint32_t value) { goal_logical_ = value; _has_field_.set(7); }

  bool has_goal_start() const { return _has_field_[8]; }
  int32_t goal_start() const { return goal_start_; }
  void set_goal_start(int32_t value) { goal_start_ = value; _has_field_.set(8); }

  bool has_goal_group() const { return _has_field_[9]; }
  uint32_t goal_group() const { return goal_group_; }
  void set_goal_group(uint32_t value) { goal_group_ = value; _has_field_.set(9); }

  bool has_goal_len() const { return _has_field_[10]; }
  int32_t goal_len() const { return goal_len_; }
  void set_goal_len(int32_t value) { goal_len_ = value; _has_field_.set(10); }

  bool has_result_logical() const { return _has_field_[11]; }
  uint32_t result_logical() const { return result_logical_; }
  void set_result_logical(uint32_t value) { result_logical_ = value; _has_field_.set(11); }

  bool has_result_start() const { return _has_field_[12]; }
  int32_t result_start() const { return result_start_; }
  void set_result_start(int32_t value) { result_start_ = value; _has_field_.set(12); }

  bool has_result_group() const { return _has_field_[13]; }
  uint32_t result_group() const { return result_group_; }
  void set_result_group(uint32_t value) { result_group_ = value; _has_field_.set(13); }

  bool has_result_len() const { return _has_field_[14]; }
  int32_t result_len() const { return result_len_; }
  void set_result_len(int32_t value) { result_len_ = value; _has_field_.set(14); }

  bool has_found() const { return _has_field_[15]; }
  uint32_t found() const { return found_; }
  void set_found(uint32_t value) { found_ = value; _has_field_.set(15); }

  bool has_groups() const { return _has_field_[16]; }
  uint32_t groups() const { return groups_; }
  void set_groups(uint32_t value) { groups_ = value; _has_field_.set(16); }

  bool has_buddy() const { return _has_field_[17]; }
  uint32_t buddy() const { return buddy_; }
  void set_buddy(uint32_t value) { buddy_ = value; _has_field_.set(17); }

  bool has_flags() const { return _has_field_[18]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(18); }

  bool has_tail() const { return _has_field_[19]; }
  uint32_t tail() const { return tail_; }
  void set_tail(uint32_t value) { tail_ = value; _has_field_.set(19); }

  bool has_cr() const { return _has_field_[20]; }
  uint32_t cr() const { return cr_; }
  void set_cr(uint32_t value) { cr_ = value; _has_field_.set(20); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t orig_logical_{};
  int32_t orig_start_{};
  uint32_t orig_group_{};
  int32_t orig_len_{};
  uint32_t goal_logical_{};
  int32_t goal_start_{};
  uint32_t goal_group_{};
  int32_t goal_len_{};
  uint32_t result_logical_{};
  int32_t result_start_{};
  uint32_t result_group_{};
  int32_t result_len_{};
  uint32_t found_{};
  uint32_t groups_{};
  uint32_t buddy_{};
  uint32_t flags_{};
  uint32_t tail_{};
  uint32_t cr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<21> _has_field_{};
};


class PERFETTO_EXPORT Ext4MbReleaseInodePaFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kCountFieldNumber = 4,
  };

  Ext4MbReleaseInodePaFtraceEvent();
  ~Ext4MbReleaseInodePaFtraceEvent() override;
  Ext4MbReleaseInodePaFtraceEvent(Ext4MbReleaseInodePaFtraceEvent&&) noexcept;
  Ext4MbReleaseInodePaFtraceEvent& operator=(Ext4MbReleaseInodePaFtraceEvent&&);
  Ext4MbReleaseInodePaFtraceEvent(const Ext4MbReleaseInodePaFtraceEvent&);
  Ext4MbReleaseInodePaFtraceEvent& operator=(const Ext4MbReleaseInodePaFtraceEvent&);
  bool operator==(const Ext4MbReleaseInodePaFtraceEvent&) const;
  bool operator!=(const Ext4MbReleaseInodePaFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_block() const { return _has_field_[3]; }
  uint64_t block() const { return block_; }
  void set_block(uint64_t value) { block_ = value; _has_field_.set(3); }

  bool has_count() const { return _has_field_[4]; }
  uint32_t count() const { return count_; }
  void set_count(uint32_t value) { count_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t block_{};
  uint32_t count_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4MbReleaseGroupPaFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kPaPstartFieldNumber = 2,
    kPaLenFieldNumber = 3,
  };

  Ext4MbReleaseGroupPaFtraceEvent();
  ~Ext4MbReleaseGroupPaFtraceEvent() override;
  Ext4MbReleaseGroupPaFtraceEvent(Ext4MbReleaseGroupPaFtraceEvent&&) noexcept;
  Ext4MbReleaseGroupPaFtraceEvent& operator=(Ext4MbReleaseGroupPaFtraceEvent&&);
  Ext4MbReleaseGroupPaFtraceEvent(const Ext4MbReleaseGroupPaFtraceEvent&);
  Ext4MbReleaseGroupPaFtraceEvent& operator=(const Ext4MbReleaseGroupPaFtraceEvent&);
  bool operator==(const Ext4MbReleaseGroupPaFtraceEvent&) const;
  bool operator!=(const Ext4MbReleaseGroupPaFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_pa_pstart() const { return _has_field_[2]; }
  uint64_t pa_pstart() const { return pa_pstart_; }
  void set_pa_pstart(uint64_t value) { pa_pstart_ = value; _has_field_.set(2); }

  bool has_pa_len() const { return _has_field_[3]; }
  uint32_t pa_len() const { return pa_len_; }
  void set_pa_len(uint32_t value) { pa_len_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t pa_pstart_{};
  uint32_t pa_len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4MbNewInodePaFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPaPstartFieldNumber = 3,
    kPaLstartFieldNumber = 4,
    kPaLenFieldNumber = 5,
  };

  Ext4MbNewInodePaFtraceEvent();
  ~Ext4MbNewInodePaFtraceEvent() override;
  Ext4MbNewInodePaFtraceEvent(Ext4MbNewInodePaFtraceEvent&&) noexcept;
  Ext4MbNewInodePaFtraceEvent& operator=(Ext4MbNewInodePaFtraceEvent&&);
  Ext4MbNewInodePaFtraceEvent(const Ext4MbNewInodePaFtraceEvent&);
  Ext4MbNewInodePaFtraceEvent& operator=(const Ext4MbNewInodePaFtraceEvent&);
  bool operator==(const Ext4MbNewInodePaFtraceEvent&) const;
  bool operator!=(const Ext4MbNewInodePaFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pa_pstart() const { return _has_field_[3]; }
  uint64_t pa_pstart() const { return pa_pstart_; }
  void set_pa_pstart(uint64_t value) { pa_pstart_ = value; _has_field_.set(3); }

  bool has_pa_lstart() const { return _has_field_[4]; }
  uint64_t pa_lstart() const { return pa_lstart_; }
  void set_pa_lstart(uint64_t value) { pa_lstart_ = value; _has_field_.set(4); }

  bool has_pa_len() const { return _has_field_[5]; }
  uint32_t pa_len() const { return pa_len_; }
  void set_pa_len(uint32_t value) { pa_len_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pa_pstart_{};
  uint64_t pa_lstart_{};
  uint32_t pa_len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4MbNewGroupPaFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPaPstartFieldNumber = 3,
    kPaLstartFieldNumber = 4,
    kPaLenFieldNumber = 5,
  };

  Ext4MbNewGroupPaFtraceEvent();
  ~Ext4MbNewGroupPaFtraceEvent() override;
  Ext4MbNewGroupPaFtraceEvent(Ext4MbNewGroupPaFtraceEvent&&) noexcept;
  Ext4MbNewGroupPaFtraceEvent& operator=(Ext4MbNewGroupPaFtraceEvent&&);
  Ext4MbNewGroupPaFtraceEvent(const Ext4MbNewGroupPaFtraceEvent&);
  Ext4MbNewGroupPaFtraceEvent& operator=(const Ext4MbNewGroupPaFtraceEvent&);
  bool operator==(const Ext4MbNewGroupPaFtraceEvent&) const;
  bool operator!=(const Ext4MbNewGroupPaFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pa_pstart() const { return _has_field_[3]; }
  uint64_t pa_pstart() const { return pa_pstart_; }
  void set_pa_pstart(uint64_t value) { pa_pstart_ = value; _has_field_.set(3); }

  bool has_pa_lstart() const { return _has_field_[4]; }
  uint64_t pa_lstart() const { return pa_lstart_; }
  void set_pa_lstart(uint64_t value) { pa_lstart_ = value; _has_field_.set(4); }

  bool has_pa_len() const { return _has_field_[5]; }
  uint32_t pa_len() const { return pa_len_; }
  void set_pa_len(uint32_t value) { pa_len_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pa_pstart_{};
  uint64_t pa_lstart_{};
  uint32_t pa_len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4MbDiscardPreallocationsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kNeededFieldNumber = 2,
  };

  Ext4MbDiscardPreallocationsFtraceEvent();
  ~Ext4MbDiscardPreallocationsFtraceEvent() override;
  Ext4MbDiscardPreallocationsFtraceEvent(Ext4MbDiscardPreallocationsFtraceEvent&&) noexcept;
  Ext4MbDiscardPreallocationsFtraceEvent& operator=(Ext4MbDiscardPreallocationsFtraceEvent&&);
  Ext4MbDiscardPreallocationsFtraceEvent(const Ext4MbDiscardPreallocationsFtraceEvent&);
  Ext4MbDiscardPreallocationsFtraceEvent& operator=(const Ext4MbDiscardPreallocationsFtraceEvent&);
  bool operator==(const Ext4MbDiscardPreallocationsFtraceEvent&) const;
  bool operator!=(const Ext4MbDiscardPreallocationsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_needed() const { return _has_field_[2]; }
  int32_t needed() const { return needed_; }
  void set_needed(int32_t value) { needed_ = value; _has_field_.set(2); }

 private:
  uint64_t dev_{};
  int32_t needed_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Ext4MbBuddyBitmapLoadFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };

  Ext4MbBuddyBitmapLoadFtraceEvent();
  ~Ext4MbBuddyBitmapLoadFtraceEvent() override;
  Ext4MbBuddyBitmapLoadFtraceEvent(Ext4MbBuddyBitmapLoadFtraceEvent&&) noexcept;
  Ext4MbBuddyBitmapLoadFtraceEvent& operator=(Ext4MbBuddyBitmapLoadFtraceEvent&&);
  Ext4MbBuddyBitmapLoadFtraceEvent(const Ext4MbBuddyBitmapLoadFtraceEvent&);
  Ext4MbBuddyBitmapLoadFtraceEvent& operator=(const Ext4MbBuddyBitmapLoadFtraceEvent&);
  bool operator==(const Ext4MbBuddyBitmapLoadFtraceEvent&) const;
  bool operator!=(const Ext4MbBuddyBitmapLoadFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_group() const { return _has_field_[2]; }
  uint32_t group() const { return group_; }
  void set_group(uint32_t value) { group_ = value; _has_field_.set(2); }

 private:
  uint64_t dev_{};
  uint32_t group_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Ext4MbBitmapLoadFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };

  Ext4MbBitmapLoadFtraceEvent();
  ~Ext4MbBitmapLoadFtraceEvent() override;
  Ext4MbBitmapLoadFtraceEvent(Ext4MbBitmapLoadFtraceEvent&&) noexcept;
  Ext4MbBitmapLoadFtraceEvent& operator=(Ext4MbBitmapLoadFtraceEvent&&);
  Ext4MbBitmapLoadFtraceEvent(const Ext4MbBitmapLoadFtraceEvent&);
  Ext4MbBitmapLoadFtraceEvent& operator=(const Ext4MbBitmapLoadFtraceEvent&);
  bool operator==(const Ext4MbBitmapLoadFtraceEvent&) const;
  bool operator!=(const Ext4MbBitmapLoadFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_group() const { return _has_field_[2]; }
  uint32_t group() const { return group_; }
  void set_group(uint32_t value) { group_ = value; _has_field_.set(2); }

 private:
  uint64_t dev_{};
  uint32_t group_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Ext4MarkInodeDirtyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIpFieldNumber = 3,
  };

  Ext4MarkInodeDirtyFtraceEvent();
  ~Ext4MarkInodeDirtyFtraceEvent() override;
  Ext4MarkInodeDirtyFtraceEvent(Ext4MarkInodeDirtyFtraceEvent&&) noexcept;
  Ext4MarkInodeDirtyFtraceEvent& operator=(Ext4MarkInodeDirtyFtraceEvent&&);
  Ext4MarkInodeDirtyFtraceEvent(const Ext4MarkInodeDirtyFtraceEvent&);
  Ext4MarkInodeDirtyFtraceEvent& operator=(const Ext4MarkInodeDirtyFtraceEvent&);
  bool operator==(const Ext4MarkInodeDirtyFtraceEvent&) const;
  bool operator!=(const Ext4MarkInodeDirtyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ip() const { return _has_field_[3]; }
  uint64_t ip() const { return ip_; }
  void set_ip(uint64_t value) { ip_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t ip_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4LoadInodeBitmapFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };

  Ext4LoadInodeBitmapFtraceEvent();
  ~Ext4LoadInodeBitmapFtraceEvent() override;
  Ext4LoadInodeBitmapFtraceEvent(Ext4LoadInodeBitmapFtraceEvent&&) noexcept;
  Ext4LoadInodeBitmapFtraceEvent& operator=(Ext4LoadInodeBitmapFtraceEvent&&);
  Ext4LoadInodeBitmapFtraceEvent(const Ext4LoadInodeBitmapFtraceEvent&);
  Ext4LoadInodeBitmapFtraceEvent& operator=(const Ext4LoadInodeBitmapFtraceEvent&);
  bool operator==(const Ext4LoadInodeBitmapFtraceEvent&) const;
  bool operator!=(const Ext4LoadInodeBitmapFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_group() const { return _has_field_[2]; }
  uint32_t group() const { return group_; }
  void set_group(uint32_t value) { group_ = value; _has_field_.set(2); }

 private:
  uint64_t dev_{};
  uint32_t group_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Ext4LoadInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
  };

  Ext4LoadInodeFtraceEvent();
  ~Ext4LoadInodeFtraceEvent() override;
  Ext4LoadInodeFtraceEvent(Ext4LoadInodeFtraceEvent&&) noexcept;
  Ext4LoadInodeFtraceEvent& operator=(Ext4LoadInodeFtraceEvent&&);
  Ext4LoadInodeFtraceEvent(const Ext4LoadInodeFtraceEvent&);
  Ext4LoadInodeFtraceEvent& operator=(const Ext4LoadInodeFtraceEvent&);
  bool operator==(const Ext4LoadInodeFtraceEvent&) const;
  bool operator!=(const Ext4LoadInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Ext4JournalledWriteEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };

  Ext4JournalledWriteEndFtraceEvent();
  ~Ext4JournalledWriteEndFtraceEvent() override;
  Ext4JournalledWriteEndFtraceEvent(Ext4JournalledWriteEndFtraceEvent&&) noexcept;
  Ext4JournalledWriteEndFtraceEvent& operator=(Ext4JournalledWriteEndFtraceEvent&&);
  Ext4JournalledWriteEndFtraceEvent(const Ext4JournalledWriteEndFtraceEvent&);
  Ext4JournalledWriteEndFtraceEvent& operator=(const Ext4JournalledWriteEndFtraceEvent&);
  bool operator==(const Ext4JournalledWriteEndFtraceEvent&) const;
  bool operator!=(const Ext4JournalledWriteEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_copied() const { return _has_field_[5]; }
  uint32_t copied() const { return copied_; }
  void set_copied(uint32_t value) { copied_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t copied_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4JournalledInvalidatepageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };

  Ext4JournalledInvalidatepageFtraceEvent();
  ~Ext4JournalledInvalidatepageFtraceEvent() override;
  Ext4JournalledInvalidatepageFtraceEvent(Ext4JournalledInvalidatepageFtraceEvent&&) noexcept;
  Ext4JournalledInvalidatepageFtraceEvent& operator=(Ext4JournalledInvalidatepageFtraceEvent&&);
  Ext4JournalledInvalidatepageFtraceEvent(const Ext4JournalledInvalidatepageFtraceEvent&);
  Ext4JournalledInvalidatepageFtraceEvent& operator=(const Ext4JournalledInvalidatepageFtraceEvent&);
  bool operator==(const Ext4JournalledInvalidatepageFtraceEvent&) const;
  bool operator!=(const Ext4JournalledInvalidatepageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_index() const { return _has_field_[3]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(3); }

  bool has_offset() const { return _has_field_[4]; }
  uint64_t offset() const { return offset_; }
  void set_offset(uint64_t value) { offset_ = value; _has_field_.set(4); }

  bool has_length() const { return _has_field_[5]; }
  uint32_t length() const { return length_; }
  void set_length(uint32_t value) { length_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t index_{};
  uint64_t offset_{};
  uint32_t length_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4JournalStartReservedFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kIpFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };

  Ext4JournalStartReservedFtraceEvent();
  ~Ext4JournalStartReservedFtraceEvent() override;
  Ext4JournalStartReservedFtraceEvent(Ext4JournalStartReservedFtraceEvent&&) noexcept;
  Ext4JournalStartReservedFtraceEvent& operator=(Ext4JournalStartReservedFtraceEvent&&);
  Ext4JournalStartReservedFtraceEvent(const Ext4JournalStartReservedFtraceEvent&);
  Ext4JournalStartReservedFtraceEvent& operator=(const Ext4JournalStartReservedFtraceEvent&);
  bool operator==(const Ext4JournalStartReservedFtraceEvent&) const;
  bool operator!=(const Ext4JournalStartReservedFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ip() const { return _has_field_[2]; }
  uint64_t ip() const { return ip_; }
  void set_ip(uint64_t value) { ip_ = value; _has_field_.set(2); }

  bool has_blocks() const { return _has_field_[3]; }
  int32_t blocks() const { return blocks_; }
  void set_blocks(int32_t value) { blocks_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ip_{};
  int32_t blocks_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4JournalStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kIpFieldNumber = 2,
    kBlocksFieldNumber = 3,
    kRsvBlocksFieldNumber = 4,
    kNblocksFieldNumber = 5,
  };

  Ext4JournalStartFtraceEvent();
  ~Ext4JournalStartFtraceEvent() override;
  Ext4JournalStartFtraceEvent(Ext4JournalStartFtraceEvent&&) noexcept;
  Ext4JournalStartFtraceEvent& operator=(Ext4JournalStartFtraceEvent&&);
  Ext4JournalStartFtraceEvent(const Ext4JournalStartFtraceEvent&);
  Ext4JournalStartFtraceEvent& operator=(const Ext4JournalStartFtraceEvent&);
  bool operator==(const Ext4JournalStartFtraceEvent&) const;
  bool operator!=(const Ext4JournalStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ip() const { return _has_field_[2]; }
  uint64_t ip() const { return ip_; }
  void set_ip(uint64_t value) { ip_ = value; _has_field_.set(2); }

  bool has_blocks() const { return _has_field_[3]; }
  int32_t blocks() const { return blocks_; }
  void set_blocks(int32_t value) { blocks_ = value; _has_field_.set(3); }

  bool has_rsv_blocks() const { return _has_field_[4]; }
  int32_t rsv_blocks() const { return rsv_blocks_; }
  void set_rsv_blocks(int32_t value) { rsv_blocks_ = value; _has_field_.set(4); }

  bool has_nblocks() const { return _has_field_[5]; }
  int32_t nblocks() const { return nblocks_; }
  void set_nblocks(int32_t value) { nblocks_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ip_{};
  int32_t blocks_{};
  int32_t rsv_blocks_{};
  int32_t nblocks_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4InvalidatepageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };

  Ext4InvalidatepageFtraceEvent();
  ~Ext4InvalidatepageFtraceEvent() override;
  Ext4InvalidatepageFtraceEvent(Ext4InvalidatepageFtraceEvent&&) noexcept;
  Ext4InvalidatepageFtraceEvent& operator=(Ext4InvalidatepageFtraceEvent&&);
  Ext4InvalidatepageFtraceEvent(const Ext4InvalidatepageFtraceEvent&);
  Ext4InvalidatepageFtraceEvent& operator=(const Ext4InvalidatepageFtraceEvent&);
  bool operator==(const Ext4InvalidatepageFtraceEvent&) const;
  bool operator!=(const Ext4InvalidatepageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_index() const { return _has_field_[3]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(3); }

  bool has_offset() const { return _has_field_[4]; }
  uint64_t offset() const { return offset_; }
  void set_offset(uint64_t value) { offset_ = value; _has_field_.set(4); }

  bool has_length() const { return _has_field_[5]; }
  uint32_t length() const { return length_; }
  void set_length(uint32_t value) { length_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t index_{};
  uint64_t offset_{};
  uint32_t length_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4InsertRangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
  };

  Ext4InsertRangeFtraceEvent();
  ~Ext4InsertRangeFtraceEvent() override;
  Ext4InsertRangeFtraceEvent(Ext4InsertRangeFtraceEvent&&) noexcept;
  Ext4InsertRangeFtraceEvent& operator=(Ext4InsertRangeFtraceEvent&&);
  Ext4InsertRangeFtraceEvent(const Ext4InsertRangeFtraceEvent&);
  Ext4InsertRangeFtraceEvent& operator=(const Ext4InsertRangeFtraceEvent&);
  bool operator==(const Ext4InsertRangeFtraceEvent&) const;
  bool operator!=(const Ext4InsertRangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_offset() const { return _has_field_[3]; }
  int64_t offset() const { return offset_; }
  void set_offset(int64_t value) { offset_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  int64_t len() const { return len_; }
  void set_len(int64_t value) { len_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t offset_{};
  int64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4IndMapBlocksExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kMflagsFieldNumber = 7,
    kRetFieldNumber = 8,
  };

  Ext4IndMapBlocksExitFtraceEvent();
  ~Ext4IndMapBlocksExitFtraceEvent() override;
  Ext4IndMapBlocksExitFtraceEvent(Ext4IndMapBlocksExitFtraceEvent&&) noexcept;
  Ext4IndMapBlocksExitFtraceEvent& operator=(Ext4IndMapBlocksExitFtraceEvent&&);
  Ext4IndMapBlocksExitFtraceEvent(const Ext4IndMapBlocksExitFtraceEvent&);
  Ext4IndMapBlocksExitFtraceEvent& operator=(const Ext4IndMapBlocksExitFtraceEvent&);
  bool operator==(const Ext4IndMapBlocksExitFtraceEvent&) const;
  bool operator!=(const Ext4IndMapBlocksExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_pblk() const { return _has_field_[4]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(4); }

  bool has_lblk() const { return _has_field_[5]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(5); }

  bool has_len() const { return _has_field_[6]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(6); }

  bool has_mflags() const { return _has_field_[7]; }
  uint32_t mflags() const { return mflags_; }
  void set_mflags(uint32_t value) { mflags_ = value; _has_field_.set(7); }

  bool has_ret() const { return _has_field_[8]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t flags_{};
  uint64_t pblk_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint32_t mflags_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT Ext4IndMapBlocksEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };

  Ext4IndMapBlocksEnterFtraceEvent();
  ~Ext4IndMapBlocksEnterFtraceEvent() override;
  Ext4IndMapBlocksEnterFtraceEvent(Ext4IndMapBlocksEnterFtraceEvent&&) noexcept;
  Ext4IndMapBlocksEnterFtraceEvent& operator=(Ext4IndMapBlocksEnterFtraceEvent&&);
  Ext4IndMapBlocksEnterFtraceEvent(const Ext4IndMapBlocksEnterFtraceEvent&);
  Ext4IndMapBlocksEnterFtraceEvent& operator=(const Ext4IndMapBlocksEnterFtraceEvent&);
  bool operator==(const Ext4IndMapBlocksEnterFtraceEvent&) const;
  bool operator!=(const Ext4IndMapBlocksEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4GetReservedClusterAllocFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
  };

  Ext4GetReservedClusterAllocFtraceEvent();
  ~Ext4GetReservedClusterAllocFtraceEvent() override;
  Ext4GetReservedClusterAllocFtraceEvent(Ext4GetReservedClusterAllocFtraceEvent&&) noexcept;
  Ext4GetReservedClusterAllocFtraceEvent& operator=(Ext4GetReservedClusterAllocFtraceEvent&&);
  Ext4GetReservedClusterAllocFtraceEvent(const Ext4GetReservedClusterAllocFtraceEvent&);
  Ext4GetReservedClusterAllocFtraceEvent& operator=(const Ext4GetReservedClusterAllocFtraceEvent&);
  bool operator==(const Ext4GetReservedClusterAllocFtraceEvent&) const;
  bool operator!=(const Ext4GetReservedClusterAllocFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  uint32_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4GetImpliedClusterAllocExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLblkFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLenFieldNumber = 5,
    kRetFieldNumber = 6,
  };

  Ext4GetImpliedClusterAllocExitFtraceEvent();
  ~Ext4GetImpliedClusterAllocExitFtraceEvent() override;
  Ext4GetImpliedClusterAllocExitFtraceEvent(Ext4GetImpliedClusterAllocExitFtraceEvent&&) noexcept;
  Ext4GetImpliedClusterAllocExitFtraceEvent& operator=(Ext4GetImpliedClusterAllocExitFtraceEvent&&);
  Ext4GetImpliedClusterAllocExitFtraceEvent(const Ext4GetImpliedClusterAllocExitFtraceEvent&);
  Ext4GetImpliedClusterAllocExitFtraceEvent& operator=(const Ext4GetImpliedClusterAllocExitFtraceEvent&);
  bool operator==(const Ext4GetImpliedClusterAllocExitFtraceEvent&) const;
  bool operator!=(const Ext4GetImpliedClusterAllocExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_pblk() const { return _has_field_[4]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(5); }

  bool has_ret() const { return _has_field_[6]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint32_t flags_{};
  uint32_t lblk_{};
  uint64_t pblk_{};
  uint32_t len_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4FreeInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kUidFieldNumber = 3,
    kGidFieldNumber = 4,
    kBlocksFieldNumber = 5,
    kModeFieldNumber = 6,
  };

  Ext4FreeInodeFtraceEvent();
  ~Ext4FreeInodeFtraceEvent() override;
  Ext4FreeInodeFtraceEvent(Ext4FreeInodeFtraceEvent&&) noexcept;
  Ext4FreeInodeFtraceEvent& operator=(Ext4FreeInodeFtraceEvent&&);
  Ext4FreeInodeFtraceEvent(const Ext4FreeInodeFtraceEvent&);
  Ext4FreeInodeFtraceEvent& operator=(const Ext4FreeInodeFtraceEvent&);
  bool operator==(const Ext4FreeInodeFtraceEvent&) const;
  bool operator!=(const Ext4FreeInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_uid() const { return _has_field_[3]; }
  uint32_t uid() const { return uid_; }
  void set_uid(uint32_t value) { uid_ = value; _has_field_.set(3); }

  bool has_gid() const { return _has_field_[4]; }
  uint32_t gid() const { return gid_; }
  void set_gid(uint32_t value) { gid_ = value; _has_field_.set(4); }

  bool has_blocks() const { return _has_field_[5]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(5); }

  bool has_mode() const { return _has_field_[6]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t uid_{};
  uint32_t gid_{};
  uint64_t blocks_{};
  uint32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4FreeBlocksFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kCountFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kModeFieldNumber = 6,
  };

  Ext4FreeBlocksFtraceEvent();
  ~Ext4FreeBlocksFtraceEvent() override;
  Ext4FreeBlocksFtraceEvent(Ext4FreeBlocksFtraceEvent&&) noexcept;
  Ext4FreeBlocksFtraceEvent& operator=(Ext4FreeBlocksFtraceEvent&&);
  Ext4FreeBlocksFtraceEvent(const Ext4FreeBlocksFtraceEvent&);
  Ext4FreeBlocksFtraceEvent& operator=(const Ext4FreeBlocksFtraceEvent&);
  bool operator==(const Ext4FreeBlocksFtraceEvent&) const;
  bool operator!=(const Ext4FreeBlocksFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_block() const { return _has_field_[3]; }
  uint64_t block() const { return block_; }
  void set_block(uint64_t value) { block_ = value; _has_field_.set(3); }

  bool has_count() const { return _has_field_[4]; }
  uint64_t count() const { return count_; }
  void set_count(uint64_t value) { count_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  int32_t flags() const { return flags_; }
  void set_flags(int32_t value) { flags_ = value; _has_field_.set(5); }

  bool has_mode() const { return _has_field_[6]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t block_{};
  uint64_t count_{};
  int32_t flags_{};
  uint32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4ForgetFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kIsMetadataFieldNumber = 4,
    kModeFieldNumber = 5,
  };

  Ext4ForgetFtraceEvent();
  ~Ext4ForgetFtraceEvent() override;
  Ext4ForgetFtraceEvent(Ext4ForgetFtraceEvent&&) noexcept;
  Ext4ForgetFtraceEvent& operator=(Ext4ForgetFtraceEvent&&);
  Ext4ForgetFtraceEvent(const Ext4ForgetFtraceEvent&);
  Ext4ForgetFtraceEvent& operator=(const Ext4ForgetFtraceEvent&);
  bool operator==(const Ext4ForgetFtraceEvent&) const;
  bool operator!=(const Ext4ForgetFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_block() const { return _has_field_[3]; }
  uint64_t block() const { return block_; }
  void set_block(uint64_t value) { block_ = value; _has_field_.set(3); }

  bool has_is_metadata() const { return _has_field_[4]; }
  int32_t is_metadata() const { return is_metadata_; }
  void set_is_metadata(int32_t value) { is_metadata_ = value; _has_field_.set(4); }

  bool has_mode() const { return _has_field_[5]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t block_{};
  int32_t is_metadata_{};
  uint32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4FindDelallocRangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kReverseFieldNumber = 5,
    kFoundFieldNumber = 6,
    kFoundBlkFieldNumber = 7,
  };

  Ext4FindDelallocRangeFtraceEvent();
  ~Ext4FindDelallocRangeFtraceEvent() override;
  Ext4FindDelallocRangeFtraceEvent(Ext4FindDelallocRangeFtraceEvent&&) noexcept;
  Ext4FindDelallocRangeFtraceEvent& operator=(Ext4FindDelallocRangeFtraceEvent&&);
  Ext4FindDelallocRangeFtraceEvent(const Ext4FindDelallocRangeFtraceEvent&);
  Ext4FindDelallocRangeFtraceEvent& operator=(const Ext4FindDelallocRangeFtraceEvent&);
  bool operator==(const Ext4FindDelallocRangeFtraceEvent&) const;
  bool operator!=(const Ext4FindDelallocRangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_from() const { return _has_field_[3]; }
  uint32_t from() const { return from_; }
  void set_from(uint32_t value) { from_ = value; _has_field_.set(3); }

  bool has_to() const { return _has_field_[4]; }
  uint32_t to() const { return to_; }
  void set_to(uint32_t value) { to_ = value; _has_field_.set(4); }

  bool has_reverse() const { return _has_field_[5]; }
  int32_t reverse() const { return reverse_; }
  void set_reverse(int32_t value) { reverse_ = value; _has_field_.set(5); }

  bool has_found() const { return _has_field_[6]; }
  int32_t found() const { return found_; }
  void set_found(int32_t value) { found_ = value; _has_field_.set(6); }

  bool has_found_blk() const { return _has_field_[7]; }
  uint32_t found_blk() const { return found_blk_; }
  void set_found_blk(uint32_t value) { found_blk_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t from_{};
  uint32_t to_{};
  int32_t reverse_{};
  int32_t found_{};
  uint32_t found_blk_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT Ext4FallocateExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kRetFieldNumber = 5,
  };

  Ext4FallocateExitFtraceEvent();
  ~Ext4FallocateExitFtraceEvent() override;
  Ext4FallocateExitFtraceEvent(Ext4FallocateExitFtraceEvent&&) noexcept;
  Ext4FallocateExitFtraceEvent& operator=(Ext4FallocateExitFtraceEvent&&);
  Ext4FallocateExitFtraceEvent(const Ext4FallocateExitFtraceEvent&);
  Ext4FallocateExitFtraceEvent& operator=(const Ext4FallocateExitFtraceEvent&);
  bool operator==(const Ext4FallocateExitFtraceEvent&) const;
  bool operator!=(const Ext4FallocateExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_blocks() const { return _has_field_[4]; }
  uint32_t blocks() const { return blocks_; }
  void set_blocks(uint32_t value) { blocks_ = value; _has_field_.set(4); }

  bool has_ret() const { return _has_field_[5]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t blocks_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4FallocateEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
    kPosFieldNumber = 6,
  };

  Ext4FallocateEnterFtraceEvent();
  ~Ext4FallocateEnterFtraceEvent() override;
  Ext4FallocateEnterFtraceEvent(Ext4FallocateEnterFtraceEvent&&) noexcept;
  Ext4FallocateEnterFtraceEvent& operator=(Ext4FallocateEnterFtraceEvent&&);
  Ext4FallocateEnterFtraceEvent(const Ext4FallocateEnterFtraceEvent&);
  Ext4FallocateEnterFtraceEvent& operator=(const Ext4FallocateEnterFtraceEvent&);
  bool operator==(const Ext4FallocateEnterFtraceEvent&) const;
  bool operator!=(const Ext4FallocateEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_offset() const { return _has_field_[3]; }
  int64_t offset() const { return offset_; }
  void set_offset(int64_t value) { offset_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  int64_t len() const { return len_; }
  void set_len(int64_t value) { len_ = value; _has_field_.set(4); }

  bool has_mode() const { return _has_field_[5]; }
  int32_t mode() const { return mode_; }
  void set_mode(int32_t value) { mode_ = value; _has_field_.set(5); }

  bool has_pos() const { return _has_field_[6]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t offset_{};
  int64_t len_{};
  int32_t mode_{};
  int64_t pos_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtShowExtentFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
    kLblkFieldNumber = 4,
    kLenFieldNumber = 5,
  };

  Ext4ExtShowExtentFtraceEvent();
  ~Ext4ExtShowExtentFtraceEvent() override;
  Ext4ExtShowExtentFtraceEvent(Ext4ExtShowExtentFtraceEvent&&) noexcept;
  Ext4ExtShowExtentFtraceEvent& operator=(Ext4ExtShowExtentFtraceEvent&&);
  Ext4ExtShowExtentFtraceEvent(const Ext4ExtShowExtentFtraceEvent&);
  Ext4ExtShowExtentFtraceEvent& operator=(const Ext4ExtShowExtentFtraceEvent&);
  bool operator==(const Ext4ExtShowExtentFtraceEvent&) const;
  bool operator!=(const Ext4ExtShowExtentFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pblk() const { return _has_field_[3]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(3); }

  bool has_lblk() const { return _has_field_[4]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pblk_{};
  uint32_t lblk_{};
  uint32_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtRmLeafFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPartialFieldNumber = 3,
    kStartFieldNumber = 4,
    kEeLblkFieldNumber = 5,
    kEePblkFieldNumber = 6,
    kEeLenFieldNumber = 7,
  };

  Ext4ExtRmLeafFtraceEvent();
  ~Ext4ExtRmLeafFtraceEvent() override;
  Ext4ExtRmLeafFtraceEvent(Ext4ExtRmLeafFtraceEvent&&) noexcept;
  Ext4ExtRmLeafFtraceEvent& operator=(Ext4ExtRmLeafFtraceEvent&&);
  Ext4ExtRmLeafFtraceEvent(const Ext4ExtRmLeafFtraceEvent&);
  Ext4ExtRmLeafFtraceEvent& operator=(const Ext4ExtRmLeafFtraceEvent&);
  bool operator==(const Ext4ExtRmLeafFtraceEvent&) const;
  bool operator!=(const Ext4ExtRmLeafFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_partial() const { return _has_field_[3]; }
  int64_t partial() const { return partial_; }
  void set_partial(int64_t value) { partial_ = value; _has_field_.set(3); }

  bool has_start() const { return _has_field_[4]; }
  uint32_t start() const { return start_; }
  void set_start(uint32_t value) { start_ = value; _has_field_.set(4); }

  bool has_ee_lblk() const { return _has_field_[5]; }
  uint32_t ee_lblk() const { return ee_lblk_; }
  void set_ee_lblk(uint32_t value) { ee_lblk_ = value; _has_field_.set(5); }

  bool has_ee_pblk() const { return _has_field_[6]; }
  uint64_t ee_pblk() const { return ee_pblk_; }
  void set_ee_pblk(uint64_t value) { ee_pblk_ = value; _has_field_.set(6); }

  bool has_ee_len() const { return _has_field_[7]; }
  int32_t ee_len() const { return ee_len_; }
  void set_ee_len(int32_t value) { ee_len_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t partial_{};
  uint32_t start_{};
  uint32_t ee_lblk_{};
  uint64_t ee_pblk_{};
  int32_t ee_len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtRmIdxFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
  };

  Ext4ExtRmIdxFtraceEvent();
  ~Ext4ExtRmIdxFtraceEvent() override;
  Ext4ExtRmIdxFtraceEvent(Ext4ExtRmIdxFtraceEvent&&) noexcept;
  Ext4ExtRmIdxFtraceEvent& operator=(Ext4ExtRmIdxFtraceEvent&&);
  Ext4ExtRmIdxFtraceEvent(const Ext4ExtRmIdxFtraceEvent&);
  Ext4ExtRmIdxFtraceEvent& operator=(const Ext4ExtRmIdxFtraceEvent&);
  bool operator==(const Ext4ExtRmIdxFtraceEvent&) const;
  bool operator!=(const Ext4ExtRmIdxFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pblk() const { return _has_field_[3]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pblk_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtRemoveSpaceDoneFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDepthFieldNumber = 5,
    kPartialFieldNumber = 6,
    kEhEntriesFieldNumber = 7,
  };

  Ext4ExtRemoveSpaceDoneFtraceEvent();
  ~Ext4ExtRemoveSpaceDoneFtraceEvent() override;
  Ext4ExtRemoveSpaceDoneFtraceEvent(Ext4ExtRemoveSpaceDoneFtraceEvent&&) noexcept;
  Ext4ExtRemoveSpaceDoneFtraceEvent& operator=(Ext4ExtRemoveSpaceDoneFtraceEvent&&);
  Ext4ExtRemoveSpaceDoneFtraceEvent(const Ext4ExtRemoveSpaceDoneFtraceEvent&);
  Ext4ExtRemoveSpaceDoneFtraceEvent& operator=(const Ext4ExtRemoveSpaceDoneFtraceEvent&);
  bool operator==(const Ext4ExtRemoveSpaceDoneFtraceEvent&) const;
  bool operator!=(const Ext4ExtRemoveSpaceDoneFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_start() const { return _has_field_[3]; }
  uint32_t start() const { return start_; }
  void set_start(uint32_t value) { start_ = value; _has_field_.set(3); }

  bool has_end() const { return _has_field_[4]; }
  uint32_t end() const { return end_; }
  void set_end(uint32_t value) { end_ = value; _has_field_.set(4); }

  bool has_depth() const { return _has_field_[5]; }
  int32_t depth() const { return depth_; }
  void set_depth(int32_t value) { depth_ = value; _has_field_.set(5); }

  bool has_partial() const { return _has_field_[6]; }
  int64_t partial() const { return partial_; }
  void set_partial(int64_t value) { partial_ = value; _has_field_.set(6); }

  bool has_eh_entries() const { return _has_field_[7]; }
  uint32_t eh_entries() const { return eh_entries_; }
  void set_eh_entries(uint32_t value) { eh_entries_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t start_{};
  uint32_t end_{};
  int32_t depth_{};
  int64_t partial_{};
  uint32_t eh_entries_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtRemoveSpaceFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDepthFieldNumber = 5,
  };

  Ext4ExtRemoveSpaceFtraceEvent();
  ~Ext4ExtRemoveSpaceFtraceEvent() override;
  Ext4ExtRemoveSpaceFtraceEvent(Ext4ExtRemoveSpaceFtraceEvent&&) noexcept;
  Ext4ExtRemoveSpaceFtraceEvent& operator=(Ext4ExtRemoveSpaceFtraceEvent&&);
  Ext4ExtRemoveSpaceFtraceEvent(const Ext4ExtRemoveSpaceFtraceEvent&);
  Ext4ExtRemoveSpaceFtraceEvent& operator=(const Ext4ExtRemoveSpaceFtraceEvent&);
  bool operator==(const Ext4ExtRemoveSpaceFtraceEvent&) const;
  bool operator!=(const Ext4ExtRemoveSpaceFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_start() const { return _has_field_[3]; }
  uint32_t start() const { return start_; }
  void set_start(uint32_t value) { start_ = value; _has_field_.set(3); }

  bool has_end() const { return _has_field_[4]; }
  uint32_t end() const { return end_; }
  void set_end(uint32_t value) { end_ = value; _has_field_.set(4); }

  bool has_depth() const { return _has_field_[5]; }
  int32_t depth() const { return depth_; }
  void set_depth(int32_t value) { depth_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t start_{};
  uint32_t end_{};
  int32_t depth_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtPutInCacheFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kStartFieldNumber = 5,
  };

  Ext4ExtPutInCacheFtraceEvent();
  ~Ext4ExtPutInCacheFtraceEvent() override;
  Ext4ExtPutInCacheFtraceEvent(Ext4ExtPutInCacheFtraceEvent&&) noexcept;
  Ext4ExtPutInCacheFtraceEvent& operator=(Ext4ExtPutInCacheFtraceEvent&&);
  Ext4ExtPutInCacheFtraceEvent(const Ext4ExtPutInCacheFtraceEvent&);
  Ext4ExtPutInCacheFtraceEvent& operator=(const Ext4ExtPutInCacheFtraceEvent&);
  bool operator==(const Ext4ExtPutInCacheFtraceEvent&) const;
  bool operator!=(const Ext4ExtPutInCacheFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_start() const { return _has_field_[5]; }
  uint64_t start() const { return start_; }
  void set_start(uint64_t value) { start_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint64_t start_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtMapBlocksExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kMflagsFieldNumber = 7,
    kRetFieldNumber = 8,
  };

  Ext4ExtMapBlocksExitFtraceEvent();
  ~Ext4ExtMapBlocksExitFtraceEvent() override;
  Ext4ExtMapBlocksExitFtraceEvent(Ext4ExtMapBlocksExitFtraceEvent&&) noexcept;
  Ext4ExtMapBlocksExitFtraceEvent& operator=(Ext4ExtMapBlocksExitFtraceEvent&&);
  Ext4ExtMapBlocksExitFtraceEvent(const Ext4ExtMapBlocksExitFtraceEvent&);
  Ext4ExtMapBlocksExitFtraceEvent& operator=(const Ext4ExtMapBlocksExitFtraceEvent&);
  bool operator==(const Ext4ExtMapBlocksExitFtraceEvent&) const;
  bool operator!=(const Ext4ExtMapBlocksExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_pblk() const { return _has_field_[4]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(4); }

  bool has_lblk() const { return _has_field_[5]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(5); }

  bool has_len() const { return _has_field_[6]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(6); }

  bool has_mflags() const { return _has_field_[7]; }
  uint32_t mflags() const { return mflags_; }
  void set_mflags(uint32_t value) { mflags_ = value; _has_field_.set(7); }

  bool has_ret() const { return _has_field_[8]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t flags_{};
  uint64_t pblk_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint32_t mflags_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtMapBlocksEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };

  Ext4ExtMapBlocksEnterFtraceEvent();
  ~Ext4ExtMapBlocksEnterFtraceEvent() override;
  Ext4ExtMapBlocksEnterFtraceEvent(Ext4ExtMapBlocksEnterFtraceEvent&&) noexcept;
  Ext4ExtMapBlocksEnterFtraceEvent& operator=(Ext4ExtMapBlocksEnterFtraceEvent&&);
  Ext4ExtMapBlocksEnterFtraceEvent(const Ext4ExtMapBlocksEnterFtraceEvent&);
  Ext4ExtMapBlocksEnterFtraceEvent& operator=(const Ext4ExtMapBlocksEnterFtraceEvent&);
  bool operator==(const Ext4ExtMapBlocksEnterFtraceEvent&) const;
  bool operator!=(const Ext4ExtMapBlocksEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtLoadExtentFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
    kLblkFieldNumber = 4,
  };

  Ext4ExtLoadExtentFtraceEvent();
  ~Ext4ExtLoadExtentFtraceEvent() override;
  Ext4ExtLoadExtentFtraceEvent(Ext4ExtLoadExtentFtraceEvent&&) noexcept;
  Ext4ExtLoadExtentFtraceEvent& operator=(Ext4ExtLoadExtentFtraceEvent&&);
  Ext4ExtLoadExtentFtraceEvent(const Ext4ExtLoadExtentFtraceEvent&);
  Ext4ExtLoadExtentFtraceEvent& operator=(const Ext4ExtLoadExtentFtraceEvent&);
  bool operator==(const Ext4ExtLoadExtentFtraceEvent&) const;
  bool operator!=(const Ext4ExtLoadExtentFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pblk() const { return _has_field_[3]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(3); }

  bool has_lblk() const { return _has_field_[4]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pblk_{};
  uint32_t lblk_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtInCacheFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kRetFieldNumber = 4,
  };

  Ext4ExtInCacheFtraceEvent();
  ~Ext4ExtInCacheFtraceEvent() override;
  Ext4ExtInCacheFtraceEvent(Ext4ExtInCacheFtraceEvent&&) noexcept;
  Ext4ExtInCacheFtraceEvent& operator=(Ext4ExtInCacheFtraceEvent&&);
  Ext4ExtInCacheFtraceEvent(const Ext4ExtInCacheFtraceEvent&);
  Ext4ExtInCacheFtraceEvent& operator=(const Ext4ExtInCacheFtraceEvent&);
  bool operator==(const Ext4ExtInCacheFtraceEvent&) const;
  bool operator!=(const Ext4ExtInCacheFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_ret() const { return _has_field_[4]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtHandleUnwrittenExtentsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kLblkFieldNumber = 4,
    kPblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kAllocatedFieldNumber = 7,
    kNewblkFieldNumber = 8,
  };

  Ext4ExtHandleUnwrittenExtentsFtraceEvent();
  ~Ext4ExtHandleUnwrittenExtentsFtraceEvent() override;
  Ext4ExtHandleUnwrittenExtentsFtraceEvent(Ext4ExtHandleUnwrittenExtentsFtraceEvent&&) noexcept;
  Ext4ExtHandleUnwrittenExtentsFtraceEvent& operator=(Ext4ExtHandleUnwrittenExtentsFtraceEvent&&);
  Ext4ExtHandleUnwrittenExtentsFtraceEvent(const Ext4ExtHandleUnwrittenExtentsFtraceEvent&);
  Ext4ExtHandleUnwrittenExtentsFtraceEvent& operator=(const Ext4ExtHandleUnwrittenExtentsFtraceEvent&);
  bool operator==(const Ext4ExtHandleUnwrittenExtentsFtraceEvent&) const;
  bool operator!=(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  int32_t flags() const { return flags_; }
  void set_flags(int32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_lblk() const { return _has_field_[4]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(4); }

  bool has_pblk() const { return _has_field_[5]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(5); }

  bool has_len() const { return _has_field_[6]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(6); }

  bool has_allocated() const { return _has_field_[7]; }
  uint32_t allocated() const { return allocated_; }
  void set_allocated(uint32_t value) { allocated_ = value; _has_field_.set(7); }

  bool has_newblk() const { return _has_field_[8]; }
  uint64_t newblk() const { return newblk_; }
  void set_newblk(uint64_t value) { newblk_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t flags_{};
  uint32_t lblk_{};
  uint64_t pblk_{};
  uint32_t len_{};
  uint32_t allocated_{};
  uint64_t newblk_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtConvertToInitializedFastpathFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kMLblkFieldNumber = 3,
    kMLenFieldNumber = 4,
    kULblkFieldNumber = 5,
    kULenFieldNumber = 6,
    kUPblkFieldNumber = 7,
    kILblkFieldNumber = 8,
    kILenFieldNumber = 9,
    kIPblkFieldNumber = 10,
  };

  Ext4ExtConvertToInitializedFastpathFtraceEvent();
  ~Ext4ExtConvertToInitializedFastpathFtraceEvent() override;
  Ext4ExtConvertToInitializedFastpathFtraceEvent(Ext4ExtConvertToInitializedFastpathFtraceEvent&&) noexcept;
  Ext4ExtConvertToInitializedFastpathFtraceEvent& operator=(Ext4ExtConvertToInitializedFastpathFtraceEvent&&);
  Ext4ExtConvertToInitializedFastpathFtraceEvent(const Ext4ExtConvertToInitializedFastpathFtraceEvent&);
  Ext4ExtConvertToInitializedFastpathFtraceEvent& operator=(const Ext4ExtConvertToInitializedFastpathFtraceEvent&);
  bool operator==(const Ext4ExtConvertToInitializedFastpathFtraceEvent&) const;
  bool operator!=(const Ext4ExtConvertToInitializedFastpathFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_m_lblk() const { return _has_field_[3]; }
  uint32_t m_lblk() const { return m_lblk_; }
  void set_m_lblk(uint32_t value) { m_lblk_ = value; _has_field_.set(3); }

  bool has_m_len() const { return _has_field_[4]; }
  uint32_t m_len() const { return m_len_; }
  void set_m_len(uint32_t value) { m_len_ = value; _has_field_.set(4); }

  bool has_u_lblk() const { return _has_field_[5]; }
  uint32_t u_lblk() const { return u_lblk_; }
  void set_u_lblk(uint32_t value) { u_lblk_ = value; _has_field_.set(5); }

  bool has_u_len() const { return _has_field_[6]; }
  uint32_t u_len() const { return u_len_; }
  void set_u_len(uint32_t value) { u_len_ = value; _has_field_.set(6); }

  bool has_u_pblk() const { return _has_field_[7]; }
  uint64_t u_pblk() const { return u_pblk_; }
  void set_u_pblk(uint64_t value) { u_pblk_ = value; _has_field_.set(7); }

  bool has_i_lblk() const { return _has_field_[8]; }
  uint32_t i_lblk() const { return i_lblk_; }
  void set_i_lblk(uint32_t value) { i_lblk_ = value; _has_field_.set(8); }

  bool has_i_len() const { return _has_field_[9]; }
  uint32_t i_len() const { return i_len_; }
  void set_i_len(uint32_t value) { i_len_ = value; _has_field_.set(9); }

  bool has_i_pblk() const { return _has_field_[10]; }
  uint64_t i_pblk() const { return i_pblk_; }
  void set_i_pblk(uint64_t value) { i_pblk_ = value; _has_field_.set(10); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t m_lblk_{};
  uint32_t m_len_{};
  uint32_t u_lblk_{};
  uint32_t u_len_{};
  uint64_t u_pblk_{};
  uint32_t i_lblk_{};
  uint32_t i_len_{};
  uint64_t i_pblk_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT Ext4ExtConvertToInitializedEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kMLblkFieldNumber = 3,
    kMLenFieldNumber = 4,
    kULblkFieldNumber = 5,
    kULenFieldNumber = 6,
    kUPblkFieldNumber = 7,
  };

  Ext4ExtConvertToInitializedEnterFtraceEvent();
  ~Ext4ExtConvertToInitializedEnterFtraceEvent() override;
  Ext4ExtConvertToInitializedEnterFtraceEvent(Ext4ExtConvertToInitializedEnterFtraceEvent&&) noexcept;
  Ext4ExtConvertToInitializedEnterFtraceEvent& operator=(Ext4ExtConvertToInitializedEnterFtraceEvent&&);
  Ext4ExtConvertToInitializedEnterFtraceEvent(const Ext4ExtConvertToInitializedEnterFtraceEvent&);
  Ext4ExtConvertToInitializedEnterFtraceEvent& operator=(const Ext4ExtConvertToInitializedEnterFtraceEvent&);
  bool operator==(const Ext4ExtConvertToInitializedEnterFtraceEvent&) const;
  bool operator!=(const Ext4ExtConvertToInitializedEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_m_lblk() const { return _has_field_[3]; }
  uint32_t m_lblk() const { return m_lblk_; }
  void set_m_lblk(uint32_t value) { m_lblk_ = value; _has_field_.set(3); }

  bool has_m_len() const { return _has_field_[4]; }
  uint32_t m_len() const { return m_len_; }
  void set_m_len(uint32_t value) { m_len_ = value; _has_field_.set(4); }

  bool has_u_lblk() const { return _has_field_[5]; }
  uint32_t u_lblk() const { return u_lblk_; }
  void set_u_lblk(uint32_t value) { u_lblk_ = value; _has_field_.set(5); }

  bool has_u_len() const { return _has_field_[6]; }
  uint32_t u_len() const { return u_len_; }
  void set_u_len(uint32_t value) { u_len_ = value; _has_field_.set(6); }

  bool has_u_pblk() const { return _has_field_[7]; }
  uint64_t u_pblk() const { return u_pblk_; }
  void set_u_pblk(uint64_t value) { u_pblk_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t m_lblk_{};
  uint32_t m_len_{};
  uint32_t u_lblk_{};
  uint32_t u_len_{};
  uint64_t u_pblk_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT Ext4EvictInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNlinkFieldNumber = 3,
  };

  Ext4EvictInodeFtraceEvent();
  ~Ext4EvictInodeFtraceEvent() override;
  Ext4EvictInodeFtraceEvent(Ext4EvictInodeFtraceEvent&&) noexcept;
  Ext4EvictInodeFtraceEvent& operator=(Ext4EvictInodeFtraceEvent&&);
  Ext4EvictInodeFtraceEvent(const Ext4EvictInodeFtraceEvent&);
  Ext4EvictInodeFtraceEvent& operator=(const Ext4EvictInodeFtraceEvent&);
  bool operator==(const Ext4EvictInodeFtraceEvent&) const;
  bool operator!=(const Ext4EvictInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nlink() const { return _has_field_[3]; }
  int32_t nlink() const { return nlink_; }
  void set_nlink(int32_t value) { nlink_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t nlink_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsShrinkScanExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kNrShrunkFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };

  Ext4EsShrinkScanExitFtraceEvent();
  ~Ext4EsShrinkScanExitFtraceEvent() override;
  Ext4EsShrinkScanExitFtraceEvent(Ext4EsShrinkScanExitFtraceEvent&&) noexcept;
  Ext4EsShrinkScanExitFtraceEvent& operator=(Ext4EsShrinkScanExitFtraceEvent&&);
  Ext4EsShrinkScanExitFtraceEvent(const Ext4EsShrinkScanExitFtraceEvent&);
  Ext4EsShrinkScanExitFtraceEvent& operator=(const Ext4EsShrinkScanExitFtraceEvent&);
  bool operator==(const Ext4EsShrinkScanExitFtraceEvent&) const;
  bool operator!=(const Ext4EsShrinkScanExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_nr_shrunk() const { return _has_field_[2]; }
  int32_t nr_shrunk() const { return nr_shrunk_; }
  void set_nr_shrunk(int32_t value) { nr_shrunk_ = value; _has_field_.set(2); }

  bool has_cache_cnt() const { return _has_field_[3]; }
  int32_t cache_cnt() const { return cache_cnt_; }
  void set_cache_cnt(int32_t value) { cache_cnt_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  int32_t nr_shrunk_{};
  int32_t cache_cnt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsShrinkScanEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kNrToScanFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };

  Ext4EsShrinkScanEnterFtraceEvent();
  ~Ext4EsShrinkScanEnterFtraceEvent() override;
  Ext4EsShrinkScanEnterFtraceEvent(Ext4EsShrinkScanEnterFtraceEvent&&) noexcept;
  Ext4EsShrinkScanEnterFtraceEvent& operator=(Ext4EsShrinkScanEnterFtraceEvent&&);
  Ext4EsShrinkScanEnterFtraceEvent(const Ext4EsShrinkScanEnterFtraceEvent&);
  Ext4EsShrinkScanEnterFtraceEvent& operator=(const Ext4EsShrinkScanEnterFtraceEvent&);
  bool operator==(const Ext4EsShrinkScanEnterFtraceEvent&) const;
  bool operator!=(const Ext4EsShrinkScanEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_nr_to_scan() const { return _has_field_[2]; }
  int32_t nr_to_scan() const { return nr_to_scan_; }
  void set_nr_to_scan(int32_t value) { nr_to_scan_ = value; _has_field_.set(2); }

  bool has_cache_cnt() const { return _has_field_[3]; }
  int32_t cache_cnt() const { return cache_cnt_; }
  void set_cache_cnt(int32_t value) { cache_cnt_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  int32_t nr_to_scan_{};
  int32_t cache_cnt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsShrinkCountFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kNrToScanFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };

  Ext4EsShrinkCountFtraceEvent();
  ~Ext4EsShrinkCountFtraceEvent() override;
  Ext4EsShrinkCountFtraceEvent(Ext4EsShrinkCountFtraceEvent&&) noexcept;
  Ext4EsShrinkCountFtraceEvent& operator=(Ext4EsShrinkCountFtraceEvent&&);
  Ext4EsShrinkCountFtraceEvent(const Ext4EsShrinkCountFtraceEvent&);
  Ext4EsShrinkCountFtraceEvent& operator=(const Ext4EsShrinkCountFtraceEvent&);
  bool operator==(const Ext4EsShrinkCountFtraceEvent&) const;
  bool operator!=(const Ext4EsShrinkCountFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_nr_to_scan() const { return _has_field_[2]; }
  int32_t nr_to_scan() const { return nr_to_scan_; }
  void set_nr_to_scan(int32_t value) { nr_to_scan_ = value; _has_field_.set(2); }

  bool has_cache_cnt() const { return _has_field_[3]; }
  int32_t cache_cnt() const { return cache_cnt_; }
  void set_cache_cnt(int32_t value) { cache_cnt_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  int32_t nr_to_scan_{};
  int32_t cache_cnt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsShrinkFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kNrShrunkFieldNumber = 2,
    kScanTimeFieldNumber = 3,
    kNrSkippedFieldNumber = 4,
    kRetriedFieldNumber = 5,
  };

  Ext4EsShrinkFtraceEvent();
  ~Ext4EsShrinkFtraceEvent() override;
  Ext4EsShrinkFtraceEvent(Ext4EsShrinkFtraceEvent&&) noexcept;
  Ext4EsShrinkFtraceEvent& operator=(Ext4EsShrinkFtraceEvent&&);
  Ext4EsShrinkFtraceEvent(const Ext4EsShrinkFtraceEvent&);
  Ext4EsShrinkFtraceEvent& operator=(const Ext4EsShrinkFtraceEvent&);
  bool operator==(const Ext4EsShrinkFtraceEvent&) const;
  bool operator!=(const Ext4EsShrinkFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_nr_shrunk() const { return _has_field_[2]; }
  int32_t nr_shrunk() const { return nr_shrunk_; }
  void set_nr_shrunk(int32_t value) { nr_shrunk_ = value; _has_field_.set(2); }

  bool has_scan_time() const { return _has_field_[3]; }
  uint64_t scan_time() const { return scan_time_; }
  void set_scan_time(uint64_t value) { scan_time_ = value; _has_field_.set(3); }

  bool has_nr_skipped() const { return _has_field_[4]; }
  int32_t nr_skipped() const { return nr_skipped_; }
  void set_nr_skipped(int32_t value) { nr_skipped_ = value; _has_field_.set(4); }

  bool has_retried() const { return _has_field_[5]; }
  int32_t retried() const { return retried_; }
  void set_retried(int32_t value) { retried_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  int32_t nr_shrunk_{};
  uint64_t scan_time_{};
  int32_t nr_skipped_{};
  int32_t retried_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsRemoveExtentFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
  };

  Ext4EsRemoveExtentFtraceEvent();
  ~Ext4EsRemoveExtentFtraceEvent() override;
  Ext4EsRemoveExtentFtraceEvent(Ext4EsRemoveExtentFtraceEvent&&) noexcept;
  Ext4EsRemoveExtentFtraceEvent& operator=(Ext4EsRemoveExtentFtraceEvent&&);
  Ext4EsRemoveExtentFtraceEvent(const Ext4EsRemoveExtentFtraceEvent&);
  Ext4EsRemoveExtentFtraceEvent& operator=(const Ext4EsRemoveExtentFtraceEvent&);
  bool operator==(const Ext4EsRemoveExtentFtraceEvent&) const;
  bool operator!=(const Ext4EsRemoveExtentFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  int64_t lblk() const { return lblk_; }
  void set_lblk(int64_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  int64_t len() const { return len_; }
  void set_len(int64_t value) { len_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t lblk_{};
  int64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsLookupExtentExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
    kFoundFieldNumber = 7,
  };

  Ext4EsLookupExtentExitFtraceEvent();
  ~Ext4EsLookupExtentExitFtraceEvent() override;
  Ext4EsLookupExtentExitFtraceEvent(Ext4EsLookupExtentExitFtraceEvent&&) noexcept;
  Ext4EsLookupExtentExitFtraceEvent& operator=(Ext4EsLookupExtentExitFtraceEvent&&);
  Ext4EsLookupExtentExitFtraceEvent(const Ext4EsLookupExtentExitFtraceEvent&);
  Ext4EsLookupExtentExitFtraceEvent& operator=(const Ext4EsLookupExtentExitFtraceEvent&);
  bool operator==(const Ext4EsLookupExtentExitFtraceEvent&) const;
  bool operator!=(const Ext4EsLookupExtentExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_pblk() const { return _has_field_[5]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(5); }

  bool has_status() const { return _has_field_[6]; }
  uint64_t status() const { return status_; }
  void set_status(uint64_t value) { status_ = value; _has_field_.set(6); }

  bool has_found() const { return _has_field_[7]; }
  int32_t found() const { return found_; }
  void set_found(int32_t value) { found_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint64_t pblk_{};
  uint64_t status_{};
  int32_t found_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsLookupExtentEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
  };

  Ext4EsLookupExtentEnterFtraceEvent();
  ~Ext4EsLookupExtentEnterFtraceEvent() override;
  Ext4EsLookupExtentEnterFtraceEvent(Ext4EsLookupExtentEnterFtraceEvent&&) noexcept;
  Ext4EsLookupExtentEnterFtraceEvent& operator=(Ext4EsLookupExtentEnterFtraceEvent&&);
  Ext4EsLookupExtentEnterFtraceEvent(const Ext4EsLookupExtentEnterFtraceEvent&);
  Ext4EsLookupExtentEnterFtraceEvent& operator=(const Ext4EsLookupExtentEnterFtraceEvent&);
  bool operator==(const Ext4EsLookupExtentEnterFtraceEvent&) const;
  bool operator!=(const Ext4EsLookupExtentEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsInsertExtentFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };

  Ext4EsInsertExtentFtraceEvent();
  ~Ext4EsInsertExtentFtraceEvent() override;
  Ext4EsInsertExtentFtraceEvent(Ext4EsInsertExtentFtraceEvent&&) noexcept;
  Ext4EsInsertExtentFtraceEvent& operator=(Ext4EsInsertExtentFtraceEvent&&);
  Ext4EsInsertExtentFtraceEvent(const Ext4EsInsertExtentFtraceEvent&);
  Ext4EsInsertExtentFtraceEvent& operator=(const Ext4EsInsertExtentFtraceEvent&);
  bool operator==(const Ext4EsInsertExtentFtraceEvent&) const;
  bool operator!=(const Ext4EsInsertExtentFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_pblk() const { return _has_field_[5]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(5); }

  bool has_status() const { return _has_field_[6]; }
  uint64_t status() const { return status_; }
  void set_status(uint64_t value) { status_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint64_t pblk_{};
  uint64_t status_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsFindDelayedExtentRangeExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };

  Ext4EsFindDelayedExtentRangeExitFtraceEvent();
  ~Ext4EsFindDelayedExtentRangeExitFtraceEvent() override;
  Ext4EsFindDelayedExtentRangeExitFtraceEvent(Ext4EsFindDelayedExtentRangeExitFtraceEvent&&) noexcept;
  Ext4EsFindDelayedExtentRangeExitFtraceEvent& operator=(Ext4EsFindDelayedExtentRangeExitFtraceEvent&&);
  Ext4EsFindDelayedExtentRangeExitFtraceEvent(const Ext4EsFindDelayedExtentRangeExitFtraceEvent&);
  Ext4EsFindDelayedExtentRangeExitFtraceEvent& operator=(const Ext4EsFindDelayedExtentRangeExitFtraceEvent&);
  bool operator==(const Ext4EsFindDelayedExtentRangeExitFtraceEvent&) const;
  bool operator!=(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_pblk() const { return _has_field_[5]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(5); }

  bool has_status() const { return _has_field_[6]; }
  uint64_t status() const { return status_; }
  void set_status(uint64_t value) { status_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint64_t pblk_{};
  uint64_t status_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsFindDelayedExtentRangeEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
  };

  Ext4EsFindDelayedExtentRangeEnterFtraceEvent();
  ~Ext4EsFindDelayedExtentRangeEnterFtraceEvent() override;
  Ext4EsFindDelayedExtentRangeEnterFtraceEvent(Ext4EsFindDelayedExtentRangeEnterFtraceEvent&&) noexcept;
  Ext4EsFindDelayedExtentRangeEnterFtraceEvent& operator=(Ext4EsFindDelayedExtentRangeEnterFtraceEvent&&);
  Ext4EsFindDelayedExtentRangeEnterFtraceEvent(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent&);
  Ext4EsFindDelayedExtentRangeEnterFtraceEvent& operator=(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent&);
  bool operator==(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent&) const;
  bool operator!=(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4EsCacheExtentFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };

  Ext4EsCacheExtentFtraceEvent();
  ~Ext4EsCacheExtentFtraceEvent() override;
  Ext4EsCacheExtentFtraceEvent(Ext4EsCacheExtentFtraceEvent&&) noexcept;
  Ext4EsCacheExtentFtraceEvent& operator=(Ext4EsCacheExtentFtraceEvent&&);
  Ext4EsCacheExtentFtraceEvent(const Ext4EsCacheExtentFtraceEvent&);
  Ext4EsCacheExtentFtraceEvent& operator=(const Ext4EsCacheExtentFtraceEvent&);
  bool operator==(const Ext4EsCacheExtentFtraceEvent&) const;
  bool operator!=(const Ext4EsCacheExtentFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint32_t lblk() const { return lblk_; }
  void set_lblk(uint32_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_pblk() const { return _has_field_[5]; }
  uint64_t pblk() const { return pblk_; }
  void set_pblk(uint64_t value) { pblk_ = value; _has_field_.set(5); }

  bool has_status() const { return _has_field_[6]; }
  uint32_t status() const { return status_; }
  void set_status(uint32_t value) { status_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t lblk_{};
  uint32_t len_{};
  uint64_t pblk_{};
  uint32_t status_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4DropInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDropFieldNumber = 3,
  };

  Ext4DropInodeFtraceEvent();
  ~Ext4DropInodeFtraceEvent() override;
  Ext4DropInodeFtraceEvent(Ext4DropInodeFtraceEvent&&) noexcept;
  Ext4DropInodeFtraceEvent& operator=(Ext4DropInodeFtraceEvent&&);
  Ext4DropInodeFtraceEvent(const Ext4DropInodeFtraceEvent&);
  Ext4DropInodeFtraceEvent& operator=(const Ext4DropInodeFtraceEvent&);
  bool operator==(const Ext4DropInodeFtraceEvent&) const;
  bool operator!=(const Ext4DropInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_drop() const { return _has_field_[3]; }
  int32_t drop() const { return drop_; }
  void set_drop(int32_t value) { drop_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t drop_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4DiscardPreallocationsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
  };

  Ext4DiscardPreallocationsFtraceEvent();
  ~Ext4DiscardPreallocationsFtraceEvent() override;
  Ext4DiscardPreallocationsFtraceEvent(Ext4DiscardPreallocationsFtraceEvent&&) noexcept;
  Ext4DiscardPreallocationsFtraceEvent& operator=(Ext4DiscardPreallocationsFtraceEvent&&);
  Ext4DiscardPreallocationsFtraceEvent(const Ext4DiscardPreallocationsFtraceEvent&);
  Ext4DiscardPreallocationsFtraceEvent& operator=(const Ext4DiscardPreallocationsFtraceEvent&);
  bool operator==(const Ext4DiscardPreallocationsFtraceEvent&) const;
  bool operator!=(const Ext4DiscardPreallocationsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT Ext4DiscardBlocksFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kBlkFieldNumber = 2,
    kCountFieldNumber = 3,
  };

  Ext4DiscardBlocksFtraceEvent();
  ~Ext4DiscardBlocksFtraceEvent() override;
  Ext4DiscardBlocksFtraceEvent(Ext4DiscardBlocksFtraceEvent&&) noexcept;
  Ext4DiscardBlocksFtraceEvent& operator=(Ext4DiscardBlocksFtraceEvent&&);
  Ext4DiscardBlocksFtraceEvent(const Ext4DiscardBlocksFtraceEvent&);
  Ext4DiscardBlocksFtraceEvent& operator=(const Ext4DiscardBlocksFtraceEvent&);
  bool operator==(const Ext4DiscardBlocksFtraceEvent&) const;
  bool operator!=(const Ext4DiscardBlocksFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_blk() const { return _has_field_[2]; }
  uint64_t blk() const { return blk_; }
  void set_blk(uint64_t value) { blk_ = value; _has_field_.set(2); }

  bool has_count() const { return _has_field_[3]; }
  uint64_t count() const { return count_; }
  void set_count(uint64_t value) { count_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t blk_{};
  uint64_t count_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4DirectIOExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kRwFieldNumber = 5,
    kRetFieldNumber = 6,
  };

  Ext4DirectIOExitFtraceEvent();
  ~Ext4DirectIOExitFtraceEvent() override;
  Ext4DirectIOExitFtraceEvent(Ext4DirectIOExitFtraceEvent&&) noexcept;
  Ext4DirectIOExitFtraceEvent& operator=(Ext4DirectIOExitFtraceEvent&&);
  Ext4DirectIOExitFtraceEvent(const Ext4DirectIOExitFtraceEvent&);
  Ext4DirectIOExitFtraceEvent& operator=(const Ext4DirectIOExitFtraceEvent&);
  bool operator==(const Ext4DirectIOExitFtraceEvent&) const;
  bool operator!=(const Ext4DirectIOExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(4); }

  bool has_rw() const { return _has_field_[5]; }
  int32_t rw() const { return rw_; }
  void set_rw(int32_t value) { rw_ = value; _has_field_.set(5); }

  bool has_ret() const { return _has_field_[6]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint64_t len_{};
  int32_t rw_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT Ext4DirectIOEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kRwFieldNumber = 5,
  };

  Ext4DirectIOEnterFtraceEvent();
  ~Ext4DirectIOEnterFtraceEvent() override;
  Ext4DirectIOEnterFtraceEvent(Ext4DirectIOEnterFtraceEvent&&) noexcept;
  Ext4DirectIOEnterFtraceEvent& operator=(Ext4DirectIOEnterFtraceEvent&&);
  Ext4DirectIOEnterFtraceEvent(const Ext4DirectIOEnterFtraceEvent&);
  Ext4DirectIOEnterFtraceEvent& operator=(const Ext4DirectIOEnterFtraceEvent&);
  bool operator==(const Ext4DirectIOEnterFtraceEvent&) const;
  bool operator!=(const Ext4DirectIOEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint64_t len() const { return len_; }
  void set_len(uint64_t value) { len_ = value; _has_field_.set(4); }

  bool has_rw() const { return _has_field_[5]; }
  int32_t rw() const { return rw_; }
  void set_rw(int32_t value) { rw_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint64_t len_{};
  int32_t rw_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4DaWritePagesExtentFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };

  Ext4DaWritePagesExtentFtraceEvent();
  ~Ext4DaWritePagesExtentFtraceEvent() override;
  Ext4DaWritePagesExtentFtraceEvent(Ext4DaWritePagesExtentFtraceEvent&&) noexcept;
  Ext4DaWritePagesExtentFtraceEvent& operator=(Ext4DaWritePagesExtentFtraceEvent&&);
  Ext4DaWritePagesExtentFtraceEvent(const Ext4DaWritePagesExtentFtraceEvent&);
  Ext4DaWritePagesExtentFtraceEvent& operator=(const Ext4DaWritePagesExtentFtraceEvent&);
  bool operator==(const Ext4DaWritePagesExtentFtraceEvent&) const;
  bool operator!=(const Ext4DaWritePagesExtentFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_lblk() const { return _has_field_[3]; }
  uint64_t lblk() const { return lblk_; }
  void set_lblk(uint64_t value) { lblk_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t lblk_{};
  uint32_t len_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4DaWritePagesFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFirstPageFieldNumber = 3,
    kNrToWriteFieldNumber = 4,
    kSyncModeFieldNumber = 5,
    kBBlocknrFieldNumber = 6,
    kBSizeFieldNumber = 7,
    kBStateFieldNumber = 8,
    kIoDoneFieldNumber = 9,
    kPagesWrittenFieldNumber = 10,
  };

  Ext4DaWritePagesFtraceEvent();
  ~Ext4DaWritePagesFtraceEvent() override;
  Ext4DaWritePagesFtraceEvent(Ext4DaWritePagesFtraceEvent&&) noexcept;
  Ext4DaWritePagesFtraceEvent& operator=(Ext4DaWritePagesFtraceEvent&&);
  Ext4DaWritePagesFtraceEvent(const Ext4DaWritePagesFtraceEvent&);
  Ext4DaWritePagesFtraceEvent& operator=(const Ext4DaWritePagesFtraceEvent&);
  bool operator==(const Ext4DaWritePagesFtraceEvent&) const;
  bool operator!=(const Ext4DaWritePagesFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_first_page() const { return _has_field_[3]; }
  uint64_t first_page() const { return first_page_; }
  void set_first_page(uint64_t value) { first_page_ = value; _has_field_.set(3); }

  bool has_nr_to_write() const { return _has_field_[4]; }
  int64_t nr_to_write() const { return nr_to_write_; }
  void set_nr_to_write(int64_t value) { nr_to_write_ = value; _has_field_.set(4); }

  bool has_sync_mode() const { return _has_field_[5]; }
  int32_t sync_mode() const { return sync_mode_; }
  void set_sync_mode(int32_t value) { sync_mode_ = value; _has_field_.set(5); }

  bool has_b_blocknr() const { return _has_field_[6]; }
  uint64_t b_blocknr() const { return b_blocknr_; }
  void set_b_blocknr(uint64_t value) { b_blocknr_ = value; _has_field_.set(6); }

  bool has_b_size() const { return _has_field_[7]; }
  uint32_t b_size() const { return b_size_; }
  void set_b_size(uint32_t value) { b_size_ = value; _has_field_.set(7); }

  bool has_b_state() const { return _has_field_[8]; }
  uint32_t b_state() const { return b_state_; }
  void set_b_state(uint32_t value) { b_state_ = value; _has_field_.set(8); }

  bool has_io_done() const { return _has_field_[9]; }
  int32_t io_done() const { return io_done_; }
  void set_io_done(int32_t value) { io_done_ = value; _has_field_.set(9); }

  bool has_pages_written() const { return _has_field_[10]; }
  int32_t pages_written() const { return pages_written_; }
  void set_pages_written(int32_t value) { pages_written_ = value; _has_field_.set(10); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t first_page_{};
  int64_t nr_to_write_{};
  int32_t sync_mode_{};
  uint64_t b_blocknr_{};
  uint32_t b_size_{};
  uint32_t b_state_{};
  int32_t io_done_{};
  int32_t pages_written_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT Ext4DaUpdateReserveSpaceFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kUsedBlocksFieldNumber = 4,
    kReservedDataBlocksFieldNumber = 5,
    kReservedMetaBlocksFieldNumber = 6,
    kAllocatedMetaBlocksFieldNumber = 7,
    kQuotaClaimFieldNumber = 8,
    kModeFieldNumber = 9,
  };

  Ext4DaUpdateReserveSpaceFtraceEvent();
  ~Ext4DaUpdateReserveSpaceFtraceEvent() override;
  Ext4DaUpdateReserveSpaceFtraceEvent(Ext4DaUpdateReserveSpaceFtraceEvent&&) noexcept;
  Ext4DaUpdateReserveSpaceFtraceEvent& operator=(Ext4DaUpdateReserveSpaceFtraceEvent&&);
  Ext4DaUpdateReserveSpaceFtraceEvent(const Ext4DaUpdateReserveSpaceFtraceEvent&);
  Ext4DaUpdateReserveSpaceFtraceEvent& operator=(const Ext4DaUpdateReserveSpaceFtraceEvent&);
  bool operator==(const Ext4DaUpdateReserveSpaceFtraceEvent&) const;
  bool operator!=(const Ext4DaUpdateReserveSpaceFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_i_blocks() const { return _has_field_[3]; }
  uint64_t i_blocks() const { return i_blocks_; }
  void set_i_blocks(uint64_t value) { i_blocks_ = value; _has_field_.set(3); }

  bool has_used_blocks() const { return _has_field_[4]; }
  int32_t used_blocks() const { return used_blocks_; }
  void set_used_blocks(int32_t value) { used_blocks_ = value; _has_field_.set(4); }

  bool has_reserved_data_blocks() const { return _has_field_[5]; }
  int32_t reserved_data_blocks() const { return reserved_data_blocks_; }
  void set_reserved_data_blocks(int32_t value) { reserved_data_blocks_ = value; _has_field_.set(5); }

  bool has_reserved_meta_blocks() const { return _has_field_[6]; }
  int32_t reserved_meta_blocks() const { return reserved_meta_blocks_; }
  void set_reserved_meta_blocks(int32_t value) { reserved_meta_blocks_ = value; _has_field_.set(6); }

  bool has_allocated_meta_blocks() const { return _has_field_[7]; }
  int32_t allocated_meta_blocks() const { return allocated_meta_blocks_; }
  void set_allocated_meta_blocks(int32_t value) { allocated_meta_blocks_ = value; _has_field_.set(7); }

  bool has_quota_claim() const { return _has_field_[8]; }
  int32_t quota_claim() const { return quota_claim_; }
  void set_quota_claim(int32_t value) { quota_claim_ = value; _has_field_.set(8); }

  bool has_mode() const { return _has_field_[9]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(9); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t i_blocks_{};
  int32_t used_blocks_{};
  int32_t reserved_data_blocks_{};
  int32_t reserved_meta_blocks_{};
  int32_t allocated_meta_blocks_{};
  int32_t quota_claim_{};
  uint32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};


class PERFETTO_EXPORT Ext4DaReserveSpaceFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kReservedDataBlocksFieldNumber = 4,
    kReservedMetaBlocksFieldNumber = 5,
    kModeFieldNumber = 6,
    kMdNeededFieldNumber = 7,
  };

  Ext4DaReserveSpaceFtraceEvent();
  ~Ext4DaReserveSpaceFtraceEvent() override;
  Ext4DaReserveSpaceFtraceEvent(Ext4DaReserveSpaceFtraceEvent&&) noexcept;
  Ext4DaReserveSpaceFtraceEvent& operator=(Ext4DaReserveSpaceFtraceEvent&&);
  Ext4DaReserveSpaceFtraceEvent(const Ext4DaReserveSpaceFtraceEvent&);
  Ext4DaReserveSpaceFtraceEvent& operator=(const Ext4DaReserveSpaceFtraceEvent&);
  bool operator==(const Ext4DaReserveSpaceFtraceEvent&) const;
  bool operator!=(const Ext4DaReserveSpaceFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_i_blocks() const { return _has_field_[3]; }
  uint64_t i_blocks() const { return i_blocks_; }
  void set_i_blocks(uint64_t value) { i_blocks_ = value; _has_field_.set(3); }

  bool has_reserved_data_blocks() const { return _has_field_[4]; }
  int32_t reserved_data_blocks() const { return reserved_data_blocks_; }
  void set_reserved_data_blocks(int32_t value) { reserved_data_blocks_ = value; _has_field_.set(4); }

  bool has_reserved_meta_blocks() const { return _has_field_[5]; }
  int32_t reserved_meta_blocks() const { return reserved_meta_blocks_; }
  void set_reserved_meta_blocks(int32_t value) { reserved_meta_blocks_ = value; _has_field_.set(5); }

  bool has_mode() const { return _has_field_[6]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(6); }

  bool has_md_needed() const { return _has_field_[7]; }
  int32_t md_needed() const { return md_needed_; }
  void set_md_needed(int32_t value) { md_needed_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t i_blocks_{};
  int32_t reserved_data_blocks_{};
  int32_t reserved_meta_blocks_{};
  uint32_t mode_{};
  int32_t md_needed_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT Ext4DaReleaseSpaceFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kFreedBlocksFieldNumber = 4,
    kReservedDataBlocksFieldNumber = 5,
    kReservedMetaBlocksFieldNumber = 6,
    kAllocatedMetaBlocksFieldNumber = 7,
    kModeFieldNumber = 8,
  };

  Ext4DaReleaseSpaceFtraceEvent();
  ~Ext4DaReleaseSpaceFtraceEvent() override;
  Ext4DaReleaseSpaceFtraceEvent(Ext4DaReleaseSpaceFtraceEvent&&) noexcept;
  Ext4DaReleaseSpaceFtraceEvent& operator=(Ext4DaReleaseSpaceFtraceEvent&&);
  Ext4DaReleaseSpaceFtraceEvent(const Ext4DaReleaseSpaceFtraceEvent&);
  Ext4DaReleaseSpaceFtraceEvent& operator=(const Ext4DaReleaseSpaceFtraceEvent&);
  bool operator==(const Ext4DaReleaseSpaceFtraceEvent&) const;
  bool operator!=(const Ext4DaReleaseSpaceFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_i_blocks() const { return _has_field_[3]; }
  uint64_t i_blocks() const { return i_blocks_; }
  void set_i_blocks(uint64_t value) { i_blocks_ = value; _has_field_.set(3); }

  bool has_freed_blocks() const { return _has_field_[4]; }
  int32_t freed_blocks() const { return freed_blocks_; }
  void set_freed_blocks(int32_t value) { freed_blocks_ = value; _has_field_.set(4); }

  bool has_reserved_data_blocks() const { return _has_field_[5]; }
  int32_t reserved_data_blocks() const { return reserved_data_blocks_; }
  void set_reserved_data_blocks(int32_t value) { reserved_data_blocks_ = value; _has_field_.set(5); }

  bool has_reserved_meta_blocks() const { return _has_field_[6]; }
  int32_t reserved_meta_blocks() const { return reserved_meta_blocks_; }
  void set_reserved_meta_blocks(int32_t value) { reserved_meta_blocks_ = value; _has_field_.set(6); }

  bool has_allocated_meta_blocks() const { return _has_field_[7]; }
  int32_t allocated_meta_blocks() const { return allocated_meta_blocks_; }
  void set_allocated_meta_blocks(int32_t value) { allocated_meta_blocks_ = value; _has_field_.set(7); }

  bool has_mode() const { return _has_field_[8]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t i_blocks_{};
  int32_t freed_blocks_{};
  int32_t reserved_data_blocks_{};
  int32_t reserved_meta_blocks_{};
  int32_t allocated_meta_blocks_{};
  uint32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT Ext4CollapseRangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
  };

  Ext4CollapseRangeFtraceEvent();
  ~Ext4CollapseRangeFtraceEvent() override;
  Ext4CollapseRangeFtraceEvent(Ext4CollapseRangeFtraceEvent&&) noexcept;
  Ext4CollapseRangeFtraceEvent& operator=(Ext4CollapseRangeFtraceEvent&&);
  Ext4CollapseRangeFtraceEvent(const Ext4CollapseRangeFtraceEvent&);
  Ext4CollapseRangeFtraceEvent& operator=(const Ext4CollapseRangeFtraceEvent&);
  bool operator==(const Ext4CollapseRangeFtraceEvent&) const;
  bool operator!=(const Ext4CollapseRangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_offset() const { return _has_field_[3]; }
  int64_t offset() const { return offset_; }
  void set_offset(int64_t value) { offset_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  int64_t len() const { return len_; }
  void set_len(int64_t value) { len_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t offset_{};
  int64_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4BeginOrderedTruncateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNewSizeFieldNumber = 3,
  };

  Ext4BeginOrderedTruncateFtraceEvent();
  ~Ext4BeginOrderedTruncateFtraceEvent() override;
  Ext4BeginOrderedTruncateFtraceEvent(Ext4BeginOrderedTruncateFtraceEvent&&) noexcept;
  Ext4BeginOrderedTruncateFtraceEvent& operator=(Ext4BeginOrderedTruncateFtraceEvent&&);
  Ext4BeginOrderedTruncateFtraceEvent(const Ext4BeginOrderedTruncateFtraceEvent&);
  Ext4BeginOrderedTruncateFtraceEvent& operator=(const Ext4BeginOrderedTruncateFtraceEvent&);
  bool operator==(const Ext4BeginOrderedTruncateFtraceEvent&) const;
  bool operator!=(const Ext4BeginOrderedTruncateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_new_size() const { return _has_field_[3]; }
  int64_t new_size() const { return new_size_; }
  void set_new_size(int64_t value) { new_size_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t new_size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4AllocateInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDirFieldNumber = 3,
    kModeFieldNumber = 4,
  };

  Ext4AllocateInodeFtraceEvent();
  ~Ext4AllocateInodeFtraceEvent() override;
  Ext4AllocateInodeFtraceEvent(Ext4AllocateInodeFtraceEvent&&) noexcept;
  Ext4AllocateInodeFtraceEvent& operator=(Ext4AllocateInodeFtraceEvent&&);
  Ext4AllocateInodeFtraceEvent(const Ext4AllocateInodeFtraceEvent&);
  Ext4AllocateInodeFtraceEvent& operator=(const Ext4AllocateInodeFtraceEvent&);
  bool operator==(const Ext4AllocateInodeFtraceEvent&) const;
  bool operator!=(const Ext4AllocateInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_dir() const { return _has_field_[3]; }
  uint64_t dir() const { return dir_; }
  void set_dir(uint64_t value) { dir_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t dir_{};
  uint32_t mode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4AllocateBlocksFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kLenFieldNumber = 4,
    kLogicalFieldNumber = 5,
    kLleftFieldNumber = 6,
    kLrightFieldNumber = 7,
    kGoalFieldNumber = 8,
    kPleftFieldNumber = 9,
    kPrightFieldNumber = 10,
    kFlagsFieldNumber = 11,
  };

  Ext4AllocateBlocksFtraceEvent();
  ~Ext4AllocateBlocksFtraceEvent() override;
  Ext4AllocateBlocksFtraceEvent(Ext4AllocateBlocksFtraceEvent&&) noexcept;
  Ext4AllocateBlocksFtraceEvent& operator=(Ext4AllocateBlocksFtraceEvent&&);
  Ext4AllocateBlocksFtraceEvent(const Ext4AllocateBlocksFtraceEvent&);
  Ext4AllocateBlocksFtraceEvent& operator=(const Ext4AllocateBlocksFtraceEvent&);
  bool operator==(const Ext4AllocateBlocksFtraceEvent&) const;
  bool operator!=(const Ext4AllocateBlocksFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_block() const { return _has_field_[3]; }
  uint64_t block() const { return block_; }
  void set_block(uint64_t value) { block_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_logical() const { return _has_field_[5]; }
  uint32_t logical() const { return logical_; }
  void set_logical(uint32_t value) { logical_ = value; _has_field_.set(5); }

  bool has_lleft() const { return _has_field_[6]; }
  uint32_t lleft() const { return lleft_; }
  void set_lleft(uint32_t value) { lleft_ = value; _has_field_.set(6); }

  bool has_lright() const { return _has_field_[7]; }
  uint32_t lright() const { return lright_; }
  void set_lright(uint32_t value) { lright_ = value; _has_field_.set(7); }

  bool has_goal() const { return _has_field_[8]; }
  uint64_t goal() const { return goal_; }
  void set_goal(uint64_t value) { goal_ = value; _has_field_.set(8); }

  bool has_pleft() const { return _has_field_[9]; }
  uint64_t pleft() const { return pleft_; }
  void set_pleft(uint64_t value) { pleft_ = value; _has_field_.set(9); }

  bool has_pright() const { return _has_field_[10]; }
  uint64_t pright() const { return pright_; }
  void set_pright(uint64_t value) { pright_ = value; _has_field_.set(10); }

  bool has_flags() const { return _has_field_[11]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(11); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t block_{};
  uint32_t len_{};
  uint32_t logical_{};
  uint32_t lleft_{};
  uint32_t lright_{};
  uint64_t goal_{};
  uint64_t pleft_{};
  uint64_t pright_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<12> _has_field_{};
};


class PERFETTO_EXPORT Ext4AllocDaBlocksFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDataBlocksFieldNumber = 3,
    kMetaBlocksFieldNumber = 4,
  };

  Ext4AllocDaBlocksFtraceEvent();
  ~Ext4AllocDaBlocksFtraceEvent() override;
  Ext4AllocDaBlocksFtraceEvent(Ext4AllocDaBlocksFtraceEvent&&) noexcept;
  Ext4AllocDaBlocksFtraceEvent& operator=(Ext4AllocDaBlocksFtraceEvent&&);
  Ext4AllocDaBlocksFtraceEvent(const Ext4AllocDaBlocksFtraceEvent&);
  Ext4AllocDaBlocksFtraceEvent& operator=(const Ext4AllocDaBlocksFtraceEvent&);
  bool operator==(const Ext4AllocDaBlocksFtraceEvent&) const;
  bool operator!=(const Ext4AllocDaBlocksFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_data_blocks() const { return _has_field_[3]; }
  uint32_t data_blocks() const { return data_blocks_; }
  void set_data_blocks(uint32_t value) { data_blocks_ = value; _has_field_.set(3); }

  bool has_meta_blocks() const { return _has_field_[4]; }
  uint32_t meta_blocks() const { return meta_blocks_; }
  void set_meta_blocks(uint32_t value) { meta_blocks_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t data_blocks_{};
  uint32_t meta_blocks_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4SyncFileExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  Ext4SyncFileExitFtraceEvent();
  ~Ext4SyncFileExitFtraceEvent() override;
  Ext4SyncFileExitFtraceEvent(Ext4SyncFileExitFtraceEvent&&) noexcept;
  Ext4SyncFileExitFtraceEvent& operator=(Ext4SyncFileExitFtraceEvent&&);
  Ext4SyncFileExitFtraceEvent(const Ext4SyncFileExitFtraceEvent&);
  Ext4SyncFileExitFtraceEvent& operator=(const Ext4SyncFileExitFtraceEvent&);
  bool operator==(const Ext4SyncFileExitFtraceEvent&) const;
  bool operator!=(const Ext4SyncFileExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT Ext4SyncFileEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kParentFieldNumber = 3,
    kDatasyncFieldNumber = 4,
  };

  Ext4SyncFileEnterFtraceEvent();
  ~Ext4SyncFileEnterFtraceEvent() override;
  Ext4SyncFileEnterFtraceEvent(Ext4SyncFileEnterFtraceEvent&&) noexcept;
  Ext4SyncFileEnterFtraceEvent& operator=(Ext4SyncFileEnterFtraceEvent&&);
  Ext4SyncFileEnterFtraceEvent(const Ext4SyncFileEnterFtraceEvent&);
  Ext4SyncFileEnterFtraceEvent& operator=(const Ext4SyncFileEnterFtraceEvent&);
  bool operator==(const Ext4SyncFileEnterFtraceEvent&) const;
  bool operator!=(const Ext4SyncFileEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_parent() const { return _has_field_[3]; }
  uint64_t parent() const { return parent_; }
  void set_parent(uint64_t value) { parent_ = value; _has_field_.set(3); }

  bool has_datasync() const { return _has_field_[4]; }
  int32_t datasync() const { return datasync_; }
  void set_datasync(int32_t value) { datasync_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t parent_{};
  int32_t datasync_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT Ext4DaWriteEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };

  Ext4DaWriteEndFtraceEvent();
  ~Ext4DaWriteEndFtraceEvent() override;
  Ext4DaWriteEndFtraceEvent(Ext4DaWriteEndFtraceEvent&&) noexcept;
  Ext4DaWriteEndFtraceEvent& operator=(Ext4DaWriteEndFtraceEvent&&);
  Ext4DaWriteEndFtraceEvent(const Ext4DaWriteEndFtraceEvent&);
  Ext4DaWriteEndFtraceEvent& operator=(const Ext4DaWriteEndFtraceEvent&);
  bool operator==(const Ext4DaWriteEndFtraceEvent&) const;
  bool operator!=(const Ext4DaWriteEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_copied() const { return _has_field_[5]; }
  uint32_t copied() const { return copied_; }
  void set_copied(uint32_t value) { copied_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t copied_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT Ext4DaWriteBeginFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };

  Ext4DaWriteBeginFtraceEvent();
  ~Ext4DaWriteBeginFtraceEvent() override;
  Ext4DaWriteBeginFtraceEvent(Ext4DaWriteBeginFtraceEvent&&) noexcept;
  Ext4DaWriteBeginFtraceEvent& operator=(Ext4DaWriteBeginFtraceEvent&&);
  Ext4DaWriteBeginFtraceEvent(const Ext4DaWriteBeginFtraceEvent&);
  Ext4DaWriteBeginFtraceEvent& operator=(const Ext4DaWriteBeginFtraceEvent&);
  bool operator==(const Ext4DaWriteBeginFtraceEvent&) const;
  bool operator!=(const Ext4DaWriteBeginFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_CPP_H_
