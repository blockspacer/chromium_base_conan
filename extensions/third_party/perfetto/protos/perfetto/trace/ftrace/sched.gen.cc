#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/sched.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent() = default;
SchedProcessWaitFtraceEvent::~SchedProcessWaitFtraceEvent() = default;
SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent&) = default;
SchedProcessWaitFtraceEvent& SchedProcessWaitFtraceEvent::operator=(const SchedProcessWaitFtraceEvent&) = default;
SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(SchedProcessWaitFtraceEvent&&) noexcept = default;
SchedProcessWaitFtraceEvent& SchedProcessWaitFtraceEvent::operator=(SchedProcessWaitFtraceEvent&&) = default;

bool SchedProcessWaitFtraceEvent::operator==(const SchedProcessWaitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && comm_ == other.comm_
   && pid_ == other.pid_
   && prio_ == other.prio_;
}

bool SchedProcessWaitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        field.get(&comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessWaitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessWaitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessWaitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    msg->AppendString(1, comm_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    msg->AppendVarInt(3, prio_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent() = default;
SchedProcessHangFtraceEvent::~SchedProcessHangFtraceEvent() = default;
SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent&) = default;
SchedProcessHangFtraceEvent& SchedProcessHangFtraceEvent::operator=(const SchedProcessHangFtraceEvent&) = default;
SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(SchedProcessHangFtraceEvent&&) noexcept = default;
SchedProcessHangFtraceEvent& SchedProcessHangFtraceEvent::operator=(SchedProcessHangFtraceEvent&&) = default;

bool SchedProcessHangFtraceEvent::operator==(const SchedProcessHangFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && comm_ == other.comm_
   && pid_ == other.pid_;
}

bool SchedProcessHangFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        field.get(&comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessHangFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessHangFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessHangFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    msg->AppendString(1, comm_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent() = default;
SchedProcessFreeFtraceEvent::~SchedProcessFreeFtraceEvent() = default;
SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent&) = default;
SchedProcessFreeFtraceEvent& SchedProcessFreeFtraceEvent::operator=(const SchedProcessFreeFtraceEvent&) = default;
SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(SchedProcessFreeFtraceEvent&&) noexcept = default;
SchedProcessFreeFtraceEvent& SchedProcessFreeFtraceEvent::operator=(SchedProcessFreeFtraceEvent&&) = default;

bool SchedProcessFreeFtraceEvent::operator==(const SchedProcessFreeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && comm_ == other.comm_
   && pid_ == other.pid_
   && prio_ == other.prio_;
}

bool SchedProcessFreeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        field.get(&comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessFreeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessFreeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessFreeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    msg->AppendString(1, comm_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    msg->AppendVarInt(3, prio_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent() = default;
SchedProcessForkFtraceEvent::~SchedProcessForkFtraceEvent() = default;
SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent&) = default;
SchedProcessForkFtraceEvent& SchedProcessForkFtraceEvent::operator=(const SchedProcessForkFtraceEvent&) = default;
SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(SchedProcessForkFtraceEvent&&) noexcept = default;
SchedProcessForkFtraceEvent& SchedProcessForkFtraceEvent::operator=(SchedProcessForkFtraceEvent&&) = default;

bool SchedProcessForkFtraceEvent::operator==(const SchedProcessForkFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && parent_comm_ == other.parent_comm_
   && parent_pid_ == other.parent_pid_
   && child_comm_ == other.child_comm_
   && child_pid_ == other.child_pid_;
}

bool SchedProcessForkFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* parent_comm */:
        field.get(&parent_comm_);
        break;
      case 2 /* parent_pid */:
        field.get(&parent_pid_);
        break;
      case 3 /* child_comm */:
        field.get(&child_comm_);
        break;
      case 4 /* child_pid */:
        field.get(&child_pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessForkFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessForkFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessForkFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: parent_comm
  if (_has_field_[1]) {
    msg->AppendString(1, parent_comm_);
  }

  // Field 2: parent_pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, parent_pid_);
  }

  // Field 3: child_comm
  if (_has_field_[3]) {
    msg->AppendString(3, child_comm_);
  }

  // Field 4: child_pid
  if (_has_field_[4]) {
    msg->AppendVarInt(4, child_pid_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent() = default;
SchedProcessExitFtraceEvent::~SchedProcessExitFtraceEvent() = default;
SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent&) = default;
SchedProcessExitFtraceEvent& SchedProcessExitFtraceEvent::operator=(const SchedProcessExitFtraceEvent&) = default;
SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(SchedProcessExitFtraceEvent&&) noexcept = default;
SchedProcessExitFtraceEvent& SchedProcessExitFtraceEvent::operator=(SchedProcessExitFtraceEvent&&) = default;

bool SchedProcessExitFtraceEvent::operator==(const SchedProcessExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && comm_ == other.comm_
   && pid_ == other.pid_
   && tgid_ == other.tgid_
   && prio_ == other.prio_;
}

bool SchedProcessExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        field.get(&comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* tgid */:
        field.get(&tgid_);
        break;
      case 4 /* prio */:
        field.get(&prio_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    msg->AppendString(1, comm_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  // Field 3: tgid
  if (_has_field_[3]) {
    msg->AppendVarInt(3, tgid_);
  }

  // Field 4: prio
  if (_has_field_[4]) {
    msg->AppendVarInt(4, prio_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent() = default;
SchedProcessExecFtraceEvent::~SchedProcessExecFtraceEvent() = default;
SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent&) = default;
SchedProcessExecFtraceEvent& SchedProcessExecFtraceEvent::operator=(const SchedProcessExecFtraceEvent&) = default;
SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(SchedProcessExecFtraceEvent&&) noexcept = default;
SchedProcessExecFtraceEvent& SchedProcessExecFtraceEvent::operator=(SchedProcessExecFtraceEvent&&) = default;

bool SchedProcessExecFtraceEvent::operator==(const SchedProcessExecFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && filename_ == other.filename_
   && pid_ == other.pid_
   && old_pid_ == other.old_pid_;
}

bool SchedProcessExecFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* filename */:
        field.get(&filename_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* old_pid */:
        field.get(&old_pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessExecFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessExecFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessExecFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: filename
  if (_has_field_[1]) {
    msg->AppendString(1, filename_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  // Field 3: old_pid
  if (_has_field_[3]) {
    msg->AppendVarInt(3, old_pid_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent() = default;
SchedWakeupNewFtraceEvent::~SchedWakeupNewFtraceEvent() = default;
SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent&) = default;
SchedWakeupNewFtraceEvent& SchedWakeupNewFtraceEvent::operator=(const SchedWakeupNewFtraceEvent&) = default;
SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(SchedWakeupNewFtraceEvent&&) noexcept = default;
SchedWakeupNewFtraceEvent& SchedWakeupNewFtraceEvent::operator=(SchedWakeupNewFtraceEvent&&) = default;

bool SchedWakeupNewFtraceEvent::operator==(const SchedWakeupNewFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && comm_ == other.comm_
   && pid_ == other.pid_
   && prio_ == other.prio_
   && success_ == other.success_
   && target_cpu_ == other.target_cpu_;
}

bool SchedWakeupNewFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        field.get(&comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      case 4 /* success */:
        field.get(&success_);
        break;
      case 5 /* target_cpu */:
        field.get(&target_cpu_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedWakeupNewFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedWakeupNewFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedWakeupNewFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    msg->AppendString(1, comm_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    msg->AppendVarInt(3, prio_);
  }

  // Field 4: success
  if (_has_field_[4]) {
    msg->AppendVarInt(4, success_);
  }

  // Field 5: target_cpu
  if (_has_field_[5]) {
    msg->AppendVarInt(5, target_cpu_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedWakingFtraceEvent::SchedWakingFtraceEvent() = default;
SchedWakingFtraceEvent::~SchedWakingFtraceEvent() = default;
SchedWakingFtraceEvent::SchedWakingFtraceEvent(const SchedWakingFtraceEvent&) = default;
SchedWakingFtraceEvent& SchedWakingFtraceEvent::operator=(const SchedWakingFtraceEvent&) = default;
SchedWakingFtraceEvent::SchedWakingFtraceEvent(SchedWakingFtraceEvent&&) noexcept = default;
SchedWakingFtraceEvent& SchedWakingFtraceEvent::operator=(SchedWakingFtraceEvent&&) = default;

bool SchedWakingFtraceEvent::operator==(const SchedWakingFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && comm_ == other.comm_
   && pid_ == other.pid_
   && prio_ == other.prio_
   && success_ == other.success_
   && target_cpu_ == other.target_cpu_;
}

bool SchedWakingFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        field.get(&comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      case 4 /* success */:
        field.get(&success_);
        break;
      case 5 /* target_cpu */:
        field.get(&target_cpu_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedWakingFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedWakingFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedWakingFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    msg->AppendString(1, comm_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    msg->AppendVarInt(3, prio_);
  }

  // Field 4: success
  if (_has_field_[4]) {
    msg->AppendVarInt(4, success_);
  }

  // Field 5: target_cpu
  if (_has_field_[5]) {
    msg->AppendVarInt(5, target_cpu_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent() = default;
SchedCpuHotplugFtraceEvent::~SchedCpuHotplugFtraceEvent() = default;
SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent&) = default;
SchedCpuHotplugFtraceEvent& SchedCpuHotplugFtraceEvent::operator=(const SchedCpuHotplugFtraceEvent&) = default;
SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(SchedCpuHotplugFtraceEvent&&) noexcept = default;
SchedCpuHotplugFtraceEvent& SchedCpuHotplugFtraceEvent::operator=(SchedCpuHotplugFtraceEvent&&) = default;

bool SchedCpuHotplugFtraceEvent::operator==(const SchedCpuHotplugFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && affected_cpu_ == other.affected_cpu_
   && error_ == other.error_
   && status_ == other.status_;
}

bool SchedCpuHotplugFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* affected_cpu */:
        field.get(&affected_cpu_);
        break;
      case 2 /* error */:
        field.get(&error_);
        break;
      case 3 /* status */:
        field.get(&status_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedCpuHotplugFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedCpuHotplugFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedCpuHotplugFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: affected_cpu
  if (_has_field_[1]) {
    msg->AppendVarInt(1, affected_cpu_);
  }

  // Field 2: error
  if (_has_field_[2]) {
    msg->AppendVarInt(2, error_);
  }

  // Field 3: status
  if (_has_field_[3]) {
    msg->AppendVarInt(3, status_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent() = default;
SchedBlockedReasonFtraceEvent::~SchedBlockedReasonFtraceEvent() = default;
SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent&) = default;
SchedBlockedReasonFtraceEvent& SchedBlockedReasonFtraceEvent::operator=(const SchedBlockedReasonFtraceEvent&) = default;
SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(SchedBlockedReasonFtraceEvent&&) noexcept = default;
SchedBlockedReasonFtraceEvent& SchedBlockedReasonFtraceEvent::operator=(SchedBlockedReasonFtraceEvent&&) = default;

bool SchedBlockedReasonFtraceEvent::operator==(const SchedBlockedReasonFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pid_ == other.pid_
   && caller_ == other.caller_
   && io_wait_ == other.io_wait_;
}

bool SchedBlockedReasonFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pid */:
        field.get(&pid_);
        break;
      case 2 /* caller */:
        field.get(&caller_);
        break;
      case 3 /* io_wait */:
        field.get(&io_wait_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedBlockedReasonFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedBlockedReasonFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedBlockedReasonFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pid_);
  }

  // Field 2: caller
  if (_has_field_[2]) {
    msg->AppendVarInt(2, caller_);
  }

  // Field 3: io_wait
  if (_has_field_[3]) {
    msg->AppendVarInt(3, io_wait_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedWakeupFtraceEvent::SchedWakeupFtraceEvent() = default;
SchedWakeupFtraceEvent::~SchedWakeupFtraceEvent() = default;
SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent&) = default;
SchedWakeupFtraceEvent& SchedWakeupFtraceEvent::operator=(const SchedWakeupFtraceEvent&) = default;
SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(SchedWakeupFtraceEvent&&) noexcept = default;
SchedWakeupFtraceEvent& SchedWakeupFtraceEvent::operator=(SchedWakeupFtraceEvent&&) = default;

bool SchedWakeupFtraceEvent::operator==(const SchedWakeupFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && comm_ == other.comm_
   && pid_ == other.pid_
   && prio_ == other.prio_
   && success_ == other.success_
   && target_cpu_ == other.target_cpu_;
}

bool SchedWakeupFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        field.get(&comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      case 4 /* success */:
        field.get(&success_);
        break;
      case 5 /* target_cpu */:
        field.get(&target_cpu_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedWakeupFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedWakeupFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedWakeupFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    msg->AppendString(1, comm_);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pid_);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    msg->AppendVarInt(3, prio_);
  }

  // Field 4: success
  if (_has_field_[4]) {
    msg->AppendVarInt(4, success_);
  }

  // Field 5: target_cpu
  if (_has_field_[5]) {
    msg->AppendVarInt(5, target_cpu_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


SchedSwitchFtraceEvent::SchedSwitchFtraceEvent() = default;
SchedSwitchFtraceEvent::~SchedSwitchFtraceEvent() = default;
SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent&) = default;
SchedSwitchFtraceEvent& SchedSwitchFtraceEvent::operator=(const SchedSwitchFtraceEvent&) = default;
SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(SchedSwitchFtraceEvent&&) noexcept = default;
SchedSwitchFtraceEvent& SchedSwitchFtraceEvent::operator=(SchedSwitchFtraceEvent&&) = default;

bool SchedSwitchFtraceEvent::operator==(const SchedSwitchFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && prev_comm_ == other.prev_comm_
   && prev_pid_ == other.prev_pid_
   && prev_prio_ == other.prev_prio_
   && prev_state_ == other.prev_state_
   && next_comm_ == other.next_comm_
   && next_pid_ == other.next_pid_
   && next_prio_ == other.next_prio_;
}

bool SchedSwitchFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* prev_comm */:
        field.get(&prev_comm_);
        break;
      case 2 /* prev_pid */:
        field.get(&prev_pid_);
        break;
      case 3 /* prev_prio */:
        field.get(&prev_prio_);
        break;
      case 4 /* prev_state */:
        field.get(&prev_state_);
        break;
      case 5 /* next_comm */:
        field.get(&next_comm_);
        break;
      case 6 /* next_pid */:
        field.get(&next_pid_);
        break;
      case 7 /* next_prio */:
        field.get(&next_prio_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedSwitchFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedSwitchFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedSwitchFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: prev_comm
  if (_has_field_[1]) {
    msg->AppendString(1, prev_comm_);
  }

  // Field 2: prev_pid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, prev_pid_);
  }

  // Field 3: prev_prio
  if (_has_field_[3]) {
    msg->AppendVarInt(3, prev_prio_);
  }

  // Field 4: prev_state
  if (_has_field_[4]) {
    msg->AppendVarInt(4, prev_state_);
  }

  // Field 5: next_comm
  if (_has_field_[5]) {
    msg->AppendString(5, next_comm_);
  }

  // Field 6: next_pid
  if (_has_field_[6]) {
    msg->AppendVarInt(6, next_pid_);
  }

  // Field 7: next_prio
  if (_has_field_[7]) {
    msg->AppendVarInt(7, next_prio_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
