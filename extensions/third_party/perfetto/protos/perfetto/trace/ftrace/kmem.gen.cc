#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/kmem.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent() = default;
IonBufferDestroyFtraceEvent::~IonBufferDestroyFtraceEvent() = default;
IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(const IonBufferDestroyFtraceEvent&) = default;
IonBufferDestroyFtraceEvent& IonBufferDestroyFtraceEvent::operator=(const IonBufferDestroyFtraceEvent&) = default;
IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(IonBufferDestroyFtraceEvent&&) noexcept = default;
IonBufferDestroyFtraceEvent& IonBufferDestroyFtraceEvent::operator=(IonBufferDestroyFtraceEvent&&) = default;

bool IonBufferDestroyFtraceEvent::operator==(const IonBufferDestroyFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && addr_ == other.addr_
   && len_ == other.len_;
}

bool IonBufferDestroyFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* addr */:
        field.get(&addr_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonBufferDestroyFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonBufferDestroyFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonBufferDestroyFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: addr
  if (_has_field_[1]) {
    msg->AppendVarInt(1, addr_);
  }

  // Field 2: len
  if (_has_field_[2]) {
    msg->AppendVarInt(2, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent() = default;
IonBufferCreateFtraceEvent::~IonBufferCreateFtraceEvent() = default;
IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(const IonBufferCreateFtraceEvent&) = default;
IonBufferCreateFtraceEvent& IonBufferCreateFtraceEvent::operator=(const IonBufferCreateFtraceEvent&) = default;
IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(IonBufferCreateFtraceEvent&&) noexcept = default;
IonBufferCreateFtraceEvent& IonBufferCreateFtraceEvent::operator=(IonBufferCreateFtraceEvent&&) = default;

bool IonBufferCreateFtraceEvent::operator==(const IonBufferCreateFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && addr_ == other.addr_
   && len_ == other.len_;
}

bool IonBufferCreateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* addr */:
        field.get(&addr_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonBufferCreateFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonBufferCreateFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonBufferCreateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: addr
  if (_has_field_[1]) {
    msg->AppendVarInt(1, addr_);
  }

  // Field 2: len
  if (_has_field_[2]) {
    msg->AppendVarInt(2, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent() = default;
IonHeapGrowFtraceEvent::~IonHeapGrowFtraceEvent() = default;
IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(const IonHeapGrowFtraceEvent&) = default;
IonHeapGrowFtraceEvent& IonHeapGrowFtraceEvent::operator=(const IonHeapGrowFtraceEvent&) = default;
IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(IonHeapGrowFtraceEvent&&) noexcept = default;
IonHeapGrowFtraceEvent& IonHeapGrowFtraceEvent::operator=(IonHeapGrowFtraceEvent&&) = default;

bool IonHeapGrowFtraceEvent::operator==(const IonHeapGrowFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && heap_name_ == other.heap_name_
   && len_ == other.len_
   && total_allocated_ == other.total_allocated_;
}

bool IonHeapGrowFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      case 3 /* total_allocated */:
        field.get(&total_allocated_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonHeapGrowFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonHeapGrowFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonHeapGrowFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: heap_name
  if (_has_field_[1]) {
    msg->AppendString(1, heap_name_);
  }

  // Field 2: len
  if (_has_field_[2]) {
    msg->AppendVarInt(2, len_);
  }

  // Field 3: total_allocated
  if (_has_field_[3]) {
    msg->AppendVarInt(3, total_allocated_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent() = default;
IonHeapShrinkFtraceEvent::~IonHeapShrinkFtraceEvent() = default;
IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(const IonHeapShrinkFtraceEvent&) = default;
IonHeapShrinkFtraceEvent& IonHeapShrinkFtraceEvent::operator=(const IonHeapShrinkFtraceEvent&) = default;
IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(IonHeapShrinkFtraceEvent&&) noexcept = default;
IonHeapShrinkFtraceEvent& IonHeapShrinkFtraceEvent::operator=(IonHeapShrinkFtraceEvent&&) = default;

bool IonHeapShrinkFtraceEvent::operator==(const IonHeapShrinkFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && heap_name_ == other.heap_name_
   && len_ == other.len_
   && total_allocated_ == other.total_allocated_;
}

bool IonHeapShrinkFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      case 3 /* total_allocated */:
        field.get(&total_allocated_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonHeapShrinkFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonHeapShrinkFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonHeapShrinkFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: heap_name
  if (_has_field_[1]) {
    msg->AppendString(1, heap_name_);
  }

  // Field 2: len
  if (_has_field_[2]) {
    msg->AppendVarInt(2, len_);
  }

  // Field 3: total_allocated
  if (_has_field_[3]) {
    msg->AppendVarInt(3, total_allocated_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


RssStatFtraceEvent::RssStatFtraceEvent() = default;
RssStatFtraceEvent::~RssStatFtraceEvent() = default;
RssStatFtraceEvent::RssStatFtraceEvent(const RssStatFtraceEvent&) = default;
RssStatFtraceEvent& RssStatFtraceEvent::operator=(const RssStatFtraceEvent&) = default;
RssStatFtraceEvent::RssStatFtraceEvent(RssStatFtraceEvent&&) noexcept = default;
RssStatFtraceEvent& RssStatFtraceEvent::operator=(RssStatFtraceEvent&&) = default;

bool RssStatFtraceEvent::operator==(const RssStatFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && member_ == other.member_
   && size_ == other.size_
   && curr_ == other.curr_
   && mm_id_ == other.mm_id_;
}

bool RssStatFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* member */:
        field.get(&member_);
        break;
      case 2 /* size */:
        field.get(&size_);
        break;
      case 3 /* curr */:
        field.get(&curr_);
        break;
      case 4 /* mm_id */:
        field.get(&mm_id_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RssStatFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RssStatFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RssStatFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: member
  if (_has_field_[1]) {
    msg->AppendVarInt(1, member_);
  }

  // Field 2: size
  if (_has_field_[2]) {
    msg->AppendVarInt(2, size_);
  }

  // Field 3: curr
  if (_has_field_[3]) {
    msg->AppendVarInt(3, curr_);
  }

  // Field 4: mm_id
  if (_has_field_[4]) {
    msg->AppendVarInt(4, mm_id_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent() = default;
MmPagePcpuDrainFtraceEvent::~MmPagePcpuDrainFtraceEvent() = default;
MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(const MmPagePcpuDrainFtraceEvent&) = default;
MmPagePcpuDrainFtraceEvent& MmPagePcpuDrainFtraceEvent::operator=(const MmPagePcpuDrainFtraceEvent&) = default;
MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(MmPagePcpuDrainFtraceEvent&&) noexcept = default;
MmPagePcpuDrainFtraceEvent& MmPagePcpuDrainFtraceEvent::operator=(MmPagePcpuDrainFtraceEvent&&) = default;

bool MmPagePcpuDrainFtraceEvent::operator==(const MmPagePcpuDrainFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && migratetype_ == other.migratetype_
   && order_ == other.order_
   && page_ == other.page_
   && pfn_ == other.pfn_;
}

bool MmPagePcpuDrainFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* migratetype */:
        field.get(&migratetype_);
        break;
      case 2 /* order */:
        field.get(&order_);
        break;
      case 3 /* page */:
        field.get(&page_);
        break;
      case 4 /* pfn */:
        field.get(&pfn_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MmPagePcpuDrainFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MmPagePcpuDrainFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MmPagePcpuDrainFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: migratetype
  if (_has_field_[1]) {
    msg->AppendVarInt(1, migratetype_);
  }

  // Field 2: order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, order_);
  }

  // Field 3: page
  if (_has_field_[3]) {
    msg->AppendVarInt(3, page_);
  }

  // Field 4: pfn
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pfn_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent() = default;
MmPageFreeBatchedFtraceEvent::~MmPageFreeBatchedFtraceEvent() = default;
MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(const MmPageFreeBatchedFtraceEvent&) = default;
MmPageFreeBatchedFtraceEvent& MmPageFreeBatchedFtraceEvent::operator=(const MmPageFreeBatchedFtraceEvent&) = default;
MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(MmPageFreeBatchedFtraceEvent&&) noexcept = default;
MmPageFreeBatchedFtraceEvent& MmPageFreeBatchedFtraceEvent::operator=(MmPageFreeBatchedFtraceEvent&&) = default;

bool MmPageFreeBatchedFtraceEvent::operator==(const MmPageFreeBatchedFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && cold_ == other.cold_
   && page_ == other.page_
   && pfn_ == other.pfn_;
}

bool MmPageFreeBatchedFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* cold */:
        field.get(&cold_);
        break;
      case 2 /* page */:
        field.get(&page_);
        break;
      case 3 /* pfn */:
        field.get(&pfn_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MmPageFreeBatchedFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MmPageFreeBatchedFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MmPageFreeBatchedFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: cold
  if (_has_field_[1]) {
    msg->AppendVarInt(1, cold_);
  }

  // Field 2: page
  if (_has_field_[2]) {
    msg->AppendVarInt(2, page_);
  }

  // Field 3: pfn
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pfn_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MmPageFreeFtraceEvent::MmPageFreeFtraceEvent() = default;
MmPageFreeFtraceEvent::~MmPageFreeFtraceEvent() = default;
MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(const MmPageFreeFtraceEvent&) = default;
MmPageFreeFtraceEvent& MmPageFreeFtraceEvent::operator=(const MmPageFreeFtraceEvent&) = default;
MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(MmPageFreeFtraceEvent&&) noexcept = default;
MmPageFreeFtraceEvent& MmPageFreeFtraceEvent::operator=(MmPageFreeFtraceEvent&&) = default;

bool MmPageFreeFtraceEvent::operator==(const MmPageFreeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && order_ == other.order_
   && page_ == other.page_
   && pfn_ == other.pfn_;
}

bool MmPageFreeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* order */:
        field.get(&order_);
        break;
      case 2 /* page */:
        field.get(&page_);
        break;
      case 3 /* pfn */:
        field.get(&pfn_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MmPageFreeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MmPageFreeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MmPageFreeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: order
  if (_has_field_[1]) {
    msg->AppendVarInt(1, order_);
  }

  // Field 2: page
  if (_has_field_[2]) {
    msg->AppendVarInt(2, page_);
  }

  // Field 3: pfn
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pfn_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent() = default;
MmPageAllocZoneLockedFtraceEvent::~MmPageAllocZoneLockedFtraceEvent() = default;
MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(const MmPageAllocZoneLockedFtraceEvent&) = default;
MmPageAllocZoneLockedFtraceEvent& MmPageAllocZoneLockedFtraceEvent::operator=(const MmPageAllocZoneLockedFtraceEvent&) = default;
MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(MmPageAllocZoneLockedFtraceEvent&&) noexcept = default;
MmPageAllocZoneLockedFtraceEvent& MmPageAllocZoneLockedFtraceEvent::operator=(MmPageAllocZoneLockedFtraceEvent&&) = default;

bool MmPageAllocZoneLockedFtraceEvent::operator==(const MmPageAllocZoneLockedFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && migratetype_ == other.migratetype_
   && order_ == other.order_
   && page_ == other.page_
   && pfn_ == other.pfn_;
}

bool MmPageAllocZoneLockedFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* migratetype */:
        field.get(&migratetype_);
        break;
      case 2 /* order */:
        field.get(&order_);
        break;
      case 3 /* page */:
        field.get(&page_);
        break;
      case 4 /* pfn */:
        field.get(&pfn_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MmPageAllocZoneLockedFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MmPageAllocZoneLockedFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MmPageAllocZoneLockedFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: migratetype
  if (_has_field_[1]) {
    msg->AppendVarInt(1, migratetype_);
  }

  // Field 2: order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, order_);
  }

  // Field 3: page
  if (_has_field_[3]) {
    msg->AppendVarInt(3, page_);
  }

  // Field 4: pfn
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pfn_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent() = default;
MmPageAllocExtfragFtraceEvent::~MmPageAllocExtfragFtraceEvent() = default;
MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(const MmPageAllocExtfragFtraceEvent&) = default;
MmPageAllocExtfragFtraceEvent& MmPageAllocExtfragFtraceEvent::operator=(const MmPageAllocExtfragFtraceEvent&) = default;
MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(MmPageAllocExtfragFtraceEvent&&) noexcept = default;
MmPageAllocExtfragFtraceEvent& MmPageAllocExtfragFtraceEvent::operator=(MmPageAllocExtfragFtraceEvent&&) = default;

bool MmPageAllocExtfragFtraceEvent::operator==(const MmPageAllocExtfragFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && alloc_migratetype_ == other.alloc_migratetype_
   && alloc_order_ == other.alloc_order_
   && fallback_migratetype_ == other.fallback_migratetype_
   && fallback_order_ == other.fallback_order_
   && page_ == other.page_
   && change_ownership_ == other.change_ownership_
   && pfn_ == other.pfn_;
}

bool MmPageAllocExtfragFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* alloc_migratetype */:
        field.get(&alloc_migratetype_);
        break;
      case 2 /* alloc_order */:
        field.get(&alloc_order_);
        break;
      case 3 /* fallback_migratetype */:
        field.get(&fallback_migratetype_);
        break;
      case 4 /* fallback_order */:
        field.get(&fallback_order_);
        break;
      case 5 /* page */:
        field.get(&page_);
        break;
      case 6 /* change_ownership */:
        field.get(&change_ownership_);
        break;
      case 7 /* pfn */:
        field.get(&pfn_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MmPageAllocExtfragFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MmPageAllocExtfragFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MmPageAllocExtfragFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: alloc_migratetype
  if (_has_field_[1]) {
    msg->AppendVarInt(1, alloc_migratetype_);
  }

  // Field 2: alloc_order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, alloc_order_);
  }

  // Field 3: fallback_migratetype
  if (_has_field_[3]) {
    msg->AppendVarInt(3, fallback_migratetype_);
  }

  // Field 4: fallback_order
  if (_has_field_[4]) {
    msg->AppendVarInt(4, fallback_order_);
  }

  // Field 5: page
  if (_has_field_[5]) {
    msg->AppendVarInt(5, page_);
  }

  // Field 6: change_ownership
  if (_has_field_[6]) {
    msg->AppendVarInt(6, change_ownership_);
  }

  // Field 7: pfn
  if (_has_field_[7]) {
    msg->AppendVarInt(7, pfn_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MmPageAllocFtraceEvent::MmPageAllocFtraceEvent() = default;
MmPageAllocFtraceEvent::~MmPageAllocFtraceEvent() = default;
MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(const MmPageAllocFtraceEvent&) = default;
MmPageAllocFtraceEvent& MmPageAllocFtraceEvent::operator=(const MmPageAllocFtraceEvent&) = default;
MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(MmPageAllocFtraceEvent&&) noexcept = default;
MmPageAllocFtraceEvent& MmPageAllocFtraceEvent::operator=(MmPageAllocFtraceEvent&&) = default;

bool MmPageAllocFtraceEvent::operator==(const MmPageAllocFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && gfp_flags_ == other.gfp_flags_
   && migratetype_ == other.migratetype_
   && order_ == other.order_
   && page_ == other.page_
   && pfn_ == other.pfn_;
}

bool MmPageAllocFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 2 /* migratetype */:
        field.get(&migratetype_);
        break;
      case 3 /* order */:
        field.get(&order_);
        break;
      case 4 /* page */:
        field.get(&page_);
        break;
      case 5 /* pfn */:
        field.get(&pfn_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MmPageAllocFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MmPageAllocFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MmPageAllocFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gfp_flags
  if (_has_field_[1]) {
    msg->AppendVarInt(1, gfp_flags_);
  }

  // Field 2: migratetype
  if (_has_field_[2]) {
    msg->AppendVarInt(2, migratetype_);
  }

  // Field 3: order
  if (_has_field_[3]) {
    msg->AppendVarInt(3, order_);
  }

  // Field 4: page
  if (_has_field_[4]) {
    msg->AppendVarInt(4, page_);
  }

  // Field 5: pfn
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pfn_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MigrateRetryFtraceEvent::MigrateRetryFtraceEvent() = default;
MigrateRetryFtraceEvent::~MigrateRetryFtraceEvent() = default;
MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(const MigrateRetryFtraceEvent&) = default;
MigrateRetryFtraceEvent& MigrateRetryFtraceEvent::operator=(const MigrateRetryFtraceEvent&) = default;
MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(MigrateRetryFtraceEvent&&) noexcept = default;
MigrateRetryFtraceEvent& MigrateRetryFtraceEvent::operator=(MigrateRetryFtraceEvent&&) = default;

bool MigrateRetryFtraceEvent::operator==(const MigrateRetryFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && tries_ == other.tries_;
}

bool MigrateRetryFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* tries */:
        field.get(&tries_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MigrateRetryFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MigrateRetryFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MigrateRetryFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: tries
  if (_has_field_[1]) {
    msg->AppendVarInt(1, tries_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent() = default;
MigratePagesStartFtraceEvent::~MigratePagesStartFtraceEvent() = default;
MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(const MigratePagesStartFtraceEvent&) = default;
MigratePagesStartFtraceEvent& MigratePagesStartFtraceEvent::operator=(const MigratePagesStartFtraceEvent&) = default;
MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(MigratePagesStartFtraceEvent&&) noexcept = default;
MigratePagesStartFtraceEvent& MigratePagesStartFtraceEvent::operator=(MigratePagesStartFtraceEvent&&) = default;

bool MigratePagesStartFtraceEvent::operator==(const MigratePagesStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && mode_ == other.mode_;
}

bool MigratePagesStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MigratePagesStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MigratePagesStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MigratePagesStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: mode
  if (_has_field_[1]) {
    msg->AppendVarInt(1, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent() = default;
MigratePagesEndFtraceEvent::~MigratePagesEndFtraceEvent() = default;
MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(const MigratePagesEndFtraceEvent&) = default;
MigratePagesEndFtraceEvent& MigratePagesEndFtraceEvent::operator=(const MigratePagesEndFtraceEvent&) = default;
MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(MigratePagesEndFtraceEvent&&) noexcept = default;
MigratePagesEndFtraceEvent& MigratePagesEndFtraceEvent::operator=(MigratePagesEndFtraceEvent&&) = default;

bool MigratePagesEndFtraceEvent::operator==(const MigratePagesEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && mode_ == other.mode_;
}

bool MigratePagesEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MigratePagesEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MigratePagesEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MigratePagesEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: mode
  if (_has_field_[1]) {
    msg->AppendVarInt(1, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent() = default;
KmemCacheFreeFtraceEvent::~KmemCacheFreeFtraceEvent() = default;
KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(const KmemCacheFreeFtraceEvent&) = default;
KmemCacheFreeFtraceEvent& KmemCacheFreeFtraceEvent::operator=(const KmemCacheFreeFtraceEvent&) = default;
KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(KmemCacheFreeFtraceEvent&&) noexcept = default;
KmemCacheFreeFtraceEvent& KmemCacheFreeFtraceEvent::operator=(KmemCacheFreeFtraceEvent&&) = default;

bool KmemCacheFreeFtraceEvent::operator==(const KmemCacheFreeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && call_site_ == other.call_site_
   && ptr_ == other.ptr_;
}

bool KmemCacheFreeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* call_site */:
        field.get(&call_site_);
        break;
      case 2 /* ptr */:
        field.get(&ptr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KmemCacheFreeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KmemCacheFreeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KmemCacheFreeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: call_site
  if (_has_field_[1]) {
    msg->AppendVarInt(1, call_site_);
  }

  // Field 2: ptr
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ptr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent() = default;
KmemCacheAllocNodeFtraceEvent::~KmemCacheAllocNodeFtraceEvent() = default;
KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(const KmemCacheAllocNodeFtraceEvent&) = default;
KmemCacheAllocNodeFtraceEvent& KmemCacheAllocNodeFtraceEvent::operator=(const KmemCacheAllocNodeFtraceEvent&) = default;
KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(KmemCacheAllocNodeFtraceEvent&&) noexcept = default;
KmemCacheAllocNodeFtraceEvent& KmemCacheAllocNodeFtraceEvent::operator=(KmemCacheAllocNodeFtraceEvent&&) = default;

bool KmemCacheAllocNodeFtraceEvent::operator==(const KmemCacheAllocNodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_alloc_ == other.bytes_alloc_
   && bytes_req_ == other.bytes_req_
   && call_site_ == other.call_site_
   && gfp_flags_ == other.gfp_flags_
   && node_ == other.node_
   && ptr_ == other.ptr_;
}

bool KmemCacheAllocNodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes_alloc */:
        field.get(&bytes_alloc_);
        break;
      case 2 /* bytes_req */:
        field.get(&bytes_req_);
        break;
      case 3 /* call_site */:
        field.get(&call_site_);
        break;
      case 4 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 5 /* node */:
        field.get(&node_);
        break;
      case 6 /* ptr */:
        field.get(&ptr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KmemCacheAllocNodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KmemCacheAllocNodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KmemCacheAllocNodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes_alloc
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_alloc_);
  }

  // Field 2: bytes_req
  if (_has_field_[2]) {
    msg->AppendVarInt(2, bytes_req_);
  }

  // Field 3: call_site
  if (_has_field_[3]) {
    msg->AppendVarInt(3, call_site_);
  }

  // Field 4: gfp_flags
  if (_has_field_[4]) {
    msg->AppendVarInt(4, gfp_flags_);
  }

  // Field 5: node
  if (_has_field_[5]) {
    msg->AppendVarInt(5, node_);
  }

  // Field 6: ptr
  if (_has_field_[6]) {
    msg->AppendVarInt(6, ptr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent() = default;
KmemCacheAllocFtraceEvent::~KmemCacheAllocFtraceEvent() = default;
KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(const KmemCacheAllocFtraceEvent&) = default;
KmemCacheAllocFtraceEvent& KmemCacheAllocFtraceEvent::operator=(const KmemCacheAllocFtraceEvent&) = default;
KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(KmemCacheAllocFtraceEvent&&) noexcept = default;
KmemCacheAllocFtraceEvent& KmemCacheAllocFtraceEvent::operator=(KmemCacheAllocFtraceEvent&&) = default;

bool KmemCacheAllocFtraceEvent::operator==(const KmemCacheAllocFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_alloc_ == other.bytes_alloc_
   && bytes_req_ == other.bytes_req_
   && call_site_ == other.call_site_
   && gfp_flags_ == other.gfp_flags_
   && ptr_ == other.ptr_;
}

bool KmemCacheAllocFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes_alloc */:
        field.get(&bytes_alloc_);
        break;
      case 2 /* bytes_req */:
        field.get(&bytes_req_);
        break;
      case 3 /* call_site */:
        field.get(&call_site_);
        break;
      case 4 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 5 /* ptr */:
        field.get(&ptr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KmemCacheAllocFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KmemCacheAllocFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KmemCacheAllocFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes_alloc
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_alloc_);
  }

  // Field 2: bytes_req
  if (_has_field_[2]) {
    msg->AppendVarInt(2, bytes_req_);
  }

  // Field 3: call_site
  if (_has_field_[3]) {
    msg->AppendVarInt(3, call_site_);
  }

  // Field 4: gfp_flags
  if (_has_field_[4]) {
    msg->AppendVarInt(4, gfp_flags_);
  }

  // Field 5: ptr
  if (_has_field_[5]) {
    msg->AppendVarInt(5, ptr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


KmallocNodeFtraceEvent::KmallocNodeFtraceEvent() = default;
KmallocNodeFtraceEvent::~KmallocNodeFtraceEvent() = default;
KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(const KmallocNodeFtraceEvent&) = default;
KmallocNodeFtraceEvent& KmallocNodeFtraceEvent::operator=(const KmallocNodeFtraceEvent&) = default;
KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(KmallocNodeFtraceEvent&&) noexcept = default;
KmallocNodeFtraceEvent& KmallocNodeFtraceEvent::operator=(KmallocNodeFtraceEvent&&) = default;

bool KmallocNodeFtraceEvent::operator==(const KmallocNodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_alloc_ == other.bytes_alloc_
   && bytes_req_ == other.bytes_req_
   && call_site_ == other.call_site_
   && gfp_flags_ == other.gfp_flags_
   && node_ == other.node_
   && ptr_ == other.ptr_;
}

bool KmallocNodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes_alloc */:
        field.get(&bytes_alloc_);
        break;
      case 2 /* bytes_req */:
        field.get(&bytes_req_);
        break;
      case 3 /* call_site */:
        field.get(&call_site_);
        break;
      case 4 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 5 /* node */:
        field.get(&node_);
        break;
      case 6 /* ptr */:
        field.get(&ptr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KmallocNodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KmallocNodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KmallocNodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes_alloc
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_alloc_);
  }

  // Field 2: bytes_req
  if (_has_field_[2]) {
    msg->AppendVarInt(2, bytes_req_);
  }

  // Field 3: call_site
  if (_has_field_[3]) {
    msg->AppendVarInt(3, call_site_);
  }

  // Field 4: gfp_flags
  if (_has_field_[4]) {
    msg->AppendVarInt(4, gfp_flags_);
  }

  // Field 5: node
  if (_has_field_[5]) {
    msg->AppendVarInt(5, node_);
  }

  // Field 6: ptr
  if (_has_field_[6]) {
    msg->AppendVarInt(6, ptr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


KmallocFtraceEvent::KmallocFtraceEvent() = default;
KmallocFtraceEvent::~KmallocFtraceEvent() = default;
KmallocFtraceEvent::KmallocFtraceEvent(const KmallocFtraceEvent&) = default;
KmallocFtraceEvent& KmallocFtraceEvent::operator=(const KmallocFtraceEvent&) = default;
KmallocFtraceEvent::KmallocFtraceEvent(KmallocFtraceEvent&&) noexcept = default;
KmallocFtraceEvent& KmallocFtraceEvent::operator=(KmallocFtraceEvent&&) = default;

bool KmallocFtraceEvent::operator==(const KmallocFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && bytes_alloc_ == other.bytes_alloc_
   && bytes_req_ == other.bytes_req_
   && call_site_ == other.call_site_
   && gfp_flags_ == other.gfp_flags_
   && ptr_ == other.ptr_;
}

bool KmallocFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* bytes_alloc */:
        field.get(&bytes_alloc_);
        break;
      case 2 /* bytes_req */:
        field.get(&bytes_req_);
        break;
      case 3 /* call_site */:
        field.get(&call_site_);
        break;
      case 4 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 5 /* ptr */:
        field.get(&ptr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KmallocFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KmallocFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KmallocFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: bytes_alloc
  if (_has_field_[1]) {
    msg->AppendVarInt(1, bytes_alloc_);
  }

  // Field 2: bytes_req
  if (_has_field_[2]) {
    msg->AppendVarInt(2, bytes_req_);
  }

  // Field 3: call_site
  if (_has_field_[3]) {
    msg->AppendVarInt(3, call_site_);
  }

  // Field 4: gfp_flags
  if (_has_field_[4]) {
    msg->AppendVarInt(4, gfp_flags_);
  }

  // Field 5: ptr
  if (_has_field_[5]) {
    msg->AppendVarInt(5, ptr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


KfreeFtraceEvent::KfreeFtraceEvent() = default;
KfreeFtraceEvent::~KfreeFtraceEvent() = default;
KfreeFtraceEvent::KfreeFtraceEvent(const KfreeFtraceEvent&) = default;
KfreeFtraceEvent& KfreeFtraceEvent::operator=(const KfreeFtraceEvent&) = default;
KfreeFtraceEvent::KfreeFtraceEvent(KfreeFtraceEvent&&) noexcept = default;
KfreeFtraceEvent& KfreeFtraceEvent::operator=(KfreeFtraceEvent&&) = default;

bool KfreeFtraceEvent::operator==(const KfreeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && call_site_ == other.call_site_
   && ptr_ == other.ptr_;
}

bool KfreeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* call_site */:
        field.get(&call_site_);
        break;
      case 2 /* ptr */:
        field.get(&ptr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KfreeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KfreeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KfreeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: call_site
  if (_has_field_[1]) {
    msg->AppendVarInt(1, call_site_);
  }

  // Field 2: ptr
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ptr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent() = default;
IonSecureCmaShrinkPoolStartFtraceEvent::~IonSecureCmaShrinkPoolStartFtraceEvent() = default;
IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(const IonSecureCmaShrinkPoolStartFtraceEvent&) = default;
IonSecureCmaShrinkPoolStartFtraceEvent& IonSecureCmaShrinkPoolStartFtraceEvent::operator=(const IonSecureCmaShrinkPoolStartFtraceEvent&) = default;
IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(IonSecureCmaShrinkPoolStartFtraceEvent&&) noexcept = default;
IonSecureCmaShrinkPoolStartFtraceEvent& IonSecureCmaShrinkPoolStartFtraceEvent::operator=(IonSecureCmaShrinkPoolStartFtraceEvent&&) = default;

bool IonSecureCmaShrinkPoolStartFtraceEvent::operator==(const IonSecureCmaShrinkPoolStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && drained_size_ == other.drained_size_
   && skipped_size_ == other.skipped_size_;
}

bool IonSecureCmaShrinkPoolStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* drained_size */:
        field.get(&drained_size_);
        break;
      case 2 /* skipped_size */:
        field.get(&skipped_size_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonSecureCmaShrinkPoolStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonSecureCmaShrinkPoolStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonSecureCmaShrinkPoolStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: drained_size
  if (_has_field_[1]) {
    msg->AppendVarInt(1, drained_size_);
  }

  // Field 2: skipped_size
  if (_has_field_[2]) {
    msg->AppendVarInt(2, skipped_size_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent() = default;
IonSecureCmaShrinkPoolEndFtraceEvent::~IonSecureCmaShrinkPoolEndFtraceEvent() = default;
IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(const IonSecureCmaShrinkPoolEndFtraceEvent&) = default;
IonSecureCmaShrinkPoolEndFtraceEvent& IonSecureCmaShrinkPoolEndFtraceEvent::operator=(const IonSecureCmaShrinkPoolEndFtraceEvent&) = default;
IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(IonSecureCmaShrinkPoolEndFtraceEvent&&) noexcept = default;
IonSecureCmaShrinkPoolEndFtraceEvent& IonSecureCmaShrinkPoolEndFtraceEvent::operator=(IonSecureCmaShrinkPoolEndFtraceEvent&&) = default;

bool IonSecureCmaShrinkPoolEndFtraceEvent::operator==(const IonSecureCmaShrinkPoolEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && drained_size_ == other.drained_size_
   && skipped_size_ == other.skipped_size_;
}

bool IonSecureCmaShrinkPoolEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* drained_size */:
        field.get(&drained_size_);
        break;
      case 2 /* skipped_size */:
        field.get(&skipped_size_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonSecureCmaShrinkPoolEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonSecureCmaShrinkPoolEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonSecureCmaShrinkPoolEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: drained_size
  if (_has_field_[1]) {
    msg->AppendVarInt(1, drained_size_);
  }

  // Field 2: skipped_size
  if (_has_field_[2]) {
    msg->AppendVarInt(2, skipped_size_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent() = default;
IonSecureCmaAllocateStartFtraceEvent::~IonSecureCmaAllocateStartFtraceEvent() = default;
IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(const IonSecureCmaAllocateStartFtraceEvent&) = default;
IonSecureCmaAllocateStartFtraceEvent& IonSecureCmaAllocateStartFtraceEvent::operator=(const IonSecureCmaAllocateStartFtraceEvent&) = default;
IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(IonSecureCmaAllocateStartFtraceEvent&&) noexcept = default;
IonSecureCmaAllocateStartFtraceEvent& IonSecureCmaAllocateStartFtraceEvent::operator=(IonSecureCmaAllocateStartFtraceEvent&&) = default;

bool IonSecureCmaAllocateStartFtraceEvent::operator==(const IonSecureCmaAllocateStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && align_ == other.align_
   && flags_ == other.flags_
   && heap_name_ == other.heap_name_
   && len_ == other.len_;
}

bool IonSecureCmaAllocateStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* align */:
        field.get(&align_);
        break;
      case 2 /* flags */:
        field.get(&flags_);
        break;
      case 3 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonSecureCmaAllocateStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonSecureCmaAllocateStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonSecureCmaAllocateStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: align
  if (_has_field_[1]) {
    msg->AppendVarInt(1, align_);
  }

  // Field 2: flags
  if (_has_field_[2]) {
    msg->AppendVarInt(2, flags_);
  }

  // Field 3: heap_name
  if (_has_field_[3]) {
    msg->AppendString(3, heap_name_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent() = default;
IonSecureCmaAllocateEndFtraceEvent::~IonSecureCmaAllocateEndFtraceEvent() = default;
IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(const IonSecureCmaAllocateEndFtraceEvent&) = default;
IonSecureCmaAllocateEndFtraceEvent& IonSecureCmaAllocateEndFtraceEvent::operator=(const IonSecureCmaAllocateEndFtraceEvent&) = default;
IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(IonSecureCmaAllocateEndFtraceEvent&&) noexcept = default;
IonSecureCmaAllocateEndFtraceEvent& IonSecureCmaAllocateEndFtraceEvent::operator=(IonSecureCmaAllocateEndFtraceEvent&&) = default;

bool IonSecureCmaAllocateEndFtraceEvent::operator==(const IonSecureCmaAllocateEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && align_ == other.align_
   && flags_ == other.flags_
   && heap_name_ == other.heap_name_
   && len_ == other.len_;
}

bool IonSecureCmaAllocateEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* align */:
        field.get(&align_);
        break;
      case 2 /* flags */:
        field.get(&flags_);
        break;
      case 3 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonSecureCmaAllocateEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonSecureCmaAllocateEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonSecureCmaAllocateEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: align
  if (_has_field_[1]) {
    msg->AppendVarInt(1, align_);
  }

  // Field 2: flags
  if (_has_field_[2]) {
    msg->AppendVarInt(2, flags_);
  }

  // Field 3: heap_name
  if (_has_field_[3]) {
    msg->AppendString(3, heap_name_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent() = default;
IonSecureCmaAddToPoolStartFtraceEvent::~IonSecureCmaAddToPoolStartFtraceEvent() = default;
IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(const IonSecureCmaAddToPoolStartFtraceEvent&) = default;
IonSecureCmaAddToPoolStartFtraceEvent& IonSecureCmaAddToPoolStartFtraceEvent::operator=(const IonSecureCmaAddToPoolStartFtraceEvent&) = default;
IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(IonSecureCmaAddToPoolStartFtraceEvent&&) noexcept = default;
IonSecureCmaAddToPoolStartFtraceEvent& IonSecureCmaAddToPoolStartFtraceEvent::operator=(IonSecureCmaAddToPoolStartFtraceEvent&&) = default;

bool IonSecureCmaAddToPoolStartFtraceEvent::operator==(const IonSecureCmaAddToPoolStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && is_prefetch_ == other.is_prefetch_
   && len_ == other.len_
   && pool_total_ == other.pool_total_;
}

bool IonSecureCmaAddToPoolStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* is_prefetch */:
        field.get(&is_prefetch_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      case 3 /* pool_total */:
        field.get(&pool_total_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonSecureCmaAddToPoolStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonSecureCmaAddToPoolStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonSecureCmaAddToPoolStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: is_prefetch
  if (_has_field_[1]) {
    msg->AppendVarInt(1, is_prefetch_);
  }

  // Field 2: len
  if (_has_field_[2]) {
    msg->AppendVarInt(2, len_);
  }

  // Field 3: pool_total
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pool_total_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent() = default;
IonSecureCmaAddToPoolEndFtraceEvent::~IonSecureCmaAddToPoolEndFtraceEvent() = default;
IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(const IonSecureCmaAddToPoolEndFtraceEvent&) = default;
IonSecureCmaAddToPoolEndFtraceEvent& IonSecureCmaAddToPoolEndFtraceEvent::operator=(const IonSecureCmaAddToPoolEndFtraceEvent&) = default;
IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(IonSecureCmaAddToPoolEndFtraceEvent&&) noexcept = default;
IonSecureCmaAddToPoolEndFtraceEvent& IonSecureCmaAddToPoolEndFtraceEvent::operator=(IonSecureCmaAddToPoolEndFtraceEvent&&) = default;

bool IonSecureCmaAddToPoolEndFtraceEvent::operator==(const IonSecureCmaAddToPoolEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && is_prefetch_ == other.is_prefetch_
   && len_ == other.len_
   && pool_total_ == other.pool_total_;
}

bool IonSecureCmaAddToPoolEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* is_prefetch */:
        field.get(&is_prefetch_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      case 3 /* pool_total */:
        field.get(&pool_total_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonSecureCmaAddToPoolEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonSecureCmaAddToPoolEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonSecureCmaAddToPoolEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: is_prefetch
  if (_has_field_[1]) {
    msg->AppendVarInt(1, is_prefetch_);
  }

  // Field 2: len
  if (_has_field_[2]) {
    msg->AppendVarInt(2, len_);
  }

  // Field 3: pool_total
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pool_total_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent() = default;
IonPrefetchingFtraceEvent::~IonPrefetchingFtraceEvent() = default;
IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(const IonPrefetchingFtraceEvent&) = default;
IonPrefetchingFtraceEvent& IonPrefetchingFtraceEvent::operator=(const IonPrefetchingFtraceEvent&) = default;
IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(IonPrefetchingFtraceEvent&&) noexcept = default;
IonPrefetchingFtraceEvent& IonPrefetchingFtraceEvent::operator=(IonPrefetchingFtraceEvent&&) = default;

bool IonPrefetchingFtraceEvent::operator==(const IonPrefetchingFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && len_ == other.len_;
}

bool IonPrefetchingFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonPrefetchingFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonPrefetchingFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonPrefetchingFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: len
  if (_has_field_[1]) {
    msg->AppendVarInt(1, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent() = default;
IonCpSecureBufferStartFtraceEvent::~IonCpSecureBufferStartFtraceEvent() = default;
IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(const IonCpSecureBufferStartFtraceEvent&) = default;
IonCpSecureBufferStartFtraceEvent& IonCpSecureBufferStartFtraceEvent::operator=(const IonCpSecureBufferStartFtraceEvent&) = default;
IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(IonCpSecureBufferStartFtraceEvent&&) noexcept = default;
IonCpSecureBufferStartFtraceEvent& IonCpSecureBufferStartFtraceEvent::operator=(IonCpSecureBufferStartFtraceEvent&&) = default;

bool IonCpSecureBufferStartFtraceEvent::operator==(const IonCpSecureBufferStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && align_ == other.align_
   && flags_ == other.flags_
   && heap_name_ == other.heap_name_
   && len_ == other.len_;
}

bool IonCpSecureBufferStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* align */:
        field.get(&align_);
        break;
      case 2 /* flags */:
        field.get(&flags_);
        break;
      case 3 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonCpSecureBufferStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonCpSecureBufferStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonCpSecureBufferStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: align
  if (_has_field_[1]) {
    msg->AppendVarInt(1, align_);
  }

  // Field 2: flags
  if (_has_field_[2]) {
    msg->AppendVarInt(2, flags_);
  }

  // Field 3: heap_name
  if (_has_field_[3]) {
    msg->AppendString(3, heap_name_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent() = default;
IonCpSecureBufferEndFtraceEvent::~IonCpSecureBufferEndFtraceEvent() = default;
IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(const IonCpSecureBufferEndFtraceEvent&) = default;
IonCpSecureBufferEndFtraceEvent& IonCpSecureBufferEndFtraceEvent::operator=(const IonCpSecureBufferEndFtraceEvent&) = default;
IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(IonCpSecureBufferEndFtraceEvent&&) noexcept = default;
IonCpSecureBufferEndFtraceEvent& IonCpSecureBufferEndFtraceEvent::operator=(IonCpSecureBufferEndFtraceEvent&&) = default;

bool IonCpSecureBufferEndFtraceEvent::operator==(const IonCpSecureBufferEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && align_ == other.align_
   && flags_ == other.flags_
   && heap_name_ == other.heap_name_
   && len_ == other.len_;
}

bool IonCpSecureBufferEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* align */:
        field.get(&align_);
        break;
      case 2 /* flags */:
        field.get(&flags_);
        break;
      case 3 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonCpSecureBufferEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonCpSecureBufferEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonCpSecureBufferEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: align
  if (_has_field_[1]) {
    msg->AppendVarInt(1, align_);
  }

  // Field 2: flags
  if (_has_field_[2]) {
    msg->AppendVarInt(2, flags_);
  }

  // Field 3: heap_name
  if (_has_field_[3]) {
    msg->AppendString(3, heap_name_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent() = default;
IonCpAllocRetryFtraceEvent::~IonCpAllocRetryFtraceEvent() = default;
IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(const IonCpAllocRetryFtraceEvent&) = default;
IonCpAllocRetryFtraceEvent& IonCpAllocRetryFtraceEvent::operator=(const IonCpAllocRetryFtraceEvent&) = default;
IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(IonCpAllocRetryFtraceEvent&&) noexcept = default;
IonCpAllocRetryFtraceEvent& IonCpAllocRetryFtraceEvent::operator=(IonCpAllocRetryFtraceEvent&&) = default;

bool IonCpAllocRetryFtraceEvent::operator==(const IonCpAllocRetryFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && tries_ == other.tries_;
}

bool IonCpAllocRetryFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* tries */:
        field.get(&tries_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonCpAllocRetryFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonCpAllocRetryFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonCpAllocRetryFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: tries
  if (_has_field_[1]) {
    msg->AppendVarInt(1, tries_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent() = default;
IonAllocBufferStartFtraceEvent::~IonAllocBufferStartFtraceEvent() = default;
IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(const IonAllocBufferStartFtraceEvent&) = default;
IonAllocBufferStartFtraceEvent& IonAllocBufferStartFtraceEvent::operator=(const IonAllocBufferStartFtraceEvent&) = default;
IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(IonAllocBufferStartFtraceEvent&&) noexcept = default;
IonAllocBufferStartFtraceEvent& IonAllocBufferStartFtraceEvent::operator=(IonAllocBufferStartFtraceEvent&&) = default;

bool IonAllocBufferStartFtraceEvent::operator==(const IonAllocBufferStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && client_name_ == other.client_name_
   && flags_ == other.flags_
   && heap_name_ == other.heap_name_
   && len_ == other.len_
   && mask_ == other.mask_;
}

bool IonAllocBufferStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* client_name */:
        field.get(&client_name_);
        break;
      case 2 /* flags */:
        field.get(&flags_);
        break;
      case 3 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* mask */:
        field.get(&mask_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonAllocBufferStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonAllocBufferStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonAllocBufferStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: client_name
  if (_has_field_[1]) {
    msg->AppendString(1, client_name_);
  }

  // Field 2: flags
  if (_has_field_[2]) {
    msg->AppendVarInt(2, flags_);
  }

  // Field 3: heap_name
  if (_has_field_[3]) {
    msg->AppendString(3, heap_name_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: mask
  if (_has_field_[5]) {
    msg->AppendVarInt(5, mask_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent() = default;
IonAllocBufferFallbackFtraceEvent::~IonAllocBufferFallbackFtraceEvent() = default;
IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(const IonAllocBufferFallbackFtraceEvent&) = default;
IonAllocBufferFallbackFtraceEvent& IonAllocBufferFallbackFtraceEvent::operator=(const IonAllocBufferFallbackFtraceEvent&) = default;
IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(IonAllocBufferFallbackFtraceEvent&&) noexcept = default;
IonAllocBufferFallbackFtraceEvent& IonAllocBufferFallbackFtraceEvent::operator=(IonAllocBufferFallbackFtraceEvent&&) = default;

bool IonAllocBufferFallbackFtraceEvent::operator==(const IonAllocBufferFallbackFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && client_name_ == other.client_name_
   && error_ == other.error_
   && flags_ == other.flags_
   && heap_name_ == other.heap_name_
   && len_ == other.len_
   && mask_ == other.mask_;
}

bool IonAllocBufferFallbackFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* client_name */:
        field.get(&client_name_);
        break;
      case 2 /* error */:
        field.get(&error_);
        break;
      case 3 /* flags */:
        field.get(&flags_);
        break;
      case 4 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 5 /* len */:
        field.get(&len_);
        break;
      case 6 /* mask */:
        field.get(&mask_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonAllocBufferFallbackFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonAllocBufferFallbackFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonAllocBufferFallbackFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: client_name
  if (_has_field_[1]) {
    msg->AppendString(1, client_name_);
  }

  // Field 2: error
  if (_has_field_[2]) {
    msg->AppendVarInt(2, error_);
  }

  // Field 3: flags
  if (_has_field_[3]) {
    msg->AppendVarInt(3, flags_);
  }

  // Field 4: heap_name
  if (_has_field_[4]) {
    msg->AppendString(4, heap_name_);
  }

  // Field 5: len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, len_);
  }

  // Field 6: mask
  if (_has_field_[6]) {
    msg->AppendVarInt(6, mask_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent() = default;
IonAllocBufferFailFtraceEvent::~IonAllocBufferFailFtraceEvent() = default;
IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(const IonAllocBufferFailFtraceEvent&) = default;
IonAllocBufferFailFtraceEvent& IonAllocBufferFailFtraceEvent::operator=(const IonAllocBufferFailFtraceEvent&) = default;
IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(IonAllocBufferFailFtraceEvent&&) noexcept = default;
IonAllocBufferFailFtraceEvent& IonAllocBufferFailFtraceEvent::operator=(IonAllocBufferFailFtraceEvent&&) = default;

bool IonAllocBufferFailFtraceEvent::operator==(const IonAllocBufferFailFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && client_name_ == other.client_name_
   && error_ == other.error_
   && flags_ == other.flags_
   && heap_name_ == other.heap_name_
   && len_ == other.len_
   && mask_ == other.mask_;
}

bool IonAllocBufferFailFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* client_name */:
        field.get(&client_name_);
        break;
      case 2 /* error */:
        field.get(&error_);
        break;
      case 3 /* flags */:
        field.get(&flags_);
        break;
      case 4 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 5 /* len */:
        field.get(&len_);
        break;
      case 6 /* mask */:
        field.get(&mask_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonAllocBufferFailFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonAllocBufferFailFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonAllocBufferFailFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: client_name
  if (_has_field_[1]) {
    msg->AppendString(1, client_name_);
  }

  // Field 2: error
  if (_has_field_[2]) {
    msg->AppendVarInt(2, error_);
  }

  // Field 3: flags
  if (_has_field_[3]) {
    msg->AppendVarInt(3, flags_);
  }

  // Field 4: heap_name
  if (_has_field_[4]) {
    msg->AppendString(4, heap_name_);
  }

  // Field 5: len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, len_);
  }

  // Field 6: mask
  if (_has_field_[6]) {
    msg->AppendVarInt(6, mask_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent() = default;
IonAllocBufferEndFtraceEvent::~IonAllocBufferEndFtraceEvent() = default;
IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(const IonAllocBufferEndFtraceEvent&) = default;
IonAllocBufferEndFtraceEvent& IonAllocBufferEndFtraceEvent::operator=(const IonAllocBufferEndFtraceEvent&) = default;
IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(IonAllocBufferEndFtraceEvent&&) noexcept = default;
IonAllocBufferEndFtraceEvent& IonAllocBufferEndFtraceEvent::operator=(IonAllocBufferEndFtraceEvent&&) = default;

bool IonAllocBufferEndFtraceEvent::operator==(const IonAllocBufferEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && client_name_ == other.client_name_
   && flags_ == other.flags_
   && heap_name_ == other.heap_name_
   && len_ == other.len_
   && mask_ == other.mask_;
}

bool IonAllocBufferEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* client_name */:
        field.get(&client_name_);
        break;
      case 2 /* flags */:
        field.get(&flags_);
        break;
      case 3 /* heap_name */:
        field.get(&heap_name_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* mask */:
        field.get(&mask_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IonAllocBufferEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IonAllocBufferEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IonAllocBufferEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: client_name
  if (_has_field_[1]) {
    msg->AppendString(1, client_name_);
  }

  // Field 2: flags
  if (_has_field_[2]) {
    msg->AppendVarInt(2, flags_);
  }

  // Field 3: heap_name
  if (_has_field_[3]) {
    msg->AppendString(3, heap_name_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: mask
  if (_has_field_[5]) {
    msg->AppendVarInt(5, mask_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent() = default;
IommuSecPtblMapRangeStartFtraceEvent::~IommuSecPtblMapRangeStartFtraceEvent() = default;
IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(const IommuSecPtblMapRangeStartFtraceEvent&) = default;
IommuSecPtblMapRangeStartFtraceEvent& IommuSecPtblMapRangeStartFtraceEvent::operator=(const IommuSecPtblMapRangeStartFtraceEvent&) = default;
IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(IommuSecPtblMapRangeStartFtraceEvent&&) noexcept = default;
IommuSecPtblMapRangeStartFtraceEvent& IommuSecPtblMapRangeStartFtraceEvent::operator=(IommuSecPtblMapRangeStartFtraceEvent&&) = default;

bool IommuSecPtblMapRangeStartFtraceEvent::operator==(const IommuSecPtblMapRangeStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && len_ == other.len_
   && num_ == other.num_
   && pa_ == other.pa_
   && sec_id_ == other.sec_id_
   && va_ == other.va_;
}

bool IommuSecPtblMapRangeStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* len */:
        field.get(&len_);
        break;
      case 2 /* num */:
        field.get(&num_);
        break;
      case 3 /* pa */:
        field.get(&pa_);
        break;
      case 4 /* sec_id */:
        field.get(&sec_id_);
        break;
      case 5 /* va */:
        field.get(&va_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IommuSecPtblMapRangeStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IommuSecPtblMapRangeStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IommuSecPtblMapRangeStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: len
  if (_has_field_[1]) {
    msg->AppendVarInt(1, len_);
  }

  // Field 2: num
  if (_has_field_[2]) {
    msg->AppendVarInt(2, num_);
  }

  // Field 3: pa
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pa_);
  }

  // Field 4: sec_id
  if (_has_field_[4]) {
    msg->AppendVarInt(4, sec_id_);
  }

  // Field 5: va
  if (_has_field_[5]) {
    msg->AppendVarInt(5, va_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent() = default;
IommuSecPtblMapRangeEndFtraceEvent::~IommuSecPtblMapRangeEndFtraceEvent() = default;
IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(const IommuSecPtblMapRangeEndFtraceEvent&) = default;
IommuSecPtblMapRangeEndFtraceEvent& IommuSecPtblMapRangeEndFtraceEvent::operator=(const IommuSecPtblMapRangeEndFtraceEvent&) = default;
IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(IommuSecPtblMapRangeEndFtraceEvent&&) noexcept = default;
IommuSecPtblMapRangeEndFtraceEvent& IommuSecPtblMapRangeEndFtraceEvent::operator=(IommuSecPtblMapRangeEndFtraceEvent&&) = default;

bool IommuSecPtblMapRangeEndFtraceEvent::operator==(const IommuSecPtblMapRangeEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && len_ == other.len_
   && num_ == other.num_
   && pa_ == other.pa_
   && sec_id_ == other.sec_id_
   && va_ == other.va_;
}

bool IommuSecPtblMapRangeEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* len */:
        field.get(&len_);
        break;
      case 2 /* num */:
        field.get(&num_);
        break;
      case 3 /* pa */:
        field.get(&pa_);
        break;
      case 4 /* sec_id */:
        field.get(&sec_id_);
        break;
      case 5 /* va */:
        field.get(&va_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IommuSecPtblMapRangeEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IommuSecPtblMapRangeEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IommuSecPtblMapRangeEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: len
  if (_has_field_[1]) {
    msg->AppendVarInt(1, len_);
  }

  // Field 2: num
  if (_has_field_[2]) {
    msg->AppendVarInt(2, num_);
  }

  // Field 3: pa
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pa_);
  }

  // Field 4: sec_id
  if (_has_field_[4]) {
    msg->AppendVarInt(4, sec_id_);
  }

  // Field 5: va
  if (_has_field_[5]) {
    msg->AppendVarInt(5, va_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent() = default;
IommuMapRangeFtraceEvent::~IommuMapRangeFtraceEvent() = default;
IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(const IommuMapRangeFtraceEvent&) = default;
IommuMapRangeFtraceEvent& IommuMapRangeFtraceEvent::operator=(const IommuMapRangeFtraceEvent&) = default;
IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(IommuMapRangeFtraceEvent&&) noexcept = default;
IommuMapRangeFtraceEvent& IommuMapRangeFtraceEvent::operator=(IommuMapRangeFtraceEvent&&) = default;

bool IommuMapRangeFtraceEvent::operator==(const IommuMapRangeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && chunk_size_ == other.chunk_size_
   && len_ == other.len_
   && pa_ == other.pa_
   && va_ == other.va_;
}

bool IommuMapRangeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* chunk_size */:
        field.get(&chunk_size_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      case 3 /* pa */:
        field.get(&pa_);
        break;
      case 4 /* va */:
        field.get(&va_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string IommuMapRangeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> IommuMapRangeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void IommuMapRangeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: chunk_size
  if (_has_field_[1]) {
    msg->AppendVarInt(1, chunk_size_);
  }

  // Field 2: len
  if (_has_field_[2]) {
    msg->AppendVarInt(2, len_);
  }

  // Field 3: pa
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pa_);
  }

  // Field 4: va
  if (_has_field_[4]) {
    msg->AppendVarInt(4, va_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent() = default;
DmaAllocContiguousRetryFtraceEvent::~DmaAllocContiguousRetryFtraceEvent() = default;
DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(const DmaAllocContiguousRetryFtraceEvent&) = default;
DmaAllocContiguousRetryFtraceEvent& DmaAllocContiguousRetryFtraceEvent::operator=(const DmaAllocContiguousRetryFtraceEvent&) = default;
DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(DmaAllocContiguousRetryFtraceEvent&&) noexcept = default;
DmaAllocContiguousRetryFtraceEvent& DmaAllocContiguousRetryFtraceEvent::operator=(DmaAllocContiguousRetryFtraceEvent&&) = default;

bool DmaAllocContiguousRetryFtraceEvent::operator==(const DmaAllocContiguousRetryFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && tries_ == other.tries_;
}

bool DmaAllocContiguousRetryFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* tries */:
        field.get(&tries_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string DmaAllocContiguousRetryFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> DmaAllocContiguousRetryFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void DmaAllocContiguousRetryFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: tries
  if (_has_field_[1]) {
    msg->AppendVarInt(1, tries_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent() = default;
AllocPagesSysStartFtraceEvent::~AllocPagesSysStartFtraceEvent() = default;
AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(const AllocPagesSysStartFtraceEvent&) = default;
AllocPagesSysStartFtraceEvent& AllocPagesSysStartFtraceEvent::operator=(const AllocPagesSysStartFtraceEvent&) = default;
AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(AllocPagesSysStartFtraceEvent&&) noexcept = default;
AllocPagesSysStartFtraceEvent& AllocPagesSysStartFtraceEvent::operator=(AllocPagesSysStartFtraceEvent&&) = default;

bool AllocPagesSysStartFtraceEvent::operator==(const AllocPagesSysStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && gfp_flags_ == other.gfp_flags_
   && order_ == other.order_;
}

bool AllocPagesSysStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 2 /* order */:
        field.get(&order_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AllocPagesSysStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AllocPagesSysStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AllocPagesSysStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gfp_flags
  if (_has_field_[1]) {
    msg->AppendVarInt(1, gfp_flags_);
  }

  // Field 2: order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, order_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent() = default;
AllocPagesSysFailFtraceEvent::~AllocPagesSysFailFtraceEvent() = default;
AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(const AllocPagesSysFailFtraceEvent&) = default;
AllocPagesSysFailFtraceEvent& AllocPagesSysFailFtraceEvent::operator=(const AllocPagesSysFailFtraceEvent&) = default;
AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(AllocPagesSysFailFtraceEvent&&) noexcept = default;
AllocPagesSysFailFtraceEvent& AllocPagesSysFailFtraceEvent::operator=(AllocPagesSysFailFtraceEvent&&) = default;

bool AllocPagesSysFailFtraceEvent::operator==(const AllocPagesSysFailFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && gfp_flags_ == other.gfp_flags_
   && order_ == other.order_;
}

bool AllocPagesSysFailFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 2 /* order */:
        field.get(&order_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AllocPagesSysFailFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AllocPagesSysFailFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AllocPagesSysFailFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gfp_flags
  if (_has_field_[1]) {
    msg->AppendVarInt(1, gfp_flags_);
  }

  // Field 2: order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, order_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent() = default;
AllocPagesSysEndFtraceEvent::~AllocPagesSysEndFtraceEvent() = default;
AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(const AllocPagesSysEndFtraceEvent&) = default;
AllocPagesSysEndFtraceEvent& AllocPagesSysEndFtraceEvent::operator=(const AllocPagesSysEndFtraceEvent&) = default;
AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(AllocPagesSysEndFtraceEvent&&) noexcept = default;
AllocPagesSysEndFtraceEvent& AllocPagesSysEndFtraceEvent::operator=(AllocPagesSysEndFtraceEvent&&) = default;

bool AllocPagesSysEndFtraceEvent::operator==(const AllocPagesSysEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && gfp_flags_ == other.gfp_flags_
   && order_ == other.order_;
}

bool AllocPagesSysEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 2 /* order */:
        field.get(&order_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AllocPagesSysEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AllocPagesSysEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AllocPagesSysEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gfp_flags
  if (_has_field_[1]) {
    msg->AppendVarInt(1, gfp_flags_);
  }

  // Field 2: order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, order_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent() = default;
AllocPagesIommuStartFtraceEvent::~AllocPagesIommuStartFtraceEvent() = default;
AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(const AllocPagesIommuStartFtraceEvent&) = default;
AllocPagesIommuStartFtraceEvent& AllocPagesIommuStartFtraceEvent::operator=(const AllocPagesIommuStartFtraceEvent&) = default;
AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(AllocPagesIommuStartFtraceEvent&&) noexcept = default;
AllocPagesIommuStartFtraceEvent& AllocPagesIommuStartFtraceEvent::operator=(AllocPagesIommuStartFtraceEvent&&) = default;

bool AllocPagesIommuStartFtraceEvent::operator==(const AllocPagesIommuStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && gfp_flags_ == other.gfp_flags_
   && order_ == other.order_;
}

bool AllocPagesIommuStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 2 /* order */:
        field.get(&order_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AllocPagesIommuStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AllocPagesIommuStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AllocPagesIommuStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gfp_flags
  if (_has_field_[1]) {
    msg->AppendVarInt(1, gfp_flags_);
  }

  // Field 2: order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, order_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent() = default;
AllocPagesIommuFailFtraceEvent::~AllocPagesIommuFailFtraceEvent() = default;
AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(const AllocPagesIommuFailFtraceEvent&) = default;
AllocPagesIommuFailFtraceEvent& AllocPagesIommuFailFtraceEvent::operator=(const AllocPagesIommuFailFtraceEvent&) = default;
AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(AllocPagesIommuFailFtraceEvent&&) noexcept = default;
AllocPagesIommuFailFtraceEvent& AllocPagesIommuFailFtraceEvent::operator=(AllocPagesIommuFailFtraceEvent&&) = default;

bool AllocPagesIommuFailFtraceEvent::operator==(const AllocPagesIommuFailFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && gfp_flags_ == other.gfp_flags_
   && order_ == other.order_;
}

bool AllocPagesIommuFailFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 2 /* order */:
        field.get(&order_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AllocPagesIommuFailFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AllocPagesIommuFailFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AllocPagesIommuFailFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gfp_flags
  if (_has_field_[1]) {
    msg->AppendVarInt(1, gfp_flags_);
  }

  // Field 2: order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, order_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent() = default;
AllocPagesIommuEndFtraceEvent::~AllocPagesIommuEndFtraceEvent() = default;
AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(const AllocPagesIommuEndFtraceEvent&) = default;
AllocPagesIommuEndFtraceEvent& AllocPagesIommuEndFtraceEvent::operator=(const AllocPagesIommuEndFtraceEvent&) = default;
AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(AllocPagesIommuEndFtraceEvent&&) noexcept = default;
AllocPagesIommuEndFtraceEvent& AllocPagesIommuEndFtraceEvent::operator=(AllocPagesIommuEndFtraceEvent&&) = default;

bool AllocPagesIommuEndFtraceEvent::operator==(const AllocPagesIommuEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && gfp_flags_ == other.gfp_flags_
   && order_ == other.order_;
}

bool AllocPagesIommuEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gfp_flags */:
        field.get(&gfp_flags_);
        break;
      case 2 /* order */:
        field.get(&order_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AllocPagesIommuEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AllocPagesIommuEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AllocPagesIommuEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gfp_flags
  if (_has_field_[1]) {
    msg->AppendVarInt(1, gfp_flags_);
  }

  // Field 2: order
  if (_has_field_[2]) {
    msg->AppendVarInt(2, order_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
