// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class RotatorBwAoAsContextFtraceEvent;
class MdpPerfUpdateBusFtraceEvent;
class MdpPerfPrefillCalcFtraceEvent;
class MdpCmdWaitPingpongFtraceEvent;
class MdpVideoUnderrunDoneFtraceEvent;
class MdpPerfSetWmLevelsFtraceEvent;
class MdpMixerUpdateFtraceEvent;
class MdpCmdReleaseBwFtraceEvent;
class MdpTraceCounterFtraceEvent;
class MdpPerfSetQosLutsFtraceEvent;
class MdpMisrCrcFtraceEvent;
class MdpCmdReadptrDoneFtraceEvent;
class MdpSsppSetFtraceEvent;
class MdpPerfSetPanicLutsFtraceEvent;
class MdpCompareBwFtraceEvent;
class MdpCmdPingpongDoneFtraceEvent;
class TracingMarkWriteFtraceEvent;
class MdpSsppChangeFtraceEvent;
class MdpPerfSetOtFtraceEvent;
class MdpCommitFtraceEvent;
class MdpCmdKickoffFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT RotatorBwAoAsContextFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kStateFieldNumber = 1,
  };

  RotatorBwAoAsContextFtraceEvent();
  ~RotatorBwAoAsContextFtraceEvent() override;
  RotatorBwAoAsContextFtraceEvent(RotatorBwAoAsContextFtraceEvent&&) noexcept;
  RotatorBwAoAsContextFtraceEvent& operator=(RotatorBwAoAsContextFtraceEvent&&);
  RotatorBwAoAsContextFtraceEvent(const RotatorBwAoAsContextFtraceEvent&);
  RotatorBwAoAsContextFtraceEvent& operator=(const RotatorBwAoAsContextFtraceEvent&);
  bool operator==(const RotatorBwAoAsContextFtraceEvent&) const;
  bool operator!=(const RotatorBwAoAsContextFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_state() const { return _has_field_[1]; }
  uint32_t state() const { return state_; }
  void set_state(uint32_t value) { state_ = value; _has_field_.set(1); }

 private:
  uint32_t state_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT MdpPerfUpdateBusFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kClientFieldNumber = 1,
    kAbQuotaFieldNumber = 2,
    kIbQuotaFieldNumber = 3,
  };

  MdpPerfUpdateBusFtraceEvent();
  ~MdpPerfUpdateBusFtraceEvent() override;
  MdpPerfUpdateBusFtraceEvent(MdpPerfUpdateBusFtraceEvent&&) noexcept;
  MdpPerfUpdateBusFtraceEvent& operator=(MdpPerfUpdateBusFtraceEvent&&);
  MdpPerfUpdateBusFtraceEvent(const MdpPerfUpdateBusFtraceEvent&);
  MdpPerfUpdateBusFtraceEvent& operator=(const MdpPerfUpdateBusFtraceEvent&);
  bool operator==(const MdpPerfUpdateBusFtraceEvent&) const;
  bool operator!=(const MdpPerfUpdateBusFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_client() const { return _has_field_[1]; }
  int32_t client() const { return client_; }
  void set_client(int32_t value) { client_ = value; _has_field_.set(1); }

  bool has_ab_quota() const { return _has_field_[2]; }
  uint64_t ab_quota() const { return ab_quota_; }
  void set_ab_quota(uint64_t value) { ab_quota_ = value; _has_field_.set(2); }

  bool has_ib_quota() const { return _has_field_[3]; }
  uint64_t ib_quota() const { return ib_quota_; }
  void set_ib_quota(uint64_t value) { ib_quota_ = value; _has_field_.set(3); }

 private:
  int32_t client_{};
  uint64_t ab_quota_{};
  uint64_t ib_quota_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT MdpPerfPrefillCalcFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPnumFieldNumber = 1,
    kLatencyBufFieldNumber = 2,
    kOtFieldNumber = 3,
    kYBufFieldNumber = 4,
    kYScalerFieldNumber = 5,
    kPpLinesFieldNumber = 6,
    kPpBytesFieldNumber = 7,
    kPostScFieldNumber = 8,
    kFbcBytesFieldNumber = 9,
    kPrefillBytesFieldNumber = 10,
  };

  MdpPerfPrefillCalcFtraceEvent();
  ~MdpPerfPrefillCalcFtraceEvent() override;
  MdpPerfPrefillCalcFtraceEvent(MdpPerfPrefillCalcFtraceEvent&&) noexcept;
  MdpPerfPrefillCalcFtraceEvent& operator=(MdpPerfPrefillCalcFtraceEvent&&);
  MdpPerfPrefillCalcFtraceEvent(const MdpPerfPrefillCalcFtraceEvent&);
  MdpPerfPrefillCalcFtraceEvent& operator=(const MdpPerfPrefillCalcFtraceEvent&);
  bool operator==(const MdpPerfPrefillCalcFtraceEvent&) const;
  bool operator!=(const MdpPerfPrefillCalcFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pnum() const { return _has_field_[1]; }
  uint32_t pnum() const { return pnum_; }
  void set_pnum(uint32_t value) { pnum_ = value; _has_field_.set(1); }

  bool has_latency_buf() const { return _has_field_[2]; }
  uint32_t latency_buf() const { return latency_buf_; }
  void set_latency_buf(uint32_t value) { latency_buf_ = value; _has_field_.set(2); }

  bool has_ot() const { return _has_field_[3]; }
  uint32_t ot() const { return ot_; }
  void set_ot(uint32_t value) { ot_ = value; _has_field_.set(3); }

  bool has_y_buf() const { return _has_field_[4]; }
  uint32_t y_buf() const { return y_buf_; }
  void set_y_buf(uint32_t value) { y_buf_ = value; _has_field_.set(4); }

  bool has_y_scaler() const { return _has_field_[5]; }
  uint32_t y_scaler() const { return y_scaler_; }
  void set_y_scaler(uint32_t value) { y_scaler_ = value; _has_field_.set(5); }

  bool has_pp_lines() const { return _has_field_[6]; }
  uint32_t pp_lines() const { return pp_lines_; }
  void set_pp_lines(uint32_t value) { pp_lines_ = value; _has_field_.set(6); }

  bool has_pp_bytes() const { return _has_field_[7]; }
  uint32_t pp_bytes() const { return pp_bytes_; }
  void set_pp_bytes(uint32_t value) { pp_bytes_ = value; _has_field_.set(7); }

  bool has_post_sc() const { return _has_field_[8]; }
  uint32_t post_sc() const { return post_sc_; }
  void set_post_sc(uint32_t value) { post_sc_ = value; _has_field_.set(8); }

  bool has_fbc_bytes() const { return _has_field_[9]; }
  uint32_t fbc_bytes() const { return fbc_bytes_; }
  void set_fbc_bytes(uint32_t value) { fbc_bytes_ = value; _has_field_.set(9); }

  bool has_prefill_bytes() const { return _has_field_[10]; }
  uint32_t prefill_bytes() const { return prefill_bytes_; }
  void set_prefill_bytes(uint32_t value) { prefill_bytes_ = value; _has_field_.set(10); }

 private:
  uint32_t pnum_{};
  uint32_t latency_buf_{};
  uint32_t ot_{};
  uint32_t y_buf_{};
  uint32_t y_scaler_{};
  uint32_t pp_lines_{};
  uint32_t pp_bytes_{};
  uint32_t post_sc_{};
  uint32_t fbc_bytes_{};
  uint32_t prefill_bytes_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT MdpCmdWaitPingpongFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };

  MdpCmdWaitPingpongFtraceEvent();
  ~MdpCmdWaitPingpongFtraceEvent() override;
  MdpCmdWaitPingpongFtraceEvent(MdpCmdWaitPingpongFtraceEvent&&) noexcept;
  MdpCmdWaitPingpongFtraceEvent& operator=(MdpCmdWaitPingpongFtraceEvent&&);
  MdpCmdWaitPingpongFtraceEvent(const MdpCmdWaitPingpongFtraceEvent&);
  MdpCmdWaitPingpongFtraceEvent& operator=(const MdpCmdWaitPingpongFtraceEvent&);
  bool operator==(const MdpCmdWaitPingpongFtraceEvent&) const;
  bool operator!=(const MdpCmdWaitPingpongFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ctl_num() const { return _has_field_[1]; }
  uint32_t ctl_num() const { return ctl_num_; }
  void set_ctl_num(uint32_t value) { ctl_num_ = value; _has_field_.set(1); }

  bool has_kickoff_cnt() const { return _has_field_[2]; }
  int32_t kickoff_cnt() const { return kickoff_cnt_; }
  void set_kickoff_cnt(int32_t value) { kickoff_cnt_ = value; _has_field_.set(2); }

 private:
  uint32_t ctl_num_{};
  int32_t kickoff_cnt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT MdpVideoUnderrunDoneFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCtlNumFieldNumber = 1,
    kUnderrunCntFieldNumber = 2,
  };

  MdpVideoUnderrunDoneFtraceEvent();
  ~MdpVideoUnderrunDoneFtraceEvent() override;
  MdpVideoUnderrunDoneFtraceEvent(MdpVideoUnderrunDoneFtraceEvent&&) noexcept;
  MdpVideoUnderrunDoneFtraceEvent& operator=(MdpVideoUnderrunDoneFtraceEvent&&);
  MdpVideoUnderrunDoneFtraceEvent(const MdpVideoUnderrunDoneFtraceEvent&);
  MdpVideoUnderrunDoneFtraceEvent& operator=(const MdpVideoUnderrunDoneFtraceEvent&);
  bool operator==(const MdpVideoUnderrunDoneFtraceEvent&) const;
  bool operator!=(const MdpVideoUnderrunDoneFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ctl_num() const { return _has_field_[1]; }
  uint32_t ctl_num() const { return ctl_num_; }
  void set_ctl_num(uint32_t value) { ctl_num_ = value; _has_field_.set(1); }

  bool has_underrun_cnt() const { return _has_field_[2]; }
  uint32_t underrun_cnt() const { return underrun_cnt_; }
  void set_underrun_cnt(uint32_t value) { underrun_cnt_ = value; _has_field_.set(2); }

 private:
  uint32_t ctl_num_{};
  uint32_t underrun_cnt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT MdpPerfSetWmLevelsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPnumFieldNumber = 1,
    kUseSpaceFieldNumber = 2,
    kPriorityBytesFieldNumber = 3,
    kWm0FieldNumber = 4,
    kWm1FieldNumber = 5,
    kWm2FieldNumber = 6,
    kMbCntFieldNumber = 7,
    kMbSizeFieldNumber = 8,
  };

  MdpPerfSetWmLevelsFtraceEvent();
  ~MdpPerfSetWmLevelsFtraceEvent() override;
  MdpPerfSetWmLevelsFtraceEvent(MdpPerfSetWmLevelsFtraceEvent&&) noexcept;
  MdpPerfSetWmLevelsFtraceEvent& operator=(MdpPerfSetWmLevelsFtraceEvent&&);
  MdpPerfSetWmLevelsFtraceEvent(const MdpPerfSetWmLevelsFtraceEvent&);
  MdpPerfSetWmLevelsFtraceEvent& operator=(const MdpPerfSetWmLevelsFtraceEvent&);
  bool operator==(const MdpPerfSetWmLevelsFtraceEvent&) const;
  bool operator!=(const MdpPerfSetWmLevelsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pnum() const { return _has_field_[1]; }
  uint32_t pnum() const { return pnum_; }
  void set_pnum(uint32_t value) { pnum_ = value; _has_field_.set(1); }

  bool has_use_space() const { return _has_field_[2]; }
  uint32_t use_space() const { return use_space_; }
  void set_use_space(uint32_t value) { use_space_ = value; _has_field_.set(2); }

  bool has_priority_bytes() const { return _has_field_[3]; }
  uint32_t priority_bytes() const { return priority_bytes_; }
  void set_priority_bytes(uint32_t value) { priority_bytes_ = value; _has_field_.set(3); }

  bool has_wm0() const { return _has_field_[4]; }
  uint32_t wm0() const { return wm0_; }
  void set_wm0(uint32_t value) { wm0_ = value; _has_field_.set(4); }

  bool has_wm1() const { return _has_field_[5]; }
  uint32_t wm1() const { return wm1_; }
  void set_wm1(uint32_t value) { wm1_ = value; _has_field_.set(5); }

  bool has_wm2() const { return _has_field_[6]; }
  uint32_t wm2() const { return wm2_; }
  void set_wm2(uint32_t value) { wm2_ = value; _has_field_.set(6); }

  bool has_mb_cnt() const { return _has_field_[7]; }
  uint32_t mb_cnt() const { return mb_cnt_; }
  void set_mb_cnt(uint32_t value) { mb_cnt_ = value; _has_field_.set(7); }

  bool has_mb_size() const { return _has_field_[8]; }
  uint32_t mb_size() const { return mb_size_; }
  void set_mb_size(uint32_t value) { mb_size_ = value; _has_field_.set(8); }

 private:
  uint32_t pnum_{};
  uint32_t use_space_{};
  uint32_t priority_bytes_{};
  uint32_t wm0_{};
  uint32_t wm1_{};
  uint32_t wm2_{};
  uint32_t mb_cnt_{};
  uint32_t mb_size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT MdpMixerUpdateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kMixerNumFieldNumber = 1,
  };

  MdpMixerUpdateFtraceEvent();
  ~MdpMixerUpdateFtraceEvent() override;
  MdpMixerUpdateFtraceEvent(MdpMixerUpdateFtraceEvent&&) noexcept;
  MdpMixerUpdateFtraceEvent& operator=(MdpMixerUpdateFtraceEvent&&);
  MdpMixerUpdateFtraceEvent(const MdpMixerUpdateFtraceEvent&);
  MdpMixerUpdateFtraceEvent& operator=(const MdpMixerUpdateFtraceEvent&);
  bool operator==(const MdpMixerUpdateFtraceEvent&) const;
  bool operator!=(const MdpMixerUpdateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_mixer_num() const { return _has_field_[1]; }
  uint32_t mixer_num() const { return mixer_num_; }
  void set_mixer_num(uint32_t value) { mixer_num_ = value; _has_field_.set(1); }

 private:
  uint32_t mixer_num_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT MdpCmdReleaseBwFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCtlNumFieldNumber = 1,
  };

  MdpCmdReleaseBwFtraceEvent();
  ~MdpCmdReleaseBwFtraceEvent() override;
  MdpCmdReleaseBwFtraceEvent(MdpCmdReleaseBwFtraceEvent&&) noexcept;
  MdpCmdReleaseBwFtraceEvent& operator=(MdpCmdReleaseBwFtraceEvent&&);
  MdpCmdReleaseBwFtraceEvent(const MdpCmdReleaseBwFtraceEvent&);
  MdpCmdReleaseBwFtraceEvent& operator=(const MdpCmdReleaseBwFtraceEvent&);
  bool operator==(const MdpCmdReleaseBwFtraceEvent&) const;
  bool operator!=(const MdpCmdReleaseBwFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ctl_num() const { return _has_field_[1]; }
  uint32_t ctl_num() const { return ctl_num_; }
  void set_ctl_num(uint32_t value) { ctl_num_ = value; _has_field_.set(1); }

 private:
  uint32_t ctl_num_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT MdpTraceCounterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPidFieldNumber = 1,
    kCounterNameFieldNumber = 2,
    kValueFieldNumber = 3,
  };

  MdpTraceCounterFtraceEvent();
  ~MdpTraceCounterFtraceEvent() override;
  MdpTraceCounterFtraceEvent(MdpTraceCounterFtraceEvent&&) noexcept;
  MdpTraceCounterFtraceEvent& operator=(MdpTraceCounterFtraceEvent&&);
  MdpTraceCounterFtraceEvent(const MdpTraceCounterFtraceEvent&);
  MdpTraceCounterFtraceEvent& operator=(const MdpTraceCounterFtraceEvent&);
  bool operator==(const MdpTraceCounterFtraceEvent&) const;
  bool operator!=(const MdpTraceCounterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pid() const { return _has_field_[1]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(1); }

  bool has_counter_name() const { return _has_field_[2]; }
  const std::string& counter_name() const { return counter_name_; }
  void set_counter_name(const std::string& value) { counter_name_ = value; _has_field_.set(2); }

  bool has_value() const { return _has_field_[3]; }
  int32_t value() const { return value_; }
  void set_value(int32_t value) { value_ = value; _has_field_.set(3); }

 private:
  int32_t pid_{};
  std::string counter_name_{};
  int32_t value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT MdpPerfSetQosLutsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kIntfFieldNumber = 3,
    kRotFieldNumber = 4,
    kFlFieldNumber = 5,
    kLutFieldNumber = 6,
    kLinearFieldNumber = 7,
  };

  MdpPerfSetQosLutsFtraceEvent();
  ~MdpPerfSetQosLutsFtraceEvent() override;
  MdpPerfSetQosLutsFtraceEvent(MdpPerfSetQosLutsFtraceEvent&&) noexcept;
  MdpPerfSetQosLutsFtraceEvent& operator=(MdpPerfSetQosLutsFtraceEvent&&);
  MdpPerfSetQosLutsFtraceEvent(const MdpPerfSetQosLutsFtraceEvent&);
  MdpPerfSetQosLutsFtraceEvent& operator=(const MdpPerfSetQosLutsFtraceEvent&);
  bool operator==(const MdpPerfSetQosLutsFtraceEvent&) const;
  bool operator!=(const MdpPerfSetQosLutsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pnum() const { return _has_field_[1]; }
  uint32_t pnum() const { return pnum_; }
  void set_pnum(uint32_t value) { pnum_ = value; _has_field_.set(1); }

  bool has_fmt() const { return _has_field_[2]; }
  uint32_t fmt() const { return fmt_; }
  void set_fmt(uint32_t value) { fmt_ = value; _has_field_.set(2); }

  bool has_intf() const { return _has_field_[3]; }
  uint32_t intf() const { return intf_; }
  void set_intf(uint32_t value) { intf_ = value; _has_field_.set(3); }

  bool has_rot() const { return _has_field_[4]; }
  uint32_t rot() const { return rot_; }
  void set_rot(uint32_t value) { rot_ = value; _has_field_.set(4); }

  bool has_fl() const { return _has_field_[5]; }
  uint32_t fl() const { return fl_; }
  void set_fl(uint32_t value) { fl_ = value; _has_field_.set(5); }

  bool has_lut() const { return _has_field_[6]; }
  uint32_t lut() const { return lut_; }
  void set_lut(uint32_t value) { lut_ = value; _has_field_.set(6); }

  bool has_linear() const { return _has_field_[7]; }
  uint32_t linear() const { return linear_; }
  void set_linear(uint32_t value) { linear_ = value; _has_field_.set(7); }

 private:
  uint32_t pnum_{};
  uint32_t fmt_{};
  uint32_t intf_{};
  uint32_t rot_{};
  uint32_t fl_{};
  uint32_t lut_{};
  uint32_t linear_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT MdpMisrCrcFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBlockIdFieldNumber = 1,
    kVsyncCntFieldNumber = 2,
    kCrcFieldNumber = 3,
  };

  MdpMisrCrcFtraceEvent();
  ~MdpMisrCrcFtraceEvent() override;
  MdpMisrCrcFtraceEvent(MdpMisrCrcFtraceEvent&&) noexcept;
  MdpMisrCrcFtraceEvent& operator=(MdpMisrCrcFtraceEvent&&);
  MdpMisrCrcFtraceEvent(const MdpMisrCrcFtraceEvent&);
  MdpMisrCrcFtraceEvent& operator=(const MdpMisrCrcFtraceEvent&);
  bool operator==(const MdpMisrCrcFtraceEvent&) const;
  bool operator!=(const MdpMisrCrcFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_block_id() const { return _has_field_[1]; }
  uint32_t block_id() const { return block_id_; }
  void set_block_id(uint32_t value) { block_id_ = value; _has_field_.set(1); }

  bool has_vsync_cnt() const { return _has_field_[2]; }
  uint32_t vsync_cnt() const { return vsync_cnt_; }
  void set_vsync_cnt(uint32_t value) { vsync_cnt_ = value; _has_field_.set(2); }

  bool has_crc() const { return _has_field_[3]; }
  uint32_t crc() const { return crc_; }
  void set_crc(uint32_t value) { crc_ = value; _has_field_.set(3); }

 private:
  uint32_t block_id_{};
  uint32_t vsync_cnt_{};
  uint32_t crc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT MdpCmdReadptrDoneFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCtlNumFieldNumber = 1,
    kKoffCntFieldNumber = 2,
  };

  MdpCmdReadptrDoneFtraceEvent();
  ~MdpCmdReadptrDoneFtraceEvent() override;
  MdpCmdReadptrDoneFtraceEvent(MdpCmdReadptrDoneFtraceEvent&&) noexcept;
  MdpCmdReadptrDoneFtraceEvent& operator=(MdpCmdReadptrDoneFtraceEvent&&);
  MdpCmdReadptrDoneFtraceEvent(const MdpCmdReadptrDoneFtraceEvent&);
  MdpCmdReadptrDoneFtraceEvent& operator=(const MdpCmdReadptrDoneFtraceEvent&);
  bool operator==(const MdpCmdReadptrDoneFtraceEvent&) const;
  bool operator!=(const MdpCmdReadptrDoneFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ctl_num() const { return _has_field_[1]; }
  uint32_t ctl_num() const { return ctl_num_; }
  void set_ctl_num(uint32_t value) { ctl_num_ = value; _has_field_.set(1); }

  bool has_koff_cnt() const { return _has_field_[2]; }
  int32_t koff_cnt() const { return koff_cnt_; }
  void set_koff_cnt(int32_t value) { koff_cnt_ = value; _has_field_.set(2); }

 private:
  uint32_t ctl_num_{};
  int32_t koff_cnt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT MdpSsppSetFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };

  MdpSsppSetFtraceEvent();
  ~MdpSsppSetFtraceEvent() override;
  MdpSsppSetFtraceEvent(MdpSsppSetFtraceEvent&&) noexcept;
  MdpSsppSetFtraceEvent& operator=(MdpSsppSetFtraceEvent&&);
  MdpSsppSetFtraceEvent(const MdpSsppSetFtraceEvent&);
  MdpSsppSetFtraceEvent& operator=(const MdpSsppSetFtraceEvent&);
  bool operator==(const MdpSsppSetFtraceEvent&) const;
  bool operator!=(const MdpSsppSetFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_num() const { return _has_field_[1]; }
  uint32_t num() const { return num_; }
  void set_num(uint32_t value) { num_ = value; _has_field_.set(1); }

  bool has_play_cnt() const { return _has_field_[2]; }
  uint32_t play_cnt() const { return play_cnt_; }
  void set_play_cnt(uint32_t value) { play_cnt_ = value; _has_field_.set(2); }

  bool has_mixer() const { return _has_field_[3]; }
  uint32_t mixer() const { return mixer_; }
  void set_mixer(uint32_t value) { mixer_ = value; _has_field_.set(3); }

  bool has_stage() const { return _has_field_[4]; }
  uint32_t stage() const { return stage_; }
  void set_stage(uint32_t value) { stage_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

  bool has_format() const { return _has_field_[6]; }
  uint32_t format() const { return format_; }
  void set_format(uint32_t value) { format_ = value; _has_field_.set(6); }

  bool has_img_w() const { return _has_field_[7]; }
  uint32_t img_w() const { return img_w_; }
  void set_img_w(uint32_t value) { img_w_ = value; _has_field_.set(7); }

  bool has_img_h() const { return _has_field_[8]; }
  uint32_t img_h() const { return img_h_; }
  void set_img_h(uint32_t value) { img_h_ = value; _has_field_.set(8); }

  bool has_src_x() const { return _has_field_[9]; }
  uint32_t src_x() const { return src_x_; }
  void set_src_x(uint32_t value) { src_x_ = value; _has_field_.set(9); }

  bool has_src_y() const { return _has_field_[10]; }
  uint32_t src_y() const { return src_y_; }
  void set_src_y(uint32_t value) { src_y_ = value; _has_field_.set(10); }

  bool has_src_w() const { return _has_field_[11]; }
  uint32_t src_w() const { return src_w_; }
  void set_src_w(uint32_t value) { src_w_ = value; _has_field_.set(11); }

  bool has_src_h() const { return _has_field_[12]; }
  uint32_t src_h() const { return src_h_; }
  void set_src_h(uint32_t value) { src_h_ = value; _has_field_.set(12); }

  bool has_dst_x() const { return _has_field_[13]; }
  uint32_t dst_x() const { return dst_x_; }
  void set_dst_x(uint32_t value) { dst_x_ = value; _has_field_.set(13); }

  bool has_dst_y() const { return _has_field_[14]; }
  uint32_t dst_y() const { return dst_y_; }
  void set_dst_y(uint32_t value) { dst_y_ = value; _has_field_.set(14); }

  bool has_dst_w() const { return _has_field_[15]; }
  uint32_t dst_w() const { return dst_w_; }
  void set_dst_w(uint32_t value) { dst_w_ = value; _has_field_.set(15); }

  bool has_dst_h() const { return _has_field_[16]; }
  uint32_t dst_h() const { return dst_h_; }
  void set_dst_h(uint32_t value) { dst_h_ = value; _has_field_.set(16); }

 private:
  uint32_t num_{};
  uint32_t play_cnt_{};
  uint32_t mixer_{};
  uint32_t stage_{};
  uint32_t flags_{};
  uint32_t format_{};
  uint32_t img_w_{};
  uint32_t img_h_{};
  uint32_t src_x_{};
  uint32_t src_y_{};
  uint32_t src_w_{};
  uint32_t src_h_{};
  uint32_t dst_x_{};
  uint32_t dst_y_{};
  uint32_t dst_w_{};
  uint32_t dst_h_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<17> _has_field_{};
};


class PERFETTO_EXPORT MdpPerfSetPanicLutsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kModeFieldNumber = 3,
    kPanicLutFieldNumber = 4,
    kRobustLutFieldNumber = 5,
  };

  MdpPerfSetPanicLutsFtraceEvent();
  ~MdpPerfSetPanicLutsFtraceEvent() override;
  MdpPerfSetPanicLutsFtraceEvent(MdpPerfSetPanicLutsFtraceEvent&&) noexcept;
  MdpPerfSetPanicLutsFtraceEvent& operator=(MdpPerfSetPanicLutsFtraceEvent&&);
  MdpPerfSetPanicLutsFtraceEvent(const MdpPerfSetPanicLutsFtraceEvent&);
  MdpPerfSetPanicLutsFtraceEvent& operator=(const MdpPerfSetPanicLutsFtraceEvent&);
  bool operator==(const MdpPerfSetPanicLutsFtraceEvent&) const;
  bool operator!=(const MdpPerfSetPanicLutsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pnum() const { return _has_field_[1]; }
  uint32_t pnum() const { return pnum_; }
  void set_pnum(uint32_t value) { pnum_ = value; _has_field_.set(1); }

  bool has_fmt() const { return _has_field_[2]; }
  uint32_t fmt() const { return fmt_; }
  void set_fmt(uint32_t value) { fmt_ = value; _has_field_.set(2); }

  bool has_mode() const { return _has_field_[3]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(3); }

  bool has_panic_lut() const { return _has_field_[4]; }
  uint32_t panic_lut() const { return panic_lut_; }
  void set_panic_lut(uint32_t value) { panic_lut_ = value; _has_field_.set(4); }

  bool has_robust_lut() const { return _has_field_[5]; }
  uint32_t robust_lut() const { return robust_lut_; }
  void set_robust_lut(uint32_t value) { robust_lut_ = value; _has_field_.set(5); }

 private:
  uint32_t pnum_{};
  uint32_t fmt_{};
  uint32_t mode_{};
  uint32_t panic_lut_{};
  uint32_t robust_lut_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT MdpCompareBwFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNewAbFieldNumber = 1,
    kNewIbFieldNumber = 2,
    kNewWbFieldNumber = 3,
    kOldAbFieldNumber = 4,
    kOldIbFieldNumber = 5,
    kOldWbFieldNumber = 6,
    kParamsChangedFieldNumber = 7,
    kUpdateBwFieldNumber = 8,
  };

  MdpCompareBwFtraceEvent();
  ~MdpCompareBwFtraceEvent() override;
  MdpCompareBwFtraceEvent(MdpCompareBwFtraceEvent&&) noexcept;
  MdpCompareBwFtraceEvent& operator=(MdpCompareBwFtraceEvent&&);
  MdpCompareBwFtraceEvent(const MdpCompareBwFtraceEvent&);
  MdpCompareBwFtraceEvent& operator=(const MdpCompareBwFtraceEvent&);
  bool operator==(const MdpCompareBwFtraceEvent&) const;
  bool operator!=(const MdpCompareBwFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_new_ab() const { return _has_field_[1]; }
  uint64_t new_ab() const { return new_ab_; }
  void set_new_ab(uint64_t value) { new_ab_ = value; _has_field_.set(1); }

  bool has_new_ib() const { return _has_field_[2]; }
  uint64_t new_ib() const { return new_ib_; }
  void set_new_ib(uint64_t value) { new_ib_ = value; _has_field_.set(2); }

  bool has_new_wb() const { return _has_field_[3]; }
  uint64_t new_wb() const { return new_wb_; }
  void set_new_wb(uint64_t value) { new_wb_ = value; _has_field_.set(3); }

  bool has_old_ab() const { return _has_field_[4]; }
  uint64_t old_ab() const { return old_ab_; }
  void set_old_ab(uint64_t value) { old_ab_ = value; _has_field_.set(4); }

  bool has_old_ib() const { return _has_field_[5]; }
  uint64_t old_ib() const { return old_ib_; }
  void set_old_ib(uint64_t value) { old_ib_ = value; _has_field_.set(5); }

  bool has_old_wb() const { return _has_field_[6]; }
  uint64_t old_wb() const { return old_wb_; }
  void set_old_wb(uint64_t value) { old_wb_ = value; _has_field_.set(6); }

  bool has_params_changed() const { return _has_field_[7]; }
  uint32_t params_changed() const { return params_changed_; }
  void set_params_changed(uint32_t value) { params_changed_ = value; _has_field_.set(7); }

  bool has_update_bw() const { return _has_field_[8]; }
  uint32_t update_bw() const { return update_bw_; }
  void set_update_bw(uint32_t value) { update_bw_ = value; _has_field_.set(8); }

 private:
  uint64_t new_ab_{};
  uint64_t new_ib_{};
  uint64_t new_wb_{};
  uint64_t old_ab_{};
  uint64_t old_ib_{};
  uint64_t old_wb_{};
  uint32_t params_changed_{};
  uint32_t update_bw_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT MdpCmdPingpongDoneFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCtlNumFieldNumber = 1,
    kIntfNumFieldNumber = 2,
    kPpNumFieldNumber = 3,
    kKoffCntFieldNumber = 4,
  };

  MdpCmdPingpongDoneFtraceEvent();
  ~MdpCmdPingpongDoneFtraceEvent() override;
  MdpCmdPingpongDoneFtraceEvent(MdpCmdPingpongDoneFtraceEvent&&) noexcept;
  MdpCmdPingpongDoneFtraceEvent& operator=(MdpCmdPingpongDoneFtraceEvent&&);
  MdpCmdPingpongDoneFtraceEvent(const MdpCmdPingpongDoneFtraceEvent&);
  MdpCmdPingpongDoneFtraceEvent& operator=(const MdpCmdPingpongDoneFtraceEvent&);
  bool operator==(const MdpCmdPingpongDoneFtraceEvent&) const;
  bool operator!=(const MdpCmdPingpongDoneFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ctl_num() const { return _has_field_[1]; }
  uint32_t ctl_num() const { return ctl_num_; }
  void set_ctl_num(uint32_t value) { ctl_num_ = value; _has_field_.set(1); }

  bool has_intf_num() const { return _has_field_[2]; }
  uint32_t intf_num() const { return intf_num_; }
  void set_intf_num(uint32_t value) { intf_num_ = value; _has_field_.set(2); }

  bool has_pp_num() const { return _has_field_[3]; }
  uint32_t pp_num() const { return pp_num_; }
  void set_pp_num(uint32_t value) { pp_num_ = value; _has_field_.set(3); }

  bool has_koff_cnt() const { return _has_field_[4]; }
  int32_t koff_cnt() const { return koff_cnt_; }
  void set_koff_cnt(int32_t value) { koff_cnt_ = value; _has_field_.set(4); }

 private:
  uint32_t ctl_num_{};
  uint32_t intf_num_{};
  uint32_t pp_num_{};
  int32_t koff_cnt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT TracingMarkWriteFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPidFieldNumber = 1,
    kTraceNameFieldNumber = 2,
    kTraceBeginFieldNumber = 3,
  };

  TracingMarkWriteFtraceEvent();
  ~TracingMarkWriteFtraceEvent() override;
  TracingMarkWriteFtraceEvent(TracingMarkWriteFtraceEvent&&) noexcept;
  TracingMarkWriteFtraceEvent& operator=(TracingMarkWriteFtraceEvent&&);
  TracingMarkWriteFtraceEvent(const TracingMarkWriteFtraceEvent&);
  TracingMarkWriteFtraceEvent& operator=(const TracingMarkWriteFtraceEvent&);
  bool operator==(const TracingMarkWriteFtraceEvent&) const;
  bool operator!=(const TracingMarkWriteFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pid() const { return _has_field_[1]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(1); }

  bool has_trace_name() const { return _has_field_[2]; }
  const std::string& trace_name() const { return trace_name_; }
  void set_trace_name(const std::string& value) { trace_name_ = value; _has_field_.set(2); }

  bool has_trace_begin() const { return _has_field_[3]; }
  uint32_t trace_begin() const { return trace_begin_; }
  void set_trace_begin(uint32_t value) { trace_begin_ = value; _has_field_.set(3); }

 private:
  int32_t pid_{};
  std::string trace_name_{};
  uint32_t trace_begin_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT MdpSsppChangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };

  MdpSsppChangeFtraceEvent();
  ~MdpSsppChangeFtraceEvent() override;
  MdpSsppChangeFtraceEvent(MdpSsppChangeFtraceEvent&&) noexcept;
  MdpSsppChangeFtraceEvent& operator=(MdpSsppChangeFtraceEvent&&);
  MdpSsppChangeFtraceEvent(const MdpSsppChangeFtraceEvent&);
  MdpSsppChangeFtraceEvent& operator=(const MdpSsppChangeFtraceEvent&);
  bool operator==(const MdpSsppChangeFtraceEvent&) const;
  bool operator!=(const MdpSsppChangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_num() const { return _has_field_[1]; }
  uint32_t num() const { return num_; }
  void set_num(uint32_t value) { num_ = value; _has_field_.set(1); }

  bool has_play_cnt() const { return _has_field_[2]; }
  uint32_t play_cnt() const { return play_cnt_; }
  void set_play_cnt(uint32_t value) { play_cnt_ = value; _has_field_.set(2); }

  bool has_mixer() const { return _has_field_[3]; }
  uint32_t mixer() const { return mixer_; }
  void set_mixer(uint32_t value) { mixer_ = value; _has_field_.set(3); }

  bool has_stage() const { return _has_field_[4]; }
  uint32_t stage() const { return stage_; }
  void set_stage(uint32_t value) { stage_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

  bool has_format() const { return _has_field_[6]; }
  uint32_t format() const { return format_; }
  void set_format(uint32_t value) { format_ = value; _has_field_.set(6); }

  bool has_img_w() const { return _has_field_[7]; }
  uint32_t img_w() const { return img_w_; }
  void set_img_w(uint32_t value) { img_w_ = value; _has_field_.set(7); }

  bool has_img_h() const { return _has_field_[8]; }
  uint32_t img_h() const { return img_h_; }
  void set_img_h(uint32_t value) { img_h_ = value; _has_field_.set(8); }

  bool has_src_x() const { return _has_field_[9]; }
  uint32_t src_x() const { return src_x_; }
  void set_src_x(uint32_t value) { src_x_ = value; _has_field_.set(9); }

  bool has_src_y() const { return _has_field_[10]; }
  uint32_t src_y() const { return src_y_; }
  void set_src_y(uint32_t value) { src_y_ = value; _has_field_.set(10); }

  bool has_src_w() const { return _has_field_[11]; }
  uint32_t src_w() const { return src_w_; }
  void set_src_w(uint32_t value) { src_w_ = value; _has_field_.set(11); }

  bool has_src_h() const { return _has_field_[12]; }
  uint32_t src_h() const { return src_h_; }
  void set_src_h(uint32_t value) { src_h_ = value; _has_field_.set(12); }

  bool has_dst_x() const { return _has_field_[13]; }
  uint32_t dst_x() const { return dst_x_; }
  void set_dst_x(uint32_t value) { dst_x_ = value; _has_field_.set(13); }

  bool has_dst_y() const { return _has_field_[14]; }
  uint32_t dst_y() const { return dst_y_; }
  void set_dst_y(uint32_t value) { dst_y_ = value; _has_field_.set(14); }

  bool has_dst_w() const { return _has_field_[15]; }
  uint32_t dst_w() const { return dst_w_; }
  void set_dst_w(uint32_t value) { dst_w_ = value; _has_field_.set(15); }

  bool has_dst_h() const { return _has_field_[16]; }
  uint32_t dst_h() const { return dst_h_; }
  void set_dst_h(uint32_t value) { dst_h_ = value; _has_field_.set(16); }

 private:
  uint32_t num_{};
  uint32_t play_cnt_{};
  uint32_t mixer_{};
  uint32_t stage_{};
  uint32_t flags_{};
  uint32_t format_{};
  uint32_t img_w_{};
  uint32_t img_h_{};
  uint32_t src_x_{};
  uint32_t src_y_{};
  uint32_t src_w_{};
  uint32_t src_h_{};
  uint32_t dst_x_{};
  uint32_t dst_y_{};
  uint32_t dst_w_{};
  uint32_t dst_h_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<17> _has_field_{};
};


class PERFETTO_EXPORT MdpPerfSetOtFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPnumFieldNumber = 1,
    kXinIdFieldNumber = 2,
    kRdLimFieldNumber = 3,
    kIsVbifRtFieldNumber = 4,
  };

  MdpPerfSetOtFtraceEvent();
  ~MdpPerfSetOtFtraceEvent() override;
  MdpPerfSetOtFtraceEvent(MdpPerfSetOtFtraceEvent&&) noexcept;
  MdpPerfSetOtFtraceEvent& operator=(MdpPerfSetOtFtraceEvent&&);
  MdpPerfSetOtFtraceEvent(const MdpPerfSetOtFtraceEvent&);
  MdpPerfSetOtFtraceEvent& operator=(const MdpPerfSetOtFtraceEvent&);
  bool operator==(const MdpPerfSetOtFtraceEvent&) const;
  bool operator!=(const MdpPerfSetOtFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pnum() const { return _has_field_[1]; }
  uint32_t pnum() const { return pnum_; }
  void set_pnum(uint32_t value) { pnum_ = value; _has_field_.set(1); }

  bool has_xin_id() const { return _has_field_[2]; }
  uint32_t xin_id() const { return xin_id_; }
  void set_xin_id(uint32_t value) { xin_id_ = value; _has_field_.set(2); }

  bool has_rd_lim() const { return _has_field_[3]; }
  uint32_t rd_lim() const { return rd_lim_; }
  void set_rd_lim(uint32_t value) { rd_lim_ = value; _has_field_.set(3); }

  bool has_is_vbif_rt() const { return _has_field_[4]; }
  uint32_t is_vbif_rt() const { return is_vbif_rt_; }
  void set_is_vbif_rt(uint32_t value) { is_vbif_rt_ = value; _has_field_.set(4); }

 private:
  uint32_t pnum_{};
  uint32_t xin_id_{};
  uint32_t rd_lim_{};
  uint32_t is_vbif_rt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT MdpCommitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kClkRateFieldNumber = 3,
    kBandwidthFieldNumber = 4,
  };

  MdpCommitFtraceEvent();
  ~MdpCommitFtraceEvent() override;
  MdpCommitFtraceEvent(MdpCommitFtraceEvent&&) noexcept;
  MdpCommitFtraceEvent& operator=(MdpCommitFtraceEvent&&);
  MdpCommitFtraceEvent(const MdpCommitFtraceEvent&);
  MdpCommitFtraceEvent& operator=(const MdpCommitFtraceEvent&);
  bool operator==(const MdpCommitFtraceEvent&) const;
  bool operator!=(const MdpCommitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_num() const { return _has_field_[1]; }
  uint32_t num() const { return num_; }
  void set_num(uint32_t value) { num_ = value; _has_field_.set(1); }

  bool has_play_cnt() const { return _has_field_[2]; }
  uint32_t play_cnt() const { return play_cnt_; }
  void set_play_cnt(uint32_t value) { play_cnt_ = value; _has_field_.set(2); }

  bool has_clk_rate() const { return _has_field_[3]; }
  uint32_t clk_rate() const { return clk_rate_; }
  void set_clk_rate(uint32_t value) { clk_rate_ = value; _has_field_.set(3); }

  bool has_bandwidth() const { return _has_field_[4]; }
  uint64_t bandwidth() const { return bandwidth_; }
  void set_bandwidth(uint64_t value) { bandwidth_ = value; _has_field_.set(4); }

 private:
  uint32_t num_{};
  uint32_t play_cnt_{};
  uint32_t clk_rate_{};
  uint64_t bandwidth_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT MdpCmdKickoffFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };

  MdpCmdKickoffFtraceEvent();
  ~MdpCmdKickoffFtraceEvent() override;
  MdpCmdKickoffFtraceEvent(MdpCmdKickoffFtraceEvent&&) noexcept;
  MdpCmdKickoffFtraceEvent& operator=(MdpCmdKickoffFtraceEvent&&);
  MdpCmdKickoffFtraceEvent(const MdpCmdKickoffFtraceEvent&);
  MdpCmdKickoffFtraceEvent& operator=(const MdpCmdKickoffFtraceEvent&);
  bool operator==(const MdpCmdKickoffFtraceEvent&) const;
  bool operator!=(const MdpCmdKickoffFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ctl_num() const { return _has_field_[1]; }
  uint32_t ctl_num() const { return ctl_num_; }
  void set_ctl_num(uint32_t value) { ctl_num_ = value; _has_field_.set(1); }

  bool has_kickoff_cnt() const { return _has_field_[2]; }
  int32_t kickoff_cnt() const { return kickoff_cnt_; }
  void set_kickoff_cnt(int32_t value) { kickoff_cnt_ = value; _has_field_.set(2); }

 private:
  uint32_t ctl_num_{};
  int32_t kickoff_cnt_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_CPP_H_
