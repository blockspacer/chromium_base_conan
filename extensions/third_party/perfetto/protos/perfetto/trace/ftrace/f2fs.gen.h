// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class F2fsWriteEndFtraceEvent;
class F2fsWriteCheckpointFtraceEvent;
class F2fsWriteBeginFtraceEvent;
class F2fsVmPageMkwriteFtraceEvent;
class F2fsUnlinkExitFtraceEvent;
class F2fsUnlinkEnterFtraceEvent;
class F2fsTruncatePartialNodesFtraceEvent;
class F2fsTruncateNodesExitFtraceEvent;
class F2fsTruncateNodesEnterFtraceEvent;
class F2fsTruncateNodeFtraceEvent;
class F2fsTruncateInodeBlocksExitFtraceEvent;
class F2fsTruncateInodeBlocksEnterFtraceEvent;
class F2fsTruncateDataBlocksRangeFtraceEvent;
class F2fsTruncateBlocksExitFtraceEvent;
class F2fsTruncateBlocksEnterFtraceEvent;
class F2fsTruncateFtraceEvent;
class F2fsSyncFsFtraceEvent;
class F2fsSyncFileExitFtraceEvent;
class F2fsSyncFileEnterFtraceEvent;
class F2fsSubmitWritePageFtraceEvent;
class F2fsSetPageDirtyFtraceEvent;
class F2fsReserveNewBlockFtraceEvent;
class F2fsReadpageFtraceEvent;
class F2fsNewInodeFtraceEvent;
class F2fsIgetExitFtraceEvent;
class F2fsIgetFtraceEvent;
class F2fsGetVictimFtraceEvent;
class F2fsGetDataBlockFtraceEvent;
class F2fsFallocateFtraceEvent;
class F2fsEvictInodeFtraceEvent;
class F2fsDoSubmitBioFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT F2fsWriteEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };

  F2fsWriteEndFtraceEvent();
  ~F2fsWriteEndFtraceEvent() override;
  F2fsWriteEndFtraceEvent(F2fsWriteEndFtraceEvent&&) noexcept;
  F2fsWriteEndFtraceEvent& operator=(F2fsWriteEndFtraceEvent&&);
  F2fsWriteEndFtraceEvent(const F2fsWriteEndFtraceEvent&);
  F2fsWriteEndFtraceEvent& operator=(const F2fsWriteEndFtraceEvent&);
  bool operator==(const F2fsWriteEndFtraceEvent&) const;
  bool operator!=(const F2fsWriteEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_copied() const { return _has_field_[5]; }
  uint32_t copied() const { return copied_; }
  void set_copied(uint32_t value) { copied_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t copied_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsWriteCheckpointFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kIsUmountFieldNumber = 2,
    kMsgFieldNumber = 3,
  };

  F2fsWriteCheckpointFtraceEvent();
  ~F2fsWriteCheckpointFtraceEvent() override;
  F2fsWriteCheckpointFtraceEvent(F2fsWriteCheckpointFtraceEvent&&) noexcept;
  F2fsWriteCheckpointFtraceEvent& operator=(F2fsWriteCheckpointFtraceEvent&&);
  F2fsWriteCheckpointFtraceEvent(const F2fsWriteCheckpointFtraceEvent&);
  F2fsWriteCheckpointFtraceEvent& operator=(const F2fsWriteCheckpointFtraceEvent&);
  bool operator==(const F2fsWriteCheckpointFtraceEvent&) const;
  bool operator!=(const F2fsWriteCheckpointFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_is_umount() const { return _has_field_[2]; }
  uint32_t is_umount() const { return is_umount_; }
  void set_is_umount(uint32_t value) { is_umount_ = value; _has_field_.set(2); }

  bool has_msg() const { return _has_field_[3]; }
  const std::string& msg() const { return msg_; }
  void set_msg(const std::string& value) { msg_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint32_t is_umount_{};
  std::string msg_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsWriteBeginFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };

  F2fsWriteBeginFtraceEvent();
  ~F2fsWriteBeginFtraceEvent() override;
  F2fsWriteBeginFtraceEvent(F2fsWriteBeginFtraceEvent&&) noexcept;
  F2fsWriteBeginFtraceEvent& operator=(F2fsWriteBeginFtraceEvent&&);
  F2fsWriteBeginFtraceEvent(const F2fsWriteBeginFtraceEvent&);
  F2fsWriteBeginFtraceEvent& operator=(const F2fsWriteBeginFtraceEvent&);
  bool operator==(const F2fsWriteBeginFtraceEvent&) const;
  bool operator!=(const F2fsWriteBeginFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsVmPageMkwriteFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
  };

  F2fsVmPageMkwriteFtraceEvent();
  ~F2fsVmPageMkwriteFtraceEvent() override;
  F2fsVmPageMkwriteFtraceEvent(F2fsVmPageMkwriteFtraceEvent&&) noexcept;
  F2fsVmPageMkwriteFtraceEvent& operator=(F2fsVmPageMkwriteFtraceEvent&&);
  F2fsVmPageMkwriteFtraceEvent(const F2fsVmPageMkwriteFtraceEvent&);
  F2fsVmPageMkwriteFtraceEvent& operator=(const F2fsVmPageMkwriteFtraceEvent&);
  bool operator==(const F2fsVmPageMkwriteFtraceEvent&) const;
  bool operator!=(const F2fsVmPageMkwriteFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(3); }

  bool has_dir() const { return _has_field_[4]; }
  int32_t dir() const { return dir_; }
  void set_dir(int32_t value) { dir_ = value; _has_field_.set(4); }

  bool has_index() const { return _has_field_[5]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(5); }

  bool has_dirty() const { return _has_field_[6]; }
  int32_t dirty() const { return dirty_; }
  void set_dirty(int32_t value) { dirty_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t type_{};
  int32_t dir_{};
  uint64_t index_{};
  int32_t dirty_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT F2fsUnlinkExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsUnlinkExitFtraceEvent();
  ~F2fsUnlinkExitFtraceEvent() override;
  F2fsUnlinkExitFtraceEvent(F2fsUnlinkExitFtraceEvent&&) noexcept;
  F2fsUnlinkExitFtraceEvent& operator=(F2fsUnlinkExitFtraceEvent&&);
  F2fsUnlinkExitFtraceEvent(const F2fsUnlinkExitFtraceEvent&);
  F2fsUnlinkExitFtraceEvent& operator=(const F2fsUnlinkExitFtraceEvent&);
  bool operator==(const F2fsUnlinkExitFtraceEvent&) const;
  bool operator!=(const F2fsUnlinkExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsUnlinkEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kNameFieldNumber = 5,
  };

  F2fsUnlinkEnterFtraceEvent();
  ~F2fsUnlinkEnterFtraceEvent() override;
  F2fsUnlinkEnterFtraceEvent(F2fsUnlinkEnterFtraceEvent&&) noexcept;
  F2fsUnlinkEnterFtraceEvent& operator=(F2fsUnlinkEnterFtraceEvent&&);
  F2fsUnlinkEnterFtraceEvent(const F2fsUnlinkEnterFtraceEvent&);
  F2fsUnlinkEnterFtraceEvent& operator=(const F2fsUnlinkEnterFtraceEvent&);
  bool operator==(const F2fsUnlinkEnterFtraceEvent&) const;
  bool operator!=(const F2fsUnlinkEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_size() const { return _has_field_[3]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(3); }

  bool has_blocks() const { return _has_field_[4]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(4); }

  bool has_name() const { return _has_field_[5]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t size_{};
  uint64_t blocks_{};
  std::string name_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncatePartialNodesFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kDepthFieldNumber = 4,
    kErrFieldNumber = 5,
  };

  F2fsTruncatePartialNodesFtraceEvent();
  ~F2fsTruncatePartialNodesFtraceEvent() override;
  F2fsTruncatePartialNodesFtraceEvent(F2fsTruncatePartialNodesFtraceEvent&&) noexcept;
  F2fsTruncatePartialNodesFtraceEvent& operator=(F2fsTruncatePartialNodesFtraceEvent&&);
  F2fsTruncatePartialNodesFtraceEvent(const F2fsTruncatePartialNodesFtraceEvent&);
  F2fsTruncatePartialNodesFtraceEvent& operator=(const F2fsTruncatePartialNodesFtraceEvent&);
  bool operator==(const F2fsTruncatePartialNodesFtraceEvent&) const;
  bool operator!=(const F2fsTruncatePartialNodesFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nid() const { return _has_field_[3]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(3); }

  bool has_depth() const { return _has_field_[4]; }
  int32_t depth() const { return depth_; }
  void set_depth(int32_t value) { depth_ = value; _has_field_.set(4); }

  bool has_err() const { return _has_field_[5]; }
  int32_t err() const { return err_; }
  void set_err(int32_t value) { err_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t nid_{};
  int32_t depth_{};
  int32_t err_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateNodesExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsTruncateNodesExitFtraceEvent();
  ~F2fsTruncateNodesExitFtraceEvent() override;
  F2fsTruncateNodesExitFtraceEvent(F2fsTruncateNodesExitFtraceEvent&&) noexcept;
  F2fsTruncateNodesExitFtraceEvent& operator=(F2fsTruncateNodesExitFtraceEvent&&);
  F2fsTruncateNodesExitFtraceEvent(const F2fsTruncateNodesExitFtraceEvent&);
  F2fsTruncateNodesExitFtraceEvent& operator=(const F2fsTruncateNodesExitFtraceEvent&);
  bool operator==(const F2fsTruncateNodesExitFtraceEvent&) const;
  bool operator!=(const F2fsTruncateNodesExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateNodesEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };

  F2fsTruncateNodesEnterFtraceEvent();
  ~F2fsTruncateNodesEnterFtraceEvent() override;
  F2fsTruncateNodesEnterFtraceEvent(F2fsTruncateNodesEnterFtraceEvent&&) noexcept;
  F2fsTruncateNodesEnterFtraceEvent& operator=(F2fsTruncateNodesEnterFtraceEvent&&);
  F2fsTruncateNodesEnterFtraceEvent(const F2fsTruncateNodesEnterFtraceEvent&);
  F2fsTruncateNodesEnterFtraceEvent& operator=(const F2fsTruncateNodesEnterFtraceEvent&);
  bool operator==(const F2fsTruncateNodesEnterFtraceEvent&) const;
  bool operator!=(const F2fsTruncateNodesEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nid() const { return _has_field_[3]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(3); }

  bool has_blk_addr() const { return _has_field_[4]; }
  uint32_t blk_addr() const { return blk_addr_; }
  void set_blk_addr(uint32_t value) { blk_addr_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t nid_{};
  uint32_t blk_addr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateNodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };

  F2fsTruncateNodeFtraceEvent();
  ~F2fsTruncateNodeFtraceEvent() override;
  F2fsTruncateNodeFtraceEvent(F2fsTruncateNodeFtraceEvent&&) noexcept;
  F2fsTruncateNodeFtraceEvent& operator=(F2fsTruncateNodeFtraceEvent&&);
  F2fsTruncateNodeFtraceEvent(const F2fsTruncateNodeFtraceEvent&);
  F2fsTruncateNodeFtraceEvent& operator=(const F2fsTruncateNodeFtraceEvent&);
  bool operator==(const F2fsTruncateNodeFtraceEvent&) const;
  bool operator!=(const F2fsTruncateNodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nid() const { return _has_field_[3]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(3); }

  bool has_blk_addr() const { return _has_field_[4]; }
  uint32_t blk_addr() const { return blk_addr_; }
  void set_blk_addr(uint32_t value) { blk_addr_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t nid_{};
  uint32_t blk_addr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateInodeBlocksExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsTruncateInodeBlocksExitFtraceEvent();
  ~F2fsTruncateInodeBlocksExitFtraceEvent() override;
  F2fsTruncateInodeBlocksExitFtraceEvent(F2fsTruncateInodeBlocksExitFtraceEvent&&) noexcept;
  F2fsTruncateInodeBlocksExitFtraceEvent& operator=(F2fsTruncateInodeBlocksExitFtraceEvent&&);
  F2fsTruncateInodeBlocksExitFtraceEvent(const F2fsTruncateInodeBlocksExitFtraceEvent&);
  F2fsTruncateInodeBlocksExitFtraceEvent& operator=(const F2fsTruncateInodeBlocksExitFtraceEvent&);
  bool operator==(const F2fsTruncateInodeBlocksExitFtraceEvent&) const;
  bool operator!=(const F2fsTruncateInodeBlocksExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateInodeBlocksEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };

  F2fsTruncateInodeBlocksEnterFtraceEvent();
  ~F2fsTruncateInodeBlocksEnterFtraceEvent() override;
  F2fsTruncateInodeBlocksEnterFtraceEvent(F2fsTruncateInodeBlocksEnterFtraceEvent&&) noexcept;
  F2fsTruncateInodeBlocksEnterFtraceEvent& operator=(F2fsTruncateInodeBlocksEnterFtraceEvent&&);
  F2fsTruncateInodeBlocksEnterFtraceEvent(const F2fsTruncateInodeBlocksEnterFtraceEvent&);
  F2fsTruncateInodeBlocksEnterFtraceEvent& operator=(const F2fsTruncateInodeBlocksEnterFtraceEvent&);
  bool operator==(const F2fsTruncateInodeBlocksEnterFtraceEvent&) const;
  bool operator!=(const F2fsTruncateInodeBlocksEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_size() const { return _has_field_[3]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(3); }

  bool has_blocks() const { return _has_field_[4]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(4); }

  bool has_from() const { return _has_field_[5]; }
  uint64_t from() const { return from_; }
  void set_from(uint64_t value) { from_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t size_{};
  uint64_t blocks_{};
  uint64_t from_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateDataBlocksRangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kOfsFieldNumber = 4,
    kFreeFieldNumber = 5,
  };

  F2fsTruncateDataBlocksRangeFtraceEvent();
  ~F2fsTruncateDataBlocksRangeFtraceEvent() override;
  F2fsTruncateDataBlocksRangeFtraceEvent(F2fsTruncateDataBlocksRangeFtraceEvent&&) noexcept;
  F2fsTruncateDataBlocksRangeFtraceEvent& operator=(F2fsTruncateDataBlocksRangeFtraceEvent&&);
  F2fsTruncateDataBlocksRangeFtraceEvent(const F2fsTruncateDataBlocksRangeFtraceEvent&);
  F2fsTruncateDataBlocksRangeFtraceEvent& operator=(const F2fsTruncateDataBlocksRangeFtraceEvent&);
  bool operator==(const F2fsTruncateDataBlocksRangeFtraceEvent&) const;
  bool operator!=(const F2fsTruncateDataBlocksRangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nid() const { return _has_field_[3]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(3); }

  bool has_ofs() const { return _has_field_[4]; }
  uint32_t ofs() const { return ofs_; }
  void set_ofs(uint32_t value) { ofs_ = value; _has_field_.set(4); }

  bool has_free() const { return _has_field_[5]; }
  int32_t free() const { return free_; }
  void set_free(int32_t value) { free_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t nid_{};
  uint32_t ofs_{};
  int32_t free_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateBlocksExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsTruncateBlocksExitFtraceEvent();
  ~F2fsTruncateBlocksExitFtraceEvent() override;
  F2fsTruncateBlocksExitFtraceEvent(F2fsTruncateBlocksExitFtraceEvent&&) noexcept;
  F2fsTruncateBlocksExitFtraceEvent& operator=(F2fsTruncateBlocksExitFtraceEvent&&);
  F2fsTruncateBlocksExitFtraceEvent(const F2fsTruncateBlocksExitFtraceEvent&);
  F2fsTruncateBlocksExitFtraceEvent& operator=(const F2fsTruncateBlocksExitFtraceEvent&);
  bool operator==(const F2fsTruncateBlocksExitFtraceEvent&) const;
  bool operator!=(const F2fsTruncateBlocksExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateBlocksEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };

  F2fsTruncateBlocksEnterFtraceEvent();
  ~F2fsTruncateBlocksEnterFtraceEvent() override;
  F2fsTruncateBlocksEnterFtraceEvent(F2fsTruncateBlocksEnterFtraceEvent&&) noexcept;
  F2fsTruncateBlocksEnterFtraceEvent& operator=(F2fsTruncateBlocksEnterFtraceEvent&&);
  F2fsTruncateBlocksEnterFtraceEvent(const F2fsTruncateBlocksEnterFtraceEvent&);
  F2fsTruncateBlocksEnterFtraceEvent& operator=(const F2fsTruncateBlocksEnterFtraceEvent&);
  bool operator==(const F2fsTruncateBlocksEnterFtraceEvent&) const;
  bool operator!=(const F2fsTruncateBlocksEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_size() const { return _has_field_[3]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(3); }

  bool has_blocks() const { return _has_field_[4]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(4); }

  bool has_from() const { return _has_field_[5]; }
  uint64_t from() const { return from_; }
  void set_from(uint64_t value) { from_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t size_{};
  uint64_t blocks_{};
  uint64_t from_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsTruncateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };

  F2fsTruncateFtraceEvent();
  ~F2fsTruncateFtraceEvent() override;
  F2fsTruncateFtraceEvent(F2fsTruncateFtraceEvent&&) noexcept;
  F2fsTruncateFtraceEvent& operator=(F2fsTruncateFtraceEvent&&);
  F2fsTruncateFtraceEvent(const F2fsTruncateFtraceEvent&);
  F2fsTruncateFtraceEvent& operator=(const F2fsTruncateFtraceEvent&);
  bool operator==(const F2fsTruncateFtraceEvent&) const;
  bool operator!=(const F2fsTruncateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pino() const { return _has_field_[3]; }
  uint64_t pino() const { return pino_; }
  void set_pino(uint64_t value) { pino_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(5); }

  bool has_nlink() const { return _has_field_[6]; }
  uint32_t nlink() const { return nlink_; }
  void set_nlink(uint32_t value) { nlink_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_advise() const { return _has_field_[8]; }
  uint32_t advise() const { return advise_; }
  void set_advise(uint32_t value) { advise_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pino_{};
  uint32_t mode_{};
  int64_t size_{};
  uint32_t nlink_{};
  uint64_t blocks_{};
  uint32_t advise_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT F2fsSyncFsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kDirtyFieldNumber = 2,
    kWaitFieldNumber = 3,
  };

  F2fsSyncFsFtraceEvent();
  ~F2fsSyncFsFtraceEvent() override;
  F2fsSyncFsFtraceEvent(F2fsSyncFsFtraceEvent&&) noexcept;
  F2fsSyncFsFtraceEvent& operator=(F2fsSyncFsFtraceEvent&&);
  F2fsSyncFsFtraceEvent(const F2fsSyncFsFtraceEvent&);
  F2fsSyncFsFtraceEvent& operator=(const F2fsSyncFsFtraceEvent&);
  bool operator==(const F2fsSyncFsFtraceEvent&) const;
  bool operator!=(const F2fsSyncFsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_dirty() const { return _has_field_[2]; }
  int32_t dirty() const { return dirty_; }
  void set_dirty(int32_t value) { dirty_ = value; _has_field_.set(2); }

  bool has_wait() const { return _has_field_[3]; }
  int32_t wait() const { return wait_; }
  void set_wait(int32_t value) { wait_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  int32_t dirty_{};
  int32_t wait_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsSyncFileExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNeedCpFieldNumber = 3,
    kDatasyncFieldNumber = 4,
    kRetFieldNumber = 5,
  };

  F2fsSyncFileExitFtraceEvent();
  ~F2fsSyncFileExitFtraceEvent() override;
  F2fsSyncFileExitFtraceEvent(F2fsSyncFileExitFtraceEvent&&) noexcept;
  F2fsSyncFileExitFtraceEvent& operator=(F2fsSyncFileExitFtraceEvent&&);
  F2fsSyncFileExitFtraceEvent(const F2fsSyncFileExitFtraceEvent&);
  F2fsSyncFileExitFtraceEvent& operator=(const F2fsSyncFileExitFtraceEvent&);
  bool operator==(const F2fsSyncFileExitFtraceEvent&) const;
  bool operator!=(const F2fsSyncFileExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_need_cp() const { return _has_field_[3]; }
  uint32_t need_cp() const { return need_cp_; }
  void set_need_cp(uint32_t value) { need_cp_ = value; _has_field_.set(3); }

  bool has_datasync() const { return _has_field_[4]; }
  int32_t datasync() const { return datasync_; }
  void set_datasync(int32_t value) { datasync_ = value; _has_field_.set(4); }

  bool has_ret() const { return _has_field_[5]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t need_cp_{};
  int32_t datasync_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsSyncFileEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };

  F2fsSyncFileEnterFtraceEvent();
  ~F2fsSyncFileEnterFtraceEvent() override;
  F2fsSyncFileEnterFtraceEvent(F2fsSyncFileEnterFtraceEvent&&) noexcept;
  F2fsSyncFileEnterFtraceEvent& operator=(F2fsSyncFileEnterFtraceEvent&&);
  F2fsSyncFileEnterFtraceEvent(const F2fsSyncFileEnterFtraceEvent&);
  F2fsSyncFileEnterFtraceEvent& operator=(const F2fsSyncFileEnterFtraceEvent&);
  bool operator==(const F2fsSyncFileEnterFtraceEvent&) const;
  bool operator!=(const F2fsSyncFileEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pino() const { return _has_field_[3]; }
  uint64_t pino() const { return pino_; }
  void set_pino(uint64_t value) { pino_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(5); }

  bool has_nlink() const { return _has_field_[6]; }
  uint32_t nlink() const { return nlink_; }
  void set_nlink(uint32_t value) { nlink_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_advise() const { return _has_field_[8]; }
  uint32_t advise() const { return advise_; }
  void set_advise(uint32_t value) { advise_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pino_{};
  uint32_t mode_{};
  int64_t size_{};
  uint32_t nlink_{};
  uint64_t blocks_{};
  uint32_t advise_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT F2fsSubmitWritePageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIndexFieldNumber = 4,
    kBlockFieldNumber = 5,
  };

  F2fsSubmitWritePageFtraceEvent();
  ~F2fsSubmitWritePageFtraceEvent() override;
  F2fsSubmitWritePageFtraceEvent(F2fsSubmitWritePageFtraceEvent&&) noexcept;
  F2fsSubmitWritePageFtraceEvent& operator=(F2fsSubmitWritePageFtraceEvent&&);
  F2fsSubmitWritePageFtraceEvent(const F2fsSubmitWritePageFtraceEvent&);
  F2fsSubmitWritePageFtraceEvent& operator=(const F2fsSubmitWritePageFtraceEvent&);
  bool operator==(const F2fsSubmitWritePageFtraceEvent&) const;
  bool operator!=(const F2fsSubmitWritePageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(3); }

  bool has_index() const { return _has_field_[4]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(4); }

  bool has_block() const { return _has_field_[5]; }
  uint32_t block() const { return block_; }
  void set_block(uint32_t value) { block_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t type_{};
  uint64_t index_{};
  uint32_t block_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsSetPageDirtyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
  };

  F2fsSetPageDirtyFtraceEvent();
  ~F2fsSetPageDirtyFtraceEvent() override;
  F2fsSetPageDirtyFtraceEvent(F2fsSetPageDirtyFtraceEvent&&) noexcept;
  F2fsSetPageDirtyFtraceEvent& operator=(F2fsSetPageDirtyFtraceEvent&&);
  F2fsSetPageDirtyFtraceEvent(const F2fsSetPageDirtyFtraceEvent&);
  F2fsSetPageDirtyFtraceEvent& operator=(const F2fsSetPageDirtyFtraceEvent&);
  bool operator==(const F2fsSetPageDirtyFtraceEvent&) const;
  bool operator!=(const F2fsSetPageDirtyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(3); }

  bool has_dir() const { return _has_field_[4]; }
  int32_t dir() const { return dir_; }
  void set_dir(int32_t value) { dir_ = value; _has_field_.set(4); }

  bool has_index() const { return _has_field_[5]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(5); }

  bool has_dirty() const { return _has_field_[6]; }
  int32_t dirty() const { return dirty_; }
  void set_dirty(int32_t value) { dirty_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t type_{};
  int32_t dir_{};
  uint64_t index_{};
  int32_t dirty_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT F2fsReserveNewBlockFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kNidFieldNumber = 2,
    kOfsInNodeFieldNumber = 3,
  };

  F2fsReserveNewBlockFtraceEvent();
  ~F2fsReserveNewBlockFtraceEvent() override;
  F2fsReserveNewBlockFtraceEvent(F2fsReserveNewBlockFtraceEvent&&) noexcept;
  F2fsReserveNewBlockFtraceEvent& operator=(F2fsReserveNewBlockFtraceEvent&&);
  F2fsReserveNewBlockFtraceEvent(const F2fsReserveNewBlockFtraceEvent&);
  F2fsReserveNewBlockFtraceEvent& operator=(const F2fsReserveNewBlockFtraceEvent&);
  bool operator==(const F2fsReserveNewBlockFtraceEvent&) const;
  bool operator!=(const F2fsReserveNewBlockFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_nid() const { return _has_field_[2]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(2); }

  bool has_ofs_in_node() const { return _has_field_[3]; }
  uint32_t ofs_in_node() const { return ofs_in_node_; }
  void set_ofs_in_node(uint32_t value) { ofs_in_node_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint32_t nid_{};
  uint32_t ofs_in_node_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsReadpageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kBlkaddrFieldNumber = 4,
    kTypeFieldNumber = 5,
  };

  F2fsReadpageFtraceEvent();
  ~F2fsReadpageFtraceEvent() override;
  F2fsReadpageFtraceEvent(F2fsReadpageFtraceEvent&&) noexcept;
  F2fsReadpageFtraceEvent& operator=(F2fsReadpageFtraceEvent&&);
  F2fsReadpageFtraceEvent(const F2fsReadpageFtraceEvent&);
  F2fsReadpageFtraceEvent& operator=(const F2fsReadpageFtraceEvent&);
  bool operator==(const F2fsReadpageFtraceEvent&) const;
  bool operator!=(const F2fsReadpageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_index() const { return _has_field_[3]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(3); }

  bool has_blkaddr() const { return _has_field_[4]; }
  uint64_t blkaddr() const { return blkaddr_; }
  void set_blkaddr(uint64_t value) { blkaddr_ = value; _has_field_.set(4); }

  bool has_type() const { return _has_field_[5]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t index_{};
  uint64_t blkaddr_{};
  int32_t type_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT F2fsNewInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsNewInodeFtraceEvent();
  ~F2fsNewInodeFtraceEvent() override;
  F2fsNewInodeFtraceEvent(F2fsNewInodeFtraceEvent&&) noexcept;
  F2fsNewInodeFtraceEvent& operator=(F2fsNewInodeFtraceEvent&&);
  F2fsNewInodeFtraceEvent(const F2fsNewInodeFtraceEvent&);
  F2fsNewInodeFtraceEvent& operator=(const F2fsNewInodeFtraceEvent&);
  bool operator==(const F2fsNewInodeFtraceEvent&) const;
  bool operator!=(const F2fsNewInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsIgetExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsIgetExitFtraceEvent();
  ~F2fsIgetExitFtraceEvent() override;
  F2fsIgetExitFtraceEvent(F2fsIgetExitFtraceEvent&&) noexcept;
  F2fsIgetExitFtraceEvent& operator=(F2fsIgetExitFtraceEvent&&);
  F2fsIgetExitFtraceEvent(const F2fsIgetExitFtraceEvent&);
  F2fsIgetExitFtraceEvent& operator=(const F2fsIgetExitFtraceEvent&);
  bool operator==(const F2fsIgetExitFtraceEvent&) const;
  bool operator!=(const F2fsIgetExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT F2fsIgetFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };

  F2fsIgetFtraceEvent();
  ~F2fsIgetFtraceEvent() override;
  F2fsIgetFtraceEvent(F2fsIgetFtraceEvent&&) noexcept;
  F2fsIgetFtraceEvent& operator=(F2fsIgetFtraceEvent&&);
  F2fsIgetFtraceEvent(const F2fsIgetFtraceEvent&);
  F2fsIgetFtraceEvent& operator=(const F2fsIgetFtraceEvent&);
  bool operator==(const F2fsIgetFtraceEvent&) const;
  bool operator!=(const F2fsIgetFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pino() const { return _has_field_[3]; }
  uint64_t pino() const { return pino_; }
  void set_pino(uint64_t value) { pino_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(5); }

  bool has_nlink() const { return _has_field_[6]; }
  uint32_t nlink() const { return nlink_; }
  void set_nlink(uint32_t value) { nlink_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_advise() const { return _has_field_[8]; }
  uint32_t advise() const { return advise_; }
  void set_advise(uint32_t value) { advise_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pino_{};
  uint32_t mode_{};
  int64_t size_{};
  uint32_t nlink_{};
  uint64_t blocks_{};
  uint32_t advise_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT F2fsGetVictimFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kTypeFieldNumber = 2,
    kGcTypeFieldNumber = 3,
    kAllocModeFieldNumber = 4,
    kGcModeFieldNumber = 5,
    kVictimFieldNumber = 6,
    kOfsUnitFieldNumber = 7,
    kPreVictimFieldNumber = 8,
    kPrefreeFieldNumber = 9,
    kFreeFieldNumber = 10,
  };

  F2fsGetVictimFtraceEvent();
  ~F2fsGetVictimFtraceEvent() override;
  F2fsGetVictimFtraceEvent(F2fsGetVictimFtraceEvent&&) noexcept;
  F2fsGetVictimFtraceEvent& operator=(F2fsGetVictimFtraceEvent&&);
  F2fsGetVictimFtraceEvent(const F2fsGetVictimFtraceEvent&);
  F2fsGetVictimFtraceEvent& operator=(const F2fsGetVictimFtraceEvent&);
  bool operator==(const F2fsGetVictimFtraceEvent&) const;
  bool operator!=(const F2fsGetVictimFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_type() const { return _has_field_[2]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(2); }

  bool has_gc_type() const { return _has_field_[3]; }
  int32_t gc_type() const { return gc_type_; }
  void set_gc_type(int32_t value) { gc_type_ = value; _has_field_.set(3); }

  bool has_alloc_mode() const { return _has_field_[4]; }
  int32_t alloc_mode() const { return alloc_mode_; }
  void set_alloc_mode(int32_t value) { alloc_mode_ = value; _has_field_.set(4); }

  bool has_gc_mode() const { return _has_field_[5]; }
  int32_t gc_mode() const { return gc_mode_; }
  void set_gc_mode(int32_t value) { gc_mode_ = value; _has_field_.set(5); }

  bool has_victim() const { return _has_field_[6]; }
  uint32_t victim() const { return victim_; }
  void set_victim(uint32_t value) { victim_ = value; _has_field_.set(6); }

  bool has_ofs_unit() const { return _has_field_[7]; }
  uint32_t ofs_unit() const { return ofs_unit_; }
  void set_ofs_unit(uint32_t value) { ofs_unit_ = value; _has_field_.set(7); }

  bool has_pre_victim() const { return _has_field_[8]; }
  uint32_t pre_victim() const { return pre_victim_; }
  void set_pre_victim(uint32_t value) { pre_victim_ = value; _has_field_.set(8); }

  bool has_prefree() const { return _has_field_[9]; }
  uint32_t prefree() const { return prefree_; }
  void set_prefree(uint32_t value) { prefree_ = value; _has_field_.set(9); }

  bool has_free() const { return _has_field_[10]; }
  uint32_t free() const { return free_; }
  void set_free(uint32_t value) { free_ = value; _has_field_.set(10); }

 private:
  uint64_t dev_{};
  int32_t type_{};
  int32_t gc_type_{};
  int32_t alloc_mode_{};
  int32_t gc_mode_{};
  uint32_t victim_{};
  uint32_t ofs_unit_{};
  uint32_t pre_victim_{};
  uint32_t prefree_{};
  uint32_t free_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT F2fsGetDataBlockFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIblockFieldNumber = 3,
    kBhStartFieldNumber = 4,
    kBhSizeFieldNumber = 5,
    kRetFieldNumber = 6,
  };

  F2fsGetDataBlockFtraceEvent();
  ~F2fsGetDataBlockFtraceEvent() override;
  F2fsGetDataBlockFtraceEvent(F2fsGetDataBlockFtraceEvent&&) noexcept;
  F2fsGetDataBlockFtraceEvent& operator=(F2fsGetDataBlockFtraceEvent&&);
  F2fsGetDataBlockFtraceEvent(const F2fsGetDataBlockFtraceEvent&);
  F2fsGetDataBlockFtraceEvent& operator=(const F2fsGetDataBlockFtraceEvent&);
  bool operator==(const F2fsGetDataBlockFtraceEvent&) const;
  bool operator!=(const F2fsGetDataBlockFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_iblock() const { return _has_field_[3]; }
  uint64_t iblock() const { return iblock_; }
  void set_iblock(uint64_t value) { iblock_ = value; _has_field_.set(3); }

  bool has_bh_start() const { return _has_field_[4]; }
  uint64_t bh_start() const { return bh_start_; }
  void set_bh_start(uint64_t value) { bh_start_ = value; _has_field_.set(4); }

  bool has_bh_size() const { return _has_field_[5]; }
  uint64_t bh_size() const { return bh_size_; }
  void set_bh_size(uint64_t value) { bh_size_ = value; _has_field_.set(5); }

  bool has_ret() const { return _has_field_[6]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t iblock_{};
  uint64_t bh_start_{};
  uint64_t bh_size_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT F2fsFallocateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLenFieldNumber = 5,
    kSizeFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kRetFieldNumber = 8,
  };

  F2fsFallocateFtraceEvent();
  ~F2fsFallocateFtraceEvent() override;
  F2fsFallocateFtraceEvent(F2fsFallocateFtraceEvent&&) noexcept;
  F2fsFallocateFtraceEvent& operator=(F2fsFallocateFtraceEvent&&);
  F2fsFallocateFtraceEvent(const F2fsFallocateFtraceEvent&);
  F2fsFallocateFtraceEvent& operator=(const F2fsFallocateFtraceEvent&);
  bool operator==(const F2fsFallocateFtraceEvent&) const;
  bool operator!=(const F2fsFallocateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_mode() const { return _has_field_[3]; }
  int32_t mode() const { return mode_; }
  void set_mode(int32_t value) { mode_ = value; _has_field_.set(3); }

  bool has_offset() const { return _has_field_[4]; }
  int64_t offset() const { return offset_; }
  void set_offset(int64_t value) { offset_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  int64_t len() const { return len_; }
  void set_len(int64_t value) { len_ = value; _has_field_.set(5); }

  bool has_size() const { return _has_field_[6]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_ret() const { return _has_field_[8]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t mode_{};
  int64_t offset_{};
  int64_t len_{};
  int64_t size_{};
  uint64_t blocks_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT F2fsEvictInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };

  F2fsEvictInodeFtraceEvent();
  ~F2fsEvictInodeFtraceEvent() override;
  F2fsEvictInodeFtraceEvent(F2fsEvictInodeFtraceEvent&&) noexcept;
  F2fsEvictInodeFtraceEvent& operator=(F2fsEvictInodeFtraceEvent&&);
  F2fsEvictInodeFtraceEvent(const F2fsEvictInodeFtraceEvent&);
  F2fsEvictInodeFtraceEvent& operator=(const F2fsEvictInodeFtraceEvent&);
  bool operator==(const F2fsEvictInodeFtraceEvent&) const;
  bool operator!=(const F2fsEvictInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pino() const { return _has_field_[3]; }
  uint64_t pino() const { return pino_; }
  void set_pino(uint64_t value) { pino_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(5); }

  bool has_nlink() const { return _has_field_[6]; }
  uint32_t nlink() const { return nlink_; }
  void set_nlink(uint32_t value) { nlink_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_advise() const { return _has_field_[8]; }
  uint32_t advise() const { return advise_; }
  void set_advise(uint32_t value) { advise_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pino_{};
  uint32_t mode_{};
  int64_t size_{};
  uint32_t nlink_{};
  uint64_t blocks_{};
  uint32_t advise_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT F2fsDoSubmitBioFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kBtypeFieldNumber = 2,
    kSyncFieldNumber = 3,
    kSectorFieldNumber = 4,
    kSizeFieldNumber = 5,
  };

  F2fsDoSubmitBioFtraceEvent();
  ~F2fsDoSubmitBioFtraceEvent() override;
  F2fsDoSubmitBioFtraceEvent(F2fsDoSubmitBioFtraceEvent&&) noexcept;
  F2fsDoSubmitBioFtraceEvent& operator=(F2fsDoSubmitBioFtraceEvent&&);
  F2fsDoSubmitBioFtraceEvent(const F2fsDoSubmitBioFtraceEvent&);
  F2fsDoSubmitBioFtraceEvent& operator=(const F2fsDoSubmitBioFtraceEvent&);
  bool operator==(const F2fsDoSubmitBioFtraceEvent&) const;
  bool operator!=(const F2fsDoSubmitBioFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_btype() const { return _has_field_[2]; }
  int32_t btype() const { return btype_; }
  void set_btype(int32_t value) { btype_ = value; _has_field_.set(2); }

  bool has_sync() const { return _has_field_[3]; }
  uint32_t sync() const { return sync_; }
  void set_sync(uint32_t value) { sync_ = value; _has_field_.set(3); }

  bool has_sector() const { return _has_field_[4]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  uint32_t size() const { return size_; }
  void set_size(uint32_t value) { size_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  int32_t btype_{};
  uint32_t sync_{};
  uint64_t sector_{};
  uint32_t size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_CPP_H_
