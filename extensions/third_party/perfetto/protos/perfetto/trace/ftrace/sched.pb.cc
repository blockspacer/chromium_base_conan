// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/sched.proto

#include "protos/perfetto/trace/ftrace/sched.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace perfetto {
namespace protos {
class SchedSwitchFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedSwitchFtraceEvent> _instance;
} _SchedSwitchFtraceEvent_default_instance_;
class SchedWakeupFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedWakeupFtraceEvent> _instance;
} _SchedWakeupFtraceEvent_default_instance_;
class SchedBlockedReasonFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedBlockedReasonFtraceEvent> _instance;
} _SchedBlockedReasonFtraceEvent_default_instance_;
class SchedCpuHotplugFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedCpuHotplugFtraceEvent> _instance;
} _SchedCpuHotplugFtraceEvent_default_instance_;
class SchedWakingFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedWakingFtraceEvent> _instance;
} _SchedWakingFtraceEvent_default_instance_;
class SchedWakeupNewFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedWakeupNewFtraceEvent> _instance;
} _SchedWakeupNewFtraceEvent_default_instance_;
class SchedProcessExecFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedProcessExecFtraceEvent> _instance;
} _SchedProcessExecFtraceEvent_default_instance_;
class SchedProcessExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedProcessExitFtraceEvent> _instance;
} _SchedProcessExitFtraceEvent_default_instance_;
class SchedProcessForkFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedProcessForkFtraceEvent> _instance;
} _SchedProcessForkFtraceEvent_default_instance_;
class SchedProcessFreeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedProcessFreeFtraceEvent> _instance;
} _SchedProcessFreeFtraceEvent_default_instance_;
class SchedProcessHangFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedProcessHangFtraceEvent> _instance;
} _SchedProcessHangFtraceEvent_default_instance_;
class SchedProcessWaitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SchedProcessWaitFtraceEvent> _instance;
} _SchedProcessWaitFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
static void InitDefaultsscc_info_SchedBlockedReasonFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedBlockedReasonFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedBlockedReasonFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedBlockedReasonFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedBlockedReasonFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedBlockedReasonFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedCpuHotplugFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedCpuHotplugFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedCpuHotplugFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedCpuHotplugFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedCpuHotplugFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedCpuHotplugFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedProcessExecFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedProcessExecFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedProcessExecFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedProcessExecFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedProcessExecFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedProcessExecFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedProcessExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedProcessExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedProcessExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedProcessExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedProcessExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedProcessExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedProcessForkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedProcessForkFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedProcessForkFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedProcessForkFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedProcessForkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedProcessForkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedProcessFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedProcessFreeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedProcessFreeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedProcessFreeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedProcessFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedProcessFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedProcessHangFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedProcessHangFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedProcessHangFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedProcessHangFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedProcessHangFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedProcessHangFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedProcessWaitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedProcessWaitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedProcessWaitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedProcessWaitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedProcessWaitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedProcessWaitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedSwitchFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedSwitchFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedSwitchFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedSwitchFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedSwitchFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedSwitchFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedWakeupFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedWakeupFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedWakeupFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedWakeupFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedWakeupFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedWakeupFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedWakeupNewFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedWakeupNewFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedWakeupNewFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedWakeupNewFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedWakeupNewFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedWakeupNewFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

static void InitDefaultsscc_info_SchedWakingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_SchedWakingFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::SchedWakingFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::SchedWakingFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SchedWakingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SchedWakingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto}, {}};

namespace perfetto {
namespace protos {

// ===================================================================

void SchedSwitchFtraceEvent::InitAsDefaultInstance() {
}
class SchedSwitchFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedSwitchFtraceEvent>()._has_bits_);
  static void set_has_prev_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prev_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prev_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prev_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_next_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_next_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_next_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

SchedSwitchFtraceEvent::SchedSwitchFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedSwitchFtraceEvent)
}
SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  prev_comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_prev_comm()) {
    prev_comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.prev_comm_);
  }
  next_comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_next_comm()) {
    next_comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.next_comm_);
  }
  ::memcpy(&prev_pid_, &from.prev_pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&next_prio_) -
    reinterpret_cast<char*>(&prev_pid_)) + sizeof(next_prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedSwitchFtraceEvent)
}

void SchedSwitchFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedSwitchFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  prev_comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  next_comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&prev_pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&next_prio_) -
      reinterpret_cast<char*>(&prev_pid_)) + sizeof(next_prio_));
}

SchedSwitchFtraceEvent::~SchedSwitchFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedSwitchFtraceEvent)
  SharedDtor();
}

void SchedSwitchFtraceEvent::SharedDtor() {
  prev_comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  next_comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedSwitchFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedSwitchFtraceEvent& SchedSwitchFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedSwitchFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedSwitchFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedSwitchFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      prev_comm_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      next_comm_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&prev_pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&next_prio_) -
        reinterpret_cast<char*>(&prev_pid_)) + sizeof(next_prio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedSwitchFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string prev_comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_prev_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prev_pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_prev_pid(&has_bits);
          prev_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prev_prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_prev_prio(&has_bits);
          prev_prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 prev_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_prev_state(&has_bits);
          prev_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string next_comm = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_next_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 next_pid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_next_pid(&has_bits);
          next_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 next_prio = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_next_prio(&has_bits);
          next_prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedSwitchFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedSwitchFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string prev_comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_prev_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 prev_pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_prev_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &prev_pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 prev_prio = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_prev_prio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &prev_prio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 prev_state = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_prev_state(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &prev_state_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string next_comm = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_next_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 next_pid = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_next_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &next_pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 next_prio = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_next_prio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &next_prio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedSwitchFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedSwitchFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedSwitchFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedSwitchFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string prev_comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->prev_comm(), output);
  }

  // optional int32 prev_pid = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->prev_pid(), output);
  }

  // optional int32 prev_prio = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->prev_prio(), output);
  }

  // optional int64 prev_state = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->prev_state(), output);
  }

  // optional string next_comm = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->next_comm(), output);
  }

  // optional int32 next_pid = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->next_pid(), output);
  }

  // optional int32 next_prio = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->next_prio(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedSwitchFtraceEvent)
}

size_t SchedSwitchFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedSwitchFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string prev_comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->prev_comm());
    }

    // optional string next_comm = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->next_comm());
    }

    // optional int32 prev_pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->prev_pid());
    }

    // optional int32 prev_prio = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->prev_prio());
    }

    // optional int64 prev_state = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->prev_state());
    }

    // optional int32 next_pid = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->next_pid());
    }

    // optional int32 next_prio = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->next_prio());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedSwitchFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedSwitchFtraceEvent*>(
      &from));
}

void SchedSwitchFtraceEvent::MergeFrom(const SchedSwitchFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedSwitchFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      prev_comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.prev_comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      next_comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.next_comm_);
    }
    if (cached_has_bits & 0x00000004u) {
      prev_pid_ = from.prev_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      prev_prio_ = from.prev_prio_;
    }
    if (cached_has_bits & 0x00000010u) {
      prev_state_ = from.prev_state_;
    }
    if (cached_has_bits & 0x00000020u) {
      next_pid_ = from.next_pid_;
    }
    if (cached_has_bits & 0x00000040u) {
      next_prio_ = from.next_prio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedSwitchFtraceEvent::CopyFrom(const SchedSwitchFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedSwitchFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedSwitchFtraceEvent::IsInitialized() const {
  return true;
}

void SchedSwitchFtraceEvent::InternalSwap(SchedSwitchFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  prev_comm_.Swap(&other->prev_comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  next_comm_.Swap(&other->next_comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(prev_pid_, other->prev_pid_);
  swap(prev_prio_, other->prev_prio_);
  swap(prev_state_, other->prev_state_);
  swap(next_pid_, other->next_pid_);
  swap(next_prio_, other->next_prio_);
}

std::string SchedSwitchFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedSwitchFtraceEvent";
}


// ===================================================================

void SchedWakeupFtraceEvent::InitAsDefaultInstance() {
}
class SchedWakeupFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakeupFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakeupFtraceEvent::SchedWakeupFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedWakeupFtraceEvent)
}
SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_comm()) {
    comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakeupFtraceEvent)
}

void SchedWakeupFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedWakeupFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&target_cpu_) -
      reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
}

SchedWakeupFtraceEvent::~SchedWakeupFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakeupFtraceEvent)
  SharedDtor();
}

void SchedWakeupFtraceEvent::SharedDtor() {
  comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedWakeupFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedWakeupFtraceEvent& SchedWakeupFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedWakeupFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedWakeupFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakeupFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_cpu_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedWakeupFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedWakeupFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedWakeupFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 prio = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_prio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &prio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 success = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_success(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &success_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 target_cpu = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_target_cpu(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_cpu_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedWakeupFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedWakeupFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedWakeupFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedWakeupFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->comm(), output);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->prio(), output);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->success(), output);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->target_cpu(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedWakeupFtraceEvent)
}

size_t SchedWakeupFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakeupFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->target_cpu());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakeupFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedWakeupFtraceEvent*>(
      &from));
}

void SchedWakeupFtraceEvent::MergeFrom(const SchedWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakeupFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      target_cpu_ = from.target_cpu_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedWakeupFtraceEvent::CopyFrom(const SchedWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakeupFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakeupFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakeupFtraceEvent::InternalSwap(SchedWakeupFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  comm_.Swap(&other->comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pid_, other->pid_);
  swap(prio_, other->prio_);
  swap(success_, other->success_);
  swap(target_cpu_, other->target_cpu_);
}

std::string SchedWakeupFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakeupFtraceEvent";
}


// ===================================================================

void SchedBlockedReasonFtraceEvent::InitAsDefaultInstance() {
}
class SchedBlockedReasonFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedBlockedReasonFtraceEvent>()._has_bits_);
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_caller(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_io_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
}
SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&caller_, &from.caller_,
    static_cast<size_t>(reinterpret_cast<char*>(&io_wait_) -
    reinterpret_cast<char*>(&caller_)) + sizeof(io_wait_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
}

void SchedBlockedReasonFtraceEvent::SharedCtor() {
  ::memset(&caller_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&io_wait_) -
      reinterpret_cast<char*>(&caller_)) + sizeof(io_wait_));
}

SchedBlockedReasonFtraceEvent::~SchedBlockedReasonFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
  SharedDtor();
}

void SchedBlockedReasonFtraceEvent::SharedDtor() {
}

void SchedBlockedReasonFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedBlockedReasonFtraceEvent& SchedBlockedReasonFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedBlockedReasonFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedBlockedReasonFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&caller_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&io_wait_) -
        reinterpret_cast<char*>(&caller_)) + sizeof(io_wait_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedBlockedReasonFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 caller = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_caller(&has_bits);
          caller_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 io_wait = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_io_wait(&has_bits);
          io_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedBlockedReasonFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 pid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 caller = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_caller(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &caller_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 io_wait = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_io_wait(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &io_wait_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedBlockedReasonFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedBlockedReasonFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedBlockedReasonFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 pid = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->pid(), output);
  }

  // optional uint64 caller = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->caller(), output);
  }

  // optional uint32 io_wait = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->io_wait(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedBlockedReasonFtraceEvent)
}

size_t SchedBlockedReasonFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 caller = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->caller());
    }

    // optional int32 pid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional uint32 io_wait = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->io_wait());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedBlockedReasonFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedBlockedReasonFtraceEvent*>(
      &from));
}

void SchedBlockedReasonFtraceEvent::MergeFrom(const SchedBlockedReasonFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      caller_ = from.caller_;
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      io_wait_ = from.io_wait_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedBlockedReasonFtraceEvent::CopyFrom(const SchedBlockedReasonFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedBlockedReasonFtraceEvent::IsInitialized() const {
  return true;
}

void SchedBlockedReasonFtraceEvent::InternalSwap(SchedBlockedReasonFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(caller_, other->caller_);
  swap(pid_, other->pid_);
  swap(io_wait_, other->io_wait_);
}

std::string SchedBlockedReasonFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedBlockedReasonFtraceEvent";
}


// ===================================================================

void SchedCpuHotplugFtraceEvent::InitAsDefaultInstance() {
}
class SchedCpuHotplugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedCpuHotplugFtraceEvent>()._has_bits_);
  static void set_has_affected_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
}
SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&affected_cpu_, &from.affected_cpu_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&affected_cpu_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
}

void SchedCpuHotplugFtraceEvent::SharedCtor() {
  ::memset(&affected_cpu_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&affected_cpu_)) + sizeof(status_));
}

SchedCpuHotplugFtraceEvent::~SchedCpuHotplugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
  SharedDtor();
}

void SchedCpuHotplugFtraceEvent::SharedDtor() {
}

void SchedCpuHotplugFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedCpuHotplugFtraceEvent& SchedCpuHotplugFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedCpuHotplugFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedCpuHotplugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&affected_cpu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&affected_cpu_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedCpuHotplugFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 affected_cpu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_affected_cpu(&has_bits);
          affected_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedCpuHotplugFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 affected_cpu = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_affected_cpu(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &affected_cpu_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 error = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_error(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 status = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedCpuHotplugFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedCpuHotplugFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedCpuHotplugFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 affected_cpu = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->affected_cpu(), output);
  }

  // optional int32 error = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->error(), output);
  }

  // optional int32 status = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->status(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedCpuHotplugFtraceEvent)
}

size_t SchedCpuHotplugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 affected_cpu = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->affected_cpu());
    }

    // optional int32 error = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->error());
    }

    // optional int32 status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedCpuHotplugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedCpuHotplugFtraceEvent*>(
      &from));
}

void SchedCpuHotplugFtraceEvent::MergeFrom(const SchedCpuHotplugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      affected_cpu_ = from.affected_cpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedCpuHotplugFtraceEvent::CopyFrom(const SchedCpuHotplugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedCpuHotplugFtraceEvent::IsInitialized() const {
  return true;
}

void SchedCpuHotplugFtraceEvent::InternalSwap(SchedCpuHotplugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(affected_cpu_, other->affected_cpu_);
  swap(error_, other->error_);
  swap(status_, other->status_);
}

std::string SchedCpuHotplugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedCpuHotplugFtraceEvent";
}


// ===================================================================

void SchedWakingFtraceEvent::InitAsDefaultInstance() {
}
class SchedWakingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakingFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakingFtraceEvent::SchedWakingFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedWakingFtraceEvent)
}
SchedWakingFtraceEvent::SchedWakingFtraceEvent(const SchedWakingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_comm()) {
    comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakingFtraceEvent)
}

void SchedWakingFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedWakingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&target_cpu_) -
      reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
}

SchedWakingFtraceEvent::~SchedWakingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakingFtraceEvent)
  SharedDtor();
}

void SchedWakingFtraceEvent::SharedDtor() {
  comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedWakingFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedWakingFtraceEvent& SchedWakingFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedWakingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedWakingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakingFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_cpu_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedWakingFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedWakingFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedWakingFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 prio = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_prio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &prio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 success = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_success(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &success_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 target_cpu = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_target_cpu(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_cpu_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedWakingFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedWakingFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedWakingFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedWakingFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->comm(), output);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->prio(), output);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->success(), output);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->target_cpu(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedWakingFtraceEvent)
}

size_t SchedWakingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakingFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->target_cpu());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakingFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedWakingFtraceEvent*>(
      &from));
}

void SchedWakingFtraceEvent::MergeFrom(const SchedWakingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakingFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      target_cpu_ = from.target_cpu_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedWakingFtraceEvent::CopyFrom(const SchedWakingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakingFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakingFtraceEvent::InternalSwap(SchedWakingFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  comm_.Swap(&other->comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pid_, other->pid_);
  swap(prio_, other->prio_);
  swap(success_, other->success_);
  swap(target_cpu_, other->target_cpu_);
}

std::string SchedWakingFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakingFtraceEvent";
}


// ===================================================================

void SchedWakeupNewFtraceEvent::InitAsDefaultInstance() {
}
class SchedWakeupNewFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakeupNewFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedWakeupNewFtraceEvent)
}
SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_comm()) {
    comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakeupNewFtraceEvent)
}

void SchedWakeupNewFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedWakeupNewFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&target_cpu_) -
      reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
}

SchedWakeupNewFtraceEvent::~SchedWakeupNewFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakeupNewFtraceEvent)
  SharedDtor();
}

void SchedWakeupNewFtraceEvent::SharedDtor() {
  comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedWakeupNewFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedWakeupNewFtraceEvent& SchedWakeupNewFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedWakeupNewFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedWakeupNewFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_cpu_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedWakeupNewFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedWakeupNewFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 prio = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_prio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &prio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 success = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_success(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &success_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 target_cpu = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_target_cpu(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_cpu_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedWakeupNewFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedWakeupNewFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedWakeupNewFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->comm(), output);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->prio(), output);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->success(), output);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->target_cpu(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedWakeupNewFtraceEvent)
}

size_t SchedWakeupNewFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->target_cpu());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakeupNewFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedWakeupNewFtraceEvent*>(
      &from));
}

void SchedWakeupNewFtraceEvent::MergeFrom(const SchedWakeupNewFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      target_cpu_ = from.target_cpu_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedWakeupNewFtraceEvent::CopyFrom(const SchedWakeupNewFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakeupNewFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakeupNewFtraceEvent::InternalSwap(SchedWakeupNewFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  comm_.Swap(&other->comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pid_, other->pid_);
  swap(prio_, other->prio_);
  swap(success_, other->success_);
  swap(target_cpu_, other->target_cpu_);
}

std::string SchedWakeupNewFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakeupNewFtraceEvent";
}


// ===================================================================

void SchedProcessExecFtraceEvent::InitAsDefaultInstance() {
}
class SchedProcessExecFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessExecFtraceEvent>()._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_old_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedProcessExecFtraceEvent)
}
SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_filename()) {
    filename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.filename_);
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&old_pid_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(old_pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessExecFtraceEvent)
}

void SchedProcessExecFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedProcessExecFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&old_pid_) -
      reinterpret_cast<char*>(&pid_)) + sizeof(old_pid_));
}

SchedProcessExecFtraceEvent::~SchedProcessExecFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessExecFtraceEvent)
  SharedDtor();
}

void SchedProcessExecFtraceEvent::SharedDtor() {
  filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedProcessExecFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedProcessExecFtraceEvent& SchedProcessExecFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedProcessExecFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedProcessExecFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessExecFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    filename_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&old_pid_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(old_pid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedProcessExecFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_filename(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 old_pid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_old_pid(&has_bits);
          old_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedProcessExecFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedProcessExecFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filename = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 old_pid = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_old_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &old_pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedProcessExecFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedProcessExecFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedProcessExecFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedProcessExecFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->filename(), output);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  // optional int32 old_pid = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->old_pid(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedProcessExecFtraceEvent)
}

size_t SchedProcessExecFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessExecFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->filename());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional int32 old_pid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->old_pid());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessExecFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedProcessExecFtraceEvent*>(
      &from));
}

void SchedProcessExecFtraceEvent::MergeFrom(const SchedProcessExecFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessExecFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      filename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.filename_);
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      old_pid_ = from.old_pid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedProcessExecFtraceEvent::CopyFrom(const SchedProcessExecFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessExecFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessExecFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessExecFtraceEvent::InternalSwap(SchedProcessExecFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  filename_.Swap(&other->filename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pid_, other->pid_);
  swap(old_pid_, other->old_pid_);
}

std::string SchedProcessExecFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessExecFtraceEvent";
}


// ===================================================================

void SchedProcessExitFtraceEvent::InitAsDefaultInstance() {
}
class SchedProcessExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessExitFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tgid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedProcessExitFtraceEvent)
}
SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_comm()) {
    comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessExitFtraceEvent)
}

void SchedProcessExitFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedProcessExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prio_) -
      reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
}

SchedProcessExitFtraceEvent::~SchedProcessExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessExitFtraceEvent)
  SharedDtor();
}

void SchedProcessExitFtraceEvent::SharedDtor() {
  comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedProcessExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedProcessExitFtraceEvent& SchedProcessExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedProcessExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedProcessExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prio_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedProcessExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 tgid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_tgid(&has_bits);
          tgid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedProcessExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedProcessExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 tgid = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_tgid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &tgid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 prio = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_prio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &prio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedProcessExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedProcessExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedProcessExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedProcessExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->comm(), output);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  // optional int32 tgid = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->tgid(), output);
  }

  // optional int32 prio = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->prio(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedProcessExitFtraceEvent)
}

size_t SchedProcessExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional int32 tgid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->tgid());
    }

    // optional int32 prio = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->prio());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedProcessExitFtraceEvent*>(
      &from));
}

void SchedProcessExitFtraceEvent::MergeFrom(const SchedProcessExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      tgid_ = from.tgid_;
    }
    if (cached_has_bits & 0x00000008u) {
      prio_ = from.prio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedProcessExitFtraceEvent::CopyFrom(const SchedProcessExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessExitFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessExitFtraceEvent::InternalSwap(SchedProcessExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  comm_.Swap(&other->comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pid_, other->pid_);
  swap(tgid_, other->tgid_);
  swap(prio_, other->prio_);
}

std::string SchedProcessExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessExitFtraceEvent";
}


// ===================================================================

void SchedProcessForkFtraceEvent::InitAsDefaultInstance() {
}
class SchedProcessForkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessForkFtraceEvent>()._has_bits_);
  static void set_has_parent_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_child_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_child_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedProcessForkFtraceEvent)
}
SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  parent_comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_parent_comm()) {
    parent_comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.parent_comm_);
  }
  child_comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_child_comm()) {
    child_comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.child_comm_);
  }
  ::memcpy(&parent_pid_, &from.parent_pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&child_pid_) -
    reinterpret_cast<char*>(&parent_pid_)) + sizeof(child_pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessForkFtraceEvent)
}

void SchedProcessForkFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedProcessForkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  parent_comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  child_comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&parent_pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&child_pid_) -
      reinterpret_cast<char*>(&parent_pid_)) + sizeof(child_pid_));
}

SchedProcessForkFtraceEvent::~SchedProcessForkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessForkFtraceEvent)
  SharedDtor();
}

void SchedProcessForkFtraceEvent::SharedDtor() {
  parent_comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  child_comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedProcessForkFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedProcessForkFtraceEvent& SchedProcessForkFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedProcessForkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedProcessForkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessForkFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      parent_comm_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      child_comm_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&parent_pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&child_pid_) -
        reinterpret_cast<char*>(&parent_pid_)) + sizeof(child_pid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedProcessForkFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string parent_comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_parent_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 parent_pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_parent_pid(&has_bits);
          parent_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string child_comm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_child_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 child_pid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_child_pid(&has_bits);
          child_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedProcessForkFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedProcessForkFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string parent_comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_parent_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 parent_pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_parent_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &parent_pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string child_comm = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_child_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 child_pid = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_child_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &child_pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedProcessForkFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedProcessForkFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedProcessForkFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedProcessForkFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string parent_comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->parent_comm(), output);
  }

  // optional int32 parent_pid = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->parent_pid(), output);
  }

  // optional string child_comm = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->child_comm(), output);
  }

  // optional int32 child_pid = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->child_pid(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedProcessForkFtraceEvent)
}

size_t SchedProcessForkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessForkFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string parent_comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->parent_comm());
    }

    // optional string child_comm = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->child_comm());
    }

    // optional int32 parent_pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->parent_pid());
    }

    // optional int32 child_pid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->child_pid());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessForkFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedProcessForkFtraceEvent*>(
      &from));
}

void SchedProcessForkFtraceEvent::MergeFrom(const SchedProcessForkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessForkFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      parent_comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.parent_comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      child_comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.child_comm_);
    }
    if (cached_has_bits & 0x00000004u) {
      parent_pid_ = from.parent_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      child_pid_ = from.child_pid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedProcessForkFtraceEvent::CopyFrom(const SchedProcessForkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessForkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessForkFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessForkFtraceEvent::InternalSwap(SchedProcessForkFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  parent_comm_.Swap(&other->parent_comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  child_comm_.Swap(&other->child_comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(parent_pid_, other->parent_pid_);
  swap(child_pid_, other->child_pid_);
}

std::string SchedProcessForkFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessForkFtraceEvent";
}


// ===================================================================

void SchedProcessFreeFtraceEvent::InitAsDefaultInstance() {
}
class SchedProcessFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessFreeFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedProcessFreeFtraceEvent)
}
SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_comm()) {
    comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessFreeFtraceEvent)
}

void SchedProcessFreeFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedProcessFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prio_) -
      reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
}

SchedProcessFreeFtraceEvent::~SchedProcessFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessFreeFtraceEvent)
  SharedDtor();
}

void SchedProcessFreeFtraceEvent::SharedDtor() {
  comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedProcessFreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedProcessFreeFtraceEvent& SchedProcessFreeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedProcessFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedProcessFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prio_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedProcessFreeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedProcessFreeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 prio = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_prio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &prio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedProcessFreeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedProcessFreeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedProcessFreeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->comm(), output);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->prio(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedProcessFreeFtraceEvent)
}

size_t SchedProcessFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->prio());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedProcessFreeFtraceEvent*>(
      &from));
}

void SchedProcessFreeFtraceEvent::MergeFrom(const SchedProcessFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedProcessFreeFtraceEvent::CopyFrom(const SchedProcessFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessFreeFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessFreeFtraceEvent::InternalSwap(SchedProcessFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  comm_.Swap(&other->comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pid_, other->pid_);
  swap(prio_, other->prio_);
}

std::string SchedProcessFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessFreeFtraceEvent";
}


// ===================================================================

void SchedProcessHangFtraceEvent::InitAsDefaultInstance() {
}
class SchedProcessHangFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessHangFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedProcessHangFtraceEvent)
}
SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_comm()) {
    comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
  }
  pid_ = from.pid_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessHangFtraceEvent)
}

void SchedProcessHangFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedProcessHangFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pid_ = 0;
}

SchedProcessHangFtraceEvent::~SchedProcessHangFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessHangFtraceEvent)
  SharedDtor();
}

void SchedProcessHangFtraceEvent::SharedDtor() {
  comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedProcessHangFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedProcessHangFtraceEvent& SchedProcessHangFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedProcessHangFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedProcessHangFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessHangFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmptyNoArena();
  }
  pid_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedProcessHangFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedProcessHangFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedProcessHangFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedProcessHangFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedProcessHangFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedProcessHangFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedProcessHangFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->comm(), output);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedProcessHangFtraceEvent)
}

size_t SchedProcessHangFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessHangFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessHangFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedProcessHangFtraceEvent*>(
      &from));
}

void SchedProcessHangFtraceEvent::MergeFrom(const SchedProcessHangFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessHangFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedProcessHangFtraceEvent::CopyFrom(const SchedProcessHangFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessHangFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessHangFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessHangFtraceEvent::InternalSwap(SchedProcessHangFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  comm_.Swap(&other->comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pid_, other->pid_);
}

std::string SchedProcessHangFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessHangFtraceEvent";
}


// ===================================================================

void SchedProcessWaitFtraceEvent::InitAsDefaultInstance() {
}
class SchedProcessWaitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessWaitFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SchedProcessWaitFtraceEvent)
}
SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_comm()) {
    comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessWaitFtraceEvent)
}

void SchedProcessWaitFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SchedProcessWaitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  comm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prio_) -
      reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
}

SchedProcessWaitFtraceEvent::~SchedProcessWaitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessWaitFtraceEvent)
  SharedDtor();
}

void SchedProcessWaitFtraceEvent::SharedDtor() {
  comm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SchedProcessWaitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SchedProcessWaitFtraceEvent& SchedProcessWaitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SchedProcessWaitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto.base);
  return *internal_default_instance();
}


void SchedProcessWaitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prio_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SchedProcessWaitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_comm(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SchedProcessWaitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string comm = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_comm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 prio = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_prio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &prio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SchedProcessWaitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SchedProcessWaitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SchedProcessWaitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->comm(), output);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->prio(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SchedProcessWaitFtraceEvent)
}

size_t SchedProcessWaitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->prio());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessWaitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SchedProcessWaitFtraceEvent*>(
      &from));
}

void SchedProcessWaitFtraceEvent::MergeFrom(const SchedProcessWaitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      comm_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.comm_);
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SchedProcessWaitFtraceEvent::CopyFrom(const SchedProcessWaitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessWaitFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessWaitFtraceEvent::InternalSwap(SchedProcessWaitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  comm_.Swap(&other->comm_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pid_, other->pid_);
  swap(prio_, other->prio_);
}

std::string SchedProcessWaitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessWaitFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedSwitchFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedSwitchFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedSwitchFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakeupFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakeupFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedWakeupFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedBlockedReasonFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedBlockedReasonFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedBlockedReasonFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedCpuHotplugFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedCpuHotplugFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedCpuHotplugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakingFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakingFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedWakingFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakeupNewFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakeupNewFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedWakeupNewFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessExecFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessExecFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedProcessExecFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedProcessExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessForkFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessForkFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedProcessForkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessFreeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedProcessFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessHangFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessHangFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedProcessHangFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessWaitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessWaitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::SchedProcessWaitFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
