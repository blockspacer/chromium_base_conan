// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_BUNDLE_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_BUNDLE_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class FtraceEventBundle;
class FtraceEventBundle_CompactSched;
class FtraceEvent;
class MaliTracingMarkWriteFtraceEvent;
class G2dTracingMarkWriteFtraceEvent;
class DpuTracingMarkWriteFtraceEvent;
class FastrpcDmaStatFtraceEvent;
class CpuhpLatencyFtraceEvent;
class CpuhpEnterFtraceEvent;
class CpuhpMultiEnterFtraceEvent;
class CpuhpExitFtraceEvent;
class CdevUpdateFtraceEvent;
class ThermalTemperatureFtraceEvent;
class GpuMemTotalFtraceEvent;
class ScmCallEndFtraceEvent;
class ScmCallStartFtraceEvent;
class IonBufferDestroyFtraceEvent;
class IonBufferCreateFtraceEvent;
class IonStatFtraceEvent;
class MarkVictimFtraceEvent;
class SdeTracingMarkWriteFtraceEvent;
class GpuFrequencyFtraceEvent;
class ZeroFtraceEvent;
class SysExitFtraceEvent;
class SysEnterFtraceEvent;
class MmEventRecordFtraceEvent;
class GenericFtraceEvent;
class GenericFtraceEvent_Field;
class OomScoreAdjUpdateFtraceEvent;
class SignalGenerateFtraceEvent;
class SignalDeliverFtraceEvent;
class BinderTransactionAllocBufFtraceEvent;
class ClkSetRateFtraceEvent;
class ClkDisableFtraceEvent;
class ClkEnableFtraceEvent;
class FenceSignaledFtraceEvent;
class FenceEnableSignalFtraceEvent;
class FenceDestroyFtraceEvent;
class FenceInitFtraceEvent;
class IonHeapGrowFtraceEvent;
class IonHeapShrinkFtraceEvent;
class RssStatFtraceEvent;
class MmPagePcpuDrainFtraceEvent;
class MmPageFreeBatchedFtraceEvent;
class MmPageFreeFtraceEvent;
class MmPageAllocZoneLockedFtraceEvent;
class MmPageAllocExtfragFtraceEvent;
class MmPageAllocFtraceEvent;
class MigrateRetryFtraceEvent;
class MigratePagesStartFtraceEvent;
class MigratePagesEndFtraceEvent;
class KmemCacheFreeFtraceEvent;
class KmemCacheAllocNodeFtraceEvent;
class KmemCacheAllocFtraceEvent;
class KmallocNodeFtraceEvent;
class KmallocFtraceEvent;
class KfreeFtraceEvent;
class IonSecureCmaShrinkPoolStartFtraceEvent;
class IonSecureCmaShrinkPoolEndFtraceEvent;
class IonSecureCmaAllocateStartFtraceEvent;
class IonSecureCmaAllocateEndFtraceEvent;
class IonSecureCmaAddToPoolStartFtraceEvent;
class IonSecureCmaAddToPoolEndFtraceEvent;
class IonPrefetchingFtraceEvent;
class IonCpSecureBufferStartFtraceEvent;
class IonCpSecureBufferEndFtraceEvent;
class IonCpAllocRetryFtraceEvent;
class IonAllocBufferStartFtraceEvent;
class IonAllocBufferFallbackFtraceEvent;
class IonAllocBufferFailFtraceEvent;
class IonAllocBufferEndFtraceEvent;
class IommuSecPtblMapRangeStartFtraceEvent;
class IommuSecPtblMapRangeEndFtraceEvent;
class IommuMapRangeFtraceEvent;
class DmaAllocContiguousRetryFtraceEvent;
class AllocPagesSysStartFtraceEvent;
class AllocPagesSysFailFtraceEvent;
class AllocPagesSysEndFtraceEvent;
class AllocPagesIommuStartFtraceEvent;
class AllocPagesIommuFailFtraceEvent;
class AllocPagesIommuEndFtraceEvent;
class F2fsWriteEndFtraceEvent;
class F2fsWriteCheckpointFtraceEvent;
class F2fsWriteBeginFtraceEvent;
class F2fsVmPageMkwriteFtraceEvent;
class F2fsUnlinkExitFtraceEvent;
class F2fsUnlinkEnterFtraceEvent;
class F2fsTruncatePartialNodesFtraceEvent;
class F2fsTruncateNodesExitFtraceEvent;
class F2fsTruncateNodesEnterFtraceEvent;
class F2fsTruncateNodeFtraceEvent;
class F2fsTruncateInodeBlocksExitFtraceEvent;
class F2fsTruncateInodeBlocksEnterFtraceEvent;
class F2fsTruncateDataBlocksRangeFtraceEvent;
class F2fsTruncateBlocksExitFtraceEvent;
class F2fsTruncateBlocksEnterFtraceEvent;
class F2fsTruncateFtraceEvent;
class F2fsSyncFsFtraceEvent;
class F2fsSyncFileExitFtraceEvent;
class F2fsSyncFileEnterFtraceEvent;
class F2fsSubmitWritePageFtraceEvent;
class F2fsSetPageDirtyFtraceEvent;
class F2fsReserveNewBlockFtraceEvent;
class F2fsReadpageFtraceEvent;
class F2fsNewInodeFtraceEvent;
class F2fsIgetExitFtraceEvent;
class F2fsIgetFtraceEvent;
class F2fsGetVictimFtraceEvent;
class F2fsGetDataBlockFtraceEvent;
class F2fsFallocateFtraceEvent;
class F2fsEvictInodeFtraceEvent;
class F2fsDoSubmitBioFtraceEvent;
class SchedProcessWaitFtraceEvent;
class SchedProcessHangFtraceEvent;
class SchedProcessFreeFtraceEvent;
class SchedProcessForkFtraceEvent;
class SchedProcessExitFtraceEvent;
class SchedProcessExecFtraceEvent;
class TaskRenameFtraceEvent;
class TaskNewtaskFtraceEvent;
class Ext4ZeroRangeFtraceEvent;
class Ext4WritepagesResultFtraceEvent;
class Ext4WritepagesFtraceEvent;
class Ext4WritepageFtraceEvent;
class Ext4WriteEndFtraceEvent;
class Ext4WriteBeginFtraceEvent;
class Ext4UnlinkExitFtraceEvent;
class Ext4UnlinkEnterFtraceEvent;
class Ext4TruncateExitFtraceEvent;
class Ext4TruncateEnterFtraceEvent;
class Ext4TrimExtentFtraceEvent;
class Ext4TrimAllFreeFtraceEvent;
class Ext4SyncFsFtraceEvent;
class Ext4RequestInodeFtraceEvent;
class Ext4RequestBlocksFtraceEvent;
class Ext4RemoveBlocksFtraceEvent;
class Ext4ReleasepageFtraceEvent;
class Ext4ReadpageFtraceEvent;
class Ext4ReadBlockBitmapLoadFtraceEvent;
class Ext4PunchHoleFtraceEvent;
class Ext4OtherInodeUpdateTimeFtraceEvent;
class Ext4MballocPreallocFtraceEvent;
class Ext4MballocFreeFtraceEvent;
class Ext4MballocDiscardFtraceEvent;
class Ext4MballocAllocFtraceEvent;
class Ext4MbReleaseInodePaFtraceEvent;
class Ext4MbReleaseGroupPaFtraceEvent;
class Ext4MbNewInodePaFtraceEvent;
class Ext4MbNewGroupPaFtraceEvent;
class Ext4MbDiscardPreallocationsFtraceEvent;
class Ext4MbBuddyBitmapLoadFtraceEvent;
class Ext4MbBitmapLoadFtraceEvent;
class Ext4MarkInodeDirtyFtraceEvent;
class Ext4LoadInodeBitmapFtraceEvent;
class Ext4LoadInodeFtraceEvent;
class Ext4JournalledWriteEndFtraceEvent;
class Ext4JournalledInvalidatepageFtraceEvent;
class Ext4JournalStartReservedFtraceEvent;
class Ext4JournalStartFtraceEvent;
class Ext4InvalidatepageFtraceEvent;
class Ext4InsertRangeFtraceEvent;
class Ext4IndMapBlocksExitFtraceEvent;
class Ext4IndMapBlocksEnterFtraceEvent;
class Ext4GetReservedClusterAllocFtraceEvent;
class Ext4GetImpliedClusterAllocExitFtraceEvent;
class Ext4FreeInodeFtraceEvent;
class Ext4FreeBlocksFtraceEvent;
class Ext4ForgetFtraceEvent;
class Ext4FindDelallocRangeFtraceEvent;
class Ext4FallocateExitFtraceEvent;
class Ext4FallocateEnterFtraceEvent;
class Ext4ExtShowExtentFtraceEvent;
class Ext4ExtRmLeafFtraceEvent;
class Ext4ExtRmIdxFtraceEvent;
class Ext4ExtRemoveSpaceDoneFtraceEvent;
class Ext4ExtRemoveSpaceFtraceEvent;
class Ext4ExtPutInCacheFtraceEvent;
class Ext4ExtMapBlocksExitFtraceEvent;
class Ext4ExtMapBlocksEnterFtraceEvent;
class Ext4ExtLoadExtentFtraceEvent;
class Ext4ExtInCacheFtraceEvent;
class Ext4ExtHandleUnwrittenExtentsFtraceEvent;
class Ext4ExtConvertToInitializedFastpathFtraceEvent;
class Ext4ExtConvertToInitializedEnterFtraceEvent;
class Ext4EvictInodeFtraceEvent;
class Ext4EsShrinkScanExitFtraceEvent;
class Ext4EsShrinkScanEnterFtraceEvent;
class Ext4EsShrinkCountFtraceEvent;
class Ext4EsShrinkFtraceEvent;
class Ext4EsRemoveExtentFtraceEvent;
class Ext4EsLookupExtentExitFtraceEvent;
class Ext4EsLookupExtentEnterFtraceEvent;
class Ext4EsInsertExtentFtraceEvent;
class Ext4EsFindDelayedExtentRangeExitFtraceEvent;
class Ext4EsFindDelayedExtentRangeEnterFtraceEvent;
class Ext4EsCacheExtentFtraceEvent;
class Ext4DropInodeFtraceEvent;
class Ext4DiscardPreallocationsFtraceEvent;
class Ext4DiscardBlocksFtraceEvent;
class Ext4DirectIOExitFtraceEvent;
class Ext4DirectIOEnterFtraceEvent;
class Ext4DaWritePagesExtentFtraceEvent;
class Ext4DaWritePagesFtraceEvent;
class Ext4DaUpdateReserveSpaceFtraceEvent;
class Ext4DaReserveSpaceFtraceEvent;
class Ext4DaReleaseSpaceFtraceEvent;
class Ext4CollapseRangeFtraceEvent;
class Ext4BeginOrderedTruncateFtraceEvent;
class Ext4AllocateInodeFtraceEvent;
class Ext4AllocateBlocksFtraceEvent;
class Ext4AllocDaBlocksFtraceEvent;
class BlockUnplugFtraceEvent;
class BlockTouchBufferFtraceEvent;
class BlockSplitFtraceEvent;
class BlockSleeprqFtraceEvent;
class BlockRqRequeueFtraceEvent;
class BlockRqRemapFtraceEvent;
class BlockRqInsertFtraceEvent;
class BlockRqCompleteFtraceEvent;
class BlockRqAbortFtraceEvent;
class BlockPlugFtraceEvent;
class BlockGetrqFtraceEvent;
class BlockDirtyBufferFtraceEvent;
class BlockBioRemapFtraceEvent;
class BlockBioQueueFtraceEvent;
class BlockBioFrontmergeFtraceEvent;
class BlockBioCompleteFtraceEvent;
class BlockBioBounceFtraceEvent;
class BlockBioBackmergeFtraceEvent;
class SchedWakeupNewFtraceEvent;
class SuspendResumeFtraceEvent;
class MmCompactionWakeupKcompactdFtraceEvent;
class MmCompactionTryToCompactPagesFtraceEvent;
class MmCompactionSuitableFtraceEvent;
class MmCompactionMigratepagesFtraceEvent;
class MmCompactionKcompactdWakeFtraceEvent;
class MmCompactionKcompactdSleepFtraceEvent;
class MmCompactionIsolateMigratepagesFtraceEvent;
class MmCompactionIsolateFreepagesFtraceEvent;
class MmCompactionFinishedFtraceEvent;
class MmCompactionEndFtraceEvent;
class MmCompactionDeferResetFtraceEvent;
class MmCompactionDeferredFtraceEvent;
class MmCompactionDeferCompactionFtraceEvent;
class MmCompactionBeginFtraceEvent;
class MmFilemapDeleteFromPageCacheFtraceEvent;
class MmFilemapAddToPageCacheFtraceEvent;
class RotatorBwAoAsContextFtraceEvent;
class MdpPerfUpdateBusFtraceEvent;
class MdpPerfPrefillCalcFtraceEvent;
class MdpCmdWaitPingpongFtraceEvent;
class MdpVideoUnderrunDoneFtraceEvent;
class MdpPerfSetWmLevelsFtraceEvent;
class MdpMixerUpdateFtraceEvent;
class MdpCmdReleaseBwFtraceEvent;
class MdpTraceCounterFtraceEvent;
class MdpPerfSetQosLutsFtraceEvent;
class MdpMisrCrcFtraceEvent;
class MdpCmdReadptrDoneFtraceEvent;
class MdpSsppSetFtraceEvent;
class MdpPerfSetPanicLutsFtraceEvent;
class MdpCompareBwFtraceEvent;
class MdpCmdPingpongDoneFtraceEvent;
class TracingMarkWriteFtraceEvent;
class MdpSsppChangeFtraceEvent;
class MdpPerfSetOtFtraceEvent;
class MdpCommitFtraceEvent;
class MdpCmdKickoffFtraceEvent;
class CgroupSetupRootFtraceEvent;
class CgroupRenameFtraceEvent;
class CgroupReleaseFtraceEvent;
class CgroupDestroyRootFtraceEvent;
class CgroupTransferTasksFtraceEvent;
class CgroupRmdirFtraceEvent;
class CgroupRemountFtraceEvent;
class CgroupMkdirFtraceEvent;
class CgroupAttachTaskFtraceEvent;
class RegulatorSetVoltageCompleteFtraceEvent;
class RegulatorSetVoltageFtraceEvent;
class RegulatorEnableDelayFtraceEvent;
class RegulatorEnableCompleteFtraceEvent;
class RegulatorEnableFtraceEvent;
class RegulatorDisableCompleteFtraceEvent;
class RegulatorDisableFtraceEvent;
class WorkqueueQueueWorkFtraceEvent;
class WorkqueueExecuteStartFtraceEvent;
class WorkqueueExecuteEndFtraceEvent;
class WorkqueueActivateWorkFtraceEvent;
class BinderUnlockFtraceEvent;
class BinderLockedFtraceEvent;
class BinderLockFtraceEvent;
class BinderSetPriorityFtraceEvent;
class BinderTransactionReceivedFtraceEvent;
class BinderTransactionFtraceEvent;
class MmVmscanKswapdSleepFtraceEvent;
class MmVmscanKswapdWakeFtraceEvent;
class MmVmscanDirectReclaimEndFtraceEvent;
class MmVmscanDirectReclaimBeginFtraceEvent;
class BlockRqIssueFtraceEvent;
class Ext4SyncFileExitFtraceEvent;
class Ext4SyncFileEnterFtraceEvent;
class Ext4DaWriteEndFtraceEvent;
class Ext4DaWriteBeginFtraceEvent;
class SyncWaitFtraceEvent;
class SyncTimelineFtraceEvent;
class SyncPtFtraceEvent;
class IrqHandlerExitFtraceEvent;
class IrqHandlerEntryFtraceEvent;
class LowmemoryKillFtraceEvent;
class SmbusReplyFtraceEvent;
class SmbusResultFtraceEvent;
class SmbusWriteFtraceEvent;
class SmbusReadFtraceEvent;
class I2cReplyFtraceEvent;
class I2cResultFtraceEvent;
class I2cWriteFtraceEvent;
class I2cReadFtraceEvent;
class SoftirqRaiseFtraceEvent;
class SoftirqExitFtraceEvent;
class SoftirqEntryFtraceEvent;
class IpiRaiseFtraceEvent;
class IpiExitFtraceEvent;
class IpiEntryFtraceEvent;
class SchedWakingFtraceEvent;
class SchedCpuHotplugFtraceEvent;
class SchedBlockedReasonFtraceEvent;
class SchedWakeupFtraceEvent;
class ClockSetRateFtraceEvent;
class ClockDisableFtraceEvent;
class ClockEnableFtraceEvent;
class CpuIdleFtraceEvent;
class CpuFrequencyLimitsFtraceEvent;
class CpuFrequencyFtraceEvent;
class SchedSwitchFtraceEvent;
class PrintFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT FtraceEventBundle : public ::protozero::CppMessageObj {
 public:
  using CompactSched = FtraceEventBundle_CompactSched;
  enum FieldNumbers {
    kCpuFieldNumber = 1,
    kEventFieldNumber = 2,
    kLostEventsFieldNumber = 3,
    kCompactSchedFieldNumber = 4,
  };

  FtraceEventBundle();
  ~FtraceEventBundle() override;
  FtraceEventBundle(FtraceEventBundle&&) noexcept;
  FtraceEventBundle& operator=(FtraceEventBundle&&);
  FtraceEventBundle(const FtraceEventBundle&);
  FtraceEventBundle& operator=(const FtraceEventBundle&);
  bool operator==(const FtraceEventBundle&) const;
  bool operator!=(const FtraceEventBundle& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cpu() const { return _has_field_[1]; }
  uint32_t cpu() const { return cpu_; }
  void set_cpu(uint32_t value) { cpu_ = value; _has_field_.set(1); }

  const std::vector<FtraceEvent>& event() const { return event_; }
  std::vector<FtraceEvent>* mutable_event() { return &event_; }
  int event_size() const;
  void clear_event();
  FtraceEvent* add_event();

  bool has_lost_events() const { return _has_field_[3]; }
  bool lost_events() const { return lost_events_; }
  void set_lost_events(bool value) { lost_events_ = value; _has_field_.set(3); }

  bool has_compact_sched() const { return _has_field_[4]; }
  const FtraceEventBundle_CompactSched& compact_sched() const { return *compact_sched_; }
  FtraceEventBundle_CompactSched* mutable_compact_sched() { _has_field_.set(4); return compact_sched_.get(); }

 private:
  uint32_t cpu_{};
  std::vector<FtraceEvent> event_;
  bool lost_events_{};
  ::protozero::CopyablePtr<FtraceEventBundle_CompactSched> compact_sched_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT FtraceEventBundle_CompactSched : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kInternTableFieldNumber = 5,
    kSwitchTimestampFieldNumber = 1,
    kSwitchPrevStateFieldNumber = 2,
    kSwitchNextPidFieldNumber = 3,
    kSwitchNextPrioFieldNumber = 4,
    kSwitchNextCommIndexFieldNumber = 6,
    kWakingTimestampFieldNumber = 7,
    kWakingPidFieldNumber = 8,
    kWakingTargetCpuFieldNumber = 9,
    kWakingPrioFieldNumber = 10,
    kWakingCommIndexFieldNumber = 11,
  };

  FtraceEventBundle_CompactSched();
  ~FtraceEventBundle_CompactSched() override;
  FtraceEventBundle_CompactSched(FtraceEventBundle_CompactSched&&) noexcept;
  FtraceEventBundle_CompactSched& operator=(FtraceEventBundle_CompactSched&&);
  FtraceEventBundle_CompactSched(const FtraceEventBundle_CompactSched&);
  FtraceEventBundle_CompactSched& operator=(const FtraceEventBundle_CompactSched&);
  bool operator==(const FtraceEventBundle_CompactSched&) const;
  bool operator!=(const FtraceEventBundle_CompactSched& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<std::string>& intern_table() const { return intern_table_; }
  std::vector<std::string>* mutable_intern_table() { return &intern_table_; }
  int intern_table_size() const { return static_cast<int>(intern_table_.size()); }
  void clear_intern_table() { intern_table_.clear(); }
  void add_intern_table(std::string value) { intern_table_.emplace_back(value); }
  std::string* add_intern_table() { intern_table_.emplace_back(); return &intern_table_.back(); }

  const std::vector<uint64_t>& switch_timestamp() const { return switch_timestamp_; }
  std::vector<uint64_t>* mutable_switch_timestamp() { return &switch_timestamp_; }
  int switch_timestamp_size() const { return static_cast<int>(switch_timestamp_.size()); }
  void clear_switch_timestamp() { switch_timestamp_.clear(); }
  void add_switch_timestamp(uint64_t value) { switch_timestamp_.emplace_back(value); }
  uint64_t* add_switch_timestamp() { switch_timestamp_.emplace_back(); return &switch_timestamp_.back(); }

  const std::vector<int64_t>& switch_prev_state() const { return switch_prev_state_; }
  std::vector<int64_t>* mutable_switch_prev_state() { return &switch_prev_state_; }
  int switch_prev_state_size() const { return static_cast<int>(switch_prev_state_.size()); }
  void clear_switch_prev_state() { switch_prev_state_.clear(); }
  void add_switch_prev_state(int64_t value) { switch_prev_state_.emplace_back(value); }
  int64_t* add_switch_prev_state() { switch_prev_state_.emplace_back(); return &switch_prev_state_.back(); }

  const std::vector<int32_t>& switch_next_pid() const { return switch_next_pid_; }
  std::vector<int32_t>* mutable_switch_next_pid() { return &switch_next_pid_; }
  int switch_next_pid_size() const { return static_cast<int>(switch_next_pid_.size()); }
  void clear_switch_next_pid() { switch_next_pid_.clear(); }
  void add_switch_next_pid(int32_t value) { switch_next_pid_.emplace_back(value); }
  int32_t* add_switch_next_pid() { switch_next_pid_.emplace_back(); return &switch_next_pid_.back(); }

  const std::vector<int32_t>& switch_next_prio() const { return switch_next_prio_; }
  std::vector<int32_t>* mutable_switch_next_prio() { return &switch_next_prio_; }
  int switch_next_prio_size() const { return static_cast<int>(switch_next_prio_.size()); }
  void clear_switch_next_prio() { switch_next_prio_.clear(); }
  void add_switch_next_prio(int32_t value) { switch_next_prio_.emplace_back(value); }
  int32_t* add_switch_next_prio() { switch_next_prio_.emplace_back(); return &switch_next_prio_.back(); }

  const std::vector<uint32_t>& switch_next_comm_index() const { return switch_next_comm_index_; }
  std::vector<uint32_t>* mutable_switch_next_comm_index() { return &switch_next_comm_index_; }
  int switch_next_comm_index_size() const { return static_cast<int>(switch_next_comm_index_.size()); }
  void clear_switch_next_comm_index() { switch_next_comm_index_.clear(); }
  void add_switch_next_comm_index(uint32_t value) { switch_next_comm_index_.emplace_back(value); }
  uint32_t* add_switch_next_comm_index() { switch_next_comm_index_.emplace_back(); return &switch_next_comm_index_.back(); }

  const std::vector<uint64_t>& waking_timestamp() const { return waking_timestamp_; }
  std::vector<uint64_t>* mutable_waking_timestamp() { return &waking_timestamp_; }
  int waking_timestamp_size() const { return static_cast<int>(waking_timestamp_.size()); }
  void clear_waking_timestamp() { waking_timestamp_.clear(); }
  void add_waking_timestamp(uint64_t value) { waking_timestamp_.emplace_back(value); }
  uint64_t* add_waking_timestamp() { waking_timestamp_.emplace_back(); return &waking_timestamp_.back(); }

  const std::vector<int32_t>& waking_pid() const { return waking_pid_; }
  std::vector<int32_t>* mutable_waking_pid() { return &waking_pid_; }
  int waking_pid_size() const { return static_cast<int>(waking_pid_.size()); }
  void clear_waking_pid() { waking_pid_.clear(); }
  void add_waking_pid(int32_t value) { waking_pid_.emplace_back(value); }
  int32_t* add_waking_pid() { waking_pid_.emplace_back(); return &waking_pid_.back(); }

  const std::vector<int32_t>& waking_target_cpu() const { return waking_target_cpu_; }
  std::vector<int32_t>* mutable_waking_target_cpu() { return &waking_target_cpu_; }
  int waking_target_cpu_size() const { return static_cast<int>(waking_target_cpu_.size()); }
  void clear_waking_target_cpu() { waking_target_cpu_.clear(); }
  void add_waking_target_cpu(int32_t value) { waking_target_cpu_.emplace_back(value); }
  int32_t* add_waking_target_cpu() { waking_target_cpu_.emplace_back(); return &waking_target_cpu_.back(); }

  const std::vector<int32_t>& waking_prio() const { return waking_prio_; }
  std::vector<int32_t>* mutable_waking_prio() { return &waking_prio_; }
  int waking_prio_size() const { return static_cast<int>(waking_prio_.size()); }
  void clear_waking_prio() { waking_prio_.clear(); }
  void add_waking_prio(int32_t value) { waking_prio_.emplace_back(value); }
  int32_t* add_waking_prio() { waking_prio_.emplace_back(); return &waking_prio_.back(); }

  const std::vector<uint32_t>& waking_comm_index() const { return waking_comm_index_; }
  std::vector<uint32_t>* mutable_waking_comm_index() { return &waking_comm_index_; }
  int waking_comm_index_size() const { return static_cast<int>(waking_comm_index_.size()); }
  void clear_waking_comm_index() { waking_comm_index_.clear(); }
  void add_waking_comm_index(uint32_t value) { waking_comm_index_.emplace_back(value); }
  uint32_t* add_waking_comm_index() { waking_comm_index_.emplace_back(); return &waking_comm_index_.back(); }

 private:
  std::vector<std::string> intern_table_;
  std::vector<uint64_t> switch_timestamp_;
  std::vector<int64_t> switch_prev_state_;
  std::vector<int32_t> switch_next_pid_;
  std::vector<int32_t> switch_next_prio_;
  std::vector<uint32_t> switch_next_comm_index_;
  std::vector<uint64_t> waking_timestamp_;
  std::vector<int32_t> waking_pid_;
  std::vector<int32_t> waking_target_cpu_;
  std::vector<int32_t> waking_prio_;
  std::vector<uint32_t> waking_comm_index_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<12> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_BUNDLE_PROTO_CPP_H_
