// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/kmem.proto

#include "protos/perfetto/trace/ftrace/kmem.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace perfetto {
namespace protos {
class AllocPagesIommuEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AllocPagesIommuEndFtraceEvent> _instance;
} _AllocPagesIommuEndFtraceEvent_default_instance_;
class AllocPagesIommuFailFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AllocPagesIommuFailFtraceEvent> _instance;
} _AllocPagesIommuFailFtraceEvent_default_instance_;
class AllocPagesIommuStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AllocPagesIommuStartFtraceEvent> _instance;
} _AllocPagesIommuStartFtraceEvent_default_instance_;
class AllocPagesSysEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AllocPagesSysEndFtraceEvent> _instance;
} _AllocPagesSysEndFtraceEvent_default_instance_;
class AllocPagesSysFailFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AllocPagesSysFailFtraceEvent> _instance;
} _AllocPagesSysFailFtraceEvent_default_instance_;
class AllocPagesSysStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AllocPagesSysStartFtraceEvent> _instance;
} _AllocPagesSysStartFtraceEvent_default_instance_;
class DmaAllocContiguousRetryFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DmaAllocContiguousRetryFtraceEvent> _instance;
} _DmaAllocContiguousRetryFtraceEvent_default_instance_;
class IommuMapRangeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IommuMapRangeFtraceEvent> _instance;
} _IommuMapRangeFtraceEvent_default_instance_;
class IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IommuSecPtblMapRangeEndFtraceEvent> _instance;
} _IommuSecPtblMapRangeEndFtraceEvent_default_instance_;
class IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IommuSecPtblMapRangeStartFtraceEvent> _instance;
} _IommuSecPtblMapRangeStartFtraceEvent_default_instance_;
class IonAllocBufferEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonAllocBufferEndFtraceEvent> _instance;
} _IonAllocBufferEndFtraceEvent_default_instance_;
class IonAllocBufferFailFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonAllocBufferFailFtraceEvent> _instance;
} _IonAllocBufferFailFtraceEvent_default_instance_;
class IonAllocBufferFallbackFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonAllocBufferFallbackFtraceEvent> _instance;
} _IonAllocBufferFallbackFtraceEvent_default_instance_;
class IonAllocBufferStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonAllocBufferStartFtraceEvent> _instance;
} _IonAllocBufferStartFtraceEvent_default_instance_;
class IonCpAllocRetryFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonCpAllocRetryFtraceEvent> _instance;
} _IonCpAllocRetryFtraceEvent_default_instance_;
class IonCpSecureBufferEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonCpSecureBufferEndFtraceEvent> _instance;
} _IonCpSecureBufferEndFtraceEvent_default_instance_;
class IonCpSecureBufferStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonCpSecureBufferStartFtraceEvent> _instance;
} _IonCpSecureBufferStartFtraceEvent_default_instance_;
class IonPrefetchingFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonPrefetchingFtraceEvent> _instance;
} _IonPrefetchingFtraceEvent_default_instance_;
class IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonSecureCmaAddToPoolEndFtraceEvent> _instance;
} _IonSecureCmaAddToPoolEndFtraceEvent_default_instance_;
class IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonSecureCmaAddToPoolStartFtraceEvent> _instance;
} _IonSecureCmaAddToPoolStartFtraceEvent_default_instance_;
class IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonSecureCmaAllocateEndFtraceEvent> _instance;
} _IonSecureCmaAllocateEndFtraceEvent_default_instance_;
class IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonSecureCmaAllocateStartFtraceEvent> _instance;
} _IonSecureCmaAllocateStartFtraceEvent_default_instance_;
class IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonSecureCmaShrinkPoolEndFtraceEvent> _instance;
} _IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_;
class IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonSecureCmaShrinkPoolStartFtraceEvent> _instance;
} _IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_;
class KfreeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<KfreeFtraceEvent> _instance;
} _KfreeFtraceEvent_default_instance_;
class KmallocFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<KmallocFtraceEvent> _instance;
} _KmallocFtraceEvent_default_instance_;
class KmallocNodeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<KmallocNodeFtraceEvent> _instance;
} _KmallocNodeFtraceEvent_default_instance_;
class KmemCacheAllocFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<KmemCacheAllocFtraceEvent> _instance;
} _KmemCacheAllocFtraceEvent_default_instance_;
class KmemCacheAllocNodeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<KmemCacheAllocNodeFtraceEvent> _instance;
} _KmemCacheAllocNodeFtraceEvent_default_instance_;
class KmemCacheFreeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<KmemCacheFreeFtraceEvent> _instance;
} _KmemCacheFreeFtraceEvent_default_instance_;
class MigratePagesEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MigratePagesEndFtraceEvent> _instance;
} _MigratePagesEndFtraceEvent_default_instance_;
class MigratePagesStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MigratePagesStartFtraceEvent> _instance;
} _MigratePagesStartFtraceEvent_default_instance_;
class MigrateRetryFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MigrateRetryFtraceEvent> _instance;
} _MigrateRetryFtraceEvent_default_instance_;
class MmPageAllocFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MmPageAllocFtraceEvent> _instance;
} _MmPageAllocFtraceEvent_default_instance_;
class MmPageAllocExtfragFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MmPageAllocExtfragFtraceEvent> _instance;
} _MmPageAllocExtfragFtraceEvent_default_instance_;
class MmPageAllocZoneLockedFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MmPageAllocZoneLockedFtraceEvent> _instance;
} _MmPageAllocZoneLockedFtraceEvent_default_instance_;
class MmPageFreeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MmPageFreeFtraceEvent> _instance;
} _MmPageFreeFtraceEvent_default_instance_;
class MmPageFreeBatchedFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MmPageFreeBatchedFtraceEvent> _instance;
} _MmPageFreeBatchedFtraceEvent_default_instance_;
class MmPagePcpuDrainFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MmPagePcpuDrainFtraceEvent> _instance;
} _MmPagePcpuDrainFtraceEvent_default_instance_;
class RssStatFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RssStatFtraceEvent> _instance;
} _RssStatFtraceEvent_default_instance_;
class IonHeapShrinkFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonHeapShrinkFtraceEvent> _instance;
} _IonHeapShrinkFtraceEvent_default_instance_;
class IonHeapGrowFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonHeapGrowFtraceEvent> _instance;
} _IonHeapGrowFtraceEvent_default_instance_;
class IonBufferCreateFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonBufferCreateFtraceEvent> _instance;
} _IonBufferCreateFtraceEvent_default_instance_;
class IonBufferDestroyFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IonBufferDestroyFtraceEvent> _instance;
} _IonBufferDestroyFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
static void InitDefaultsscc_info_AllocPagesIommuEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_AllocPagesIommuEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::AllocPagesIommuEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::AllocPagesIommuEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AllocPagesIommuEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AllocPagesIommuEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_AllocPagesIommuFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_AllocPagesIommuFailFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::AllocPagesIommuFailFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::AllocPagesIommuFailFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AllocPagesIommuFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AllocPagesIommuFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_AllocPagesIommuStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_AllocPagesIommuStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::AllocPagesIommuStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::AllocPagesIommuStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AllocPagesIommuStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AllocPagesIommuStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_AllocPagesSysEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_AllocPagesSysEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::AllocPagesSysEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::AllocPagesSysEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AllocPagesSysEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AllocPagesSysEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_AllocPagesSysFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_AllocPagesSysFailFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::AllocPagesSysFailFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::AllocPagesSysFailFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AllocPagesSysFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AllocPagesSysFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_AllocPagesSysStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_AllocPagesSysStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::AllocPagesSysStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::AllocPagesSysStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AllocPagesSysStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AllocPagesSysStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_DmaAllocContiguousRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_DmaAllocContiguousRetryFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DmaAllocContiguousRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_DmaAllocContiguousRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IommuMapRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IommuMapRangeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IommuMapRangeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IommuMapRangeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IommuMapRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IommuMapRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IommuSecPtblMapRangeEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IommuSecPtblMapRangeEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IommuSecPtblMapRangeEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IommuSecPtblMapRangeEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IommuSecPtblMapRangeStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IommuSecPtblMapRangeStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IommuSecPtblMapRangeStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IommuSecPtblMapRangeStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonAllocBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonAllocBufferEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonAllocBufferEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonAllocBufferEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonAllocBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonAllocBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonAllocBufferFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonAllocBufferFailFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonAllocBufferFailFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonAllocBufferFailFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonAllocBufferFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonAllocBufferFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonAllocBufferFallbackFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonAllocBufferFallbackFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonAllocBufferFallbackFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonAllocBufferFallbackFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonAllocBufferFallbackFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonAllocBufferFallbackFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonAllocBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonAllocBufferStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonAllocBufferStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonAllocBufferStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonAllocBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonAllocBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonBufferCreateFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonBufferCreateFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonBufferCreateFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonBufferCreateFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonBufferCreateFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonBufferCreateFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonBufferDestroyFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonBufferDestroyFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonBufferDestroyFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonBufferDestroyFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonBufferDestroyFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonBufferDestroyFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonCpAllocRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonCpAllocRetryFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonCpAllocRetryFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonCpAllocRetryFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonCpAllocRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonCpAllocRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonCpSecureBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonCpSecureBufferEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonCpSecureBufferEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonCpSecureBufferEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonCpSecureBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonCpSecureBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonCpSecureBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonCpSecureBufferStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonCpSecureBufferStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonCpSecureBufferStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonCpSecureBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonCpSecureBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonHeapGrowFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonHeapGrowFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonHeapGrowFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonHeapGrowFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonHeapGrowFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonHeapGrowFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonHeapShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonHeapShrinkFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonHeapShrinkFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonHeapShrinkFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonHeapShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonHeapShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonPrefetchingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonPrefetchingFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonPrefetchingFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonPrefetchingFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonPrefetchingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonPrefetchingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonSecureCmaAddToPoolEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonSecureCmaAddToPoolEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonSecureCmaAddToPoolEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonSecureCmaAddToPoolEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonSecureCmaAddToPoolStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonSecureCmaAddToPoolStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonSecureCmaAddToPoolStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonSecureCmaAddToPoolStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonSecureCmaAllocateEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonSecureCmaAllocateEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonSecureCmaAllocateEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonSecureCmaAllocateEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonSecureCmaAllocateStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonSecureCmaAllocateStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonSecureCmaAllocateStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonSecureCmaAllocateStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonSecureCmaShrinkPoolEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonSecureCmaShrinkPoolEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonSecureCmaShrinkPoolEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_IonSecureCmaShrinkPoolStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IonSecureCmaShrinkPoolStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_IonSecureCmaShrinkPoolStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_KfreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_KfreeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::KfreeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::KfreeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_KfreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_KfreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_KmallocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_KmallocFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::KmallocFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::KmallocFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_KmallocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_KmallocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_KmallocNodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_KmallocNodeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::KmallocNodeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::KmallocNodeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_KmallocNodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_KmallocNodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_KmemCacheAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_KmemCacheAllocFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::KmemCacheAllocFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::KmemCacheAllocFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_KmemCacheAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_KmemCacheAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_KmemCacheAllocNodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_KmemCacheAllocNodeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::KmemCacheAllocNodeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::KmemCacheAllocNodeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_KmemCacheAllocNodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_KmemCacheAllocNodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_KmemCacheFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_KmemCacheFreeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::KmemCacheFreeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::KmemCacheFreeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_KmemCacheFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_KmemCacheFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MigratePagesEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MigratePagesEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MigratePagesEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MigratePagesEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MigratePagesEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MigratePagesEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MigratePagesStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MigratePagesStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MigratePagesStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MigratePagesStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MigratePagesStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MigratePagesStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MigrateRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MigrateRetryFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MigrateRetryFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MigrateRetryFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MigrateRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MigrateRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MmPageAllocExtfragFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MmPageAllocExtfragFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MmPageAllocExtfragFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MmPageAllocExtfragFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MmPageAllocExtfragFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MmPageAllocExtfragFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MmPageAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MmPageAllocFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MmPageAllocFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MmPageAllocFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MmPageAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MmPageAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MmPageAllocZoneLockedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MmPageAllocZoneLockedFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MmPageAllocZoneLockedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MmPageAllocZoneLockedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MmPageFreeBatchedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MmPageFreeBatchedFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MmPageFreeBatchedFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MmPageFreeBatchedFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MmPageFreeBatchedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MmPageFreeBatchedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MmPageFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MmPageFreeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MmPageFreeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MmPageFreeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MmPageFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MmPageFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_MmPagePcpuDrainFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_MmPagePcpuDrainFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::MmPagePcpuDrainFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::MmPagePcpuDrainFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MmPagePcpuDrainFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MmPagePcpuDrainFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

static void InitDefaultsscc_info_RssStatFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_RssStatFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::RssStatFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::RssStatFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RssStatFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_RssStatFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto}, {}};

namespace perfetto {
namespace protos {

// ===================================================================

void AllocPagesIommuEndFtraceEvent::InitAsDefaultInstance() {
}
class AllocPagesIommuEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuEndFtraceEvent>()._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
}
AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(const AllocPagesIommuEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gfp_flags_, &from.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&order_) -
    reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
}

void AllocPagesIommuEndFtraceEvent::SharedCtor() {
  ::memset(&gfp_flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order_) -
      reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
}

AllocPagesIommuEndFtraceEvent::~AllocPagesIommuEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  SharedDtor();
}

void AllocPagesIommuEndFtraceEvent::SharedDtor() {
}

void AllocPagesIommuEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AllocPagesIommuEndFtraceEvent& AllocPagesIommuEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AllocPagesIommuEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void AllocPagesIommuEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&order_) -
        reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AllocPagesIommuEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AllocPagesIommuEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gfp_flags = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AllocPagesIommuEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->gfp_flags(), output);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->order(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AllocPagesIommuEndFtraceEvent)
}

size_t AllocPagesIommuEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesIommuEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AllocPagesIommuEndFtraceEvent*>(
      &from));
}

void AllocPagesIommuEndFtraceEvent::MergeFrom(const AllocPagesIommuEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      order_ = from.order_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AllocPagesIommuEndFtraceEvent::CopyFrom(const AllocPagesIommuEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuEndFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuEndFtraceEvent::InternalSwap(AllocPagesIommuEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gfp_flags_, other->gfp_flags_);
  swap(order_, other->order_);
}

std::string AllocPagesIommuEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesIommuEndFtraceEvent";
}


// ===================================================================

void AllocPagesIommuFailFtraceEvent::InitAsDefaultInstance() {
}
class AllocPagesIommuFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuFailFtraceEvent>()._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
}
AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(const AllocPagesIommuFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gfp_flags_, &from.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&order_) -
    reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
}

void AllocPagesIommuFailFtraceEvent::SharedCtor() {
  ::memset(&gfp_flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order_) -
      reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
}

AllocPagesIommuFailFtraceEvent::~AllocPagesIommuFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  SharedDtor();
}

void AllocPagesIommuFailFtraceEvent::SharedDtor() {
}

void AllocPagesIommuFailFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AllocPagesIommuFailFtraceEvent& AllocPagesIommuFailFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AllocPagesIommuFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void AllocPagesIommuFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&order_) -
        reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AllocPagesIommuFailFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AllocPagesIommuFailFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gfp_flags = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AllocPagesIommuFailFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->gfp_flags(), output);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->order(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AllocPagesIommuFailFtraceEvent)
}

size_t AllocPagesIommuFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesIommuFailFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AllocPagesIommuFailFtraceEvent*>(
      &from));
}

void AllocPagesIommuFailFtraceEvent::MergeFrom(const AllocPagesIommuFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      order_ = from.order_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AllocPagesIommuFailFtraceEvent::CopyFrom(const AllocPagesIommuFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuFailFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuFailFtraceEvent::InternalSwap(AllocPagesIommuFailFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gfp_flags_, other->gfp_flags_);
  swap(order_, other->order_);
}

std::string AllocPagesIommuFailFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesIommuFailFtraceEvent";
}


// ===================================================================

void AllocPagesIommuStartFtraceEvent::InitAsDefaultInstance() {
}
class AllocPagesIommuStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuStartFtraceEvent>()._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
}
AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(const AllocPagesIommuStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gfp_flags_, &from.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&order_) -
    reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
}

void AllocPagesIommuStartFtraceEvent::SharedCtor() {
  ::memset(&gfp_flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order_) -
      reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
}

AllocPagesIommuStartFtraceEvent::~AllocPagesIommuStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  SharedDtor();
}

void AllocPagesIommuStartFtraceEvent::SharedDtor() {
}

void AllocPagesIommuStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AllocPagesIommuStartFtraceEvent& AllocPagesIommuStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AllocPagesIommuStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void AllocPagesIommuStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&order_) -
        reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AllocPagesIommuStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AllocPagesIommuStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gfp_flags = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AllocPagesIommuStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->gfp_flags(), output);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->order(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AllocPagesIommuStartFtraceEvent)
}

size_t AllocPagesIommuStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesIommuStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AllocPagesIommuStartFtraceEvent*>(
      &from));
}

void AllocPagesIommuStartFtraceEvent::MergeFrom(const AllocPagesIommuStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      order_ = from.order_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AllocPagesIommuStartFtraceEvent::CopyFrom(const AllocPagesIommuStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuStartFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuStartFtraceEvent::InternalSwap(AllocPagesIommuStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gfp_flags_, other->gfp_flags_);
  swap(order_, other->order_);
}

std::string AllocPagesIommuStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesIommuStartFtraceEvent";
}


// ===================================================================

void AllocPagesSysEndFtraceEvent::InitAsDefaultInstance() {
}
class AllocPagesSysEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysEndFtraceEvent>()._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
}
AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(const AllocPagesSysEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gfp_flags_, &from.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&order_) -
    reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
}

void AllocPagesSysEndFtraceEvent::SharedCtor() {
  ::memset(&gfp_flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order_) -
      reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
}

AllocPagesSysEndFtraceEvent::~AllocPagesSysEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
  SharedDtor();
}

void AllocPagesSysEndFtraceEvent::SharedDtor() {
}

void AllocPagesSysEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AllocPagesSysEndFtraceEvent& AllocPagesSysEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AllocPagesSysEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void AllocPagesSysEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&order_) -
        reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AllocPagesSysEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AllocPagesSysEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gfp_flags = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AllocPagesSysEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AllocPagesSysEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AllocPagesSysEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->gfp_flags(), output);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->order(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AllocPagesSysEndFtraceEvent)
}

size_t AllocPagesSysEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesSysEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AllocPagesSysEndFtraceEvent*>(
      &from));
}

void AllocPagesSysEndFtraceEvent::MergeFrom(const AllocPagesSysEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      order_ = from.order_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AllocPagesSysEndFtraceEvent::CopyFrom(const AllocPagesSysEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysEndFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysEndFtraceEvent::InternalSwap(AllocPagesSysEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gfp_flags_, other->gfp_flags_);
  swap(order_, other->order_);
}

std::string AllocPagesSysEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesSysEndFtraceEvent";
}


// ===================================================================

void AllocPagesSysFailFtraceEvent::InitAsDefaultInstance() {
}
class AllocPagesSysFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysFailFtraceEvent>()._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
}
AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(const AllocPagesSysFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gfp_flags_, &from.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&order_) -
    reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
}

void AllocPagesSysFailFtraceEvent::SharedCtor() {
  ::memset(&gfp_flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order_) -
      reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
}

AllocPagesSysFailFtraceEvent::~AllocPagesSysFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
  SharedDtor();
}

void AllocPagesSysFailFtraceEvent::SharedDtor() {
}

void AllocPagesSysFailFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AllocPagesSysFailFtraceEvent& AllocPagesSysFailFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AllocPagesSysFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void AllocPagesSysFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&order_) -
        reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AllocPagesSysFailFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AllocPagesSysFailFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gfp_flags = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AllocPagesSysFailFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AllocPagesSysFailFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AllocPagesSysFailFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->gfp_flags(), output);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->order(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AllocPagesSysFailFtraceEvent)
}

size_t AllocPagesSysFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesSysFailFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AllocPagesSysFailFtraceEvent*>(
      &from));
}

void AllocPagesSysFailFtraceEvent::MergeFrom(const AllocPagesSysFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      order_ = from.order_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AllocPagesSysFailFtraceEvent::CopyFrom(const AllocPagesSysFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysFailFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysFailFtraceEvent::InternalSwap(AllocPagesSysFailFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gfp_flags_, other->gfp_flags_);
  swap(order_, other->order_);
}

std::string AllocPagesSysFailFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesSysFailFtraceEvent";
}


// ===================================================================

void AllocPagesSysStartFtraceEvent::InitAsDefaultInstance() {
}
class AllocPagesSysStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysStartFtraceEvent>()._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
}
AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(const AllocPagesSysStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gfp_flags_, &from.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&order_) -
    reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
}

void AllocPagesSysStartFtraceEvent::SharedCtor() {
  ::memset(&gfp_flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order_) -
      reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
}

AllocPagesSysStartFtraceEvent::~AllocPagesSysStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
  SharedDtor();
}

void AllocPagesSysStartFtraceEvent::SharedDtor() {
}

void AllocPagesSysStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AllocPagesSysStartFtraceEvent& AllocPagesSysStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AllocPagesSysStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void AllocPagesSysStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&order_) -
        reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AllocPagesSysStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AllocPagesSysStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gfp_flags = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AllocPagesSysStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AllocPagesSysStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AllocPagesSysStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->gfp_flags(), output);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->order(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AllocPagesSysStartFtraceEvent)
}

size_t AllocPagesSysStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesSysStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AllocPagesSysStartFtraceEvent*>(
      &from));
}

void AllocPagesSysStartFtraceEvent::MergeFrom(const AllocPagesSysStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      order_ = from.order_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AllocPagesSysStartFtraceEvent::CopyFrom(const AllocPagesSysStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysStartFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysStartFtraceEvent::InternalSwap(AllocPagesSysStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gfp_flags_, other->gfp_flags_);
  swap(order_, other->order_);
}

std::string AllocPagesSysStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesSysStartFtraceEvent";
}


// ===================================================================

void DmaAllocContiguousRetryFtraceEvent::InitAsDefaultInstance() {
}
class DmaAllocContiguousRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<DmaAllocContiguousRetryFtraceEvent>()._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
}
DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(const DmaAllocContiguousRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  tries_ = from.tries_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
}

void DmaAllocContiguousRetryFtraceEvent::SharedCtor() {
  tries_ = 0;
}

DmaAllocContiguousRetryFtraceEvent::~DmaAllocContiguousRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  SharedDtor();
}

void DmaAllocContiguousRetryFtraceEvent::SharedDtor() {
}

void DmaAllocContiguousRetryFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DmaAllocContiguousRetryFtraceEvent& DmaAllocContiguousRetryFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DmaAllocContiguousRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void DmaAllocContiguousRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tries_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DmaAllocContiguousRetryFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DmaAllocContiguousRetryFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 tries = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_tries(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &tries_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DmaAllocContiguousRetryFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->tries(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
}

size_t DmaAllocContiguousRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->tries());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DmaAllocContiguousRetryFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DmaAllocContiguousRetryFtraceEvent*>(
      &from));
}

void DmaAllocContiguousRetryFtraceEvent::MergeFrom(const DmaAllocContiguousRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_tries()) {
    set_tries(from.tries());
  }
}

void DmaAllocContiguousRetryFtraceEvent::CopyFrom(const DmaAllocContiguousRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DmaAllocContiguousRetryFtraceEvent::IsInitialized() const {
  return true;
}

void DmaAllocContiguousRetryFtraceEvent::InternalSwap(DmaAllocContiguousRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(tries_, other->tries_);
}

std::string DmaAllocContiguousRetryFtraceEvent::GetTypeName() const {
  return "perfetto.protos.DmaAllocContiguousRetryFtraceEvent";
}


// ===================================================================

void IommuMapRangeFtraceEvent::InitAsDefaultInstance() {
}
class IommuMapRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuMapRangeFtraceEvent>()._has_bits_);
  static void set_has_chunk_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IommuMapRangeFtraceEvent)
}
IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(const IommuMapRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&chunk_size_, &from.chunk_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&va_) -
    reinterpret_cast<char*>(&chunk_size_)) + sizeof(va_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuMapRangeFtraceEvent)
}

void IommuMapRangeFtraceEvent::SharedCtor() {
  ::memset(&chunk_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&va_) -
      reinterpret_cast<char*>(&chunk_size_)) + sizeof(va_));
}

IommuMapRangeFtraceEvent::~IommuMapRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuMapRangeFtraceEvent)
  SharedDtor();
}

void IommuMapRangeFtraceEvent::SharedDtor() {
}

void IommuMapRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IommuMapRangeFtraceEvent& IommuMapRangeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IommuMapRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IommuMapRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuMapRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&chunk_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&va_) -
        reinterpret_cast<char*>(&chunk_size_)) + sizeof(va_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IommuMapRangeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 chunk_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_chunk_size(&has_bits);
          chunk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 va = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_va(&has_bits);
          va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IommuMapRangeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IommuMapRangeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 chunk_size = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_chunk_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunk_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pa = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pa(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pa_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 va = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_va(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &va_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IommuMapRangeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IommuMapRangeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IommuMapRangeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IommuMapRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 chunk_size = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->chunk_size(), output);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->len(), output);
  }

  // optional uint64 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pa(), output);
  }

  // optional uint64 va = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->va(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IommuMapRangeFtraceEvent)
}

size_t IommuMapRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuMapRangeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 chunk_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->chunk_size());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional uint64 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pa());
    }

    // optional uint64 va = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->va());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IommuMapRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IommuMapRangeFtraceEvent*>(
      &from));
}

void IommuMapRangeFtraceEvent::MergeFrom(const IommuMapRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuMapRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      chunk_size_ = from.chunk_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_ = from.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      va_ = from.va_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IommuMapRangeFtraceEvent::CopyFrom(const IommuMapRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuMapRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuMapRangeFtraceEvent::IsInitialized() const {
  return true;
}

void IommuMapRangeFtraceEvent::InternalSwap(IommuMapRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(chunk_size_, other->chunk_size_);
  swap(len_, other->len_);
  swap(pa_, other->pa_);
  swap(va_, other->va_);
}

std::string IommuMapRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IommuMapRangeFtraceEvent";
}


// ===================================================================

void IommuSecPtblMapRangeEndFtraceEvent::InitAsDefaultInstance() {
}
class IommuSecPtblMapRangeEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuSecPtblMapRangeEndFtraceEvent>()._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sec_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
}
IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(const IommuSecPtblMapRangeEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&len_, &from.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&sec_id_) -
    reinterpret_cast<char*>(&len_)) + sizeof(sec_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
}

void IommuSecPtblMapRangeEndFtraceEvent::SharedCtor() {
  ::memset(&len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sec_id_) -
      reinterpret_cast<char*>(&len_)) + sizeof(sec_id_));
}

IommuSecPtblMapRangeEndFtraceEvent::~IommuSecPtblMapRangeEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  SharedDtor();
}

void IommuSecPtblMapRangeEndFtraceEvent::SharedDtor() {
}

void IommuSecPtblMapRangeEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IommuSecPtblMapRangeEndFtraceEvent& IommuSecPtblMapRangeEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IommuSecPtblMapRangeEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IommuSecPtblMapRangeEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sec_id_) -
        reinterpret_cast<char*>(&len_)) + sizeof(sec_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IommuSecPtblMapRangeEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num(&has_bits);
          num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 sec_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_sec_id(&has_bits);
          sec_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 va = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_va(&has_bits);
          va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IommuSecPtblMapRangeEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 len = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 pa = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pa(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pa_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sec_id = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_sec_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &sec_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 va = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_va(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &va_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IommuSecPtblMapRangeEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->len(), output);
  }

  // optional int32 num = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num(), output);
  }

  // optional uint32 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->pa(), output);
  }

  // optional int32 sec_id = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->sec_id(), output);
  }

  // optional uint64 va = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->va(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
}

size_t IommuSecPtblMapRangeEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 len = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional int32 num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional uint32 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->pa());
    }

    // optional uint64 va = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->va());
    }

    // optional int32 sec_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->sec_id());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IommuSecPtblMapRangeEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IommuSecPtblMapRangeEndFtraceEvent*>(
      &from));
}

void IommuSecPtblMapRangeEndFtraceEvent::MergeFrom(const IommuSecPtblMapRangeEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_ = from.num_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_ = from.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      va_ = from.va_;
    }
    if (cached_has_bits & 0x00000010u) {
      sec_id_ = from.sec_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IommuSecPtblMapRangeEndFtraceEvent::CopyFrom(const IommuSecPtblMapRangeEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuSecPtblMapRangeEndFtraceEvent::IsInitialized() const {
  return true;
}

void IommuSecPtblMapRangeEndFtraceEvent::InternalSwap(IommuSecPtblMapRangeEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(len_, other->len_);
  swap(num_, other->num_);
  swap(pa_, other->pa_);
  swap(va_, other->va_);
  swap(sec_id_, other->sec_id_);
}

std::string IommuSecPtblMapRangeEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent";
}


// ===================================================================

void IommuSecPtblMapRangeStartFtraceEvent::InitAsDefaultInstance() {
}
class IommuSecPtblMapRangeStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuSecPtblMapRangeStartFtraceEvent>()._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sec_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
}
IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(const IommuSecPtblMapRangeStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&len_, &from.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&sec_id_) -
    reinterpret_cast<char*>(&len_)) + sizeof(sec_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
}

void IommuSecPtblMapRangeStartFtraceEvent::SharedCtor() {
  ::memset(&len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sec_id_) -
      reinterpret_cast<char*>(&len_)) + sizeof(sec_id_));
}

IommuSecPtblMapRangeStartFtraceEvent::~IommuSecPtblMapRangeStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  SharedDtor();
}

void IommuSecPtblMapRangeStartFtraceEvent::SharedDtor() {
}

void IommuSecPtblMapRangeStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IommuSecPtblMapRangeStartFtraceEvent& IommuSecPtblMapRangeStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IommuSecPtblMapRangeStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IommuSecPtblMapRangeStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sec_id_) -
        reinterpret_cast<char*>(&len_)) + sizeof(sec_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IommuSecPtblMapRangeStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num(&has_bits);
          num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 sec_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_sec_id(&has_bits);
          sec_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 va = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_va(&has_bits);
          va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IommuSecPtblMapRangeStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 len = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 pa = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pa(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pa_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sec_id = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_sec_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &sec_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 va = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_va(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &va_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IommuSecPtblMapRangeStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->len(), output);
  }

  // optional int32 num = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num(), output);
  }

  // optional uint32 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->pa(), output);
  }

  // optional int32 sec_id = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->sec_id(), output);
  }

  // optional uint64 va = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->va(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
}

size_t IommuSecPtblMapRangeStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 len = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional int32 num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional uint32 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->pa());
    }

    // optional uint64 va = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->va());
    }

    // optional int32 sec_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->sec_id());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IommuSecPtblMapRangeStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IommuSecPtblMapRangeStartFtraceEvent*>(
      &from));
}

void IommuSecPtblMapRangeStartFtraceEvent::MergeFrom(const IommuSecPtblMapRangeStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_ = from.num_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_ = from.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      va_ = from.va_;
    }
    if (cached_has_bits & 0x00000010u) {
      sec_id_ = from.sec_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IommuSecPtblMapRangeStartFtraceEvent::CopyFrom(const IommuSecPtblMapRangeStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuSecPtblMapRangeStartFtraceEvent::IsInitialized() const {
  return true;
}

void IommuSecPtblMapRangeStartFtraceEvent::InternalSwap(IommuSecPtblMapRangeStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(len_, other->len_);
  swap(num_, other->num_);
  swap(pa_, other->pa_);
  swap(va_, other->va_);
  swap(sec_id_, other->sec_id_);
}

std::string IommuSecPtblMapRangeStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent";
}


// ===================================================================

void IonAllocBufferEndFtraceEvent::InitAsDefaultInstance() {
}
class IonAllocBufferEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferEndFtraceEvent>()._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
}
IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(const IonAllocBufferEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_name()) {
    client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
  }
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&flags_, &from.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&flags_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
}

void IonAllocBufferEndFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonAllocBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&flags_)) + sizeof(len_));
}

IonAllocBufferEndFtraceEvent::~IonAllocBufferEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
  SharedDtor();
}

void IonAllocBufferEndFtraceEvent::SharedDtor() {
  client_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonAllocBufferEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonAllocBufferEndFtraceEvent& IonAllocBufferEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonAllocBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonAllocBufferEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      client_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      heap_name_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&flags_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonAllocBufferEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_client_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_mask(&has_bits);
          mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonAllocBufferEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string client_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_client_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string heap_name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mask = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_mask(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mask_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonAllocBufferEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonAllocBufferEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonAllocBufferEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_name(), output);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->flags(), output);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->heap_name(), output);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->len(), output);
  }

  // optional uint32 mask = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->mask(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonAllocBufferEndFtraceEvent)
}

size_t IonAllocBufferEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->client_name());
    }

    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 mask = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mask());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonAllocBufferEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonAllocBufferEndFtraceEvent*>(
      &from));
}

void IonAllocBufferEndFtraceEvent::MergeFrom(const IonAllocBufferEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      mask_ = from.mask_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonAllocBufferEndFtraceEvent::CopyFrom(const IonAllocBufferEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferEndFtraceEvent::InternalSwap(IonAllocBufferEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_name_.Swap(&other->client_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(flags_, other->flags_);
  swap(mask_, other->mask_);
  swap(len_, other->len_);
}

std::string IonAllocBufferEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonAllocBufferEndFtraceEvent";
}


// ===================================================================

void IonAllocBufferFailFtraceEvent::InitAsDefaultInstance() {
}
class IonAllocBufferFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferFailFtraceEvent>()._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
}
IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(const IonAllocBufferFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_name()) {
    client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
  }
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&error_, &from.error_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&error_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
}

void IonAllocBufferFailFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonAllocBufferFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&error_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&error_)) + sizeof(len_));
}

IonAllocBufferFailFtraceEvent::~IonAllocBufferFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
  SharedDtor();
}

void IonAllocBufferFailFtraceEvent::SharedDtor() {
  client_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonAllocBufferFailFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonAllocBufferFailFtraceEvent& IonAllocBufferFailFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonAllocBufferFailFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonAllocBufferFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      client_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      heap_name_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&error_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonAllocBufferFailFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_client_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string heap_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mask = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_mask(&has_bits);
          mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonAllocBufferFailFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string client_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_client_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 error = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_error(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string heap_name = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mask = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_mask(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mask_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonAllocBufferFailFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonAllocBufferFailFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonAllocBufferFailFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_name(), output);
  }

  // optional int64 error = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->error(), output);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->flags(), output);
  }

  // optional string heap_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->heap_name(), output);
  }

  // optional uint64 len = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->len(), output);
  }

  // optional uint32 mask = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->mask(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonAllocBufferFailFtraceEvent)
}

size_t IonAllocBufferFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->client_name());
    }

    // optional string heap_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional int64 error = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->error());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 mask = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mask());
    }

    // optional uint64 len = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonAllocBufferFailFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonAllocBufferFailFtraceEvent*>(
      &from));
}

void IonAllocBufferFailFtraceEvent::MergeFrom(const IonAllocBufferFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      mask_ = from.mask_;
    }
    if (cached_has_bits & 0x00000020u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonAllocBufferFailFtraceEvent::CopyFrom(const IonAllocBufferFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferFailFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferFailFtraceEvent::InternalSwap(IonAllocBufferFailFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_name_.Swap(&other->client_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(error_, other->error_);
  swap(flags_, other->flags_);
  swap(mask_, other->mask_);
  swap(len_, other->len_);
}

std::string IonAllocBufferFailFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonAllocBufferFailFtraceEvent";
}


// ===================================================================

void IonAllocBufferFallbackFtraceEvent::InitAsDefaultInstance() {
}
class IonAllocBufferFallbackFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferFallbackFtraceEvent>()._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
}
IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(const IonAllocBufferFallbackFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_name()) {
    client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
  }
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&error_, &from.error_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&error_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
}

void IonAllocBufferFallbackFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonAllocBufferFallbackFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&error_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&error_)) + sizeof(len_));
}

IonAllocBufferFallbackFtraceEvent::~IonAllocBufferFallbackFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  SharedDtor();
}

void IonAllocBufferFallbackFtraceEvent::SharedDtor() {
  client_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonAllocBufferFallbackFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonAllocBufferFallbackFtraceEvent& IonAllocBufferFallbackFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonAllocBufferFallbackFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonAllocBufferFallbackFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      client_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      heap_name_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&error_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonAllocBufferFallbackFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_client_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string heap_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mask = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_mask(&has_bits);
          mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonAllocBufferFallbackFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string client_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_client_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 error = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_error(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string heap_name = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mask = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_mask(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mask_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonAllocBufferFallbackFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_name(), output);
  }

  // optional int64 error = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->error(), output);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->flags(), output);
  }

  // optional string heap_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->heap_name(), output);
  }

  // optional uint64 len = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->len(), output);
  }

  // optional uint32 mask = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->mask(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
}

size_t IonAllocBufferFallbackFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->client_name());
    }

    // optional string heap_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional int64 error = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->error());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 mask = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mask());
    }

    // optional uint64 len = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonAllocBufferFallbackFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonAllocBufferFallbackFtraceEvent*>(
      &from));
}

void IonAllocBufferFallbackFtraceEvent::MergeFrom(const IonAllocBufferFallbackFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      mask_ = from.mask_;
    }
    if (cached_has_bits & 0x00000020u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonAllocBufferFallbackFtraceEvent::CopyFrom(const IonAllocBufferFallbackFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferFallbackFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferFallbackFtraceEvent::InternalSwap(IonAllocBufferFallbackFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_name_.Swap(&other->client_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(error_, other->error_);
  swap(flags_, other->flags_);
  swap(mask_, other->mask_);
  swap(len_, other->len_);
}

std::string IonAllocBufferFallbackFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonAllocBufferFallbackFtraceEvent";
}


// ===================================================================

void IonAllocBufferStartFtraceEvent::InitAsDefaultInstance() {
}
class IonAllocBufferStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferStartFtraceEvent>()._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
}
IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(const IonAllocBufferStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_name()) {
    client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
  }
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&flags_, &from.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&flags_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
}

void IonAllocBufferStartFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonAllocBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&flags_)) + sizeof(len_));
}

IonAllocBufferStartFtraceEvent::~IonAllocBufferStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
  SharedDtor();
}

void IonAllocBufferStartFtraceEvent::SharedDtor() {
  client_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonAllocBufferStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonAllocBufferStartFtraceEvent& IonAllocBufferStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonAllocBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonAllocBufferStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      client_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      heap_name_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&flags_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonAllocBufferStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_client_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_mask(&has_bits);
          mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonAllocBufferStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string client_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_client_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string heap_name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mask = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_mask(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mask_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonAllocBufferStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonAllocBufferStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonAllocBufferStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_name(), output);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->flags(), output);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->heap_name(), output);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->len(), output);
  }

  // optional uint32 mask = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->mask(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonAllocBufferStartFtraceEvent)
}

size_t IonAllocBufferStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->client_name());
    }

    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 mask = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mask());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonAllocBufferStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonAllocBufferStartFtraceEvent*>(
      &from));
}

void IonAllocBufferStartFtraceEvent::MergeFrom(const IonAllocBufferStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      client_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      mask_ = from.mask_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonAllocBufferStartFtraceEvent::CopyFrom(const IonAllocBufferStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferStartFtraceEvent::InternalSwap(IonAllocBufferStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_name_.Swap(&other->client_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(flags_, other->flags_);
  swap(mask_, other->mask_);
  swap(len_, other->len_);
}

std::string IonAllocBufferStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonAllocBufferStartFtraceEvent";
}


// ===================================================================

void IonCpAllocRetryFtraceEvent::InitAsDefaultInstance() {
}
class IonCpAllocRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpAllocRetryFtraceEvent>()._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
}
IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(const IonCpAllocRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  tries_ = from.tries_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
}

void IonCpAllocRetryFtraceEvent::SharedCtor() {
  tries_ = 0;
}

IonCpAllocRetryFtraceEvent::~IonCpAllocRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
  SharedDtor();
}

void IonCpAllocRetryFtraceEvent::SharedDtor() {
}

void IonCpAllocRetryFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonCpAllocRetryFtraceEvent& IonCpAllocRetryFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonCpAllocRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonCpAllocRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tries_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonCpAllocRetryFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonCpAllocRetryFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 tries = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_tries(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &tries_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonCpAllocRetryFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonCpAllocRetryFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonCpAllocRetryFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->tries(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonCpAllocRetryFtraceEvent)
}

size_t IonCpAllocRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->tries());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonCpAllocRetryFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonCpAllocRetryFtraceEvent*>(
      &from));
}

void IonCpAllocRetryFtraceEvent::MergeFrom(const IonCpAllocRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_tries()) {
    set_tries(from.tries());
  }
}

void IonCpAllocRetryFtraceEvent::CopyFrom(const IonCpAllocRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpAllocRetryFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpAllocRetryFtraceEvent::InternalSwap(IonCpAllocRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(tries_, other->tries_);
}

std::string IonCpAllocRetryFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonCpAllocRetryFtraceEvent";
}


// ===================================================================

void IonCpSecureBufferEndFtraceEvent::InitAsDefaultInstance() {
}
class IonCpSecureBufferEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpSecureBufferEndFtraceEvent>()._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
}
IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(const IonCpSecureBufferEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&align_, &from.align_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&align_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
}

void IonCpSecureBufferEndFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonCpSecureBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&align_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&align_)) + sizeof(len_));
}

IonCpSecureBufferEndFtraceEvent::~IonCpSecureBufferEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  SharedDtor();
}

void IonCpSecureBufferEndFtraceEvent::SharedDtor() {
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonCpSecureBufferEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonCpSecureBufferEndFtraceEvent& IonCpSecureBufferEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonCpSecureBufferEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonCpSecureBufferEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    heap_name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&align_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&align_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonCpSecureBufferEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonCpSecureBufferEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 align = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_align(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &align_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 flags = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string heap_name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonCpSecureBufferEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->align(), output);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->flags(), output);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->heap_name(), output);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
}

size_t IonCpSecureBufferEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonCpSecureBufferEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonCpSecureBufferEndFtraceEvent*>(
      &from));
}

void IonCpSecureBufferEndFtraceEvent::MergeFrom(const IonCpSecureBufferEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      align_ = from.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonCpSecureBufferEndFtraceEvent::CopyFrom(const IonCpSecureBufferEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpSecureBufferEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpSecureBufferEndFtraceEvent::InternalSwap(IonCpSecureBufferEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(align_, other->align_);
  swap(flags_, other->flags_);
  swap(len_, other->len_);
}

std::string IonCpSecureBufferEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonCpSecureBufferEndFtraceEvent";
}


// ===================================================================

void IonCpSecureBufferStartFtraceEvent::InitAsDefaultInstance() {
}
class IonCpSecureBufferStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpSecureBufferStartFtraceEvent>()._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
}
IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(const IonCpSecureBufferStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&align_, &from.align_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&align_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
}

void IonCpSecureBufferStartFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonCpSecureBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&align_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&align_)) + sizeof(len_));
}

IonCpSecureBufferStartFtraceEvent::~IonCpSecureBufferStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  SharedDtor();
}

void IonCpSecureBufferStartFtraceEvent::SharedDtor() {
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonCpSecureBufferStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonCpSecureBufferStartFtraceEvent& IonCpSecureBufferStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonCpSecureBufferStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonCpSecureBufferStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    heap_name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&align_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&align_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonCpSecureBufferStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonCpSecureBufferStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 align = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_align(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &align_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 flags = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string heap_name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonCpSecureBufferStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->align(), output);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->flags(), output);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->heap_name(), output);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
}

size_t IonCpSecureBufferStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonCpSecureBufferStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonCpSecureBufferStartFtraceEvent*>(
      &from));
}

void IonCpSecureBufferStartFtraceEvent::MergeFrom(const IonCpSecureBufferStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      align_ = from.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonCpSecureBufferStartFtraceEvent::CopyFrom(const IonCpSecureBufferStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpSecureBufferStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpSecureBufferStartFtraceEvent::InternalSwap(IonCpSecureBufferStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(align_, other->align_);
  swap(flags_, other->flags_);
  swap(len_, other->len_);
}

std::string IonCpSecureBufferStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonCpSecureBufferStartFtraceEvent";
}


// ===================================================================

void IonPrefetchingFtraceEvent::InitAsDefaultInstance() {
}
class IonPrefetchingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonPrefetchingFtraceEvent>()._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonPrefetchingFtraceEvent)
}
IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(const IonPrefetchingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  len_ = from.len_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonPrefetchingFtraceEvent)
}

void IonPrefetchingFtraceEvent::SharedCtor() {
  len_ = PROTOBUF_ULONGLONG(0);
}

IonPrefetchingFtraceEvent::~IonPrefetchingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonPrefetchingFtraceEvent)
  SharedDtor();
}

void IonPrefetchingFtraceEvent::SharedDtor() {
}

void IonPrefetchingFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonPrefetchingFtraceEvent& IonPrefetchingFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonPrefetchingFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonPrefetchingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonPrefetchingFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonPrefetchingFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonPrefetchingFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonPrefetchingFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 len = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonPrefetchingFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonPrefetchingFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonPrefetchingFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonPrefetchingFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonPrefetchingFtraceEvent)
}

size_t IonPrefetchingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonPrefetchingFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 len = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->len());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonPrefetchingFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonPrefetchingFtraceEvent*>(
      &from));
}

void IonPrefetchingFtraceEvent::MergeFrom(const IonPrefetchingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonPrefetchingFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_len()) {
    set_len(from.len());
  }
}

void IonPrefetchingFtraceEvent::CopyFrom(const IonPrefetchingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonPrefetchingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonPrefetchingFtraceEvent::IsInitialized() const {
  return true;
}

void IonPrefetchingFtraceEvent::InternalSwap(IonPrefetchingFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(len_, other->len_);
}

std::string IonPrefetchingFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonPrefetchingFtraceEvent";
}


// ===================================================================

void IonSecureCmaAddToPoolEndFtraceEvent::InitAsDefaultInstance() {
}
class IonSecureCmaAddToPoolEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAddToPoolEndFtraceEvent>()._has_bits_);
  static void set_has_is_prefetch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pool_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
}
IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(const IonSecureCmaAddToPoolEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&len_, &from.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&pool_total_) -
    reinterpret_cast<char*>(&len_)) + sizeof(pool_total_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
}

void IonSecureCmaAddToPoolEndFtraceEvent::SharedCtor() {
  ::memset(&len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pool_total_) -
      reinterpret_cast<char*>(&len_)) + sizeof(pool_total_));
}

IonSecureCmaAddToPoolEndFtraceEvent::~IonSecureCmaAddToPoolEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  SharedDtor();
}

void IonSecureCmaAddToPoolEndFtraceEvent::SharedDtor() {
}

void IonSecureCmaAddToPoolEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonSecureCmaAddToPoolEndFtraceEvent& IonSecureCmaAddToPoolEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonSecureCmaAddToPoolEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonSecureCmaAddToPoolEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pool_total_) -
        reinterpret_cast<char*>(&len_)) + sizeof(pool_total_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonSecureCmaAddToPoolEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 is_prefetch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_is_prefetch(&has_bits);
          is_prefetch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pool_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pool_total(&has_bits);
          pool_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonSecureCmaAddToPoolEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 is_prefetch = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_is_prefetch(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_prefetch_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pool_total = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pool_total(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pool_total_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonSecureCmaAddToPoolEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 is_prefetch = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->is_prefetch(), output);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->len(), output);
  }

  // optional int32 pool_total = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->pool_total(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
}

size_t IonSecureCmaAddToPoolEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional uint32 is_prefetch = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->is_prefetch());
    }

    // optional int32 pool_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pool_total());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaAddToPoolEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonSecureCmaAddToPoolEndFtraceEvent*>(
      &from));
}

void IonSecureCmaAddToPoolEndFtraceEvent::MergeFrom(const IonSecureCmaAddToPoolEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_prefetch_ = from.is_prefetch_;
    }
    if (cached_has_bits & 0x00000004u) {
      pool_total_ = from.pool_total_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonSecureCmaAddToPoolEndFtraceEvent::CopyFrom(const IonSecureCmaAddToPoolEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAddToPoolEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAddToPoolEndFtraceEvent::InternalSwap(IonSecureCmaAddToPoolEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(len_, other->len_);
  swap(is_prefetch_, other->is_prefetch_);
  swap(pool_total_, other->pool_total_);
}

std::string IonSecureCmaAddToPoolEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent";
}


// ===================================================================

void IonSecureCmaAddToPoolStartFtraceEvent::InitAsDefaultInstance() {
}
class IonSecureCmaAddToPoolStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAddToPoolStartFtraceEvent>()._has_bits_);
  static void set_has_is_prefetch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pool_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
}
IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(const IonSecureCmaAddToPoolStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&len_, &from.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&pool_total_) -
    reinterpret_cast<char*>(&len_)) + sizeof(pool_total_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
}

void IonSecureCmaAddToPoolStartFtraceEvent::SharedCtor() {
  ::memset(&len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pool_total_) -
      reinterpret_cast<char*>(&len_)) + sizeof(pool_total_));
}

IonSecureCmaAddToPoolStartFtraceEvent::~IonSecureCmaAddToPoolStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  SharedDtor();
}

void IonSecureCmaAddToPoolStartFtraceEvent::SharedDtor() {
}

void IonSecureCmaAddToPoolStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonSecureCmaAddToPoolStartFtraceEvent& IonSecureCmaAddToPoolStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonSecureCmaAddToPoolStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonSecureCmaAddToPoolStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pool_total_) -
        reinterpret_cast<char*>(&len_)) + sizeof(pool_total_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonSecureCmaAddToPoolStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 is_prefetch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_is_prefetch(&has_bits);
          is_prefetch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pool_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pool_total(&has_bits);
          pool_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonSecureCmaAddToPoolStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 is_prefetch = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_is_prefetch(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_prefetch_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pool_total = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pool_total(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pool_total_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonSecureCmaAddToPoolStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 is_prefetch = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->is_prefetch(), output);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->len(), output);
  }

  // optional int32 pool_total = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->pool_total(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
}

size_t IonSecureCmaAddToPoolStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional uint32 is_prefetch = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->is_prefetch());
    }

    // optional int32 pool_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pool_total());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaAddToPoolStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonSecureCmaAddToPoolStartFtraceEvent*>(
      &from));
}

void IonSecureCmaAddToPoolStartFtraceEvent::MergeFrom(const IonSecureCmaAddToPoolStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_prefetch_ = from.is_prefetch_;
    }
    if (cached_has_bits & 0x00000004u) {
      pool_total_ = from.pool_total_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonSecureCmaAddToPoolStartFtraceEvent::CopyFrom(const IonSecureCmaAddToPoolStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAddToPoolStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAddToPoolStartFtraceEvent::InternalSwap(IonSecureCmaAddToPoolStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(len_, other->len_);
  swap(is_prefetch_, other->is_prefetch_);
  swap(pool_total_, other->pool_total_);
}

std::string IonSecureCmaAddToPoolStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent";
}


// ===================================================================

void IonSecureCmaAllocateEndFtraceEvent::InitAsDefaultInstance() {
}
class IonSecureCmaAllocateEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAllocateEndFtraceEvent>()._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
}
IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(const IonSecureCmaAllocateEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&align_, &from.align_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&align_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
}

void IonSecureCmaAllocateEndFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonSecureCmaAllocateEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&align_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&align_)) + sizeof(len_));
}

IonSecureCmaAllocateEndFtraceEvent::~IonSecureCmaAllocateEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  SharedDtor();
}

void IonSecureCmaAllocateEndFtraceEvent::SharedDtor() {
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonSecureCmaAllocateEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonSecureCmaAllocateEndFtraceEvent& IonSecureCmaAllocateEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonSecureCmaAllocateEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonSecureCmaAllocateEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    heap_name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&align_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&align_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonSecureCmaAllocateEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonSecureCmaAllocateEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 align = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_align(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &align_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 flags = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string heap_name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonSecureCmaAllocateEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->align(), output);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->flags(), output);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->heap_name(), output);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
}

size_t IonSecureCmaAllocateEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaAllocateEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonSecureCmaAllocateEndFtraceEvent*>(
      &from));
}

void IonSecureCmaAllocateEndFtraceEvent::MergeFrom(const IonSecureCmaAllocateEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      align_ = from.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonSecureCmaAllocateEndFtraceEvent::CopyFrom(const IonSecureCmaAllocateEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAllocateEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAllocateEndFtraceEvent::InternalSwap(IonSecureCmaAllocateEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(align_, other->align_);
  swap(flags_, other->flags_);
  swap(len_, other->len_);
}

std::string IonSecureCmaAllocateEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaAllocateEndFtraceEvent";
}


// ===================================================================

void IonSecureCmaAllocateStartFtraceEvent::InitAsDefaultInstance() {
}
class IonSecureCmaAllocateStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAllocateStartFtraceEvent>()._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
}
IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(const IonSecureCmaAllocateStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&align_, &from.align_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&align_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
}

void IonSecureCmaAllocateStartFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonSecureCmaAllocateStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&align_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&align_)) + sizeof(len_));
}

IonSecureCmaAllocateStartFtraceEvent::~IonSecureCmaAllocateStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  SharedDtor();
}

void IonSecureCmaAllocateStartFtraceEvent::SharedDtor() {
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonSecureCmaAllocateStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonSecureCmaAllocateStartFtraceEvent& IonSecureCmaAllocateStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonSecureCmaAllocateStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonSecureCmaAllocateStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    heap_name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&align_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&align_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonSecureCmaAllocateStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonSecureCmaAllocateStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 align = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_align(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &align_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 flags = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string heap_name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonSecureCmaAllocateStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->align(), output);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->flags(), output);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->heap_name(), output);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
}

size_t IonSecureCmaAllocateStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaAllocateStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonSecureCmaAllocateStartFtraceEvent*>(
      &from));
}

void IonSecureCmaAllocateStartFtraceEvent::MergeFrom(const IonSecureCmaAllocateStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      align_ = from.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonSecureCmaAllocateStartFtraceEvent::CopyFrom(const IonSecureCmaAllocateStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAllocateStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAllocateStartFtraceEvent::InternalSwap(IonSecureCmaAllocateStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(align_, other->align_);
  swap(flags_, other->flags_);
  swap(len_, other->len_);
}

std::string IonSecureCmaAllocateStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaAllocateStartFtraceEvent";
}


// ===================================================================

void IonSecureCmaShrinkPoolEndFtraceEvent::InitAsDefaultInstance() {
}
class IonSecureCmaShrinkPoolEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaShrinkPoolEndFtraceEvent>()._has_bits_);
  static void set_has_drained_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skipped_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
}
IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(const IonSecureCmaShrinkPoolEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&drained_size_, &from.drained_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&skipped_size_) -
    reinterpret_cast<char*>(&drained_size_)) + sizeof(skipped_size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
}

void IonSecureCmaShrinkPoolEndFtraceEvent::SharedCtor() {
  ::memset(&drained_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&skipped_size_) -
      reinterpret_cast<char*>(&drained_size_)) + sizeof(skipped_size_));
}

IonSecureCmaShrinkPoolEndFtraceEvent::~IonSecureCmaShrinkPoolEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  SharedDtor();
}

void IonSecureCmaShrinkPoolEndFtraceEvent::SharedDtor() {
}

void IonSecureCmaShrinkPoolEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonSecureCmaShrinkPoolEndFtraceEvent& IonSecureCmaShrinkPoolEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonSecureCmaShrinkPoolEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonSecureCmaShrinkPoolEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&drained_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&skipped_size_) -
        reinterpret_cast<char*>(&drained_size_)) + sizeof(skipped_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonSecureCmaShrinkPoolEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 drained_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_drained_size(&has_bits);
          drained_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 skipped_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_skipped_size(&has_bits);
          skipped_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonSecureCmaShrinkPoolEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 drained_size = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_drained_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &drained_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 skipped_size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_skipped_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &skipped_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonSecureCmaShrinkPoolEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 drained_size = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->drained_size(), output);
  }

  // optional uint64 skipped_size = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->skipped_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
}

size_t IonSecureCmaShrinkPoolEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 drained_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->drained_size());
    }

    // optional uint64 skipped_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->skipped_size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaShrinkPoolEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonSecureCmaShrinkPoolEndFtraceEvent*>(
      &from));
}

void IonSecureCmaShrinkPoolEndFtraceEvent::MergeFrom(const IonSecureCmaShrinkPoolEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      drained_size_ = from.drained_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      skipped_size_ = from.skipped_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonSecureCmaShrinkPoolEndFtraceEvent::CopyFrom(const IonSecureCmaShrinkPoolEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaShrinkPoolEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaShrinkPoolEndFtraceEvent::InternalSwap(IonSecureCmaShrinkPoolEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(drained_size_, other->drained_size_);
  swap(skipped_size_, other->skipped_size_);
}

std::string IonSecureCmaShrinkPoolEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent";
}


// ===================================================================

void IonSecureCmaShrinkPoolStartFtraceEvent::InitAsDefaultInstance() {
}
class IonSecureCmaShrinkPoolStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaShrinkPoolStartFtraceEvent>()._has_bits_);
  static void set_has_drained_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skipped_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
}
IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(const IonSecureCmaShrinkPoolStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&drained_size_, &from.drained_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&skipped_size_) -
    reinterpret_cast<char*>(&drained_size_)) + sizeof(skipped_size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
}

void IonSecureCmaShrinkPoolStartFtraceEvent::SharedCtor() {
  ::memset(&drained_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&skipped_size_) -
      reinterpret_cast<char*>(&drained_size_)) + sizeof(skipped_size_));
}

IonSecureCmaShrinkPoolStartFtraceEvent::~IonSecureCmaShrinkPoolStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  SharedDtor();
}

void IonSecureCmaShrinkPoolStartFtraceEvent::SharedDtor() {
}

void IonSecureCmaShrinkPoolStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonSecureCmaShrinkPoolStartFtraceEvent& IonSecureCmaShrinkPoolStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonSecureCmaShrinkPoolStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonSecureCmaShrinkPoolStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&drained_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&skipped_size_) -
        reinterpret_cast<char*>(&drained_size_)) + sizeof(skipped_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonSecureCmaShrinkPoolStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 drained_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_drained_size(&has_bits);
          drained_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 skipped_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_skipped_size(&has_bits);
          skipped_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonSecureCmaShrinkPoolStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 drained_size = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_drained_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &drained_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 skipped_size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_skipped_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &skipped_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonSecureCmaShrinkPoolStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 drained_size = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->drained_size(), output);
  }

  // optional uint64 skipped_size = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->skipped_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
}

size_t IonSecureCmaShrinkPoolStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 drained_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->drained_size());
    }

    // optional uint64 skipped_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->skipped_size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaShrinkPoolStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonSecureCmaShrinkPoolStartFtraceEvent*>(
      &from));
}

void IonSecureCmaShrinkPoolStartFtraceEvent::MergeFrom(const IonSecureCmaShrinkPoolStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      drained_size_ = from.drained_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      skipped_size_ = from.skipped_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonSecureCmaShrinkPoolStartFtraceEvent::CopyFrom(const IonSecureCmaShrinkPoolStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaShrinkPoolStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaShrinkPoolStartFtraceEvent::InternalSwap(IonSecureCmaShrinkPoolStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(drained_size_, other->drained_size_);
  swap(skipped_size_, other->skipped_size_);
}

std::string IonSecureCmaShrinkPoolStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent";
}


// ===================================================================

void KfreeFtraceEvent::InitAsDefaultInstance() {
}
class KfreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KfreeFtraceEvent>()._has_bits_);
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KfreeFtraceEvent::KfreeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.KfreeFtraceEvent)
}
KfreeFtraceEvent::KfreeFtraceEvent(const KfreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&call_site_, &from.call_site_,
    static_cast<size_t>(reinterpret_cast<char*>(&ptr_) -
    reinterpret_cast<char*>(&call_site_)) + sizeof(ptr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KfreeFtraceEvent)
}

void KfreeFtraceEvent::SharedCtor() {
  ::memset(&call_site_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ptr_) -
      reinterpret_cast<char*>(&call_site_)) + sizeof(ptr_));
}

KfreeFtraceEvent::~KfreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KfreeFtraceEvent)
  SharedDtor();
}

void KfreeFtraceEvent::SharedDtor() {
}

void KfreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const KfreeFtraceEvent& KfreeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_KfreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void KfreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KfreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&call_site_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ptr_) -
        reinterpret_cast<char*>(&call_site_)) + sizeof(ptr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* KfreeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 call_site = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_call_site(&has_bits);
          call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ptr(&has_bits);
          ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool KfreeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.KfreeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 call_site = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_call_site(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &call_site_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ptr = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ptr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ptr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.KfreeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.KfreeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void KfreeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.KfreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 call_site = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->call_site(), output);
  }

  // optional uint64 ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ptr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.KfreeFtraceEvent)
}

size_t KfreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KfreeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 call_site = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->call_site());
    }

    // optional uint64 ptr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ptr());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KfreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KfreeFtraceEvent*>(
      &from));
}

void KfreeFtraceEvent::MergeFrom(const KfreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KfreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      call_site_ = from.call_site_;
    }
    if (cached_has_bits & 0x00000002u) {
      ptr_ = from.ptr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void KfreeFtraceEvent::CopyFrom(const KfreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KfreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KfreeFtraceEvent::IsInitialized() const {
  return true;
}

void KfreeFtraceEvent::InternalSwap(KfreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(call_site_, other->call_site_);
  swap(ptr_, other->ptr_);
}

std::string KfreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KfreeFtraceEvent";
}


// ===================================================================

void KmallocFtraceEvent::InitAsDefaultInstance() {
}
class KmallocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmallocFtraceEvent>()._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KmallocFtraceEvent::KmallocFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.KmallocFtraceEvent)
}
KmallocFtraceEvent::KmallocFtraceEvent(const KmallocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bytes_alloc_, &from.bytes_alloc_,
    static_cast<size_t>(reinterpret_cast<char*>(&gfp_flags_) -
    reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(gfp_flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmallocFtraceEvent)
}

void KmallocFtraceEvent::SharedCtor() {
  ::memset(&bytes_alloc_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gfp_flags_) -
      reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(gfp_flags_));
}

KmallocFtraceEvent::~KmallocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmallocFtraceEvent)
  SharedDtor();
}

void KmallocFtraceEvent::SharedDtor() {
}

void KmallocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const KmallocFtraceEvent& KmallocFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_KmallocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void KmallocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmallocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&bytes_alloc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gfp_flags_) -
        reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(gfp_flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* KmallocFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ptr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ptr(&has_bits);
          ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool KmallocFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.KmallocFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 bytes_alloc = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_bytes_alloc(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_alloc_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 bytes_req = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_bytes_req(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_req_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 call_site = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_call_site(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &call_site_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gfp_flags = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ptr = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_ptr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ptr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.KmallocFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.KmallocFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void KmallocFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.KmallocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->bytes_alloc(), output);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->bytes_req(), output);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->call_site(), output);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->gfp_flags(), output);
  }

  // optional uint64 ptr = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->ptr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.KmallocFtraceEvent)
}

size_t KmallocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmallocFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->call_site());
    }

    // optional uint64 ptr = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ptr());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmallocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KmallocFtraceEvent*>(
      &from));
}

void KmallocFtraceEvent::MergeFrom(const KmallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmallocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      bytes_alloc_ = from.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      bytes_req_ = from.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      call_site_ = from.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      ptr_ = from.ptr_;
    }
    if (cached_has_bits & 0x00000010u) {
      gfp_flags_ = from.gfp_flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void KmallocFtraceEvent::CopyFrom(const KmallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmallocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmallocFtraceEvent::IsInitialized() const {
  return true;
}

void KmallocFtraceEvent::InternalSwap(KmallocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bytes_alloc_, other->bytes_alloc_);
  swap(bytes_req_, other->bytes_req_);
  swap(call_site_, other->call_site_);
  swap(ptr_, other->ptr_);
  swap(gfp_flags_, other->gfp_flags_);
}

std::string KmallocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmallocFtraceEvent";
}


// ===================================================================

void KmallocNodeFtraceEvent::InitAsDefaultInstance() {
}
class KmallocNodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmallocNodeFtraceEvent>()._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

KmallocNodeFtraceEvent::KmallocNodeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.KmallocNodeFtraceEvent)
}
KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(const KmallocNodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bytes_alloc_, &from.bytes_alloc_,
    static_cast<size_t>(reinterpret_cast<char*>(&ptr_) -
    reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(ptr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmallocNodeFtraceEvent)
}

void KmallocNodeFtraceEvent::SharedCtor() {
  ::memset(&bytes_alloc_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ptr_) -
      reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(ptr_));
}

KmallocNodeFtraceEvent::~KmallocNodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmallocNodeFtraceEvent)
  SharedDtor();
}

void KmallocNodeFtraceEvent::SharedDtor() {
}

void KmallocNodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const KmallocNodeFtraceEvent& KmallocNodeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_KmallocNodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void KmallocNodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmallocNodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&bytes_alloc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ptr_) -
        reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(ptr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* KmallocNodeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 node = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_node(&has_bits);
          node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ptr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ptr(&has_bits);
          ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool KmallocNodeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.KmallocNodeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 bytes_alloc = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_bytes_alloc(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_alloc_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 bytes_req = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_bytes_req(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_req_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 call_site = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_call_site(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &call_site_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gfp_flags = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 node = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_node(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ptr = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_ptr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ptr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.KmallocNodeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.KmallocNodeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void KmallocNodeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.KmallocNodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->bytes_alloc(), output);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->bytes_req(), output);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->call_site(), output);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->gfp_flags(), output);
  }

  // optional int32 node = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->node(), output);
  }

  // optional uint64 ptr = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->ptr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.KmallocNodeFtraceEvent)
}

size_t KmallocNodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmallocNodeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->call_site());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional int32 node = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->node());
    }

    // optional uint64 ptr = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ptr());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmallocNodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KmallocNodeFtraceEvent*>(
      &from));
}

void KmallocNodeFtraceEvent::MergeFrom(const KmallocNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmallocNodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      bytes_alloc_ = from.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      bytes_req_ = from.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      call_site_ = from.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      node_ = from.node_;
    }
    if (cached_has_bits & 0x00000020u) {
      ptr_ = from.ptr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void KmallocNodeFtraceEvent::CopyFrom(const KmallocNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmallocNodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmallocNodeFtraceEvent::IsInitialized() const {
  return true;
}

void KmallocNodeFtraceEvent::InternalSwap(KmallocNodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bytes_alloc_, other->bytes_alloc_);
  swap(bytes_req_, other->bytes_req_);
  swap(call_site_, other->call_site_);
  swap(gfp_flags_, other->gfp_flags_);
  swap(node_, other->node_);
  swap(ptr_, other->ptr_);
}

std::string KmallocNodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmallocNodeFtraceEvent";
}


// ===================================================================

void KmemCacheAllocFtraceEvent::InitAsDefaultInstance() {
}
class KmemCacheAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheAllocFtraceEvent>()._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.KmemCacheAllocFtraceEvent)
}
KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(const KmemCacheAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bytes_alloc_, &from.bytes_alloc_,
    static_cast<size_t>(reinterpret_cast<char*>(&gfp_flags_) -
    reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(gfp_flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheAllocFtraceEvent)
}

void KmemCacheAllocFtraceEvent::SharedCtor() {
  ::memset(&bytes_alloc_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gfp_flags_) -
      reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(gfp_flags_));
}

KmemCacheAllocFtraceEvent::~KmemCacheAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheAllocFtraceEvent)
  SharedDtor();
}

void KmemCacheAllocFtraceEvent::SharedDtor() {
}

void KmemCacheAllocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const KmemCacheAllocFtraceEvent& KmemCacheAllocFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_KmemCacheAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void KmemCacheAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&bytes_alloc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gfp_flags_) -
        reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(gfp_flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* KmemCacheAllocFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ptr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ptr(&has_bits);
          ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool KmemCacheAllocFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 bytes_alloc = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_bytes_alloc(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_alloc_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 bytes_req = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_bytes_req(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_req_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 call_site = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_call_site(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &call_site_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gfp_flags = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ptr = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_ptr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ptr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.KmemCacheAllocFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.KmemCacheAllocFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void KmemCacheAllocFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->bytes_alloc(), output);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->bytes_req(), output);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->call_site(), output);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->gfp_flags(), output);
  }

  // optional uint64 ptr = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->ptr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.KmemCacheAllocFtraceEvent)
}

size_t KmemCacheAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->call_site());
    }

    // optional uint64 ptr = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ptr());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmemCacheAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KmemCacheAllocFtraceEvent*>(
      &from));
}

void KmemCacheAllocFtraceEvent::MergeFrom(const KmemCacheAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      bytes_alloc_ = from.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      bytes_req_ = from.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      call_site_ = from.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      ptr_ = from.ptr_;
    }
    if (cached_has_bits & 0x00000010u) {
      gfp_flags_ = from.gfp_flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void KmemCacheAllocFtraceEvent::CopyFrom(const KmemCacheAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheAllocFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheAllocFtraceEvent::InternalSwap(KmemCacheAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bytes_alloc_, other->bytes_alloc_);
  swap(bytes_req_, other->bytes_req_);
  swap(call_site_, other->call_site_);
  swap(ptr_, other->ptr_);
  swap(gfp_flags_, other->gfp_flags_);
}

std::string KmemCacheAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmemCacheAllocFtraceEvent";
}


// ===================================================================

void KmemCacheAllocNodeFtraceEvent::InitAsDefaultInstance() {
}
class KmemCacheAllocNodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheAllocNodeFtraceEvent>()._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
}
KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(const KmemCacheAllocNodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bytes_alloc_, &from.bytes_alloc_,
    static_cast<size_t>(reinterpret_cast<char*>(&ptr_) -
    reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(ptr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
}

void KmemCacheAllocNodeFtraceEvent::SharedCtor() {
  ::memset(&bytes_alloc_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ptr_) -
      reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(ptr_));
}

KmemCacheAllocNodeFtraceEvent::~KmemCacheAllocNodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  SharedDtor();
}

void KmemCacheAllocNodeFtraceEvent::SharedDtor() {
}

void KmemCacheAllocNodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const KmemCacheAllocNodeFtraceEvent& KmemCacheAllocNodeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_KmemCacheAllocNodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void KmemCacheAllocNodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&bytes_alloc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ptr_) -
        reinterpret_cast<char*>(&bytes_alloc_)) + sizeof(ptr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* KmemCacheAllocNodeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 node = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_node(&has_bits);
          node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ptr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ptr(&has_bits);
          ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool KmemCacheAllocNodeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 bytes_alloc = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_bytes_alloc(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_alloc_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 bytes_req = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_bytes_req(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_req_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 call_site = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_call_site(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &call_site_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gfp_flags = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 node = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_node(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ptr = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_ptr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ptr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void KmemCacheAllocNodeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->bytes_alloc(), output);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->bytes_req(), output);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->call_site(), output);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->gfp_flags(), output);
  }

  // optional int32 node = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->node(), output);
  }

  // optional uint64 ptr = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->ptr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
}

size_t KmemCacheAllocNodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->call_site());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional int32 node = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->node());
    }

    // optional uint64 ptr = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ptr());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmemCacheAllocNodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KmemCacheAllocNodeFtraceEvent*>(
      &from));
}

void KmemCacheAllocNodeFtraceEvent::MergeFrom(const KmemCacheAllocNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      bytes_alloc_ = from.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      bytes_req_ = from.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      call_site_ = from.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      node_ = from.node_;
    }
    if (cached_has_bits & 0x00000020u) {
      ptr_ = from.ptr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void KmemCacheAllocNodeFtraceEvent::CopyFrom(const KmemCacheAllocNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheAllocNodeFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheAllocNodeFtraceEvent::InternalSwap(KmemCacheAllocNodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bytes_alloc_, other->bytes_alloc_);
  swap(bytes_req_, other->bytes_req_);
  swap(call_site_, other->call_site_);
  swap(gfp_flags_, other->gfp_flags_);
  swap(node_, other->node_);
  swap(ptr_, other->ptr_);
}

std::string KmemCacheAllocNodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmemCacheAllocNodeFtraceEvent";
}


// ===================================================================

void KmemCacheFreeFtraceEvent::InitAsDefaultInstance() {
}
class KmemCacheFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheFreeFtraceEvent>()._has_bits_);
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.KmemCacheFreeFtraceEvent)
}
KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(const KmemCacheFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&call_site_, &from.call_site_,
    static_cast<size_t>(reinterpret_cast<char*>(&ptr_) -
    reinterpret_cast<char*>(&call_site_)) + sizeof(ptr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheFreeFtraceEvent)
}

void KmemCacheFreeFtraceEvent::SharedCtor() {
  ::memset(&call_site_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ptr_) -
      reinterpret_cast<char*>(&call_site_)) + sizeof(ptr_));
}

KmemCacheFreeFtraceEvent::~KmemCacheFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheFreeFtraceEvent)
  SharedDtor();
}

void KmemCacheFreeFtraceEvent::SharedDtor() {
}

void KmemCacheFreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const KmemCacheFreeFtraceEvent& KmemCacheFreeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_KmemCacheFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void KmemCacheFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&call_site_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ptr_) -
        reinterpret_cast<char*>(&call_site_)) + sizeof(ptr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* KmemCacheFreeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 call_site = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_call_site(&has_bits);
          call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ptr(&has_bits);
          ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool KmemCacheFreeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 call_site = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_call_site(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &call_site_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ptr = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ptr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ptr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.KmemCacheFreeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.KmemCacheFreeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void KmemCacheFreeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 call_site = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->call_site(), output);
  }

  // optional uint64 ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ptr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.KmemCacheFreeFtraceEvent)
}

size_t KmemCacheFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 call_site = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->call_site());
    }

    // optional uint64 ptr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ptr());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmemCacheFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KmemCacheFreeFtraceEvent*>(
      &from));
}

void KmemCacheFreeFtraceEvent::MergeFrom(const KmemCacheFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      call_site_ = from.call_site_;
    }
    if (cached_has_bits & 0x00000002u) {
      ptr_ = from.ptr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void KmemCacheFreeFtraceEvent::CopyFrom(const KmemCacheFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheFreeFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheFreeFtraceEvent::InternalSwap(KmemCacheFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(call_site_, other->call_site_);
  swap(ptr_, other->ptr_);
}

std::string KmemCacheFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmemCacheFreeFtraceEvent";
}


// ===================================================================

void MigratePagesEndFtraceEvent::InitAsDefaultInstance() {
}
class MigratePagesEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigratePagesEndFtraceEvent>()._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MigratePagesEndFtraceEvent)
}
MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(const MigratePagesEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigratePagesEndFtraceEvent)
}

void MigratePagesEndFtraceEvent::SharedCtor() {
  mode_ = 0;
}

MigratePagesEndFtraceEvent::~MigratePagesEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigratePagesEndFtraceEvent)
  SharedDtor();
}

void MigratePagesEndFtraceEvent::SharedDtor() {
}

void MigratePagesEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MigratePagesEndFtraceEvent& MigratePagesEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MigratePagesEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MigratePagesEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigratePagesEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mode_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MigratePagesEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MigratePagesEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MigratePagesEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mode = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MigratePagesEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MigratePagesEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MigratePagesEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MigratePagesEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 mode = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MigratePagesEndFtraceEvent)
}

size_t MigratePagesEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigratePagesEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 mode = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->mode());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MigratePagesEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MigratePagesEndFtraceEvent*>(
      &from));
}

void MigratePagesEndFtraceEvent::MergeFrom(const MigratePagesEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigratePagesEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_mode()) {
    set_mode(from.mode());
  }
}

void MigratePagesEndFtraceEvent::CopyFrom(const MigratePagesEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigratePagesEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigratePagesEndFtraceEvent::IsInitialized() const {
  return true;
}

void MigratePagesEndFtraceEvent::InternalSwap(MigratePagesEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(mode_, other->mode_);
}

std::string MigratePagesEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MigratePagesEndFtraceEvent";
}


// ===================================================================

void MigratePagesStartFtraceEvent::InitAsDefaultInstance() {
}
class MigratePagesStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigratePagesStartFtraceEvent>()._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MigratePagesStartFtraceEvent)
}
MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(const MigratePagesStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigratePagesStartFtraceEvent)
}

void MigratePagesStartFtraceEvent::SharedCtor() {
  mode_ = 0;
}

MigratePagesStartFtraceEvent::~MigratePagesStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigratePagesStartFtraceEvent)
  SharedDtor();
}

void MigratePagesStartFtraceEvent::SharedDtor() {
}

void MigratePagesStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MigratePagesStartFtraceEvent& MigratePagesStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MigratePagesStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MigratePagesStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigratePagesStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mode_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MigratePagesStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MigratePagesStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MigratePagesStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mode = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MigratePagesStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MigratePagesStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MigratePagesStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MigratePagesStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 mode = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MigratePagesStartFtraceEvent)
}

size_t MigratePagesStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigratePagesStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 mode = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->mode());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MigratePagesStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MigratePagesStartFtraceEvent*>(
      &from));
}

void MigratePagesStartFtraceEvent::MergeFrom(const MigratePagesStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigratePagesStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_mode()) {
    set_mode(from.mode());
  }
}

void MigratePagesStartFtraceEvent::CopyFrom(const MigratePagesStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigratePagesStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigratePagesStartFtraceEvent::IsInitialized() const {
  return true;
}

void MigratePagesStartFtraceEvent::InternalSwap(MigratePagesStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(mode_, other->mode_);
}

std::string MigratePagesStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MigratePagesStartFtraceEvent";
}


// ===================================================================

void MigrateRetryFtraceEvent::InitAsDefaultInstance() {
}
class MigrateRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigrateRetryFtraceEvent>()._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigrateRetryFtraceEvent::MigrateRetryFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MigrateRetryFtraceEvent)
}
MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(const MigrateRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  tries_ = from.tries_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigrateRetryFtraceEvent)
}

void MigrateRetryFtraceEvent::SharedCtor() {
  tries_ = 0;
}

MigrateRetryFtraceEvent::~MigrateRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigrateRetryFtraceEvent)
  SharedDtor();
}

void MigrateRetryFtraceEvent::SharedDtor() {
}

void MigrateRetryFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MigrateRetryFtraceEvent& MigrateRetryFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MigrateRetryFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MigrateRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigrateRetryFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tries_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MigrateRetryFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MigrateRetryFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MigrateRetryFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 tries = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_tries(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &tries_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MigrateRetryFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MigrateRetryFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MigrateRetryFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MigrateRetryFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->tries(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MigrateRetryFtraceEvent)
}

size_t MigrateRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigrateRetryFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->tries());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MigrateRetryFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MigrateRetryFtraceEvent*>(
      &from));
}

void MigrateRetryFtraceEvent::MergeFrom(const MigrateRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigrateRetryFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_tries()) {
    set_tries(from.tries());
  }
}

void MigrateRetryFtraceEvent::CopyFrom(const MigrateRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigrateRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigrateRetryFtraceEvent::IsInitialized() const {
  return true;
}

void MigrateRetryFtraceEvent::InternalSwap(MigrateRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(tries_, other->tries_);
}

std::string MigrateRetryFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MigrateRetryFtraceEvent";
}


// ===================================================================

void MmPageAllocFtraceEvent::InitAsDefaultInstance() {
}
class MmPageAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocFtraceEvent>()._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPageAllocFtraceEvent::MmPageAllocFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MmPageAllocFtraceEvent)
}
MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(const MmPageAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gfp_flags_, &from.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&order_) -
    reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocFtraceEvent)
}

void MmPageAllocFtraceEvent::SharedCtor() {
  ::memset(&gfp_flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order_) -
      reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
}

MmPageAllocFtraceEvent::~MmPageAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocFtraceEvent)
  SharedDtor();
}

void MmPageAllocFtraceEvent::SharedDtor() {
}

void MmPageAllocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MmPageAllocFtraceEvent& MmPageAllocFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MmPageAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MmPageAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&order_) -
        reinterpret_cast<char*>(&gfp_flags_)) + sizeof(order_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MmPageAllocFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 migratetype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_migratetype(&has_bits);
          migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 page = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_page(&has_bits);
          page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pfn = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pfn(&has_bits);
          pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MmPageAllocFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MmPageAllocFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gfp_flags = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_gfp_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gfp_flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 migratetype = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_migratetype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &migratetype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 page = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_page(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &page_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pfn = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pfn(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pfn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MmPageAllocFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MmPageAllocFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MmPageAllocFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MmPageAllocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->gfp_flags(), output);
  }

  // optional int32 migratetype = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->migratetype(), output);
  }

  // optional uint32 order = 3;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->order(), output);
  }

  // optional uint64 page = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->page(), output);
  }

  // optional uint64 pfn = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->pfn(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MmPageAllocFtraceEvent)
}

size_t MmPageAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gfp_flags());
    }

    // optional int32 migratetype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->migratetype());
    }

    // optional uint64 page = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->page());
    }

    // optional uint64 pfn = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pfn());
    }

    // optional uint32 order = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MmPageAllocFtraceEvent*>(
      &from));
}

void MmPageAllocFtraceEvent::MergeFrom(const MmPageAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      gfp_flags_ = from.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      migratetype_ = from.migratetype_;
    }
    if (cached_has_bits & 0x00000004u) {
      page_ = from.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      pfn_ = from.pfn_;
    }
    if (cached_has_bits & 0x00000010u) {
      order_ = from.order_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MmPageAllocFtraceEvent::CopyFrom(const MmPageAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocFtraceEvent::InternalSwap(MmPageAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gfp_flags_, other->gfp_flags_);
  swap(migratetype_, other->migratetype_);
  swap(page_, other->page_);
  swap(pfn_, other->pfn_);
  swap(order_, other->order_);
}

std::string MmPageAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageAllocFtraceEvent";
}


// ===================================================================

void MmPageAllocExtfragFtraceEvent::InitAsDefaultInstance() {
}
class MmPageAllocExtfragFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocExtfragFtraceEvent>()._has_bits_);
  static void set_has_alloc_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alloc_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fallback_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fallback_order(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_change_ownership(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
}
MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(const MmPageAllocExtfragFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&alloc_migratetype_, &from.alloc_migratetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&change_ownership_) -
    reinterpret_cast<char*>(&alloc_migratetype_)) + sizeof(change_ownership_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
}

void MmPageAllocExtfragFtraceEvent::SharedCtor() {
  ::memset(&alloc_migratetype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&change_ownership_) -
      reinterpret_cast<char*>(&alloc_migratetype_)) + sizeof(change_ownership_));
}

MmPageAllocExtfragFtraceEvent::~MmPageAllocExtfragFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  SharedDtor();
}

void MmPageAllocExtfragFtraceEvent::SharedDtor() {
}

void MmPageAllocExtfragFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MmPageAllocExtfragFtraceEvent& MmPageAllocExtfragFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MmPageAllocExtfragFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MmPageAllocExtfragFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&alloc_migratetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&change_ownership_) -
        reinterpret_cast<char*>(&alloc_migratetype_)) + sizeof(change_ownership_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MmPageAllocExtfragFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 alloc_migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_alloc_migratetype(&has_bits);
          alloc_migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 alloc_order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_alloc_order(&has_bits);
          alloc_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 fallback_migratetype = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_fallback_migratetype(&has_bits);
          fallback_migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 fallback_order = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_fallback_order(&has_bits);
          fallback_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 page = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_page(&has_bits);
          page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 change_ownership = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_change_ownership(&has_bits);
          change_ownership_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pfn = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_pfn(&has_bits);
          pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MmPageAllocExtfragFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 alloc_migratetype = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_alloc_migratetype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &alloc_migratetype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 alloc_order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_alloc_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &alloc_order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 fallback_migratetype = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_fallback_migratetype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &fallback_migratetype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 fallback_order = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_fallback_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &fallback_order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 page = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_page(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &page_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 change_ownership = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_change_ownership(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &change_ownership_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pfn = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_pfn(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pfn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MmPageAllocExtfragFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 alloc_migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->alloc_migratetype(), output);
  }

  // optional int32 alloc_order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->alloc_order(), output);
  }

  // optional int32 fallback_migratetype = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->fallback_migratetype(), output);
  }

  // optional int32 fallback_order = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->fallback_order(), output);
  }

  // optional uint64 page = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->page(), output);
  }

  // optional int32 change_ownership = 6;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->change_ownership(), output);
  }

  // optional uint64 pfn = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(7, this->pfn(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MmPageAllocExtfragFtraceEvent)
}

size_t MmPageAllocExtfragFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int32 alloc_migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->alloc_migratetype());
    }

    // optional int32 alloc_order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->alloc_order());
    }

    // optional int32 fallback_migratetype = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->fallback_migratetype());
    }

    // optional int32 fallback_order = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->fallback_order());
    }

    // optional uint64 page = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->page());
    }

    // optional uint64 pfn = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pfn());
    }

    // optional int32 change_ownership = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->change_ownership());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageAllocExtfragFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MmPageAllocExtfragFtraceEvent*>(
      &from));
}

void MmPageAllocExtfragFtraceEvent::MergeFrom(const MmPageAllocExtfragFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      alloc_migratetype_ = from.alloc_migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      alloc_order_ = from.alloc_order_;
    }
    if (cached_has_bits & 0x00000004u) {
      fallback_migratetype_ = from.fallback_migratetype_;
    }
    if (cached_has_bits & 0x00000008u) {
      fallback_order_ = from.fallback_order_;
    }
    if (cached_has_bits & 0x00000010u) {
      page_ = from.page_;
    }
    if (cached_has_bits & 0x00000020u) {
      pfn_ = from.pfn_;
    }
    if (cached_has_bits & 0x00000040u) {
      change_ownership_ = from.change_ownership_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MmPageAllocExtfragFtraceEvent::CopyFrom(const MmPageAllocExtfragFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocExtfragFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocExtfragFtraceEvent::InternalSwap(MmPageAllocExtfragFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(alloc_migratetype_, other->alloc_migratetype_);
  swap(alloc_order_, other->alloc_order_);
  swap(fallback_migratetype_, other->fallback_migratetype_);
  swap(fallback_order_, other->fallback_order_);
  swap(page_, other->page_);
  swap(pfn_, other->pfn_);
  swap(change_ownership_, other->change_ownership_);
}

std::string MmPageAllocExtfragFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageAllocExtfragFtraceEvent";
}


// ===================================================================

void MmPageAllocZoneLockedFtraceEvent::InitAsDefaultInstance() {
}
class MmPageAllocZoneLockedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocZoneLockedFtraceEvent>()._has_bits_);
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
}
MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(const MmPageAllocZoneLockedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&migratetype_, &from.migratetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&pfn_) -
    reinterpret_cast<char*>(&migratetype_)) + sizeof(pfn_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
}

void MmPageAllocZoneLockedFtraceEvent::SharedCtor() {
  ::memset(&migratetype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pfn_) -
      reinterpret_cast<char*>(&migratetype_)) + sizeof(pfn_));
}

MmPageAllocZoneLockedFtraceEvent::~MmPageAllocZoneLockedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  SharedDtor();
}

void MmPageAllocZoneLockedFtraceEvent::SharedDtor() {
}

void MmPageAllocZoneLockedFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MmPageAllocZoneLockedFtraceEvent& MmPageAllocZoneLockedFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MmPageAllocZoneLockedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MmPageAllocZoneLockedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&migratetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pfn_) -
        reinterpret_cast<char*>(&migratetype_)) + sizeof(pfn_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MmPageAllocZoneLockedFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_migratetype(&has_bits);
          migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_page(&has_bits);
          page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pfn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pfn(&has_bits);
          pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MmPageAllocZoneLockedFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 migratetype = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_migratetype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &migratetype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 page = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_page(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &page_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pfn = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pfn(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pfn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MmPageAllocZoneLockedFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->migratetype(), output);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->order(), output);
  }

  // optional uint64 page = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->page(), output);
  }

  // optional uint64 pfn = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->pfn(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
}

size_t MmPageAllocZoneLockedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->migratetype());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

    // optional uint64 page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->page());
    }

    // optional uint64 pfn = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pfn());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageAllocZoneLockedFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MmPageAllocZoneLockedFtraceEvent*>(
      &from));
}

void MmPageAllocZoneLockedFtraceEvent::MergeFrom(const MmPageAllocZoneLockedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      migratetype_ = from.migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      order_ = from.order_;
    }
    if (cached_has_bits & 0x00000004u) {
      page_ = from.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      pfn_ = from.pfn_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MmPageAllocZoneLockedFtraceEvent::CopyFrom(const MmPageAllocZoneLockedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocZoneLockedFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocZoneLockedFtraceEvent::InternalSwap(MmPageAllocZoneLockedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(migratetype_, other->migratetype_);
  swap(order_, other->order_);
  swap(page_, other->page_);
  swap(pfn_, other->pfn_);
}

std::string MmPageAllocZoneLockedFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageAllocZoneLockedFtraceEvent";
}


// ===================================================================

void MmPageFreeFtraceEvent::InitAsDefaultInstance() {
}
class MmPageFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageFreeFtraceEvent>()._has_bits_);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MmPageFreeFtraceEvent::MmPageFreeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MmPageFreeFtraceEvent)
}
MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(const MmPageFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&page_, &from.page_,
    static_cast<size_t>(reinterpret_cast<char*>(&order_) -
    reinterpret_cast<char*>(&page_)) + sizeof(order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageFreeFtraceEvent)
}

void MmPageFreeFtraceEvent::SharedCtor() {
  ::memset(&page_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order_) -
      reinterpret_cast<char*>(&page_)) + sizeof(order_));
}

MmPageFreeFtraceEvent::~MmPageFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageFreeFtraceEvent)
  SharedDtor();
}

void MmPageFreeFtraceEvent::SharedDtor() {
}

void MmPageFreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MmPageFreeFtraceEvent& MmPageFreeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MmPageFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MmPageFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&page_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&order_) -
        reinterpret_cast<char*>(&page_)) + sizeof(order_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MmPageFreeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 order = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 page = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_page(&has_bits);
          page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pfn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pfn(&has_bits);
          pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MmPageFreeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MmPageFreeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 order = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 page = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_page(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &page_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pfn = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pfn(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pfn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MmPageFreeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MmPageFreeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MmPageFreeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MmPageFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 order = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->order(), output);
  }

  // optional uint64 page = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->page(), output);
  }

  // optional uint64 pfn = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pfn(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MmPageFreeFtraceEvent)
}

size_t MmPageFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageFreeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 page = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->page());
    }

    // optional uint64 pfn = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pfn());
    }

    // optional uint32 order = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MmPageFreeFtraceEvent*>(
      &from));
}

void MmPageFreeFtraceEvent::MergeFrom(const MmPageFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      page_ = from.page_;
    }
    if (cached_has_bits & 0x00000002u) {
      pfn_ = from.pfn_;
    }
    if (cached_has_bits & 0x00000004u) {
      order_ = from.order_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MmPageFreeFtraceEvent::CopyFrom(const MmPageFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageFreeFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageFreeFtraceEvent::InternalSwap(MmPageFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(page_, other->page_);
  swap(pfn_, other->pfn_);
  swap(order_, other->order_);
}

std::string MmPageFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageFreeFtraceEvent";
}


// ===================================================================

void MmPageFreeBatchedFtraceEvent::InitAsDefaultInstance() {
}
class MmPageFreeBatchedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageFreeBatchedFtraceEvent>()._has_bits_);
  static void set_has_cold(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
}
MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(const MmPageFreeBatchedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&page_, &from.page_,
    static_cast<size_t>(reinterpret_cast<char*>(&cold_) -
    reinterpret_cast<char*>(&page_)) + sizeof(cold_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
}

void MmPageFreeBatchedFtraceEvent::SharedCtor() {
  ::memset(&page_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cold_) -
      reinterpret_cast<char*>(&page_)) + sizeof(cold_));
}

MmPageFreeBatchedFtraceEvent::~MmPageFreeBatchedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  SharedDtor();
}

void MmPageFreeBatchedFtraceEvent::SharedDtor() {
}

void MmPageFreeBatchedFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MmPageFreeBatchedFtraceEvent& MmPageFreeBatchedFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MmPageFreeBatchedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MmPageFreeBatchedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&page_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cold_) -
        reinterpret_cast<char*>(&page_)) + sizeof(cold_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MmPageFreeBatchedFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 cold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_cold(&has_bits);
          cold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 page = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_page(&has_bits);
          page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pfn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pfn(&has_bits);
          pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MmPageFreeBatchedFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cold = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_cold(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &cold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 page = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_page(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &page_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pfn = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pfn(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pfn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MmPageFreeBatchedFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 cold = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->cold(), output);
  }

  // optional uint64 page = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->page(), output);
  }

  // optional uint64 pfn = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pfn(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MmPageFreeBatchedFtraceEvent)
}

size_t MmPageFreeBatchedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 page = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->page());
    }

    // optional uint64 pfn = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pfn());
    }

    // optional int32 cold = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->cold());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageFreeBatchedFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MmPageFreeBatchedFtraceEvent*>(
      &from));
}

void MmPageFreeBatchedFtraceEvent::MergeFrom(const MmPageFreeBatchedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      page_ = from.page_;
    }
    if (cached_has_bits & 0x00000002u) {
      pfn_ = from.pfn_;
    }
    if (cached_has_bits & 0x00000004u) {
      cold_ = from.cold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MmPageFreeBatchedFtraceEvent::CopyFrom(const MmPageFreeBatchedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageFreeBatchedFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageFreeBatchedFtraceEvent::InternalSwap(MmPageFreeBatchedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(page_, other->page_);
  swap(pfn_, other->pfn_);
  swap(cold_, other->cold_);
}

std::string MmPageFreeBatchedFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageFreeBatchedFtraceEvent";
}


// ===================================================================

void MmPagePcpuDrainFtraceEvent::InitAsDefaultInstance() {
}
class MmPagePcpuDrainFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPagePcpuDrainFtraceEvent>()._has_bits_);
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
}
MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(const MmPagePcpuDrainFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&migratetype_, &from.migratetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&pfn_) -
    reinterpret_cast<char*>(&migratetype_)) + sizeof(pfn_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
}

void MmPagePcpuDrainFtraceEvent::SharedCtor() {
  ::memset(&migratetype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pfn_) -
      reinterpret_cast<char*>(&migratetype_)) + sizeof(pfn_));
}

MmPagePcpuDrainFtraceEvent::~MmPagePcpuDrainFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  SharedDtor();
}

void MmPagePcpuDrainFtraceEvent::SharedDtor() {
}

void MmPagePcpuDrainFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MmPagePcpuDrainFtraceEvent& MmPagePcpuDrainFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MmPagePcpuDrainFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void MmPagePcpuDrainFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&migratetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pfn_) -
        reinterpret_cast<char*>(&migratetype_)) + sizeof(pfn_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MmPagePcpuDrainFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_migratetype(&has_bits);
          migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_page(&has_bits);
          page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pfn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pfn(&has_bits);
          pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MmPagePcpuDrainFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 migratetype = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_migratetype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &migratetype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 order = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_order(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 page = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_page(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &page_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pfn = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pfn(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pfn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MmPagePcpuDrainFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->migratetype(), output);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->order(), output);
  }

  // optional uint64 page = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->page(), output);
  }

  // optional uint64 pfn = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->pfn(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.MmPagePcpuDrainFtraceEvent)
}

size_t MmPagePcpuDrainFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->migratetype());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->order());
    }

    // optional uint64 page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->page());
    }

    // optional uint64 pfn = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pfn());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPagePcpuDrainFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MmPagePcpuDrainFtraceEvent*>(
      &from));
}

void MmPagePcpuDrainFtraceEvent::MergeFrom(const MmPagePcpuDrainFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      migratetype_ = from.migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      order_ = from.order_;
    }
    if (cached_has_bits & 0x00000004u) {
      page_ = from.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      pfn_ = from.pfn_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MmPagePcpuDrainFtraceEvent::CopyFrom(const MmPagePcpuDrainFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPagePcpuDrainFtraceEvent::IsInitialized() const {
  return true;
}

void MmPagePcpuDrainFtraceEvent::InternalSwap(MmPagePcpuDrainFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(migratetype_, other->migratetype_);
  swap(order_, other->order_);
  swap(page_, other->page_);
  swap(pfn_, other->pfn_);
}

std::string MmPagePcpuDrainFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPagePcpuDrainFtraceEvent";
}


// ===================================================================

void RssStatFtraceEvent::InitAsDefaultInstance() {
}
class RssStatFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<RssStatFtraceEvent>()._has_bits_);
  static void set_has_member(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_curr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mm_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RssStatFtraceEvent::RssStatFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.RssStatFtraceEvent)
}
RssStatFtraceEvent::RssStatFtraceEvent(const RssStatFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&size_, &from.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&mm_id_) -
    reinterpret_cast<char*>(&size_)) + sizeof(mm_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.RssStatFtraceEvent)
}

void RssStatFtraceEvent::SharedCtor() {
  ::memset(&size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mm_id_) -
      reinterpret_cast<char*>(&size_)) + sizeof(mm_id_));
}

RssStatFtraceEvent::~RssStatFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.RssStatFtraceEvent)
  SharedDtor();
}

void RssStatFtraceEvent::SharedDtor() {
}

void RssStatFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RssStatFtraceEvent& RssStatFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RssStatFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void RssStatFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.RssStatFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mm_id_) -
        reinterpret_cast<char*>(&size_)) + sizeof(mm_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RssStatFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 member = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_member(&has_bits);
          member_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 curr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_curr(&has_bits);
          curr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mm_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_mm_id(&has_bits);
          mm_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RssStatFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.RssStatFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 member = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_member(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &member_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 curr = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_curr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &curr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mm_id = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_mm_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mm_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.RssStatFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.RssStatFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RssStatFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.RssStatFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 member = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->member(), output);
  }

  // optional int64 size = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->size(), output);
  }

  // optional uint32 curr = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->curr(), output);
  }

  // optional uint32 mm_id = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->mm_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.RssStatFtraceEvent)
}

size_t RssStatFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.RssStatFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 size = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->size());
    }

    // optional int32 member = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->member());
    }

    // optional uint32 curr = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->curr());
    }

    // optional uint32 mm_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mm_id());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RssStatFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RssStatFtraceEvent*>(
      &from));
}

void RssStatFtraceEvent::MergeFrom(const RssStatFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.RssStatFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000002u) {
      member_ = from.member_;
    }
    if (cached_has_bits & 0x00000004u) {
      curr_ = from.curr_;
    }
    if (cached_has_bits & 0x00000008u) {
      mm_id_ = from.mm_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RssStatFtraceEvent::CopyFrom(const RssStatFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.RssStatFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RssStatFtraceEvent::IsInitialized() const {
  return true;
}

void RssStatFtraceEvent::InternalSwap(RssStatFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(size_, other->size_);
  swap(member_, other->member_);
  swap(curr_, other->curr_);
  swap(mm_id_, other->mm_id_);
}

std::string RssStatFtraceEvent::GetTypeName() const {
  return "perfetto.protos.RssStatFtraceEvent";
}


// ===================================================================

void IonHeapShrinkFtraceEvent::InitAsDefaultInstance() {
}
class IonHeapShrinkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonHeapShrinkFtraceEvent>()._has_bits_);
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_total_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonHeapShrinkFtraceEvent)
}
IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(const IonHeapShrinkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&len_, &from.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&total_allocated_) -
    reinterpret_cast<char*>(&len_)) + sizeof(total_allocated_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonHeapShrinkFtraceEvent)
}

void IonHeapShrinkFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonHeapShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&total_allocated_) -
      reinterpret_cast<char*>(&len_)) + sizeof(total_allocated_));
}

IonHeapShrinkFtraceEvent::~IonHeapShrinkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonHeapShrinkFtraceEvent)
  SharedDtor();
}

void IonHeapShrinkFtraceEvent::SharedDtor() {
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonHeapShrinkFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonHeapShrinkFtraceEvent& IonHeapShrinkFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonHeapShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonHeapShrinkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    heap_name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_allocated_) -
        reinterpret_cast<char*>(&len_)) + sizeof(total_allocated_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonHeapShrinkFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string heap_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 total_allocated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_total_allocated(&has_bits);
          total_allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonHeapShrinkFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string heap_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 total_allocated = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_total_allocated(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &total_allocated_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonHeapShrinkFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonHeapShrinkFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonHeapShrinkFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string heap_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->heap_name(), output);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->len(), output);
  }

  // optional int64 total_allocated = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->total_allocated(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonHeapShrinkFtraceEvent)
}

size_t IonHeapShrinkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string heap_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional int64 total_allocated = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->total_allocated());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonHeapShrinkFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonHeapShrinkFtraceEvent*>(
      &from));
}

void IonHeapShrinkFtraceEvent::MergeFrom(const IonHeapShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      total_allocated_ = from.total_allocated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonHeapShrinkFtraceEvent::CopyFrom(const IonHeapShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonHeapShrinkFtraceEvent::IsInitialized() const {
  return true;
}

void IonHeapShrinkFtraceEvent::InternalSwap(IonHeapShrinkFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(len_, other->len_);
  swap(total_allocated_, other->total_allocated_);
}

std::string IonHeapShrinkFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonHeapShrinkFtraceEvent";
}


// ===================================================================

void IonHeapGrowFtraceEvent::InitAsDefaultInstance() {
}
class IonHeapGrowFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonHeapGrowFtraceEvent>()._has_bits_);
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_total_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonHeapGrowFtraceEvent)
}
IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(const IonHeapGrowFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_heap_name()) {
    heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
  }
  ::memcpy(&len_, &from.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&total_allocated_) -
    reinterpret_cast<char*>(&len_)) + sizeof(total_allocated_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonHeapGrowFtraceEvent)
}

void IonHeapGrowFtraceEvent::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IonHeapGrowFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  heap_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&total_allocated_) -
      reinterpret_cast<char*>(&len_)) + sizeof(total_allocated_));
}

IonHeapGrowFtraceEvent::~IonHeapGrowFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonHeapGrowFtraceEvent)
  SharedDtor();
}

void IonHeapGrowFtraceEvent::SharedDtor() {
  heap_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IonHeapGrowFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonHeapGrowFtraceEvent& IonHeapGrowFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonHeapGrowFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonHeapGrowFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonHeapGrowFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    heap_name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_allocated_) -
        reinterpret_cast<char*>(&len_)) + sizeof(total_allocated_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonHeapGrowFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string heap_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_heap_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 total_allocated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_total_allocated(&has_bits);
          total_allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonHeapGrowFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonHeapGrowFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string heap_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_heap_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 total_allocated = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_total_allocated(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &total_allocated_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonHeapGrowFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonHeapGrowFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonHeapGrowFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonHeapGrowFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string heap_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->heap_name(), output);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->len(), output);
  }

  // optional int64 total_allocated = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->total_allocated(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonHeapGrowFtraceEvent)
}

size_t IonHeapGrowFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonHeapGrowFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string heap_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->heap_name());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional int64 total_allocated = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->total_allocated());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonHeapGrowFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonHeapGrowFtraceEvent*>(
      &from));
}

void IonHeapGrowFtraceEvent::MergeFrom(const IonHeapGrowFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonHeapGrowFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      heap_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.heap_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      total_allocated_ = from.total_allocated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonHeapGrowFtraceEvent::CopyFrom(const IonHeapGrowFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonHeapGrowFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonHeapGrowFtraceEvent::IsInitialized() const {
  return true;
}

void IonHeapGrowFtraceEvent::InternalSwap(IonHeapGrowFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  heap_name_.Swap(&other->heap_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(len_, other->len_);
  swap(total_allocated_, other->total_allocated_);
}

std::string IonHeapGrowFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonHeapGrowFtraceEvent";
}


// ===================================================================

void IonBufferCreateFtraceEvent::InitAsDefaultInstance() {
}
class IonBufferCreateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonBufferCreateFtraceEvent>()._has_bits_);
  static void set_has_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonBufferCreateFtraceEvent)
}
IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(const IonBufferCreateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&addr_, &from.addr_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&addr_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonBufferCreateFtraceEvent)
}

void IonBufferCreateFtraceEvent::SharedCtor() {
  ::memset(&addr_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&addr_)) + sizeof(len_));
}

IonBufferCreateFtraceEvent::~IonBufferCreateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonBufferCreateFtraceEvent)
  SharedDtor();
}

void IonBufferCreateFtraceEvent::SharedDtor() {
}

void IonBufferCreateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonBufferCreateFtraceEvent& IonBufferCreateFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonBufferCreateFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonBufferCreateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonBufferCreateFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&addr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&addr_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonBufferCreateFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 addr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_addr(&has_bits);
          addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonBufferCreateFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonBufferCreateFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 addr = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_addr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &addr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonBufferCreateFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonBufferCreateFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonBufferCreateFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonBufferCreateFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 addr = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->addr(), output);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonBufferCreateFtraceEvent)
}

size_t IonBufferCreateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonBufferCreateFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 addr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->addr());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonBufferCreateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonBufferCreateFtraceEvent*>(
      &from));
}

void IonBufferCreateFtraceEvent::MergeFrom(const IonBufferCreateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonBufferCreateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      addr_ = from.addr_;
    }
    if (cached_has_bits & 0x00000002u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonBufferCreateFtraceEvent::CopyFrom(const IonBufferCreateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonBufferCreateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonBufferCreateFtraceEvent::IsInitialized() const {
  return true;
}

void IonBufferCreateFtraceEvent::InternalSwap(IonBufferCreateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(addr_, other->addr_);
  swap(len_, other->len_);
}

std::string IonBufferCreateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonBufferCreateFtraceEvent";
}


// ===================================================================

void IonBufferDestroyFtraceEvent::InitAsDefaultInstance() {
}
class IonBufferDestroyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonBufferDestroyFtraceEvent>()._has_bits_);
  static void set_has_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.IonBufferDestroyFtraceEvent)
}
IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(const IonBufferDestroyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&addr_, &from.addr_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&addr_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonBufferDestroyFtraceEvent)
}

void IonBufferDestroyFtraceEvent::SharedCtor() {
  ::memset(&addr_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&addr_)) + sizeof(len_));
}

IonBufferDestroyFtraceEvent::~IonBufferDestroyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonBufferDestroyFtraceEvent)
  SharedDtor();
}

void IonBufferDestroyFtraceEvent::SharedDtor() {
}

void IonBufferDestroyFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IonBufferDestroyFtraceEvent& IonBufferDestroyFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IonBufferDestroyFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto.base);
  return *internal_default_instance();
}


void IonBufferDestroyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&addr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&addr_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IonBufferDestroyFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 addr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_addr(&has_bits);
          addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IonBufferDestroyFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 addr = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_addr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &addr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.IonBufferDestroyFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.IonBufferDestroyFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IonBufferDestroyFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 addr = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->addr(), output);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.IonBufferDestroyFtraceEvent)
}

size_t IonBufferDestroyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 addr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->addr());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonBufferDestroyFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IonBufferDestroyFtraceEvent*>(
      &from));
}

void IonBufferDestroyFtraceEvent::MergeFrom(const IonBufferDestroyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      addr_ = from.addr_;
    }
    if (cached_has_bits & 0x00000002u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IonBufferDestroyFtraceEvent::CopyFrom(const IonBufferDestroyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonBufferDestroyFtraceEvent::IsInitialized() const {
  return true;
}

void IonBufferDestroyFtraceEvent::InternalSwap(IonBufferDestroyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(addr_, other->addr_);
  swap(len_, other->len_);
}

std::string IonBufferDestroyFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonBufferDestroyFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::AllocPagesIommuEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuFailFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuFailFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::AllocPagesIommuFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::AllocPagesIommuStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::AllocPagesSysEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysFailFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysFailFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::AllocPagesSysFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::AllocPagesSysStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuMapRangeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IommuMapRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IommuMapRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonAllocBufferEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferFailFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferFailFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonAllocBufferFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferFallbackFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferFallbackFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonAllocBufferFallbackFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonAllocBufferStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpAllocRetryFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonCpAllocRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonCpAllocRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpSecureBufferEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonCpSecureBufferEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonCpSecureBufferEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpSecureBufferStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonCpSecureBufferStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonCpSecureBufferStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonPrefetchingFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonPrefetchingFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonPrefetchingFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KfreeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::KfreeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::KfreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmallocFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::KmallocFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::KmallocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmallocNodeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::KmallocNodeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::KmallocNodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheAllocFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::KmemCacheAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheAllocNodeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheAllocNodeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::KmemCacheAllocNodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheFreeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::KmemCacheFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigratePagesEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MigratePagesEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MigratePagesEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigratePagesStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MigratePagesStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MigratePagesStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigrateRetryFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MigrateRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MigrateRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MmPageAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocExtfragFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocExtfragFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MmPageAllocExtfragFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageFreeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MmPageFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MmPageFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageFreeBatchedFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MmPageFreeBatchedFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MmPageFreeBatchedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPagePcpuDrainFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::MmPagePcpuDrainFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::MmPagePcpuDrainFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::RssStatFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::RssStatFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::RssStatFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonHeapShrinkFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonHeapShrinkFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonHeapShrinkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonHeapGrowFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonHeapGrowFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonHeapGrowFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonBufferCreateFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonBufferCreateFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonBufferCreateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonBufferDestroyFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::IonBufferDestroyFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::IonBufferDestroyFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
