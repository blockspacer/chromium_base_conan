// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class IonBufferDestroyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonBufferDestroyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonBufferDestroyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonBufferDestroyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_addr() const { return at<1>().valid(); }
  uint64_t addr() const { return at<1>().as_uint64(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
};

class IonBufferDestroyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonBufferDestroyFtraceEvent_Decoder;
  enum : int32_t {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  void set_addr(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonBufferCreateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonBufferCreateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonBufferCreateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonBufferCreateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_addr() const { return at<1>().valid(); }
  uint64_t addr() const { return at<1>().as_uint64(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
};

class IonBufferCreateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonBufferCreateFtraceEvent_Decoder;
  enum : int32_t {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  void set_addr(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonHeapGrowFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonHeapGrowFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonHeapGrowFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonHeapGrowFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_heap_name() const { return at<1>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<1>().as_string(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_total_allocated() const { return at<3>().valid(); }
  int64_t total_allocated() const { return at<3>().as_int64(); }
};

class IonHeapGrowFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonHeapGrowFtraceEvent_Decoder;
  enum : int32_t {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  void set_heap_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_total_allocated(int64_t value) {
    AppendVarInt(3, value);
  }
};

class IonHeapShrinkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonHeapShrinkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonHeapShrinkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonHeapShrinkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_heap_name() const { return at<1>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<1>().as_string(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_total_allocated() const { return at<3>().valid(); }
  int64_t total_allocated() const { return at<3>().as_int64(); }
};

class IonHeapShrinkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonHeapShrinkFtraceEvent_Decoder;
  enum : int32_t {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  void set_heap_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_total_allocated(int64_t value) {
    AppendVarInt(3, value);
  }
};

class RssStatFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RssStatFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RssStatFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RssStatFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_member() const { return at<1>().valid(); }
  int32_t member() const { return at<1>().as_int32(); }
  bool has_size() const { return at<2>().valid(); }
  int64_t size() const { return at<2>().as_int64(); }
  bool has_curr() const { return at<3>().valid(); }
  uint32_t curr() const { return at<3>().as_uint32(); }
  bool has_mm_id() const { return at<4>().valid(); }
  uint32_t mm_id() const { return at<4>().as_uint32(); }
};

class RssStatFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RssStatFtraceEvent_Decoder;
  enum : int32_t {
    kMemberFieldNumber = 1,
    kSizeFieldNumber = 2,
    kCurrFieldNumber = 3,
    kMmIdFieldNumber = 4,
  };
  void set_member(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_curr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_mm_id(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class MmPagePcpuDrainFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPagePcpuDrainFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPagePcpuDrainFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPagePcpuDrainFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_migratetype() const { return at<1>().valid(); }
  int32_t migratetype() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
  bool has_page() const { return at<3>().valid(); }
  uint64_t page() const { return at<3>().as_uint64(); }
  bool has_pfn() const { return at<4>().valid(); }
  uint64_t pfn() const { return at<4>().as_uint64(); }
};

class MmPagePcpuDrainFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPagePcpuDrainFtraceEvent_Decoder;
  enum : int32_t {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  void set_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmPageFreeBatchedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageFreeBatchedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageFreeBatchedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageFreeBatchedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cold() const { return at<1>().valid(); }
  int32_t cold() const { return at<1>().as_int32(); }
  bool has_page() const { return at<2>().valid(); }
  uint64_t page() const { return at<2>().as_uint64(); }
  bool has_pfn() const { return at<3>().valid(); }
  uint64_t pfn() const { return at<3>().as_uint64(); }
};

class MmPageFreeBatchedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageFreeBatchedFtraceEvent_Decoder;
  enum : int32_t {
    kColdFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };
  void set_cold(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MmPageFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_order() const { return at<1>().valid(); }
  uint32_t order() const { return at<1>().as_uint32(); }
  bool has_page() const { return at<2>().valid(); }
  uint64_t page() const { return at<2>().as_uint64(); }
  bool has_pfn() const { return at<3>().valid(); }
  uint64_t pfn() const { return at<3>().as_uint64(); }
};

class MmPageFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageFreeFtraceEvent_Decoder;
  enum : int32_t {
    kOrderFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };
  void set_order(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MmPageAllocZoneLockedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocZoneLockedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocZoneLockedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocZoneLockedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_migratetype() const { return at<1>().valid(); }
  int32_t migratetype() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
  bool has_page() const { return at<3>().valid(); }
  uint64_t page() const { return at<3>().as_uint64(); }
  bool has_pfn() const { return at<4>().valid(); }
  uint64_t pfn() const { return at<4>().as_uint64(); }
};

class MmPageAllocZoneLockedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocZoneLockedFtraceEvent_Decoder;
  enum : int32_t {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  void set_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmPageAllocExtfragFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocExtfragFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocExtfragFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocExtfragFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_alloc_migratetype() const { return at<1>().valid(); }
  int32_t alloc_migratetype() const { return at<1>().as_int32(); }
  bool has_alloc_order() const { return at<2>().valid(); }
  int32_t alloc_order() const { return at<2>().as_int32(); }
  bool has_fallback_migratetype() const { return at<3>().valid(); }
  int32_t fallback_migratetype() const { return at<3>().as_int32(); }
  bool has_fallback_order() const { return at<4>().valid(); }
  int32_t fallback_order() const { return at<4>().as_int32(); }
  bool has_page() const { return at<5>().valid(); }
  uint64_t page() const { return at<5>().as_uint64(); }
  bool has_change_ownership() const { return at<6>().valid(); }
  int32_t change_ownership() const { return at<6>().as_int32(); }
  bool has_pfn() const { return at<7>().valid(); }
  uint64_t pfn() const { return at<7>().as_uint64(); }
};

class MmPageAllocExtfragFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocExtfragFtraceEvent_Decoder;
  enum : int32_t {
    kAllocMigratetypeFieldNumber = 1,
    kAllocOrderFieldNumber = 2,
    kFallbackMigratetypeFieldNumber = 3,
    kFallbackOrderFieldNumber = 4,
    kPageFieldNumber = 5,
    kChangeOwnershipFieldNumber = 6,
    kPfnFieldNumber = 7,
  };
  void set_alloc_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_alloc_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_fallback_migratetype(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_fallback_order(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_change_ownership(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class MmPageAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_migratetype() const { return at<2>().valid(); }
  int32_t migratetype() const { return at<2>().as_int32(); }
  bool has_order() const { return at<3>().valid(); }
  uint32_t order() const { return at<3>().as_uint32(); }
  bool has_page() const { return at<4>().valid(); }
  uint64_t page() const { return at<4>().as_uint64(); }
  bool has_pfn() const { return at<5>().valid(); }
  uint64_t pfn() const { return at<5>().as_uint64(); }
};

class MmPageAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kMigratetypeFieldNumber = 2,
    kOrderFieldNumber = 3,
    kPageFieldNumber = 4,
    kPfnFieldNumber = 5,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_migratetype(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class MigrateRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigrateRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigrateRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigrateRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class MigrateRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigrateRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MigratePagesStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigratePagesStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigratePagesStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigratePagesStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mode() const { return at<1>().valid(); }
  int32_t mode() const { return at<1>().as_int32(); }
};

class MigratePagesStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigratePagesStartFtraceEvent_Decoder;
  enum : int32_t {
    kModeFieldNumber = 1,
  };
  void set_mode(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MigratePagesEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigratePagesEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigratePagesEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigratePagesEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mode() const { return at<1>().valid(); }
  int32_t mode() const { return at<1>().as_int32(); }
};

class MigratePagesEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigratePagesEndFtraceEvent_Decoder;
  enum : int32_t {
    kModeFieldNumber = 1,
  };
  void set_mode(int32_t value) {
    AppendVarInt(1, value);
  }
};

class KmemCacheFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_call_site() const { return at<1>().valid(); }
  uint64_t call_site() const { return at<1>().as_uint64(); }
  bool has_ptr() const { return at<2>().valid(); }
  uint64_t ptr() const { return at<2>().as_uint64(); }
};

class KmemCacheFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheFreeFtraceEvent_Decoder;
  enum : int32_t {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  void set_call_site(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class KmemCacheAllocNodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheAllocNodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheAllocNodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheAllocNodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_node() const { return at<5>().valid(); }
  int32_t node() const { return at<5>().as_int32(); }
  bool has_ptr() const { return at<6>().valid(); }
  uint64_t ptr() const { return at<6>().as_uint64(); }
};

class KmemCacheAllocNodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheAllocNodeFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_node(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class KmemCacheAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_ptr() const { return at<5>().valid(); }
  uint64_t ptr() const { return at<5>().as_uint64(); }
};

class KmemCacheAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheAllocFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class KmallocNodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmallocNodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmallocNodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmallocNodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_node() const { return at<5>().valid(); }
  int32_t node() const { return at<5>().as_int32(); }
  bool has_ptr() const { return at<6>().valid(); }
  uint64_t ptr() const { return at<6>().as_uint64(); }
};

class KmallocNodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmallocNodeFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_node(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class KmallocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmallocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmallocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmallocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_ptr() const { return at<5>().valid(); }
  uint64_t ptr() const { return at<5>().as_uint64(); }
};

class KmallocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmallocFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class KfreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KfreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KfreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KfreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_call_site() const { return at<1>().valid(); }
  uint64_t call_site() const { return at<1>().as_uint64(); }
  bool has_ptr() const { return at<2>().valid(); }
  uint64_t ptr() const { return at<2>().as_uint64(); }
};

class KfreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KfreeFtraceEvent_Decoder;
  enum : int32_t {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  void set_call_site(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaShrinkPoolStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_drained_size() const { return at<1>().valid(); }
  uint64_t drained_size() const { return at<1>().as_uint64(); }
  bool has_skipped_size() const { return at<2>().valid(); }
  uint64_t skipped_size() const { return at<2>().as_uint64(); }
};

class IonSecureCmaShrinkPoolStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaShrinkPoolStartFtraceEvent_Decoder;
  enum : int32_t {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  void set_drained_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_skipped_size(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaShrinkPoolEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_drained_size() const { return at<1>().valid(); }
  uint64_t drained_size() const { return at<1>().as_uint64(); }
  bool has_skipped_size() const { return at<2>().valid(); }
  uint64_t skipped_size() const { return at<2>().as_uint64(); }
};

class IonSecureCmaShrinkPoolEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaShrinkPoolEndFtraceEvent_Decoder;
  enum : int32_t {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  void set_drained_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_skipped_size(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaAllocateStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAllocateStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAllocateStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAllocateStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonSecureCmaAllocateStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAllocateStartFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonSecureCmaAllocateEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAllocateEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAllocateEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAllocateEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonSecureCmaAllocateEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAllocateEndFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonSecureCmaAddToPoolStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_prefetch() const { return at<1>().valid(); }
  uint32_t is_prefetch() const { return at<1>().as_uint32(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pool_total() const { return at<3>().valid(); }
  int32_t pool_total() const { return at<3>().as_int32(); }
};

class IonSecureCmaAddToPoolStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAddToPoolStartFtraceEvent_Decoder;
  enum : int32_t {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };
  void set_is_prefetch(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pool_total(int32_t value) {
    AppendVarInt(3, value);
  }
};

class IonSecureCmaAddToPoolEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_prefetch() const { return at<1>().valid(); }
  uint32_t is_prefetch() const { return at<1>().as_uint32(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pool_total() const { return at<3>().valid(); }
  int32_t pool_total() const { return at<3>().as_int32(); }
};

class IonSecureCmaAddToPoolEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAddToPoolEndFtraceEvent_Decoder;
  enum : int32_t {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };
  void set_is_prefetch(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pool_total(int32_t value) {
    AppendVarInt(3, value);
  }
};

class IonPrefetchingFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonPrefetchingFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonPrefetchingFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonPrefetchingFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
};

class IonPrefetchingFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonPrefetchingFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class IonCpSecureBufferStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpSecureBufferStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpSecureBufferStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpSecureBufferStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonCpSecureBufferStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpSecureBufferStartFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonCpSecureBufferEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpSecureBufferEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpSecureBufferEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpSecureBufferEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonCpSecureBufferEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpSecureBufferEndFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonCpAllocRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpAllocRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpAllocRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpAllocRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class IonCpAllocRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpAllocRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class IonAllocBufferStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_mask() const { return at<5>().valid(); }
  uint32_t mask() const { return at<5>().as_uint32(); }
};

class IonAllocBufferStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferStartFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };
  void set_client_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_client_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class IonAllocBufferFallbackFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferFallbackFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferFallbackFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferFallbackFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  int64_t error() const { return at<2>().as_int64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_heap_name() const { return at<4>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<4>().as_string(); }
  bool has_len() const { return at<5>().valid(); }
  uint64_t len() const { return at<5>().as_uint64(); }
  bool has_mask() const { return at<6>().valid(); }
  uint32_t mask() const { return at<6>().as_uint32(); }
};

class IonAllocBufferFallbackFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferFallbackFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };
  void set_client_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_client_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_error(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class IonAllocBufferFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  int64_t error() const { return at<2>().as_int64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_heap_name() const { return at<4>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<4>().as_string(); }
  bool has_len() const { return at<5>().valid(); }
  uint64_t len() const { return at<5>().as_uint64(); }
  bool has_mask() const { return at<6>().valid(); }
  uint32_t mask() const { return at<6>().as_uint32(); }
};

class IonAllocBufferFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferFailFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };
  void set_client_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_client_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_error(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class IonAllocBufferEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_mask() const { return at<5>().valid(); }
  uint32_t mask() const { return at<5>().as_uint32(); }
};

class IonAllocBufferEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferEndFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };
  void set_client_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_client_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class IommuSecPtblMapRangeStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuSecPtblMapRangeStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuSecPtblMapRangeStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuSecPtblMapRangeStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
  bool has_num() const { return at<2>().valid(); }
  int32_t num() const { return at<2>().as_int32(); }
  bool has_pa() const { return at<3>().valid(); }
  uint32_t pa() const { return at<3>().as_uint32(); }
  bool has_sec_id() const { return at<4>().valid(); }
  int32_t sec_id() const { return at<4>().as_int32(); }
  bool has_va() const { return at<5>().valid(); }
  uint64_t va() const { return at<5>().as_uint64(); }
};

class IommuSecPtblMapRangeStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuSecPtblMapRangeStartFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sec_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class IommuSecPtblMapRangeEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuSecPtblMapRangeEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuSecPtblMapRangeEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuSecPtblMapRangeEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
  bool has_num() const { return at<2>().valid(); }
  int32_t num() const { return at<2>().as_int32(); }
  bool has_pa() const { return at<3>().valid(); }
  uint32_t pa() const { return at<3>().as_uint32(); }
  bool has_sec_id() const { return at<4>().valid(); }
  int32_t sec_id() const { return at<4>().as_int32(); }
  bool has_va() const { return at<5>().valid(); }
  uint64_t va() const { return at<5>().as_uint64(); }
};

class IommuSecPtblMapRangeEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuSecPtblMapRangeEndFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sec_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class IommuMapRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuMapRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuMapRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuMapRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chunk_size() const { return at<1>().valid(); }
  uint64_t chunk_size() const { return at<1>().as_uint64(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pa() const { return at<3>().valid(); }
  uint64_t pa() const { return at<3>().as_uint64(); }
  bool has_va() const { return at<4>().valid(); }
  uint64_t va() const { return at<4>().as_uint64(); }
};

class IommuMapRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuMapRangeFtraceEvent_Decoder;
  enum : int32_t {
    kChunkSizeFieldNumber = 1,
    kLenFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 4,
  };
  void set_chunk_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class DmaAllocContiguousRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DmaAllocContiguousRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DmaAllocContiguousRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DmaAllocContiguousRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class DmaAllocContiguousRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = DmaAllocContiguousRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class AllocPagesSysStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysStartFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesSysFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysFailFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesSysEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysEndFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuStartFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuFailFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuEndFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
