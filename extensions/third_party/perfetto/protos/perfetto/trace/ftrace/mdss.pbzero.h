// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class RotatorBwAoAsContextFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RotatorBwAoAsContextFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RotatorBwAoAsContextFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RotatorBwAoAsContextFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
};

class RotatorBwAoAsContextFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RotatorBwAoAsContextFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
  };
  void set_state(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpPerfUpdateBusFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfUpdateBusFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfUpdateBusFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfUpdateBusFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client() const { return at<1>().valid(); }
  int32_t client() const { return at<1>().as_int32(); }
  bool has_ab_quota() const { return at<2>().valid(); }
  uint64_t ab_quota() const { return at<2>().as_uint64(); }
  bool has_ib_quota() const { return at<3>().valid(); }
  uint64_t ib_quota() const { return at<3>().as_uint64(); }
};

class MdpPerfUpdateBusFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfUpdateBusFtraceEvent_Decoder;
  enum : int32_t {
    kClientFieldNumber = 1,
    kAbQuotaFieldNumber = 2,
    kIbQuotaFieldNumber = 3,
  };
  void set_client(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ab_quota(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ib_quota(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MdpPerfPrefillCalcFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfPrefillCalcFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfPrefillCalcFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfPrefillCalcFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_latency_buf() const { return at<2>().valid(); }
  uint32_t latency_buf() const { return at<2>().as_uint32(); }
  bool has_ot() const { return at<3>().valid(); }
  uint32_t ot() const { return at<3>().as_uint32(); }
  bool has_y_buf() const { return at<4>().valid(); }
  uint32_t y_buf() const { return at<4>().as_uint32(); }
  bool has_y_scaler() const { return at<5>().valid(); }
  uint32_t y_scaler() const { return at<5>().as_uint32(); }
  bool has_pp_lines() const { return at<6>().valid(); }
  uint32_t pp_lines() const { return at<6>().as_uint32(); }
  bool has_pp_bytes() const { return at<7>().valid(); }
  uint32_t pp_bytes() const { return at<7>().as_uint32(); }
  bool has_post_sc() const { return at<8>().valid(); }
  uint32_t post_sc() const { return at<8>().as_uint32(); }
  bool has_fbc_bytes() const { return at<9>().valid(); }
  uint32_t fbc_bytes() const { return at<9>().as_uint32(); }
  bool has_prefill_bytes() const { return at<10>().valid(); }
  uint32_t prefill_bytes() const { return at<10>().as_uint32(); }
};

class MdpPerfPrefillCalcFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfPrefillCalcFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kLatencyBufFieldNumber = 2,
    kOtFieldNumber = 3,
    kYBufFieldNumber = 4,
    kYScalerFieldNumber = 5,
    kPpLinesFieldNumber = 6,
    kPpBytesFieldNumber = 7,
    kPostScFieldNumber = 8,
    kFbcBytesFieldNumber = 9,
    kPrefillBytesFieldNumber = 10,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_latency_buf(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ot(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_y_buf(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_y_scaler(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_pp_lines(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_pp_bytes(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_post_sc(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_fbc_bytes(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_prefill_bytes(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class MdpCmdWaitPingpongFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdWaitPingpongFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdWaitPingpongFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdWaitPingpongFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_kickoff_cnt() const { return at<2>().valid(); }
  int32_t kickoff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdWaitPingpongFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdWaitPingpongFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_kickoff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpVideoUnderrunDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpVideoUnderrunDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpVideoUnderrunDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpVideoUnderrunDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_underrun_cnt() const { return at<2>().valid(); }
  uint32_t underrun_cnt() const { return at<2>().as_uint32(); }
};

class MdpVideoUnderrunDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpVideoUnderrunDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kUnderrunCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_underrun_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpPerfSetWmLevelsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetWmLevelsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetWmLevelsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetWmLevelsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_use_space() const { return at<2>().valid(); }
  uint32_t use_space() const { return at<2>().as_uint32(); }
  bool has_priority_bytes() const { return at<3>().valid(); }
  uint32_t priority_bytes() const { return at<3>().as_uint32(); }
  bool has_wm0() const { return at<4>().valid(); }
  uint32_t wm0() const { return at<4>().as_uint32(); }
  bool has_wm1() const { return at<5>().valid(); }
  uint32_t wm1() const { return at<5>().as_uint32(); }
  bool has_wm2() const { return at<6>().valid(); }
  uint32_t wm2() const { return at<6>().as_uint32(); }
  bool has_mb_cnt() const { return at<7>().valid(); }
  uint32_t mb_cnt() const { return at<7>().as_uint32(); }
  bool has_mb_size() const { return at<8>().valid(); }
  uint32_t mb_size() const { return at<8>().as_uint32(); }
};

class MdpPerfSetWmLevelsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetWmLevelsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kUseSpaceFieldNumber = 2,
    kPriorityBytesFieldNumber = 3,
    kWm0FieldNumber = 4,
    kWm1FieldNumber = 5,
    kWm2FieldNumber = 6,
    kMbCntFieldNumber = 7,
    kMbSizeFieldNumber = 8,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_use_space(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_priority_bytes(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_wm0(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_wm1(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_wm2(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mb_cnt(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_mb_size(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class MdpMixerUpdateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpMixerUpdateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpMixerUpdateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpMixerUpdateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mixer_num() const { return at<1>().valid(); }
  uint32_t mixer_num() const { return at<1>().as_uint32(); }
};

class MdpMixerUpdateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpMixerUpdateFtraceEvent_Decoder;
  enum : int32_t {
    kMixerNumFieldNumber = 1,
  };
  void set_mixer_num(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpCmdReleaseBwFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdReleaseBwFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdReleaseBwFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdReleaseBwFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
};

class MdpCmdReleaseBwFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdReleaseBwFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpTraceCounterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpTraceCounterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpTraceCounterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpTraceCounterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_counter_name() const { return at<2>().valid(); }
  ::protozero::ConstChars counter_name() const { return at<2>().as_string(); }
  bool has_value() const { return at<3>().valid(); }
  int32_t value() const { return at<3>().as_int32(); }
};

class MdpTraceCounterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpTraceCounterFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCounterNameFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_counter_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_counter_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_value(int32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpPerfSetQosLutsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetQosLutsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetQosLutsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetQosLutsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_fmt() const { return at<2>().valid(); }
  uint32_t fmt() const { return at<2>().as_uint32(); }
  bool has_intf() const { return at<3>().valid(); }
  uint32_t intf() const { return at<3>().as_uint32(); }
  bool has_rot() const { return at<4>().valid(); }
  uint32_t rot() const { return at<4>().as_uint32(); }
  bool has_fl() const { return at<5>().valid(); }
  uint32_t fl() const { return at<5>().as_uint32(); }
  bool has_lut() const { return at<6>().valid(); }
  uint32_t lut() const { return at<6>().as_uint32(); }
  bool has_linear() const { return at<7>().valid(); }
  uint32_t linear() const { return at<7>().as_uint32(); }
};

class MdpPerfSetQosLutsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetQosLutsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kIntfFieldNumber = 3,
    kRotFieldNumber = 4,
    kFlFieldNumber = 5,
    kLutFieldNumber = 6,
    kLinearFieldNumber = 7,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fmt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_intf(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rot(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_fl(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lut(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_linear(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class MdpMisrCrcFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpMisrCrcFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpMisrCrcFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpMisrCrcFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_id() const { return at<1>().valid(); }
  uint32_t block_id() const { return at<1>().as_uint32(); }
  bool has_vsync_cnt() const { return at<2>().valid(); }
  uint32_t vsync_cnt() const { return at<2>().as_uint32(); }
  bool has_crc() const { return at<3>().valid(); }
  uint32_t crc() const { return at<3>().as_uint32(); }
};

class MdpMisrCrcFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpMisrCrcFtraceEvent_Decoder;
  enum : int32_t {
    kBlockIdFieldNumber = 1,
    kVsyncCntFieldNumber = 2,
    kCrcFieldNumber = 3,
  };
  void set_block_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_vsync_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_crc(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpCmdReadptrDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdReadptrDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdReadptrDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdReadptrDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_koff_cnt() const { return at<2>().valid(); }
  int32_t koff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdReadptrDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdReadptrDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_koff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpSsppSetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpSsppSetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpSsppSetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpSsppSetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_mixer() const { return at<3>().valid(); }
  uint32_t mixer() const { return at<3>().as_uint32(); }
  bool has_stage() const { return at<4>().valid(); }
  uint32_t stage() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
  bool has_format() const { return at<6>().valid(); }
  uint32_t format() const { return at<6>().as_uint32(); }
  bool has_img_w() const { return at<7>().valid(); }
  uint32_t img_w() const { return at<7>().as_uint32(); }
  bool has_img_h() const { return at<8>().valid(); }
  uint32_t img_h() const { return at<8>().as_uint32(); }
  bool has_src_x() const { return at<9>().valid(); }
  uint32_t src_x() const { return at<9>().as_uint32(); }
  bool has_src_y() const { return at<10>().valid(); }
  uint32_t src_y() const { return at<10>().as_uint32(); }
  bool has_src_w() const { return at<11>().valid(); }
  uint32_t src_w() const { return at<11>().as_uint32(); }
  bool has_src_h() const { return at<12>().valid(); }
  uint32_t src_h() const { return at<12>().as_uint32(); }
  bool has_dst_x() const { return at<13>().valid(); }
  uint32_t dst_x() const { return at<13>().as_uint32(); }
  bool has_dst_y() const { return at<14>().valid(); }
  uint32_t dst_y() const { return at<14>().as_uint32(); }
  bool has_dst_w() const { return at<15>().valid(); }
  uint32_t dst_w() const { return at<15>().as_uint32(); }
  bool has_dst_h() const { return at<16>().valid(); }
  uint32_t dst_h() const { return at<16>().as_uint32(); }
};

class MdpSsppSetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpSsppSetFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mixer(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_format(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_img_w(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_img_h(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_src_x(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_src_y(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_src_w(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_src_h(uint32_t value) {
    AppendVarInt(12, value);
  }
  void set_dst_x(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_dst_y(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_dst_w(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_dst_h(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class MdpPerfSetPanicLutsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetPanicLutsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetPanicLutsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetPanicLutsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_fmt() const { return at<2>().valid(); }
  uint32_t fmt() const { return at<2>().as_uint32(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
  bool has_panic_lut() const { return at<4>().valid(); }
  uint32_t panic_lut() const { return at<4>().as_uint32(); }
  bool has_robust_lut() const { return at<5>().valid(); }
  uint32_t robust_lut() const { return at<5>().as_uint32(); }
};

class MdpPerfSetPanicLutsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetPanicLutsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kModeFieldNumber = 3,
    kPanicLutFieldNumber = 4,
    kRobustLutFieldNumber = 5,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fmt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_panic_lut(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_robust_lut(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class MdpCompareBwFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCompareBwFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCompareBwFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCompareBwFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_new_ab() const { return at<1>().valid(); }
  uint64_t new_ab() const { return at<1>().as_uint64(); }
  bool has_new_ib() const { return at<2>().valid(); }
  uint64_t new_ib() const { return at<2>().as_uint64(); }
  bool has_new_wb() const { return at<3>().valid(); }
  uint64_t new_wb() const { return at<3>().as_uint64(); }
  bool has_old_ab() const { return at<4>().valid(); }
  uint64_t old_ab() const { return at<4>().as_uint64(); }
  bool has_old_ib() const { return at<5>().valid(); }
  uint64_t old_ib() const { return at<5>().as_uint64(); }
  bool has_old_wb() const { return at<6>().valid(); }
  uint64_t old_wb() const { return at<6>().as_uint64(); }
  bool has_params_changed() const { return at<7>().valid(); }
  uint32_t params_changed() const { return at<7>().as_uint32(); }
  bool has_update_bw() const { return at<8>().valid(); }
  uint32_t update_bw() const { return at<8>().as_uint32(); }
};

class MdpCompareBwFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCompareBwFtraceEvent_Decoder;
  enum : int32_t {
    kNewAbFieldNumber = 1,
    kNewIbFieldNumber = 2,
    kNewWbFieldNumber = 3,
    kOldAbFieldNumber = 4,
    kOldIbFieldNumber = 5,
    kOldWbFieldNumber = 6,
    kParamsChangedFieldNumber = 7,
    kUpdateBwFieldNumber = 8,
  };
  void set_new_ab(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_new_ib(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_wb(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_old_ab(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_old_ib(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_old_wb(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_params_changed(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_update_bw(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class MdpCmdPingpongDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdPingpongDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdPingpongDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdPingpongDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_intf_num() const { return at<2>().valid(); }
  uint32_t intf_num() const { return at<2>().as_uint32(); }
  bool has_pp_num() const { return at<3>().valid(); }
  uint32_t pp_num() const { return at<3>().as_uint32(); }
  bool has_koff_cnt() const { return at<4>().valid(); }
  int32_t koff_cnt() const { return at<4>().as_int32(); }
};

class MdpCmdPingpongDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdPingpongDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kIntfNumFieldNumber = 2,
    kPpNumFieldNumber = 3,
    kKoffCntFieldNumber = 4,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_intf_num(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_pp_num(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_koff_cnt(int32_t value) {
    AppendVarInt(4, value);
  }
};

class TracingMarkWriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracingMarkWriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingMarkWriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingMarkWriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_trace_name() const { return at<2>().valid(); }
  ::protozero::ConstChars trace_name() const { return at<2>().as_string(); }
  bool has_trace_begin() const { return at<3>().valid(); }
  uint32_t trace_begin() const { return at<3>().as_uint32(); }
};

class TracingMarkWriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TracingMarkWriteFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kTraceNameFieldNumber = 2,
    kTraceBeginFieldNumber = 3,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_trace_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_trace_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_trace_begin(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpSsppChangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpSsppChangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpSsppChangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpSsppChangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_mixer() const { return at<3>().valid(); }
  uint32_t mixer() const { return at<3>().as_uint32(); }
  bool has_stage() const { return at<4>().valid(); }
  uint32_t stage() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
  bool has_format() const { return at<6>().valid(); }
  uint32_t format() const { return at<6>().as_uint32(); }
  bool has_img_w() const { return at<7>().valid(); }
  uint32_t img_w() const { return at<7>().as_uint32(); }
  bool has_img_h() const { return at<8>().valid(); }
  uint32_t img_h() const { return at<8>().as_uint32(); }
  bool has_src_x() const { return at<9>().valid(); }
  uint32_t src_x() const { return at<9>().as_uint32(); }
  bool has_src_y() const { return at<10>().valid(); }
  uint32_t src_y() const { return at<10>().as_uint32(); }
  bool has_src_w() const { return at<11>().valid(); }
  uint32_t src_w() const { return at<11>().as_uint32(); }
  bool has_src_h() const { return at<12>().valid(); }
  uint32_t src_h() const { return at<12>().as_uint32(); }
  bool has_dst_x() const { return at<13>().valid(); }
  uint32_t dst_x() const { return at<13>().as_uint32(); }
  bool has_dst_y() const { return at<14>().valid(); }
  uint32_t dst_y() const { return at<14>().as_uint32(); }
  bool has_dst_w() const { return at<15>().valid(); }
  uint32_t dst_w() const { return at<15>().as_uint32(); }
  bool has_dst_h() const { return at<16>().valid(); }
  uint32_t dst_h() const { return at<16>().as_uint32(); }
};

class MdpSsppChangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpSsppChangeFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mixer(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_format(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_img_w(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_img_h(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_src_x(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_src_y(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_src_w(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_src_h(uint32_t value) {
    AppendVarInt(12, value);
  }
  void set_dst_x(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_dst_y(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_dst_w(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_dst_h(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class MdpPerfSetOtFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetOtFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetOtFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetOtFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_xin_id() const { return at<2>().valid(); }
  uint32_t xin_id() const { return at<2>().as_uint32(); }
  bool has_rd_lim() const { return at<3>().valid(); }
  uint32_t rd_lim() const { return at<3>().as_uint32(); }
  bool has_is_vbif_rt() const { return at<4>().valid(); }
  uint32_t is_vbif_rt() const { return at<4>().as_uint32(); }
};

class MdpPerfSetOtFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetOtFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kXinIdFieldNumber = 2,
    kRdLimFieldNumber = 3,
    kIsVbifRtFieldNumber = 4,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_xin_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_rd_lim(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_is_vbif_rt(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class MdpCommitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCommitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCommitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCommitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_clk_rate() const { return at<3>().valid(); }
  uint32_t clk_rate() const { return at<3>().as_uint32(); }
  bool has_bandwidth() const { return at<4>().valid(); }
  uint64_t bandwidth() const { return at<4>().as_uint64(); }
};

class MdpCommitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCommitFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kClkRateFieldNumber = 3,
    kBandwidthFieldNumber = 4,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_clk_rate(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_bandwidth(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MdpCmdKickoffFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdKickoffFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdKickoffFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdKickoffFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_kickoff_cnt() const { return at<2>().valid(); }
  int32_t kickoff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdKickoffFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdKickoffFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_kickoff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
