// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class MmVmscanKswapdSleepFtraceEvent;
class MmVmscanKswapdWakeFtraceEvent;
class MmVmscanDirectReclaimEndFtraceEvent;
class MmVmscanDirectReclaimBeginFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT MmVmscanKswapdSleepFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNidFieldNumber = 1,
  };

  MmVmscanKswapdSleepFtraceEvent();
  ~MmVmscanKswapdSleepFtraceEvent() override;
  MmVmscanKswapdSleepFtraceEvent(MmVmscanKswapdSleepFtraceEvent&&) noexcept;
  MmVmscanKswapdSleepFtraceEvent& operator=(MmVmscanKswapdSleepFtraceEvent&&);
  MmVmscanKswapdSleepFtraceEvent(const MmVmscanKswapdSleepFtraceEvent&);
  MmVmscanKswapdSleepFtraceEvent& operator=(const MmVmscanKswapdSleepFtraceEvent&);
  bool operator==(const MmVmscanKswapdSleepFtraceEvent&) const;
  bool operator!=(const MmVmscanKswapdSleepFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_nid() const { return _has_field_[1]; }
  int32_t nid() const { return nid_; }
  void set_nid(int32_t value) { nid_ = value; _has_field_.set(1); }

 private:
  int32_t nid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT MmVmscanKswapdWakeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
  };

  MmVmscanKswapdWakeFtraceEvent();
  ~MmVmscanKswapdWakeFtraceEvent() override;
  MmVmscanKswapdWakeFtraceEvent(MmVmscanKswapdWakeFtraceEvent&&) noexcept;
  MmVmscanKswapdWakeFtraceEvent& operator=(MmVmscanKswapdWakeFtraceEvent&&);
  MmVmscanKswapdWakeFtraceEvent(const MmVmscanKswapdWakeFtraceEvent&);
  MmVmscanKswapdWakeFtraceEvent& operator=(const MmVmscanKswapdWakeFtraceEvent&);
  bool operator==(const MmVmscanKswapdWakeFtraceEvent&) const;
  bool operator!=(const MmVmscanKswapdWakeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_nid() const { return _has_field_[1]; }
  int32_t nid() const { return nid_; }
  void set_nid(int32_t value) { nid_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  int32_t order() const { return order_; }
  void set_order(int32_t value) { order_ = value; _has_field_.set(2); }

 private:
  int32_t nid_{};
  int32_t order_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT MmVmscanDirectReclaimEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNrReclaimedFieldNumber = 1,
  };

  MmVmscanDirectReclaimEndFtraceEvent();
  ~MmVmscanDirectReclaimEndFtraceEvent() override;
  MmVmscanDirectReclaimEndFtraceEvent(MmVmscanDirectReclaimEndFtraceEvent&&) noexcept;
  MmVmscanDirectReclaimEndFtraceEvent& operator=(MmVmscanDirectReclaimEndFtraceEvent&&);
  MmVmscanDirectReclaimEndFtraceEvent(const MmVmscanDirectReclaimEndFtraceEvent&);
  MmVmscanDirectReclaimEndFtraceEvent& operator=(const MmVmscanDirectReclaimEndFtraceEvent&);
  bool operator==(const MmVmscanDirectReclaimEndFtraceEvent&) const;
  bool operator!=(const MmVmscanDirectReclaimEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_nr_reclaimed() const { return _has_field_[1]; }
  uint64_t nr_reclaimed() const { return nr_reclaimed_; }
  void set_nr_reclaimed(uint64_t value) { nr_reclaimed_ = value; _has_field_.set(1); }

 private:
  uint64_t nr_reclaimed_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT MmVmscanDirectReclaimBeginFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kOrderFieldNumber = 1,
    kMayWritepageFieldNumber = 2,
    kGfpFlagsFieldNumber = 3,
  };

  MmVmscanDirectReclaimBeginFtraceEvent();
  ~MmVmscanDirectReclaimBeginFtraceEvent() override;
  MmVmscanDirectReclaimBeginFtraceEvent(MmVmscanDirectReclaimBeginFtraceEvent&&) noexcept;
  MmVmscanDirectReclaimBeginFtraceEvent& operator=(MmVmscanDirectReclaimBeginFtraceEvent&&);
  MmVmscanDirectReclaimBeginFtraceEvent(const MmVmscanDirectReclaimBeginFtraceEvent&);
  MmVmscanDirectReclaimBeginFtraceEvent& operator=(const MmVmscanDirectReclaimBeginFtraceEvent&);
  bool operator==(const MmVmscanDirectReclaimBeginFtraceEvent&) const;
  bool operator!=(const MmVmscanDirectReclaimBeginFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_order() const { return _has_field_[1]; }
  int32_t order() const { return order_; }
  void set_order(int32_t value) { order_ = value; _has_field_.set(1); }

  bool has_may_writepage() const { return _has_field_[2]; }
  int32_t may_writepage() const { return may_writepage_; }
  void set_may_writepage(int32_t value) { may_writepage_ = value; _has_field_.set(2); }

  bool has_gfp_flags() const { return _has_field_[3]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(3); }

 private:
  int32_t order_{};
  int32_t may_writepage_{};
  uint32_t gfp_flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_CPP_H_
