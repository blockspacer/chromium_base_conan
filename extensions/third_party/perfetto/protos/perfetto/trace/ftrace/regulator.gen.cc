#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/regulator.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

RegulatorSetVoltageCompleteFtraceEvent::RegulatorSetVoltageCompleteFtraceEvent() = default;
RegulatorSetVoltageCompleteFtraceEvent::~RegulatorSetVoltageCompleteFtraceEvent() = default;
RegulatorSetVoltageCompleteFtraceEvent::RegulatorSetVoltageCompleteFtraceEvent(const RegulatorSetVoltageCompleteFtraceEvent&) = default;
RegulatorSetVoltageCompleteFtraceEvent& RegulatorSetVoltageCompleteFtraceEvent::operator=(const RegulatorSetVoltageCompleteFtraceEvent&) = default;
RegulatorSetVoltageCompleteFtraceEvent::RegulatorSetVoltageCompleteFtraceEvent(RegulatorSetVoltageCompleteFtraceEvent&&) noexcept = default;
RegulatorSetVoltageCompleteFtraceEvent& RegulatorSetVoltageCompleteFtraceEvent::operator=(RegulatorSetVoltageCompleteFtraceEvent&&) = default;

bool RegulatorSetVoltageCompleteFtraceEvent::operator==(const RegulatorSetVoltageCompleteFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_
   && val_ == other.val_;
}

bool RegulatorSetVoltageCompleteFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      case 2 /* val */:
        field.get(&val_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RegulatorSetVoltageCompleteFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RegulatorSetVoltageCompleteFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RegulatorSetVoltageCompleteFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  // Field 2: val
  if (_has_field_[2]) {
    msg->AppendVarInt(2, val_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


RegulatorSetVoltageFtraceEvent::RegulatorSetVoltageFtraceEvent() = default;
RegulatorSetVoltageFtraceEvent::~RegulatorSetVoltageFtraceEvent() = default;
RegulatorSetVoltageFtraceEvent::RegulatorSetVoltageFtraceEvent(const RegulatorSetVoltageFtraceEvent&) = default;
RegulatorSetVoltageFtraceEvent& RegulatorSetVoltageFtraceEvent::operator=(const RegulatorSetVoltageFtraceEvent&) = default;
RegulatorSetVoltageFtraceEvent::RegulatorSetVoltageFtraceEvent(RegulatorSetVoltageFtraceEvent&&) noexcept = default;
RegulatorSetVoltageFtraceEvent& RegulatorSetVoltageFtraceEvent::operator=(RegulatorSetVoltageFtraceEvent&&) = default;

bool RegulatorSetVoltageFtraceEvent::operator==(const RegulatorSetVoltageFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_
   && min_ == other.min_
   && max_ == other.max_;
}

bool RegulatorSetVoltageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      case 2 /* min */:
        field.get(&min_);
        break;
      case 3 /* max */:
        field.get(&max_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RegulatorSetVoltageFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RegulatorSetVoltageFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RegulatorSetVoltageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  // Field 2: min
  if (_has_field_[2]) {
    msg->AppendVarInt(2, min_);
  }

  // Field 3: max
  if (_has_field_[3]) {
    msg->AppendVarInt(3, max_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


RegulatorEnableDelayFtraceEvent::RegulatorEnableDelayFtraceEvent() = default;
RegulatorEnableDelayFtraceEvent::~RegulatorEnableDelayFtraceEvent() = default;
RegulatorEnableDelayFtraceEvent::RegulatorEnableDelayFtraceEvent(const RegulatorEnableDelayFtraceEvent&) = default;
RegulatorEnableDelayFtraceEvent& RegulatorEnableDelayFtraceEvent::operator=(const RegulatorEnableDelayFtraceEvent&) = default;
RegulatorEnableDelayFtraceEvent::RegulatorEnableDelayFtraceEvent(RegulatorEnableDelayFtraceEvent&&) noexcept = default;
RegulatorEnableDelayFtraceEvent& RegulatorEnableDelayFtraceEvent::operator=(RegulatorEnableDelayFtraceEvent&&) = default;

bool RegulatorEnableDelayFtraceEvent::operator==(const RegulatorEnableDelayFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_;
}

bool RegulatorEnableDelayFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RegulatorEnableDelayFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RegulatorEnableDelayFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RegulatorEnableDelayFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


RegulatorEnableCompleteFtraceEvent::RegulatorEnableCompleteFtraceEvent() = default;
RegulatorEnableCompleteFtraceEvent::~RegulatorEnableCompleteFtraceEvent() = default;
RegulatorEnableCompleteFtraceEvent::RegulatorEnableCompleteFtraceEvent(const RegulatorEnableCompleteFtraceEvent&) = default;
RegulatorEnableCompleteFtraceEvent& RegulatorEnableCompleteFtraceEvent::operator=(const RegulatorEnableCompleteFtraceEvent&) = default;
RegulatorEnableCompleteFtraceEvent::RegulatorEnableCompleteFtraceEvent(RegulatorEnableCompleteFtraceEvent&&) noexcept = default;
RegulatorEnableCompleteFtraceEvent& RegulatorEnableCompleteFtraceEvent::operator=(RegulatorEnableCompleteFtraceEvent&&) = default;

bool RegulatorEnableCompleteFtraceEvent::operator==(const RegulatorEnableCompleteFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_;
}

bool RegulatorEnableCompleteFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RegulatorEnableCompleteFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RegulatorEnableCompleteFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RegulatorEnableCompleteFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


RegulatorEnableFtraceEvent::RegulatorEnableFtraceEvent() = default;
RegulatorEnableFtraceEvent::~RegulatorEnableFtraceEvent() = default;
RegulatorEnableFtraceEvent::RegulatorEnableFtraceEvent(const RegulatorEnableFtraceEvent&) = default;
RegulatorEnableFtraceEvent& RegulatorEnableFtraceEvent::operator=(const RegulatorEnableFtraceEvent&) = default;
RegulatorEnableFtraceEvent::RegulatorEnableFtraceEvent(RegulatorEnableFtraceEvent&&) noexcept = default;
RegulatorEnableFtraceEvent& RegulatorEnableFtraceEvent::operator=(RegulatorEnableFtraceEvent&&) = default;

bool RegulatorEnableFtraceEvent::operator==(const RegulatorEnableFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_;
}

bool RegulatorEnableFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RegulatorEnableFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RegulatorEnableFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RegulatorEnableFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


RegulatorDisableCompleteFtraceEvent::RegulatorDisableCompleteFtraceEvent() = default;
RegulatorDisableCompleteFtraceEvent::~RegulatorDisableCompleteFtraceEvent() = default;
RegulatorDisableCompleteFtraceEvent::RegulatorDisableCompleteFtraceEvent(const RegulatorDisableCompleteFtraceEvent&) = default;
RegulatorDisableCompleteFtraceEvent& RegulatorDisableCompleteFtraceEvent::operator=(const RegulatorDisableCompleteFtraceEvent&) = default;
RegulatorDisableCompleteFtraceEvent::RegulatorDisableCompleteFtraceEvent(RegulatorDisableCompleteFtraceEvent&&) noexcept = default;
RegulatorDisableCompleteFtraceEvent& RegulatorDisableCompleteFtraceEvent::operator=(RegulatorDisableCompleteFtraceEvent&&) = default;

bool RegulatorDisableCompleteFtraceEvent::operator==(const RegulatorDisableCompleteFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_;
}

bool RegulatorDisableCompleteFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RegulatorDisableCompleteFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RegulatorDisableCompleteFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RegulatorDisableCompleteFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


RegulatorDisableFtraceEvent::RegulatorDisableFtraceEvent() = default;
RegulatorDisableFtraceEvent::~RegulatorDisableFtraceEvent() = default;
RegulatorDisableFtraceEvent::RegulatorDisableFtraceEvent(const RegulatorDisableFtraceEvent&) = default;
RegulatorDisableFtraceEvent& RegulatorDisableFtraceEvent::operator=(const RegulatorDisableFtraceEvent&) = default;
RegulatorDisableFtraceEvent::RegulatorDisableFtraceEvent(RegulatorDisableFtraceEvent&&) noexcept = default;
RegulatorDisableFtraceEvent& RegulatorDisableFtraceEvent::operator=(RegulatorDisableFtraceEvent&&) = default;

bool RegulatorDisableFtraceEvent::operator==(const RegulatorDisableFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_;
}

bool RegulatorDisableFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RegulatorDisableFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RegulatorDisableFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RegulatorDisableFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
