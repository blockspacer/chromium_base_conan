#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/ext4.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent() = default;
Ext4ZeroRangeFtraceEvent::~Ext4ZeroRangeFtraceEvent() = default;
Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(const Ext4ZeroRangeFtraceEvent&) = default;
Ext4ZeroRangeFtraceEvent& Ext4ZeroRangeFtraceEvent::operator=(const Ext4ZeroRangeFtraceEvent&) = default;
Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(Ext4ZeroRangeFtraceEvent&&) noexcept = default;
Ext4ZeroRangeFtraceEvent& Ext4ZeroRangeFtraceEvent::operator=(Ext4ZeroRangeFtraceEvent&&) = default;

bool Ext4ZeroRangeFtraceEvent::operator==(const Ext4ZeroRangeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && offset_ == other.offset_
   && len_ == other.len_
   && mode_ == other.mode_;
}

bool Ext4ZeroRangeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* offset */:
        field.get(&offset_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ZeroRangeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ZeroRangeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ZeroRangeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, offset_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: mode
  if (_has_field_[5]) {
    msg->AppendVarInt(5, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent() = default;
Ext4WritepagesResultFtraceEvent::~Ext4WritepagesResultFtraceEvent() = default;
Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(const Ext4WritepagesResultFtraceEvent&) = default;
Ext4WritepagesResultFtraceEvent& Ext4WritepagesResultFtraceEvent::operator=(const Ext4WritepagesResultFtraceEvent&) = default;
Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(Ext4WritepagesResultFtraceEvent&&) noexcept = default;
Ext4WritepagesResultFtraceEvent& Ext4WritepagesResultFtraceEvent::operator=(Ext4WritepagesResultFtraceEvent&&) = default;

bool Ext4WritepagesResultFtraceEvent::operator==(const Ext4WritepagesResultFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_
   && pages_written_ == other.pages_written_
   && pages_skipped_ == other.pages_skipped_
   && writeback_index_ == other.writeback_index_
   && sync_mode_ == other.sync_mode_;
}

bool Ext4WritepagesResultFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      case 4 /* pages_written */:
        field.get(&pages_written_);
        break;
      case 5 /* pages_skipped */:
        field.get(&pages_skipped_);
        break;
      case 6 /* writeback_index */:
        field.get(&writeback_index_);
        break;
      case 7 /* sync_mode */:
        field.get(&sync_mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4WritepagesResultFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4WritepagesResultFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4WritepagesResultFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  // Field 4: pages_written
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pages_written_);
  }

  // Field 5: pages_skipped
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pages_skipped_);
  }

  // Field 6: writeback_index
  if (_has_field_[6]) {
    msg->AppendVarInt(6, writeback_index_);
  }

  // Field 7: sync_mode
  if (_has_field_[7]) {
    msg->AppendVarInt(7, sync_mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent() = default;
Ext4WritepagesFtraceEvent::~Ext4WritepagesFtraceEvent() = default;
Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(const Ext4WritepagesFtraceEvent&) = default;
Ext4WritepagesFtraceEvent& Ext4WritepagesFtraceEvent::operator=(const Ext4WritepagesFtraceEvent&) = default;
Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(Ext4WritepagesFtraceEvent&&) noexcept = default;
Ext4WritepagesFtraceEvent& Ext4WritepagesFtraceEvent::operator=(Ext4WritepagesFtraceEvent&&) = default;

bool Ext4WritepagesFtraceEvent::operator==(const Ext4WritepagesFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && nr_to_write_ == other.nr_to_write_
   && pages_skipped_ == other.pages_skipped_
   && range_start_ == other.range_start_
   && range_end_ == other.range_end_
   && writeback_index_ == other.writeback_index_
   && sync_mode_ == other.sync_mode_
   && for_kupdate_ == other.for_kupdate_
   && range_cyclic_ == other.range_cyclic_;
}

bool Ext4WritepagesFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* nr_to_write */:
        field.get(&nr_to_write_);
        break;
      case 4 /* pages_skipped */:
        field.get(&pages_skipped_);
        break;
      case 5 /* range_start */:
        field.get(&range_start_);
        break;
      case 6 /* range_end */:
        field.get(&range_end_);
        break;
      case 7 /* writeback_index */:
        field.get(&writeback_index_);
        break;
      case 8 /* sync_mode */:
        field.get(&sync_mode_);
        break;
      case 9 /* for_kupdate */:
        field.get(&for_kupdate_);
        break;
      case 10 /* range_cyclic */:
        field.get(&range_cyclic_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4WritepagesFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4WritepagesFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4WritepagesFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: nr_to_write
  if (_has_field_[3]) {
    msg->AppendVarInt(3, nr_to_write_);
  }

  // Field 4: pages_skipped
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pages_skipped_);
  }

  // Field 5: range_start
  if (_has_field_[5]) {
    msg->AppendVarInt(5, range_start_);
  }

  // Field 6: range_end
  if (_has_field_[6]) {
    msg->AppendVarInt(6, range_end_);
  }

  // Field 7: writeback_index
  if (_has_field_[7]) {
    msg->AppendVarInt(7, writeback_index_);
  }

  // Field 8: sync_mode
  if (_has_field_[8]) {
    msg->AppendVarInt(8, sync_mode_);
  }

  // Field 9: for_kupdate
  if (_has_field_[9]) {
    msg->AppendVarInt(9, for_kupdate_);
  }

  // Field 10: range_cyclic
  if (_has_field_[10]) {
    msg->AppendVarInt(10, range_cyclic_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent() = default;
Ext4WritepageFtraceEvent::~Ext4WritepageFtraceEvent() = default;
Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(const Ext4WritepageFtraceEvent&) = default;
Ext4WritepageFtraceEvent& Ext4WritepageFtraceEvent::operator=(const Ext4WritepageFtraceEvent&) = default;
Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(Ext4WritepageFtraceEvent&&) noexcept = default;
Ext4WritepageFtraceEvent& Ext4WritepageFtraceEvent::operator=(Ext4WritepageFtraceEvent&&) = default;

bool Ext4WritepageFtraceEvent::operator==(const Ext4WritepageFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && index_ == other.index_;
}

bool Ext4WritepageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* index */:
        field.get(&index_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4WritepageFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4WritepageFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4WritepageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: index
  if (_has_field_[3]) {
    msg->AppendVarInt(3, index_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent() = default;
Ext4WriteEndFtraceEvent::~Ext4WriteEndFtraceEvent() = default;
Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(const Ext4WriteEndFtraceEvent&) = default;
Ext4WriteEndFtraceEvent& Ext4WriteEndFtraceEvent::operator=(const Ext4WriteEndFtraceEvent&) = default;
Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(Ext4WriteEndFtraceEvent&&) noexcept = default;
Ext4WriteEndFtraceEvent& Ext4WriteEndFtraceEvent::operator=(Ext4WriteEndFtraceEvent&&) = default;

bool Ext4WriteEndFtraceEvent::operator==(const Ext4WriteEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && copied_ == other.copied_;
}

bool Ext4WriteEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* copied */:
        field.get(&copied_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4WriteEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4WriteEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4WriteEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: copied
  if (_has_field_[5]) {
    msg->AppendVarInt(5, copied_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent() = default;
Ext4WriteBeginFtraceEvent::~Ext4WriteBeginFtraceEvent() = default;
Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(const Ext4WriteBeginFtraceEvent&) = default;
Ext4WriteBeginFtraceEvent& Ext4WriteBeginFtraceEvent::operator=(const Ext4WriteBeginFtraceEvent&) = default;
Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(Ext4WriteBeginFtraceEvent&&) noexcept = default;
Ext4WriteBeginFtraceEvent& Ext4WriteBeginFtraceEvent::operator=(Ext4WriteBeginFtraceEvent&&) = default;

bool Ext4WriteBeginFtraceEvent::operator==(const Ext4WriteBeginFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && flags_ == other.flags_;
}

bool Ext4WriteBeginFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4WriteBeginFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4WriteBeginFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4WriteBeginFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent() = default;
Ext4UnlinkExitFtraceEvent::~Ext4UnlinkExitFtraceEvent() = default;
Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(const Ext4UnlinkExitFtraceEvent&) = default;
Ext4UnlinkExitFtraceEvent& Ext4UnlinkExitFtraceEvent::operator=(const Ext4UnlinkExitFtraceEvent&) = default;
Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(Ext4UnlinkExitFtraceEvent&&) noexcept = default;
Ext4UnlinkExitFtraceEvent& Ext4UnlinkExitFtraceEvent::operator=(Ext4UnlinkExitFtraceEvent&&) = default;

bool Ext4UnlinkExitFtraceEvent::operator==(const Ext4UnlinkExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_;
}

bool Ext4UnlinkExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4UnlinkExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4UnlinkExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4UnlinkExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent() = default;
Ext4UnlinkEnterFtraceEvent::~Ext4UnlinkEnterFtraceEvent() = default;
Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(const Ext4UnlinkEnterFtraceEvent&) = default;
Ext4UnlinkEnterFtraceEvent& Ext4UnlinkEnterFtraceEvent::operator=(const Ext4UnlinkEnterFtraceEvent&) = default;
Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(Ext4UnlinkEnterFtraceEvent&&) noexcept = default;
Ext4UnlinkEnterFtraceEvent& Ext4UnlinkEnterFtraceEvent::operator=(Ext4UnlinkEnterFtraceEvent&&) = default;

bool Ext4UnlinkEnterFtraceEvent::operator==(const Ext4UnlinkEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && parent_ == other.parent_
   && size_ == other.size_;
}

bool Ext4UnlinkEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* parent */:
        field.get(&parent_);
        break;
      case 4 /* size */:
        field.get(&size_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4UnlinkEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4UnlinkEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4UnlinkEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: parent
  if (_has_field_[3]) {
    msg->AppendVarInt(3, parent_);
  }

  // Field 4: size
  if (_has_field_[4]) {
    msg->AppendVarInt(4, size_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent() = default;
Ext4TruncateExitFtraceEvent::~Ext4TruncateExitFtraceEvent() = default;
Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(const Ext4TruncateExitFtraceEvent&) = default;
Ext4TruncateExitFtraceEvent& Ext4TruncateExitFtraceEvent::operator=(const Ext4TruncateExitFtraceEvent&) = default;
Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(Ext4TruncateExitFtraceEvent&&) noexcept = default;
Ext4TruncateExitFtraceEvent& Ext4TruncateExitFtraceEvent::operator=(Ext4TruncateExitFtraceEvent&&) = default;

bool Ext4TruncateExitFtraceEvent::operator==(const Ext4TruncateExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && blocks_ == other.blocks_;
}

bool Ext4TruncateExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* blocks */:
        field.get(&blocks_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4TruncateExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4TruncateExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4TruncateExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: blocks
  if (_has_field_[3]) {
    msg->AppendVarInt(3, blocks_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent() = default;
Ext4TruncateEnterFtraceEvent::~Ext4TruncateEnterFtraceEvent() = default;
Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(const Ext4TruncateEnterFtraceEvent&) = default;
Ext4TruncateEnterFtraceEvent& Ext4TruncateEnterFtraceEvent::operator=(const Ext4TruncateEnterFtraceEvent&) = default;
Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(Ext4TruncateEnterFtraceEvent&&) noexcept = default;
Ext4TruncateEnterFtraceEvent& Ext4TruncateEnterFtraceEvent::operator=(Ext4TruncateEnterFtraceEvent&&) = default;

bool Ext4TruncateEnterFtraceEvent::operator==(const Ext4TruncateEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && blocks_ == other.blocks_;
}

bool Ext4TruncateEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* blocks */:
        field.get(&blocks_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4TruncateEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4TruncateEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4TruncateEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: blocks
  if (_has_field_[3]) {
    msg->AppendVarInt(3, blocks_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent() = default;
Ext4TrimExtentFtraceEvent::~Ext4TrimExtentFtraceEvent() = default;
Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(const Ext4TrimExtentFtraceEvent&) = default;
Ext4TrimExtentFtraceEvent& Ext4TrimExtentFtraceEvent::operator=(const Ext4TrimExtentFtraceEvent&) = default;
Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(Ext4TrimExtentFtraceEvent&&) noexcept = default;
Ext4TrimExtentFtraceEvent& Ext4TrimExtentFtraceEvent::operator=(Ext4TrimExtentFtraceEvent&&) = default;

bool Ext4TrimExtentFtraceEvent::operator==(const Ext4TrimExtentFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_major_ == other.dev_major_
   && dev_minor_ == other.dev_minor_
   && group_ == other.group_
   && start_ == other.start_
   && len_ == other.len_;
}

bool Ext4TrimExtentFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev_major */:
        field.get(&dev_major_);
        break;
      case 2 /* dev_minor */:
        field.get(&dev_minor_);
        break;
      case 3 /* group */:
        field.get(&group_);
        break;
      case 4 /* start */:
        field.get(&start_);
        break;
      case 5 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4TrimExtentFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4TrimExtentFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4TrimExtentFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev_major
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_major_);
  }

  // Field 2: dev_minor
  if (_has_field_[2]) {
    msg->AppendVarInt(2, dev_minor_);
  }

  // Field 3: group
  if (_has_field_[3]) {
    msg->AppendVarInt(3, group_);
  }

  // Field 4: start
  if (_has_field_[4]) {
    msg->AppendVarInt(4, start_);
  }

  // Field 5: len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent() = default;
Ext4TrimAllFreeFtraceEvent::~Ext4TrimAllFreeFtraceEvent() = default;
Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(const Ext4TrimAllFreeFtraceEvent&) = default;
Ext4TrimAllFreeFtraceEvent& Ext4TrimAllFreeFtraceEvent::operator=(const Ext4TrimAllFreeFtraceEvent&) = default;
Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(Ext4TrimAllFreeFtraceEvent&&) noexcept = default;
Ext4TrimAllFreeFtraceEvent& Ext4TrimAllFreeFtraceEvent::operator=(Ext4TrimAllFreeFtraceEvent&&) = default;

bool Ext4TrimAllFreeFtraceEvent::operator==(const Ext4TrimAllFreeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_major_ == other.dev_major_
   && dev_minor_ == other.dev_minor_
   && group_ == other.group_
   && start_ == other.start_
   && len_ == other.len_;
}

bool Ext4TrimAllFreeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev_major */:
        field.get(&dev_major_);
        break;
      case 2 /* dev_minor */:
        field.get(&dev_minor_);
        break;
      case 3 /* group */:
        field.get(&group_);
        break;
      case 4 /* start */:
        field.get(&start_);
        break;
      case 5 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4TrimAllFreeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4TrimAllFreeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4TrimAllFreeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev_major
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_major_);
  }

  // Field 2: dev_minor
  if (_has_field_[2]) {
    msg->AppendVarInt(2, dev_minor_);
  }

  // Field 3: group
  if (_has_field_[3]) {
    msg->AppendVarInt(3, group_);
  }

  // Field 4: start
  if (_has_field_[4]) {
    msg->AppendVarInt(4, start_);
  }

  // Field 5: len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent() = default;
Ext4SyncFsFtraceEvent::~Ext4SyncFsFtraceEvent() = default;
Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(const Ext4SyncFsFtraceEvent&) = default;
Ext4SyncFsFtraceEvent& Ext4SyncFsFtraceEvent::operator=(const Ext4SyncFsFtraceEvent&) = default;
Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(Ext4SyncFsFtraceEvent&&) noexcept = default;
Ext4SyncFsFtraceEvent& Ext4SyncFsFtraceEvent::operator=(Ext4SyncFsFtraceEvent&&) = default;

bool Ext4SyncFsFtraceEvent::operator==(const Ext4SyncFsFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && wait_ == other.wait_;
}

bool Ext4SyncFsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* wait */:
        field.get(&wait_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4SyncFsFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4SyncFsFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4SyncFsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: wait
  if (_has_field_[2]) {
    msg->AppendVarInt(2, wait_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent() = default;
Ext4RequestInodeFtraceEvent::~Ext4RequestInodeFtraceEvent() = default;
Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(const Ext4RequestInodeFtraceEvent&) = default;
Ext4RequestInodeFtraceEvent& Ext4RequestInodeFtraceEvent::operator=(const Ext4RequestInodeFtraceEvent&) = default;
Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(Ext4RequestInodeFtraceEvent&&) noexcept = default;
Ext4RequestInodeFtraceEvent& Ext4RequestInodeFtraceEvent::operator=(Ext4RequestInodeFtraceEvent&&) = default;

bool Ext4RequestInodeFtraceEvent::operator==(const Ext4RequestInodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && dir_ == other.dir_
   && mode_ == other.mode_;
}

bool Ext4RequestInodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* dir */:
        field.get(&dir_);
        break;
      case 3 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4RequestInodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4RequestInodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4RequestInodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: dir
  if (_has_field_[2]) {
    msg->AppendVarInt(2, dir_);
  }

  // Field 3: mode
  if (_has_field_[3]) {
    msg->AppendVarInt(3, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent() = default;
Ext4RequestBlocksFtraceEvent::~Ext4RequestBlocksFtraceEvent() = default;
Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(const Ext4RequestBlocksFtraceEvent&) = default;
Ext4RequestBlocksFtraceEvent& Ext4RequestBlocksFtraceEvent::operator=(const Ext4RequestBlocksFtraceEvent&) = default;
Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(Ext4RequestBlocksFtraceEvent&&) noexcept = default;
Ext4RequestBlocksFtraceEvent& Ext4RequestBlocksFtraceEvent::operator=(Ext4RequestBlocksFtraceEvent&&) = default;

bool Ext4RequestBlocksFtraceEvent::operator==(const Ext4RequestBlocksFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && len_ == other.len_
   && logical_ == other.logical_
   && lleft_ == other.lleft_
   && lright_ == other.lright_
   && goal_ == other.goal_
   && pleft_ == other.pleft_
   && pright_ == other.pright_
   && flags_ == other.flags_;
}

bool Ext4RequestBlocksFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* len */:
        field.get(&len_);
        break;
      case 4 /* logical */:
        field.get(&logical_);
        break;
      case 5 /* lleft */:
        field.get(&lleft_);
        break;
      case 6 /* lright */:
        field.get(&lright_);
        break;
      case 7 /* goal */:
        field.get(&goal_);
        break;
      case 8 /* pleft */:
        field.get(&pleft_);
        break;
      case 9 /* pright */:
        field.get(&pright_);
        break;
      case 10 /* flags */:
        field.get(&flags_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4RequestBlocksFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4RequestBlocksFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4RequestBlocksFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: len
  if (_has_field_[3]) {
    msg->AppendVarInt(3, len_);
  }

  // Field 4: logical
  if (_has_field_[4]) {
    msg->AppendVarInt(4, logical_);
  }

  // Field 5: lleft
  if (_has_field_[5]) {
    msg->AppendVarInt(5, lleft_);
  }

  // Field 6: lright
  if (_has_field_[6]) {
    msg->AppendVarInt(6, lright_);
  }

  // Field 7: goal
  if (_has_field_[7]) {
    msg->AppendVarInt(7, goal_);
  }

  // Field 8: pleft
  if (_has_field_[8]) {
    msg->AppendVarInt(8, pleft_);
  }

  // Field 9: pright
  if (_has_field_[9]) {
    msg->AppendVarInt(9, pright_);
  }

  // Field 10: flags
  if (_has_field_[10]) {
    msg->AppendVarInt(10, flags_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent() = default;
Ext4RemoveBlocksFtraceEvent::~Ext4RemoveBlocksFtraceEvent() = default;
Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(const Ext4RemoveBlocksFtraceEvent&) = default;
Ext4RemoveBlocksFtraceEvent& Ext4RemoveBlocksFtraceEvent::operator=(const Ext4RemoveBlocksFtraceEvent&) = default;
Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(Ext4RemoveBlocksFtraceEvent&&) noexcept = default;
Ext4RemoveBlocksFtraceEvent& Ext4RemoveBlocksFtraceEvent::operator=(Ext4RemoveBlocksFtraceEvent&&) = default;

bool Ext4RemoveBlocksFtraceEvent::operator==(const Ext4RemoveBlocksFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && from_ == other.from_
   && to_ == other.to_
   && partial_ == other.partial_
   && ee_pblk_ == other.ee_pblk_
   && ee_lblk_ == other.ee_lblk_
   && ee_len_ == other.ee_len_;
}

bool Ext4RemoveBlocksFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* from */:
        field.get(&from_);
        break;
      case 4 /* to */:
        field.get(&to_);
        break;
      case 5 /* partial */:
        field.get(&partial_);
        break;
      case 6 /* ee_pblk */:
        field.get(&ee_pblk_);
        break;
      case 7 /* ee_lblk */:
        field.get(&ee_lblk_);
        break;
      case 8 /* ee_len */:
        field.get(&ee_len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4RemoveBlocksFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4RemoveBlocksFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4RemoveBlocksFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: from
  if (_has_field_[3]) {
    msg->AppendVarInt(3, from_);
  }

  // Field 4: to
  if (_has_field_[4]) {
    msg->AppendVarInt(4, to_);
  }

  // Field 5: partial
  if (_has_field_[5]) {
    msg->AppendVarInt(5, partial_);
  }

  // Field 6: ee_pblk
  if (_has_field_[6]) {
    msg->AppendVarInt(6, ee_pblk_);
  }

  // Field 7: ee_lblk
  if (_has_field_[7]) {
    msg->AppendVarInt(7, ee_lblk_);
  }

  // Field 8: ee_len
  if (_has_field_[8]) {
    msg->AppendVarInt(8, ee_len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent() = default;
Ext4ReleasepageFtraceEvent::~Ext4ReleasepageFtraceEvent() = default;
Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(const Ext4ReleasepageFtraceEvent&) = default;
Ext4ReleasepageFtraceEvent& Ext4ReleasepageFtraceEvent::operator=(const Ext4ReleasepageFtraceEvent&) = default;
Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(Ext4ReleasepageFtraceEvent&&) noexcept = default;
Ext4ReleasepageFtraceEvent& Ext4ReleasepageFtraceEvent::operator=(Ext4ReleasepageFtraceEvent&&) = default;

bool Ext4ReleasepageFtraceEvent::operator==(const Ext4ReleasepageFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && index_ == other.index_;
}

bool Ext4ReleasepageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* index */:
        field.get(&index_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ReleasepageFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ReleasepageFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ReleasepageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: index
  if (_has_field_[3]) {
    msg->AppendVarInt(3, index_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent() = default;
Ext4ReadpageFtraceEvent::~Ext4ReadpageFtraceEvent() = default;
Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(const Ext4ReadpageFtraceEvent&) = default;
Ext4ReadpageFtraceEvent& Ext4ReadpageFtraceEvent::operator=(const Ext4ReadpageFtraceEvent&) = default;
Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(Ext4ReadpageFtraceEvent&&) noexcept = default;
Ext4ReadpageFtraceEvent& Ext4ReadpageFtraceEvent::operator=(Ext4ReadpageFtraceEvent&&) = default;

bool Ext4ReadpageFtraceEvent::operator==(const Ext4ReadpageFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && index_ == other.index_;
}

bool Ext4ReadpageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* index */:
        field.get(&index_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ReadpageFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ReadpageFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ReadpageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: index
  if (_has_field_[3]) {
    msg->AppendVarInt(3, index_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent() = default;
Ext4ReadBlockBitmapLoadFtraceEvent::~Ext4ReadBlockBitmapLoadFtraceEvent() = default;
Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(const Ext4ReadBlockBitmapLoadFtraceEvent&) = default;
Ext4ReadBlockBitmapLoadFtraceEvent& Ext4ReadBlockBitmapLoadFtraceEvent::operator=(const Ext4ReadBlockBitmapLoadFtraceEvent&) = default;
Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(Ext4ReadBlockBitmapLoadFtraceEvent&&) noexcept = default;
Ext4ReadBlockBitmapLoadFtraceEvent& Ext4ReadBlockBitmapLoadFtraceEvent::operator=(Ext4ReadBlockBitmapLoadFtraceEvent&&) = default;

bool Ext4ReadBlockBitmapLoadFtraceEvent::operator==(const Ext4ReadBlockBitmapLoadFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && group_ == other.group_;
}

bool Ext4ReadBlockBitmapLoadFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* group */:
        field.get(&group_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ReadBlockBitmapLoadFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ReadBlockBitmapLoadFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ReadBlockBitmapLoadFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: group
  if (_has_field_[2]) {
    msg->AppendVarInt(2, group_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent() = default;
Ext4PunchHoleFtraceEvent::~Ext4PunchHoleFtraceEvent() = default;
Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(const Ext4PunchHoleFtraceEvent&) = default;
Ext4PunchHoleFtraceEvent& Ext4PunchHoleFtraceEvent::operator=(const Ext4PunchHoleFtraceEvent&) = default;
Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(Ext4PunchHoleFtraceEvent&&) noexcept = default;
Ext4PunchHoleFtraceEvent& Ext4PunchHoleFtraceEvent::operator=(Ext4PunchHoleFtraceEvent&&) = default;

bool Ext4PunchHoleFtraceEvent::operator==(const Ext4PunchHoleFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && offset_ == other.offset_
   && len_ == other.len_
   && mode_ == other.mode_;
}

bool Ext4PunchHoleFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* offset */:
        field.get(&offset_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4PunchHoleFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4PunchHoleFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4PunchHoleFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, offset_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: mode
  if (_has_field_[5]) {
    msg->AppendVarInt(5, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent() = default;
Ext4OtherInodeUpdateTimeFtraceEvent::~Ext4OtherInodeUpdateTimeFtraceEvent() = default;
Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(const Ext4OtherInodeUpdateTimeFtraceEvent&) = default;
Ext4OtherInodeUpdateTimeFtraceEvent& Ext4OtherInodeUpdateTimeFtraceEvent::operator=(const Ext4OtherInodeUpdateTimeFtraceEvent&) = default;
Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(Ext4OtherInodeUpdateTimeFtraceEvent&&) noexcept = default;
Ext4OtherInodeUpdateTimeFtraceEvent& Ext4OtherInodeUpdateTimeFtraceEvent::operator=(Ext4OtherInodeUpdateTimeFtraceEvent&&) = default;

bool Ext4OtherInodeUpdateTimeFtraceEvent::operator==(const Ext4OtherInodeUpdateTimeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && orig_ino_ == other.orig_ino_
   && uid_ == other.uid_
   && gid_ == other.gid_
   && mode_ == other.mode_;
}

bool Ext4OtherInodeUpdateTimeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* orig_ino */:
        field.get(&orig_ino_);
        break;
      case 4 /* uid */:
        field.get(&uid_);
        break;
      case 5 /* gid */:
        field.get(&gid_);
        break;
      case 6 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4OtherInodeUpdateTimeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4OtherInodeUpdateTimeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4OtherInodeUpdateTimeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: orig_ino
  if (_has_field_[3]) {
    msg->AppendVarInt(3, orig_ino_);
  }

  // Field 4: uid
  if (_has_field_[4]) {
    msg->AppendVarInt(4, uid_);
  }

  // Field 5: gid
  if (_has_field_[5]) {
    msg->AppendVarInt(5, gid_);
  }

  // Field 6: mode
  if (_has_field_[6]) {
    msg->AppendVarInt(6, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent() = default;
Ext4MballocPreallocFtraceEvent::~Ext4MballocPreallocFtraceEvent() = default;
Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(const Ext4MballocPreallocFtraceEvent&) = default;
Ext4MballocPreallocFtraceEvent& Ext4MballocPreallocFtraceEvent::operator=(const Ext4MballocPreallocFtraceEvent&) = default;
Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(Ext4MballocPreallocFtraceEvent&&) noexcept = default;
Ext4MballocPreallocFtraceEvent& Ext4MballocPreallocFtraceEvent::operator=(Ext4MballocPreallocFtraceEvent&&) = default;

bool Ext4MballocPreallocFtraceEvent::operator==(const Ext4MballocPreallocFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && orig_logical_ == other.orig_logical_
   && orig_start_ == other.orig_start_
   && orig_group_ == other.orig_group_
   && orig_len_ == other.orig_len_
   && result_logical_ == other.result_logical_
   && result_start_ == other.result_start_
   && result_group_ == other.result_group_
   && result_len_ == other.result_len_;
}

bool Ext4MballocPreallocFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* orig_logical */:
        field.get(&orig_logical_);
        break;
      case 4 /* orig_start */:
        field.get(&orig_start_);
        break;
      case 5 /* orig_group */:
        field.get(&orig_group_);
        break;
      case 6 /* orig_len */:
        field.get(&orig_len_);
        break;
      case 7 /* result_logical */:
        field.get(&result_logical_);
        break;
      case 8 /* result_start */:
        field.get(&result_start_);
        break;
      case 9 /* result_group */:
        field.get(&result_group_);
        break;
      case 10 /* result_len */:
        field.get(&result_len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MballocPreallocFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MballocPreallocFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MballocPreallocFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: orig_logical
  if (_has_field_[3]) {
    msg->AppendVarInt(3, orig_logical_);
  }

  // Field 4: orig_start
  if (_has_field_[4]) {
    msg->AppendVarInt(4, orig_start_);
  }

  // Field 5: orig_group
  if (_has_field_[5]) {
    msg->AppendVarInt(5, orig_group_);
  }

  // Field 6: orig_len
  if (_has_field_[6]) {
    msg->AppendVarInt(6, orig_len_);
  }

  // Field 7: result_logical
  if (_has_field_[7]) {
    msg->AppendVarInt(7, result_logical_);
  }

  // Field 8: result_start
  if (_has_field_[8]) {
    msg->AppendVarInt(8, result_start_);
  }

  // Field 9: result_group
  if (_has_field_[9]) {
    msg->AppendVarInt(9, result_group_);
  }

  // Field 10: result_len
  if (_has_field_[10]) {
    msg->AppendVarInt(10, result_len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent() = default;
Ext4MballocFreeFtraceEvent::~Ext4MballocFreeFtraceEvent() = default;
Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(const Ext4MballocFreeFtraceEvent&) = default;
Ext4MballocFreeFtraceEvent& Ext4MballocFreeFtraceEvent::operator=(const Ext4MballocFreeFtraceEvent&) = default;
Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(Ext4MballocFreeFtraceEvent&&) noexcept = default;
Ext4MballocFreeFtraceEvent& Ext4MballocFreeFtraceEvent::operator=(Ext4MballocFreeFtraceEvent&&) = default;

bool Ext4MballocFreeFtraceEvent::operator==(const Ext4MballocFreeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && result_start_ == other.result_start_
   && result_group_ == other.result_group_
   && result_len_ == other.result_len_;
}

bool Ext4MballocFreeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* result_start */:
        field.get(&result_start_);
        break;
      case 4 /* result_group */:
        field.get(&result_group_);
        break;
      case 5 /* result_len */:
        field.get(&result_len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MballocFreeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MballocFreeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MballocFreeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: result_start
  if (_has_field_[3]) {
    msg->AppendVarInt(3, result_start_);
  }

  // Field 4: result_group
  if (_has_field_[4]) {
    msg->AppendVarInt(4, result_group_);
  }

  // Field 5: result_len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, result_len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent() = default;
Ext4MballocDiscardFtraceEvent::~Ext4MballocDiscardFtraceEvent() = default;
Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(const Ext4MballocDiscardFtraceEvent&) = default;
Ext4MballocDiscardFtraceEvent& Ext4MballocDiscardFtraceEvent::operator=(const Ext4MballocDiscardFtraceEvent&) = default;
Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(Ext4MballocDiscardFtraceEvent&&) noexcept = default;
Ext4MballocDiscardFtraceEvent& Ext4MballocDiscardFtraceEvent::operator=(Ext4MballocDiscardFtraceEvent&&) = default;

bool Ext4MballocDiscardFtraceEvent::operator==(const Ext4MballocDiscardFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && result_start_ == other.result_start_
   && result_group_ == other.result_group_
   && result_len_ == other.result_len_;
}

bool Ext4MballocDiscardFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* result_start */:
        field.get(&result_start_);
        break;
      case 4 /* result_group */:
        field.get(&result_group_);
        break;
      case 5 /* result_len */:
        field.get(&result_len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MballocDiscardFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MballocDiscardFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MballocDiscardFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: result_start
  if (_has_field_[3]) {
    msg->AppendVarInt(3, result_start_);
  }

  // Field 4: result_group
  if (_has_field_[4]) {
    msg->AppendVarInt(4, result_group_);
  }

  // Field 5: result_len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, result_len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent() = default;
Ext4MballocAllocFtraceEvent::~Ext4MballocAllocFtraceEvent() = default;
Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(const Ext4MballocAllocFtraceEvent&) = default;
Ext4MballocAllocFtraceEvent& Ext4MballocAllocFtraceEvent::operator=(const Ext4MballocAllocFtraceEvent&) = default;
Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(Ext4MballocAllocFtraceEvent&&) noexcept = default;
Ext4MballocAllocFtraceEvent& Ext4MballocAllocFtraceEvent::operator=(Ext4MballocAllocFtraceEvent&&) = default;

bool Ext4MballocAllocFtraceEvent::operator==(const Ext4MballocAllocFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && orig_logical_ == other.orig_logical_
   && orig_start_ == other.orig_start_
   && orig_group_ == other.orig_group_
   && orig_len_ == other.orig_len_
   && goal_logical_ == other.goal_logical_
   && goal_start_ == other.goal_start_
   && goal_group_ == other.goal_group_
   && goal_len_ == other.goal_len_
   && result_logical_ == other.result_logical_
   && result_start_ == other.result_start_
   && result_group_ == other.result_group_
   && result_len_ == other.result_len_
   && found_ == other.found_
   && groups_ == other.groups_
   && buddy_ == other.buddy_
   && flags_ == other.flags_
   && tail_ == other.tail_
   && cr_ == other.cr_;
}

bool Ext4MballocAllocFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* orig_logical */:
        field.get(&orig_logical_);
        break;
      case 4 /* orig_start */:
        field.get(&orig_start_);
        break;
      case 5 /* orig_group */:
        field.get(&orig_group_);
        break;
      case 6 /* orig_len */:
        field.get(&orig_len_);
        break;
      case 7 /* goal_logical */:
        field.get(&goal_logical_);
        break;
      case 8 /* goal_start */:
        field.get(&goal_start_);
        break;
      case 9 /* goal_group */:
        field.get(&goal_group_);
        break;
      case 10 /* goal_len */:
        field.get(&goal_len_);
        break;
      case 11 /* result_logical */:
        field.get(&result_logical_);
        break;
      case 12 /* result_start */:
        field.get(&result_start_);
        break;
      case 13 /* result_group */:
        field.get(&result_group_);
        break;
      case 14 /* result_len */:
        field.get(&result_len_);
        break;
      case 15 /* found */:
        field.get(&found_);
        break;
      case 16 /* groups */:
        field.get(&groups_);
        break;
      case 17 /* buddy */:
        field.get(&buddy_);
        break;
      case 18 /* flags */:
        field.get(&flags_);
        break;
      case 19 /* tail */:
        field.get(&tail_);
        break;
      case 20 /* cr */:
        field.get(&cr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MballocAllocFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MballocAllocFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MballocAllocFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: orig_logical
  if (_has_field_[3]) {
    msg->AppendVarInt(3, orig_logical_);
  }

  // Field 4: orig_start
  if (_has_field_[4]) {
    msg->AppendVarInt(4, orig_start_);
  }

  // Field 5: orig_group
  if (_has_field_[5]) {
    msg->AppendVarInt(5, orig_group_);
  }

  // Field 6: orig_len
  if (_has_field_[6]) {
    msg->AppendVarInt(6, orig_len_);
  }

  // Field 7: goal_logical
  if (_has_field_[7]) {
    msg->AppendVarInt(7, goal_logical_);
  }

  // Field 8: goal_start
  if (_has_field_[8]) {
    msg->AppendVarInt(8, goal_start_);
  }

  // Field 9: goal_group
  if (_has_field_[9]) {
    msg->AppendVarInt(9, goal_group_);
  }

  // Field 10: goal_len
  if (_has_field_[10]) {
    msg->AppendVarInt(10, goal_len_);
  }

  // Field 11: result_logical
  if (_has_field_[11]) {
    msg->AppendVarInt(11, result_logical_);
  }

  // Field 12: result_start
  if (_has_field_[12]) {
    msg->AppendVarInt(12, result_start_);
  }

  // Field 13: result_group
  if (_has_field_[13]) {
    msg->AppendVarInt(13, result_group_);
  }

  // Field 14: result_len
  if (_has_field_[14]) {
    msg->AppendVarInt(14, result_len_);
  }

  // Field 15: found
  if (_has_field_[15]) {
    msg->AppendVarInt(15, found_);
  }

  // Field 16: groups
  if (_has_field_[16]) {
    msg->AppendVarInt(16, groups_);
  }

  // Field 17: buddy
  if (_has_field_[17]) {
    msg->AppendVarInt(17, buddy_);
  }

  // Field 18: flags
  if (_has_field_[18]) {
    msg->AppendVarInt(18, flags_);
  }

  // Field 19: tail
  if (_has_field_[19]) {
    msg->AppendVarInt(19, tail_);
  }

  // Field 20: cr
  if (_has_field_[20]) {
    msg->AppendVarInt(20, cr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent() = default;
Ext4MbReleaseInodePaFtraceEvent::~Ext4MbReleaseInodePaFtraceEvent() = default;
Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(const Ext4MbReleaseInodePaFtraceEvent&) = default;
Ext4MbReleaseInodePaFtraceEvent& Ext4MbReleaseInodePaFtraceEvent::operator=(const Ext4MbReleaseInodePaFtraceEvent&) = default;
Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(Ext4MbReleaseInodePaFtraceEvent&&) noexcept = default;
Ext4MbReleaseInodePaFtraceEvent& Ext4MbReleaseInodePaFtraceEvent::operator=(Ext4MbReleaseInodePaFtraceEvent&&) = default;

bool Ext4MbReleaseInodePaFtraceEvent::operator==(const Ext4MbReleaseInodePaFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && block_ == other.block_
   && count_ == other.count_;
}

bool Ext4MbReleaseInodePaFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* block */:
        field.get(&block_);
        break;
      case 4 /* count */:
        field.get(&count_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MbReleaseInodePaFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MbReleaseInodePaFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MbReleaseInodePaFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: block
  if (_has_field_[3]) {
    msg->AppendVarInt(3, block_);
  }

  // Field 4: count
  if (_has_field_[4]) {
    msg->AppendVarInt(4, count_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent() = default;
Ext4MbReleaseGroupPaFtraceEvent::~Ext4MbReleaseGroupPaFtraceEvent() = default;
Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(const Ext4MbReleaseGroupPaFtraceEvent&) = default;
Ext4MbReleaseGroupPaFtraceEvent& Ext4MbReleaseGroupPaFtraceEvent::operator=(const Ext4MbReleaseGroupPaFtraceEvent&) = default;
Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(Ext4MbReleaseGroupPaFtraceEvent&&) noexcept = default;
Ext4MbReleaseGroupPaFtraceEvent& Ext4MbReleaseGroupPaFtraceEvent::operator=(Ext4MbReleaseGroupPaFtraceEvent&&) = default;

bool Ext4MbReleaseGroupPaFtraceEvent::operator==(const Ext4MbReleaseGroupPaFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && pa_pstart_ == other.pa_pstart_
   && pa_len_ == other.pa_len_;
}

bool Ext4MbReleaseGroupPaFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* pa_pstart */:
        field.get(&pa_pstart_);
        break;
      case 3 /* pa_len */:
        field.get(&pa_len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MbReleaseGroupPaFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MbReleaseGroupPaFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MbReleaseGroupPaFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: pa_pstart
  if (_has_field_[2]) {
    msg->AppendVarInt(2, pa_pstart_);
  }

  // Field 3: pa_len
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pa_len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent() = default;
Ext4MbNewInodePaFtraceEvent::~Ext4MbNewInodePaFtraceEvent() = default;
Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(const Ext4MbNewInodePaFtraceEvent&) = default;
Ext4MbNewInodePaFtraceEvent& Ext4MbNewInodePaFtraceEvent::operator=(const Ext4MbNewInodePaFtraceEvent&) = default;
Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(Ext4MbNewInodePaFtraceEvent&&) noexcept = default;
Ext4MbNewInodePaFtraceEvent& Ext4MbNewInodePaFtraceEvent::operator=(Ext4MbNewInodePaFtraceEvent&&) = default;

bool Ext4MbNewInodePaFtraceEvent::operator==(const Ext4MbNewInodePaFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pa_pstart_ == other.pa_pstart_
   && pa_lstart_ == other.pa_lstart_
   && pa_len_ == other.pa_len_;
}

bool Ext4MbNewInodePaFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pa_pstart */:
        field.get(&pa_pstart_);
        break;
      case 4 /* pa_lstart */:
        field.get(&pa_lstart_);
        break;
      case 5 /* pa_len */:
        field.get(&pa_len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MbNewInodePaFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MbNewInodePaFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MbNewInodePaFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pa_pstart
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pa_pstart_);
  }

  // Field 4: pa_lstart
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pa_lstart_);
  }

  // Field 5: pa_len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pa_len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent() = default;
Ext4MbNewGroupPaFtraceEvent::~Ext4MbNewGroupPaFtraceEvent() = default;
Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(const Ext4MbNewGroupPaFtraceEvent&) = default;
Ext4MbNewGroupPaFtraceEvent& Ext4MbNewGroupPaFtraceEvent::operator=(const Ext4MbNewGroupPaFtraceEvent&) = default;
Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(Ext4MbNewGroupPaFtraceEvent&&) noexcept = default;
Ext4MbNewGroupPaFtraceEvent& Ext4MbNewGroupPaFtraceEvent::operator=(Ext4MbNewGroupPaFtraceEvent&&) = default;

bool Ext4MbNewGroupPaFtraceEvent::operator==(const Ext4MbNewGroupPaFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pa_pstart_ == other.pa_pstart_
   && pa_lstart_ == other.pa_lstart_
   && pa_len_ == other.pa_len_;
}

bool Ext4MbNewGroupPaFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pa_pstart */:
        field.get(&pa_pstart_);
        break;
      case 4 /* pa_lstart */:
        field.get(&pa_lstart_);
        break;
      case 5 /* pa_len */:
        field.get(&pa_len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MbNewGroupPaFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MbNewGroupPaFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MbNewGroupPaFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pa_pstart
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pa_pstart_);
  }

  // Field 4: pa_lstart
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pa_lstart_);
  }

  // Field 5: pa_len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pa_len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent() = default;
Ext4MbDiscardPreallocationsFtraceEvent::~Ext4MbDiscardPreallocationsFtraceEvent() = default;
Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(const Ext4MbDiscardPreallocationsFtraceEvent&) = default;
Ext4MbDiscardPreallocationsFtraceEvent& Ext4MbDiscardPreallocationsFtraceEvent::operator=(const Ext4MbDiscardPreallocationsFtraceEvent&) = default;
Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(Ext4MbDiscardPreallocationsFtraceEvent&&) noexcept = default;
Ext4MbDiscardPreallocationsFtraceEvent& Ext4MbDiscardPreallocationsFtraceEvent::operator=(Ext4MbDiscardPreallocationsFtraceEvent&&) = default;

bool Ext4MbDiscardPreallocationsFtraceEvent::operator==(const Ext4MbDiscardPreallocationsFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && needed_ == other.needed_;
}

bool Ext4MbDiscardPreallocationsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* needed */:
        field.get(&needed_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MbDiscardPreallocationsFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MbDiscardPreallocationsFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MbDiscardPreallocationsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: needed
  if (_has_field_[2]) {
    msg->AppendVarInt(2, needed_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent() = default;
Ext4MbBuddyBitmapLoadFtraceEvent::~Ext4MbBuddyBitmapLoadFtraceEvent() = default;
Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(const Ext4MbBuddyBitmapLoadFtraceEvent&) = default;
Ext4MbBuddyBitmapLoadFtraceEvent& Ext4MbBuddyBitmapLoadFtraceEvent::operator=(const Ext4MbBuddyBitmapLoadFtraceEvent&) = default;
Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(Ext4MbBuddyBitmapLoadFtraceEvent&&) noexcept = default;
Ext4MbBuddyBitmapLoadFtraceEvent& Ext4MbBuddyBitmapLoadFtraceEvent::operator=(Ext4MbBuddyBitmapLoadFtraceEvent&&) = default;

bool Ext4MbBuddyBitmapLoadFtraceEvent::operator==(const Ext4MbBuddyBitmapLoadFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && group_ == other.group_;
}

bool Ext4MbBuddyBitmapLoadFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* group */:
        field.get(&group_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MbBuddyBitmapLoadFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MbBuddyBitmapLoadFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MbBuddyBitmapLoadFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: group
  if (_has_field_[2]) {
    msg->AppendVarInt(2, group_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent() = default;
Ext4MbBitmapLoadFtraceEvent::~Ext4MbBitmapLoadFtraceEvent() = default;
Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(const Ext4MbBitmapLoadFtraceEvent&) = default;
Ext4MbBitmapLoadFtraceEvent& Ext4MbBitmapLoadFtraceEvent::operator=(const Ext4MbBitmapLoadFtraceEvent&) = default;
Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(Ext4MbBitmapLoadFtraceEvent&&) noexcept = default;
Ext4MbBitmapLoadFtraceEvent& Ext4MbBitmapLoadFtraceEvent::operator=(Ext4MbBitmapLoadFtraceEvent&&) = default;

bool Ext4MbBitmapLoadFtraceEvent::operator==(const Ext4MbBitmapLoadFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && group_ == other.group_;
}

bool Ext4MbBitmapLoadFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* group */:
        field.get(&group_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MbBitmapLoadFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MbBitmapLoadFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MbBitmapLoadFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: group
  if (_has_field_[2]) {
    msg->AppendVarInt(2, group_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent() = default;
Ext4MarkInodeDirtyFtraceEvent::~Ext4MarkInodeDirtyFtraceEvent() = default;
Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(const Ext4MarkInodeDirtyFtraceEvent&) = default;
Ext4MarkInodeDirtyFtraceEvent& Ext4MarkInodeDirtyFtraceEvent::operator=(const Ext4MarkInodeDirtyFtraceEvent&) = default;
Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(Ext4MarkInodeDirtyFtraceEvent&&) noexcept = default;
Ext4MarkInodeDirtyFtraceEvent& Ext4MarkInodeDirtyFtraceEvent::operator=(Ext4MarkInodeDirtyFtraceEvent&&) = default;

bool Ext4MarkInodeDirtyFtraceEvent::operator==(const Ext4MarkInodeDirtyFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ip_ == other.ip_;
}

bool Ext4MarkInodeDirtyFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ip */:
        field.get(&ip_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4MarkInodeDirtyFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4MarkInodeDirtyFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4MarkInodeDirtyFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ip
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ip_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent() = default;
Ext4LoadInodeBitmapFtraceEvent::~Ext4LoadInodeBitmapFtraceEvent() = default;
Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(const Ext4LoadInodeBitmapFtraceEvent&) = default;
Ext4LoadInodeBitmapFtraceEvent& Ext4LoadInodeBitmapFtraceEvent::operator=(const Ext4LoadInodeBitmapFtraceEvent&) = default;
Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(Ext4LoadInodeBitmapFtraceEvent&&) noexcept = default;
Ext4LoadInodeBitmapFtraceEvent& Ext4LoadInodeBitmapFtraceEvent::operator=(Ext4LoadInodeBitmapFtraceEvent&&) = default;

bool Ext4LoadInodeBitmapFtraceEvent::operator==(const Ext4LoadInodeBitmapFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && group_ == other.group_;
}

bool Ext4LoadInodeBitmapFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* group */:
        field.get(&group_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4LoadInodeBitmapFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4LoadInodeBitmapFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4LoadInodeBitmapFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: group
  if (_has_field_[2]) {
    msg->AppendVarInt(2, group_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent() = default;
Ext4LoadInodeFtraceEvent::~Ext4LoadInodeFtraceEvent() = default;
Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(const Ext4LoadInodeFtraceEvent&) = default;
Ext4LoadInodeFtraceEvent& Ext4LoadInodeFtraceEvent::operator=(const Ext4LoadInodeFtraceEvent&) = default;
Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(Ext4LoadInodeFtraceEvent&&) noexcept = default;
Ext4LoadInodeFtraceEvent& Ext4LoadInodeFtraceEvent::operator=(Ext4LoadInodeFtraceEvent&&) = default;

bool Ext4LoadInodeFtraceEvent::operator==(const Ext4LoadInodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_;
}

bool Ext4LoadInodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4LoadInodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4LoadInodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4LoadInodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent() = default;
Ext4JournalledWriteEndFtraceEvent::~Ext4JournalledWriteEndFtraceEvent() = default;
Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(const Ext4JournalledWriteEndFtraceEvent&) = default;
Ext4JournalledWriteEndFtraceEvent& Ext4JournalledWriteEndFtraceEvent::operator=(const Ext4JournalledWriteEndFtraceEvent&) = default;
Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(Ext4JournalledWriteEndFtraceEvent&&) noexcept = default;
Ext4JournalledWriteEndFtraceEvent& Ext4JournalledWriteEndFtraceEvent::operator=(Ext4JournalledWriteEndFtraceEvent&&) = default;

bool Ext4JournalledWriteEndFtraceEvent::operator==(const Ext4JournalledWriteEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && copied_ == other.copied_;
}

bool Ext4JournalledWriteEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* copied */:
        field.get(&copied_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4JournalledWriteEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4JournalledWriteEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4JournalledWriteEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: copied
  if (_has_field_[5]) {
    msg->AppendVarInt(5, copied_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent() = default;
Ext4JournalledInvalidatepageFtraceEvent::~Ext4JournalledInvalidatepageFtraceEvent() = default;
Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(const Ext4JournalledInvalidatepageFtraceEvent&) = default;
Ext4JournalledInvalidatepageFtraceEvent& Ext4JournalledInvalidatepageFtraceEvent::operator=(const Ext4JournalledInvalidatepageFtraceEvent&) = default;
Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(Ext4JournalledInvalidatepageFtraceEvent&&) noexcept = default;
Ext4JournalledInvalidatepageFtraceEvent& Ext4JournalledInvalidatepageFtraceEvent::operator=(Ext4JournalledInvalidatepageFtraceEvent&&) = default;

bool Ext4JournalledInvalidatepageFtraceEvent::operator==(const Ext4JournalledInvalidatepageFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && index_ == other.index_
   && offset_ == other.offset_
   && length_ == other.length_;
}

bool Ext4JournalledInvalidatepageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* index */:
        field.get(&index_);
        break;
      case 4 /* offset */:
        field.get(&offset_);
        break;
      case 5 /* length */:
        field.get(&length_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4JournalledInvalidatepageFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4JournalledInvalidatepageFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4JournalledInvalidatepageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: index
  if (_has_field_[3]) {
    msg->AppendVarInt(3, index_);
  }

  // Field 4: offset
  if (_has_field_[4]) {
    msg->AppendVarInt(4, offset_);
  }

  // Field 5: length
  if (_has_field_[5]) {
    msg->AppendVarInt(5, length_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent() = default;
Ext4JournalStartReservedFtraceEvent::~Ext4JournalStartReservedFtraceEvent() = default;
Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(const Ext4JournalStartReservedFtraceEvent&) = default;
Ext4JournalStartReservedFtraceEvent& Ext4JournalStartReservedFtraceEvent::operator=(const Ext4JournalStartReservedFtraceEvent&) = default;
Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(Ext4JournalStartReservedFtraceEvent&&) noexcept = default;
Ext4JournalStartReservedFtraceEvent& Ext4JournalStartReservedFtraceEvent::operator=(Ext4JournalStartReservedFtraceEvent&&) = default;

bool Ext4JournalStartReservedFtraceEvent::operator==(const Ext4JournalStartReservedFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ip_ == other.ip_
   && blocks_ == other.blocks_;
}

bool Ext4JournalStartReservedFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ip */:
        field.get(&ip_);
        break;
      case 3 /* blocks */:
        field.get(&blocks_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4JournalStartReservedFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4JournalStartReservedFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4JournalStartReservedFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ip
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ip_);
  }

  // Field 3: blocks
  if (_has_field_[3]) {
    msg->AppendVarInt(3, blocks_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent() = default;
Ext4JournalStartFtraceEvent::~Ext4JournalStartFtraceEvent() = default;
Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(const Ext4JournalStartFtraceEvent&) = default;
Ext4JournalStartFtraceEvent& Ext4JournalStartFtraceEvent::operator=(const Ext4JournalStartFtraceEvent&) = default;
Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(Ext4JournalStartFtraceEvent&&) noexcept = default;
Ext4JournalStartFtraceEvent& Ext4JournalStartFtraceEvent::operator=(Ext4JournalStartFtraceEvent&&) = default;

bool Ext4JournalStartFtraceEvent::operator==(const Ext4JournalStartFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ip_ == other.ip_
   && blocks_ == other.blocks_
   && rsv_blocks_ == other.rsv_blocks_
   && nblocks_ == other.nblocks_;
}

bool Ext4JournalStartFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ip */:
        field.get(&ip_);
        break;
      case 3 /* blocks */:
        field.get(&blocks_);
        break;
      case 4 /* rsv_blocks */:
        field.get(&rsv_blocks_);
        break;
      case 5 /* nblocks */:
        field.get(&nblocks_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4JournalStartFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4JournalStartFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4JournalStartFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ip
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ip_);
  }

  // Field 3: blocks
  if (_has_field_[3]) {
    msg->AppendVarInt(3, blocks_);
  }

  // Field 4: rsv_blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, rsv_blocks_);
  }

  // Field 5: nblocks
  if (_has_field_[5]) {
    msg->AppendVarInt(5, nblocks_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent() = default;
Ext4InvalidatepageFtraceEvent::~Ext4InvalidatepageFtraceEvent() = default;
Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(const Ext4InvalidatepageFtraceEvent&) = default;
Ext4InvalidatepageFtraceEvent& Ext4InvalidatepageFtraceEvent::operator=(const Ext4InvalidatepageFtraceEvent&) = default;
Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(Ext4InvalidatepageFtraceEvent&&) noexcept = default;
Ext4InvalidatepageFtraceEvent& Ext4InvalidatepageFtraceEvent::operator=(Ext4InvalidatepageFtraceEvent&&) = default;

bool Ext4InvalidatepageFtraceEvent::operator==(const Ext4InvalidatepageFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && index_ == other.index_
   && offset_ == other.offset_
   && length_ == other.length_;
}

bool Ext4InvalidatepageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* index */:
        field.get(&index_);
        break;
      case 4 /* offset */:
        field.get(&offset_);
        break;
      case 5 /* length */:
        field.get(&length_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4InvalidatepageFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4InvalidatepageFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4InvalidatepageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: index
  if (_has_field_[3]) {
    msg->AppendVarInt(3, index_);
  }

  // Field 4: offset
  if (_has_field_[4]) {
    msg->AppendVarInt(4, offset_);
  }

  // Field 5: length
  if (_has_field_[5]) {
    msg->AppendVarInt(5, length_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent() = default;
Ext4InsertRangeFtraceEvent::~Ext4InsertRangeFtraceEvent() = default;
Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(const Ext4InsertRangeFtraceEvent&) = default;
Ext4InsertRangeFtraceEvent& Ext4InsertRangeFtraceEvent::operator=(const Ext4InsertRangeFtraceEvent&) = default;
Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(Ext4InsertRangeFtraceEvent&&) noexcept = default;
Ext4InsertRangeFtraceEvent& Ext4InsertRangeFtraceEvent::operator=(Ext4InsertRangeFtraceEvent&&) = default;

bool Ext4InsertRangeFtraceEvent::operator==(const Ext4InsertRangeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && offset_ == other.offset_
   && len_ == other.len_;
}

bool Ext4InsertRangeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* offset */:
        field.get(&offset_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4InsertRangeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4InsertRangeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4InsertRangeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, offset_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent() = default;
Ext4IndMapBlocksExitFtraceEvent::~Ext4IndMapBlocksExitFtraceEvent() = default;
Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(const Ext4IndMapBlocksExitFtraceEvent&) = default;
Ext4IndMapBlocksExitFtraceEvent& Ext4IndMapBlocksExitFtraceEvent::operator=(const Ext4IndMapBlocksExitFtraceEvent&) = default;
Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(Ext4IndMapBlocksExitFtraceEvent&&) noexcept = default;
Ext4IndMapBlocksExitFtraceEvent& Ext4IndMapBlocksExitFtraceEvent::operator=(Ext4IndMapBlocksExitFtraceEvent&&) = default;

bool Ext4IndMapBlocksExitFtraceEvent::operator==(const Ext4IndMapBlocksExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && flags_ == other.flags_
   && pblk_ == other.pblk_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && mflags_ == other.mflags_
   && ret_ == other.ret_;
}

bool Ext4IndMapBlocksExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* flags */:
        field.get(&flags_);
        break;
      case 4 /* pblk */:
        field.get(&pblk_);
        break;
      case 5 /* lblk */:
        field.get(&lblk_);
        break;
      case 6 /* len */:
        field.get(&len_);
        break;
      case 7 /* mflags */:
        field.get(&mflags_);
        break;
      case 8 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4IndMapBlocksExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4IndMapBlocksExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4IndMapBlocksExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: flags
  if (_has_field_[3]) {
    msg->AppendVarInt(3, flags_);
  }

  // Field 4: pblk
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pblk_);
  }

  // Field 5: lblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, lblk_);
  }

  // Field 6: len
  if (_has_field_[6]) {
    msg->AppendVarInt(6, len_);
  }

  // Field 7: mflags
  if (_has_field_[7]) {
    msg->AppendVarInt(7, mflags_);
  }

  // Field 8: ret
  if (_has_field_[8]) {
    msg->AppendVarInt(8, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent() = default;
Ext4IndMapBlocksEnterFtraceEvent::~Ext4IndMapBlocksEnterFtraceEvent() = default;
Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(const Ext4IndMapBlocksEnterFtraceEvent&) = default;
Ext4IndMapBlocksEnterFtraceEvent& Ext4IndMapBlocksEnterFtraceEvent::operator=(const Ext4IndMapBlocksEnterFtraceEvent&) = default;
Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(Ext4IndMapBlocksEnterFtraceEvent&&) noexcept = default;
Ext4IndMapBlocksEnterFtraceEvent& Ext4IndMapBlocksEnterFtraceEvent::operator=(Ext4IndMapBlocksEnterFtraceEvent&&) = default;

bool Ext4IndMapBlocksEnterFtraceEvent::operator==(const Ext4IndMapBlocksEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && flags_ == other.flags_;
}

bool Ext4IndMapBlocksEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4IndMapBlocksEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4IndMapBlocksEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4IndMapBlocksEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent() = default;
Ext4GetReservedClusterAllocFtraceEvent::~Ext4GetReservedClusterAllocFtraceEvent() = default;
Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(const Ext4GetReservedClusterAllocFtraceEvent&) = default;
Ext4GetReservedClusterAllocFtraceEvent& Ext4GetReservedClusterAllocFtraceEvent::operator=(const Ext4GetReservedClusterAllocFtraceEvent&) = default;
Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(Ext4GetReservedClusterAllocFtraceEvent&&) noexcept = default;
Ext4GetReservedClusterAllocFtraceEvent& Ext4GetReservedClusterAllocFtraceEvent::operator=(Ext4GetReservedClusterAllocFtraceEvent&&) = default;

bool Ext4GetReservedClusterAllocFtraceEvent::operator==(const Ext4GetReservedClusterAllocFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_;
}

bool Ext4GetReservedClusterAllocFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4GetReservedClusterAllocFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4GetReservedClusterAllocFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4GetReservedClusterAllocFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent() = default;
Ext4GetImpliedClusterAllocExitFtraceEvent::~Ext4GetImpliedClusterAllocExitFtraceEvent() = default;
Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(const Ext4GetImpliedClusterAllocExitFtraceEvent&) = default;
Ext4GetImpliedClusterAllocExitFtraceEvent& Ext4GetImpliedClusterAllocExitFtraceEvent::operator=(const Ext4GetImpliedClusterAllocExitFtraceEvent&) = default;
Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(Ext4GetImpliedClusterAllocExitFtraceEvent&&) noexcept = default;
Ext4GetImpliedClusterAllocExitFtraceEvent& Ext4GetImpliedClusterAllocExitFtraceEvent::operator=(Ext4GetImpliedClusterAllocExitFtraceEvent&&) = default;

bool Ext4GetImpliedClusterAllocExitFtraceEvent::operator==(const Ext4GetImpliedClusterAllocExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && flags_ == other.flags_
   && lblk_ == other.lblk_
   && pblk_ == other.pblk_
   && len_ == other.len_
   && ret_ == other.ret_;
}

bool Ext4GetImpliedClusterAllocExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* flags */:
        field.get(&flags_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* pblk */:
        field.get(&pblk_);
        break;
      case 5 /* len */:
        field.get(&len_);
        break;
      case 6 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4GetImpliedClusterAllocExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4GetImpliedClusterAllocExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: flags
  if (_has_field_[2]) {
    msg->AppendVarInt(2, flags_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: pblk
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pblk_);
  }

  // Field 5: len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, len_);
  }

  // Field 6: ret
  if (_has_field_[6]) {
    msg->AppendVarInt(6, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent() = default;
Ext4FreeInodeFtraceEvent::~Ext4FreeInodeFtraceEvent() = default;
Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(const Ext4FreeInodeFtraceEvent&) = default;
Ext4FreeInodeFtraceEvent& Ext4FreeInodeFtraceEvent::operator=(const Ext4FreeInodeFtraceEvent&) = default;
Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(Ext4FreeInodeFtraceEvent&&) noexcept = default;
Ext4FreeInodeFtraceEvent& Ext4FreeInodeFtraceEvent::operator=(Ext4FreeInodeFtraceEvent&&) = default;

bool Ext4FreeInodeFtraceEvent::operator==(const Ext4FreeInodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && uid_ == other.uid_
   && gid_ == other.gid_
   && blocks_ == other.blocks_
   && mode_ == other.mode_;
}

bool Ext4FreeInodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* uid */:
        field.get(&uid_);
        break;
      case 4 /* gid */:
        field.get(&gid_);
        break;
      case 5 /* blocks */:
        field.get(&blocks_);
        break;
      case 6 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4FreeInodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4FreeInodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4FreeInodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: uid
  if (_has_field_[3]) {
    msg->AppendVarInt(3, uid_);
  }

  // Field 4: gid
  if (_has_field_[4]) {
    msg->AppendVarInt(4, gid_);
  }

  // Field 5: blocks
  if (_has_field_[5]) {
    msg->AppendVarInt(5, blocks_);
  }

  // Field 6: mode
  if (_has_field_[6]) {
    msg->AppendVarInt(6, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent() = default;
Ext4FreeBlocksFtraceEvent::~Ext4FreeBlocksFtraceEvent() = default;
Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(const Ext4FreeBlocksFtraceEvent&) = default;
Ext4FreeBlocksFtraceEvent& Ext4FreeBlocksFtraceEvent::operator=(const Ext4FreeBlocksFtraceEvent&) = default;
Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(Ext4FreeBlocksFtraceEvent&&) noexcept = default;
Ext4FreeBlocksFtraceEvent& Ext4FreeBlocksFtraceEvent::operator=(Ext4FreeBlocksFtraceEvent&&) = default;

bool Ext4FreeBlocksFtraceEvent::operator==(const Ext4FreeBlocksFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && block_ == other.block_
   && count_ == other.count_
   && flags_ == other.flags_
   && mode_ == other.mode_;
}

bool Ext4FreeBlocksFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* block */:
        field.get(&block_);
        break;
      case 4 /* count */:
        field.get(&count_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      case 6 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4FreeBlocksFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4FreeBlocksFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4FreeBlocksFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: block
  if (_has_field_[3]) {
    msg->AppendVarInt(3, block_);
  }

  // Field 4: count
  if (_has_field_[4]) {
    msg->AppendVarInt(4, count_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  // Field 6: mode
  if (_has_field_[6]) {
    msg->AppendVarInt(6, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent() = default;
Ext4ForgetFtraceEvent::~Ext4ForgetFtraceEvent() = default;
Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(const Ext4ForgetFtraceEvent&) = default;
Ext4ForgetFtraceEvent& Ext4ForgetFtraceEvent::operator=(const Ext4ForgetFtraceEvent&) = default;
Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(Ext4ForgetFtraceEvent&&) noexcept = default;
Ext4ForgetFtraceEvent& Ext4ForgetFtraceEvent::operator=(Ext4ForgetFtraceEvent&&) = default;

bool Ext4ForgetFtraceEvent::operator==(const Ext4ForgetFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && block_ == other.block_
   && is_metadata_ == other.is_metadata_
   && mode_ == other.mode_;
}

bool Ext4ForgetFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* block */:
        field.get(&block_);
        break;
      case 4 /* is_metadata */:
        field.get(&is_metadata_);
        break;
      case 5 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ForgetFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ForgetFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ForgetFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: block
  if (_has_field_[3]) {
    msg->AppendVarInt(3, block_);
  }

  // Field 4: is_metadata
  if (_has_field_[4]) {
    msg->AppendVarInt(4, is_metadata_);
  }

  // Field 5: mode
  if (_has_field_[5]) {
    msg->AppendVarInt(5, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent() = default;
Ext4FindDelallocRangeFtraceEvent::~Ext4FindDelallocRangeFtraceEvent() = default;
Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(const Ext4FindDelallocRangeFtraceEvent&) = default;
Ext4FindDelallocRangeFtraceEvent& Ext4FindDelallocRangeFtraceEvent::operator=(const Ext4FindDelallocRangeFtraceEvent&) = default;
Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(Ext4FindDelallocRangeFtraceEvent&&) noexcept = default;
Ext4FindDelallocRangeFtraceEvent& Ext4FindDelallocRangeFtraceEvent::operator=(Ext4FindDelallocRangeFtraceEvent&&) = default;

bool Ext4FindDelallocRangeFtraceEvent::operator==(const Ext4FindDelallocRangeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && from_ == other.from_
   && to_ == other.to_
   && reverse_ == other.reverse_
   && found_ == other.found_
   && found_blk_ == other.found_blk_;
}

bool Ext4FindDelallocRangeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* from */:
        field.get(&from_);
        break;
      case 4 /* to */:
        field.get(&to_);
        break;
      case 5 /* reverse */:
        field.get(&reverse_);
        break;
      case 6 /* found */:
        field.get(&found_);
        break;
      case 7 /* found_blk */:
        field.get(&found_blk_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4FindDelallocRangeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4FindDelallocRangeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4FindDelallocRangeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: from
  if (_has_field_[3]) {
    msg->AppendVarInt(3, from_);
  }

  // Field 4: to
  if (_has_field_[4]) {
    msg->AppendVarInt(4, to_);
  }

  // Field 5: reverse
  if (_has_field_[5]) {
    msg->AppendVarInt(5, reverse_);
  }

  // Field 6: found
  if (_has_field_[6]) {
    msg->AppendVarInt(6, found_);
  }

  // Field 7: found_blk
  if (_has_field_[7]) {
    msg->AppendVarInt(7, found_blk_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent() = default;
Ext4FallocateExitFtraceEvent::~Ext4FallocateExitFtraceEvent() = default;
Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(const Ext4FallocateExitFtraceEvent&) = default;
Ext4FallocateExitFtraceEvent& Ext4FallocateExitFtraceEvent::operator=(const Ext4FallocateExitFtraceEvent&) = default;
Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(Ext4FallocateExitFtraceEvent&&) noexcept = default;
Ext4FallocateExitFtraceEvent& Ext4FallocateExitFtraceEvent::operator=(Ext4FallocateExitFtraceEvent&&) = default;

bool Ext4FallocateExitFtraceEvent::operator==(const Ext4FallocateExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && blocks_ == other.blocks_
   && ret_ == other.ret_;
}

bool Ext4FallocateExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* blocks */:
        field.get(&blocks_);
        break;
      case 5 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4FallocateExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4FallocateExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4FallocateExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, blocks_);
  }

  // Field 5: ret
  if (_has_field_[5]) {
    msg->AppendVarInt(5, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent() = default;
Ext4FallocateEnterFtraceEvent::~Ext4FallocateEnterFtraceEvent() = default;
Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(const Ext4FallocateEnterFtraceEvent&) = default;
Ext4FallocateEnterFtraceEvent& Ext4FallocateEnterFtraceEvent::operator=(const Ext4FallocateEnterFtraceEvent&) = default;
Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(Ext4FallocateEnterFtraceEvent&&) noexcept = default;
Ext4FallocateEnterFtraceEvent& Ext4FallocateEnterFtraceEvent::operator=(Ext4FallocateEnterFtraceEvent&&) = default;

bool Ext4FallocateEnterFtraceEvent::operator==(const Ext4FallocateEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && offset_ == other.offset_
   && len_ == other.len_
   && mode_ == other.mode_
   && pos_ == other.pos_;
}

bool Ext4FallocateEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* offset */:
        field.get(&offset_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* mode */:
        field.get(&mode_);
        break;
      case 6 /* pos */:
        field.get(&pos_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4FallocateEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4FallocateEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4FallocateEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, offset_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: mode
  if (_has_field_[5]) {
    msg->AppendVarInt(5, mode_);
  }

  // Field 6: pos
  if (_has_field_[6]) {
    msg->AppendVarInt(6, pos_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent() = default;
Ext4ExtShowExtentFtraceEvent::~Ext4ExtShowExtentFtraceEvent() = default;
Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(const Ext4ExtShowExtentFtraceEvent&) = default;
Ext4ExtShowExtentFtraceEvent& Ext4ExtShowExtentFtraceEvent::operator=(const Ext4ExtShowExtentFtraceEvent&) = default;
Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(Ext4ExtShowExtentFtraceEvent&&) noexcept = default;
Ext4ExtShowExtentFtraceEvent& Ext4ExtShowExtentFtraceEvent::operator=(Ext4ExtShowExtentFtraceEvent&&) = default;

bool Ext4ExtShowExtentFtraceEvent::operator==(const Ext4ExtShowExtentFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pblk_ == other.pblk_
   && lblk_ == other.lblk_
   && len_ == other.len_;
}

bool Ext4ExtShowExtentFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pblk */:
        field.get(&pblk_);
        break;
      case 4 /* lblk */:
        field.get(&lblk_);
        break;
      case 5 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtShowExtentFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtShowExtentFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtShowExtentFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pblk_);
  }

  // Field 4: lblk
  if (_has_field_[4]) {
    msg->AppendVarInt(4, lblk_);
  }

  // Field 5: len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent() = default;
Ext4ExtRmLeafFtraceEvent::~Ext4ExtRmLeafFtraceEvent() = default;
Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(const Ext4ExtRmLeafFtraceEvent&) = default;
Ext4ExtRmLeafFtraceEvent& Ext4ExtRmLeafFtraceEvent::operator=(const Ext4ExtRmLeafFtraceEvent&) = default;
Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(Ext4ExtRmLeafFtraceEvent&&) noexcept = default;
Ext4ExtRmLeafFtraceEvent& Ext4ExtRmLeafFtraceEvent::operator=(Ext4ExtRmLeafFtraceEvent&&) = default;

bool Ext4ExtRmLeafFtraceEvent::operator==(const Ext4ExtRmLeafFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && partial_ == other.partial_
   && start_ == other.start_
   && ee_lblk_ == other.ee_lblk_
   && ee_pblk_ == other.ee_pblk_
   && ee_len_ == other.ee_len_;
}

bool Ext4ExtRmLeafFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* partial */:
        field.get(&partial_);
        break;
      case 4 /* start */:
        field.get(&start_);
        break;
      case 5 /* ee_lblk */:
        field.get(&ee_lblk_);
        break;
      case 6 /* ee_pblk */:
        field.get(&ee_pblk_);
        break;
      case 7 /* ee_len */:
        field.get(&ee_len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtRmLeafFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtRmLeafFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtRmLeafFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: partial
  if (_has_field_[3]) {
    msg->AppendVarInt(3, partial_);
  }

  // Field 4: start
  if (_has_field_[4]) {
    msg->AppendVarInt(4, start_);
  }

  // Field 5: ee_lblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, ee_lblk_);
  }

  // Field 6: ee_pblk
  if (_has_field_[6]) {
    msg->AppendVarInt(6, ee_pblk_);
  }

  // Field 7: ee_len
  if (_has_field_[7]) {
    msg->AppendVarInt(7, ee_len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent() = default;
Ext4ExtRmIdxFtraceEvent::~Ext4ExtRmIdxFtraceEvent() = default;
Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(const Ext4ExtRmIdxFtraceEvent&) = default;
Ext4ExtRmIdxFtraceEvent& Ext4ExtRmIdxFtraceEvent::operator=(const Ext4ExtRmIdxFtraceEvent&) = default;
Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(Ext4ExtRmIdxFtraceEvent&&) noexcept = default;
Ext4ExtRmIdxFtraceEvent& Ext4ExtRmIdxFtraceEvent::operator=(Ext4ExtRmIdxFtraceEvent&&) = default;

bool Ext4ExtRmIdxFtraceEvent::operator==(const Ext4ExtRmIdxFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pblk_ == other.pblk_;
}

bool Ext4ExtRmIdxFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pblk */:
        field.get(&pblk_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtRmIdxFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtRmIdxFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtRmIdxFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pblk_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent() = default;
Ext4ExtRemoveSpaceDoneFtraceEvent::~Ext4ExtRemoveSpaceDoneFtraceEvent() = default;
Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(const Ext4ExtRemoveSpaceDoneFtraceEvent&) = default;
Ext4ExtRemoveSpaceDoneFtraceEvent& Ext4ExtRemoveSpaceDoneFtraceEvent::operator=(const Ext4ExtRemoveSpaceDoneFtraceEvent&) = default;
Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(Ext4ExtRemoveSpaceDoneFtraceEvent&&) noexcept = default;
Ext4ExtRemoveSpaceDoneFtraceEvent& Ext4ExtRemoveSpaceDoneFtraceEvent::operator=(Ext4ExtRemoveSpaceDoneFtraceEvent&&) = default;

bool Ext4ExtRemoveSpaceDoneFtraceEvent::operator==(const Ext4ExtRemoveSpaceDoneFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && start_ == other.start_
   && end_ == other.end_
   && depth_ == other.depth_
   && partial_ == other.partial_
   && eh_entries_ == other.eh_entries_;
}

bool Ext4ExtRemoveSpaceDoneFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* start */:
        field.get(&start_);
        break;
      case 4 /* end */:
        field.get(&end_);
        break;
      case 5 /* depth */:
        field.get(&depth_);
        break;
      case 6 /* partial */:
        field.get(&partial_);
        break;
      case 7 /* eh_entries */:
        field.get(&eh_entries_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtRemoveSpaceDoneFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtRemoveSpaceDoneFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: start
  if (_has_field_[3]) {
    msg->AppendVarInt(3, start_);
  }

  // Field 4: end
  if (_has_field_[4]) {
    msg->AppendVarInt(4, end_);
  }

  // Field 5: depth
  if (_has_field_[5]) {
    msg->AppendVarInt(5, depth_);
  }

  // Field 6: partial
  if (_has_field_[6]) {
    msg->AppendVarInt(6, partial_);
  }

  // Field 7: eh_entries
  if (_has_field_[7]) {
    msg->AppendVarInt(7, eh_entries_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent() = default;
Ext4ExtRemoveSpaceFtraceEvent::~Ext4ExtRemoveSpaceFtraceEvent() = default;
Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(const Ext4ExtRemoveSpaceFtraceEvent&) = default;
Ext4ExtRemoveSpaceFtraceEvent& Ext4ExtRemoveSpaceFtraceEvent::operator=(const Ext4ExtRemoveSpaceFtraceEvent&) = default;
Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(Ext4ExtRemoveSpaceFtraceEvent&&) noexcept = default;
Ext4ExtRemoveSpaceFtraceEvent& Ext4ExtRemoveSpaceFtraceEvent::operator=(Ext4ExtRemoveSpaceFtraceEvent&&) = default;

bool Ext4ExtRemoveSpaceFtraceEvent::operator==(const Ext4ExtRemoveSpaceFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && start_ == other.start_
   && end_ == other.end_
   && depth_ == other.depth_;
}

bool Ext4ExtRemoveSpaceFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* start */:
        field.get(&start_);
        break;
      case 4 /* end */:
        field.get(&end_);
        break;
      case 5 /* depth */:
        field.get(&depth_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtRemoveSpaceFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtRemoveSpaceFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtRemoveSpaceFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: start
  if (_has_field_[3]) {
    msg->AppendVarInt(3, start_);
  }

  // Field 4: end
  if (_has_field_[4]) {
    msg->AppendVarInt(4, end_);
  }

  // Field 5: depth
  if (_has_field_[5]) {
    msg->AppendVarInt(5, depth_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent() = default;
Ext4ExtPutInCacheFtraceEvent::~Ext4ExtPutInCacheFtraceEvent() = default;
Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(const Ext4ExtPutInCacheFtraceEvent&) = default;
Ext4ExtPutInCacheFtraceEvent& Ext4ExtPutInCacheFtraceEvent::operator=(const Ext4ExtPutInCacheFtraceEvent&) = default;
Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(Ext4ExtPutInCacheFtraceEvent&&) noexcept = default;
Ext4ExtPutInCacheFtraceEvent& Ext4ExtPutInCacheFtraceEvent::operator=(Ext4ExtPutInCacheFtraceEvent&&) = default;

bool Ext4ExtPutInCacheFtraceEvent::operator==(const Ext4ExtPutInCacheFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && start_ == other.start_;
}

bool Ext4ExtPutInCacheFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* start */:
        field.get(&start_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtPutInCacheFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtPutInCacheFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtPutInCacheFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: start
  if (_has_field_[5]) {
    msg->AppendVarInt(5, start_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent() = default;
Ext4ExtMapBlocksExitFtraceEvent::~Ext4ExtMapBlocksExitFtraceEvent() = default;
Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(const Ext4ExtMapBlocksExitFtraceEvent&) = default;
Ext4ExtMapBlocksExitFtraceEvent& Ext4ExtMapBlocksExitFtraceEvent::operator=(const Ext4ExtMapBlocksExitFtraceEvent&) = default;
Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(Ext4ExtMapBlocksExitFtraceEvent&&) noexcept = default;
Ext4ExtMapBlocksExitFtraceEvent& Ext4ExtMapBlocksExitFtraceEvent::operator=(Ext4ExtMapBlocksExitFtraceEvent&&) = default;

bool Ext4ExtMapBlocksExitFtraceEvent::operator==(const Ext4ExtMapBlocksExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && flags_ == other.flags_
   && pblk_ == other.pblk_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && mflags_ == other.mflags_
   && ret_ == other.ret_;
}

bool Ext4ExtMapBlocksExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* flags */:
        field.get(&flags_);
        break;
      case 4 /* pblk */:
        field.get(&pblk_);
        break;
      case 5 /* lblk */:
        field.get(&lblk_);
        break;
      case 6 /* len */:
        field.get(&len_);
        break;
      case 7 /* mflags */:
        field.get(&mflags_);
        break;
      case 8 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtMapBlocksExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtMapBlocksExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtMapBlocksExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: flags
  if (_has_field_[3]) {
    msg->AppendVarInt(3, flags_);
  }

  // Field 4: pblk
  if (_has_field_[4]) {
    msg->AppendVarInt(4, pblk_);
  }

  // Field 5: lblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, lblk_);
  }

  // Field 6: len
  if (_has_field_[6]) {
    msg->AppendVarInt(6, len_);
  }

  // Field 7: mflags
  if (_has_field_[7]) {
    msg->AppendVarInt(7, mflags_);
  }

  // Field 8: ret
  if (_has_field_[8]) {
    msg->AppendVarInt(8, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent() = default;
Ext4ExtMapBlocksEnterFtraceEvent::~Ext4ExtMapBlocksEnterFtraceEvent() = default;
Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(const Ext4ExtMapBlocksEnterFtraceEvent&) = default;
Ext4ExtMapBlocksEnterFtraceEvent& Ext4ExtMapBlocksEnterFtraceEvent::operator=(const Ext4ExtMapBlocksEnterFtraceEvent&) = default;
Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(Ext4ExtMapBlocksEnterFtraceEvent&&) noexcept = default;
Ext4ExtMapBlocksEnterFtraceEvent& Ext4ExtMapBlocksEnterFtraceEvent::operator=(Ext4ExtMapBlocksEnterFtraceEvent&&) = default;

bool Ext4ExtMapBlocksEnterFtraceEvent::operator==(const Ext4ExtMapBlocksEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && flags_ == other.flags_;
}

bool Ext4ExtMapBlocksEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtMapBlocksEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtMapBlocksEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtMapBlocksEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent() = default;
Ext4ExtLoadExtentFtraceEvent::~Ext4ExtLoadExtentFtraceEvent() = default;
Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(const Ext4ExtLoadExtentFtraceEvent&) = default;
Ext4ExtLoadExtentFtraceEvent& Ext4ExtLoadExtentFtraceEvent::operator=(const Ext4ExtLoadExtentFtraceEvent&) = default;
Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(Ext4ExtLoadExtentFtraceEvent&&) noexcept = default;
Ext4ExtLoadExtentFtraceEvent& Ext4ExtLoadExtentFtraceEvent::operator=(Ext4ExtLoadExtentFtraceEvent&&) = default;

bool Ext4ExtLoadExtentFtraceEvent::operator==(const Ext4ExtLoadExtentFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pblk_ == other.pblk_
   && lblk_ == other.lblk_;
}

bool Ext4ExtLoadExtentFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pblk */:
        field.get(&pblk_);
        break;
      case 4 /* lblk */:
        field.get(&lblk_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtLoadExtentFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtLoadExtentFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtLoadExtentFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pblk_);
  }

  // Field 4: lblk
  if (_has_field_[4]) {
    msg->AppendVarInt(4, lblk_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent() = default;
Ext4ExtInCacheFtraceEvent::~Ext4ExtInCacheFtraceEvent() = default;
Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(const Ext4ExtInCacheFtraceEvent&) = default;
Ext4ExtInCacheFtraceEvent& Ext4ExtInCacheFtraceEvent::operator=(const Ext4ExtInCacheFtraceEvent&) = default;
Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(Ext4ExtInCacheFtraceEvent&&) noexcept = default;
Ext4ExtInCacheFtraceEvent& Ext4ExtInCacheFtraceEvent::operator=(Ext4ExtInCacheFtraceEvent&&) = default;

bool Ext4ExtInCacheFtraceEvent::operator==(const Ext4ExtInCacheFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && ret_ == other.ret_;
}

bool Ext4ExtInCacheFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtInCacheFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtInCacheFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtInCacheFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: ret
  if (_has_field_[4]) {
    msg->AppendVarInt(4, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent() = default;
Ext4ExtHandleUnwrittenExtentsFtraceEvent::~Ext4ExtHandleUnwrittenExtentsFtraceEvent() = default;
Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(const Ext4ExtHandleUnwrittenExtentsFtraceEvent&) = default;
Ext4ExtHandleUnwrittenExtentsFtraceEvent& Ext4ExtHandleUnwrittenExtentsFtraceEvent::operator=(const Ext4ExtHandleUnwrittenExtentsFtraceEvent&) = default;
Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(Ext4ExtHandleUnwrittenExtentsFtraceEvent&&) noexcept = default;
Ext4ExtHandleUnwrittenExtentsFtraceEvent& Ext4ExtHandleUnwrittenExtentsFtraceEvent::operator=(Ext4ExtHandleUnwrittenExtentsFtraceEvent&&) = default;

bool Ext4ExtHandleUnwrittenExtentsFtraceEvent::operator==(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && flags_ == other.flags_
   && lblk_ == other.lblk_
   && pblk_ == other.pblk_
   && len_ == other.len_
   && allocated_ == other.allocated_
   && newblk_ == other.newblk_;
}

bool Ext4ExtHandleUnwrittenExtentsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* flags */:
        field.get(&flags_);
        break;
      case 4 /* lblk */:
        field.get(&lblk_);
        break;
      case 5 /* pblk */:
        field.get(&pblk_);
        break;
      case 6 /* len */:
        field.get(&len_);
        break;
      case 7 /* allocated */:
        field.get(&allocated_);
        break;
      case 8 /* newblk */:
        field.get(&newblk_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtHandleUnwrittenExtentsFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtHandleUnwrittenExtentsFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: flags
  if (_has_field_[3]) {
    msg->AppendVarInt(3, flags_);
  }

  // Field 4: lblk
  if (_has_field_[4]) {
    msg->AppendVarInt(4, lblk_);
  }

  // Field 5: pblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pblk_);
  }

  // Field 6: len
  if (_has_field_[6]) {
    msg->AppendVarInt(6, len_);
  }

  // Field 7: allocated
  if (_has_field_[7]) {
    msg->AppendVarInt(7, allocated_);
  }

  // Field 8: newblk
  if (_has_field_[8]) {
    msg->AppendVarInt(8, newblk_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent() = default;
Ext4ExtConvertToInitializedFastpathFtraceEvent::~Ext4ExtConvertToInitializedFastpathFtraceEvent() = default;
Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(const Ext4ExtConvertToInitializedFastpathFtraceEvent&) = default;
Ext4ExtConvertToInitializedFastpathFtraceEvent& Ext4ExtConvertToInitializedFastpathFtraceEvent::operator=(const Ext4ExtConvertToInitializedFastpathFtraceEvent&) = default;
Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(Ext4ExtConvertToInitializedFastpathFtraceEvent&&) noexcept = default;
Ext4ExtConvertToInitializedFastpathFtraceEvent& Ext4ExtConvertToInitializedFastpathFtraceEvent::operator=(Ext4ExtConvertToInitializedFastpathFtraceEvent&&) = default;

bool Ext4ExtConvertToInitializedFastpathFtraceEvent::operator==(const Ext4ExtConvertToInitializedFastpathFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && m_lblk_ == other.m_lblk_
   && m_len_ == other.m_len_
   && u_lblk_ == other.u_lblk_
   && u_len_ == other.u_len_
   && u_pblk_ == other.u_pblk_
   && i_lblk_ == other.i_lblk_
   && i_len_ == other.i_len_
   && i_pblk_ == other.i_pblk_;
}

bool Ext4ExtConvertToInitializedFastpathFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* m_lblk */:
        field.get(&m_lblk_);
        break;
      case 4 /* m_len */:
        field.get(&m_len_);
        break;
      case 5 /* u_lblk */:
        field.get(&u_lblk_);
        break;
      case 6 /* u_len */:
        field.get(&u_len_);
        break;
      case 7 /* u_pblk */:
        field.get(&u_pblk_);
        break;
      case 8 /* i_lblk */:
        field.get(&i_lblk_);
        break;
      case 9 /* i_len */:
        field.get(&i_len_);
        break;
      case 10 /* i_pblk */:
        field.get(&i_pblk_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtConvertToInitializedFastpathFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtConvertToInitializedFastpathFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: m_lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, m_lblk_);
  }

  // Field 4: m_len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, m_len_);
  }

  // Field 5: u_lblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, u_lblk_);
  }

  // Field 6: u_len
  if (_has_field_[6]) {
    msg->AppendVarInt(6, u_len_);
  }

  // Field 7: u_pblk
  if (_has_field_[7]) {
    msg->AppendVarInt(7, u_pblk_);
  }

  // Field 8: i_lblk
  if (_has_field_[8]) {
    msg->AppendVarInt(8, i_lblk_);
  }

  // Field 9: i_len
  if (_has_field_[9]) {
    msg->AppendVarInt(9, i_len_);
  }

  // Field 10: i_pblk
  if (_has_field_[10]) {
    msg->AppendVarInt(10, i_pblk_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent() = default;
Ext4ExtConvertToInitializedEnterFtraceEvent::~Ext4ExtConvertToInitializedEnterFtraceEvent() = default;
Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(const Ext4ExtConvertToInitializedEnterFtraceEvent&) = default;
Ext4ExtConvertToInitializedEnterFtraceEvent& Ext4ExtConvertToInitializedEnterFtraceEvent::operator=(const Ext4ExtConvertToInitializedEnterFtraceEvent&) = default;
Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(Ext4ExtConvertToInitializedEnterFtraceEvent&&) noexcept = default;
Ext4ExtConvertToInitializedEnterFtraceEvent& Ext4ExtConvertToInitializedEnterFtraceEvent::operator=(Ext4ExtConvertToInitializedEnterFtraceEvent&&) = default;

bool Ext4ExtConvertToInitializedEnterFtraceEvent::operator==(const Ext4ExtConvertToInitializedEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && m_lblk_ == other.m_lblk_
   && m_len_ == other.m_len_
   && u_lblk_ == other.u_lblk_
   && u_len_ == other.u_len_
   && u_pblk_ == other.u_pblk_;
}

bool Ext4ExtConvertToInitializedEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* m_lblk */:
        field.get(&m_lblk_);
        break;
      case 4 /* m_len */:
        field.get(&m_len_);
        break;
      case 5 /* u_lblk */:
        field.get(&u_lblk_);
        break;
      case 6 /* u_len */:
        field.get(&u_len_);
        break;
      case 7 /* u_pblk */:
        field.get(&u_pblk_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4ExtConvertToInitializedEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4ExtConvertToInitializedEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: m_lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, m_lblk_);
  }

  // Field 4: m_len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, m_len_);
  }

  // Field 5: u_lblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, u_lblk_);
  }

  // Field 6: u_len
  if (_has_field_[6]) {
    msg->AppendVarInt(6, u_len_);
  }

  // Field 7: u_pblk
  if (_has_field_[7]) {
    msg->AppendVarInt(7, u_pblk_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent() = default;
Ext4EvictInodeFtraceEvent::~Ext4EvictInodeFtraceEvent() = default;
Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(const Ext4EvictInodeFtraceEvent&) = default;
Ext4EvictInodeFtraceEvent& Ext4EvictInodeFtraceEvent::operator=(const Ext4EvictInodeFtraceEvent&) = default;
Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(Ext4EvictInodeFtraceEvent&&) noexcept = default;
Ext4EvictInodeFtraceEvent& Ext4EvictInodeFtraceEvent::operator=(Ext4EvictInodeFtraceEvent&&) = default;

bool Ext4EvictInodeFtraceEvent::operator==(const Ext4EvictInodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && nlink_ == other.nlink_;
}

bool Ext4EvictInodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* nlink */:
        field.get(&nlink_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EvictInodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EvictInodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EvictInodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: nlink
  if (_has_field_[3]) {
    msg->AppendVarInt(3, nlink_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent() = default;
Ext4EsShrinkScanExitFtraceEvent::~Ext4EsShrinkScanExitFtraceEvent() = default;
Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(const Ext4EsShrinkScanExitFtraceEvent&) = default;
Ext4EsShrinkScanExitFtraceEvent& Ext4EsShrinkScanExitFtraceEvent::operator=(const Ext4EsShrinkScanExitFtraceEvent&) = default;
Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(Ext4EsShrinkScanExitFtraceEvent&&) noexcept = default;
Ext4EsShrinkScanExitFtraceEvent& Ext4EsShrinkScanExitFtraceEvent::operator=(Ext4EsShrinkScanExitFtraceEvent&&) = default;

bool Ext4EsShrinkScanExitFtraceEvent::operator==(const Ext4EsShrinkScanExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && nr_shrunk_ == other.nr_shrunk_
   && cache_cnt_ == other.cache_cnt_;
}

bool Ext4EsShrinkScanExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* nr_shrunk */:
        field.get(&nr_shrunk_);
        break;
      case 3 /* cache_cnt */:
        field.get(&cache_cnt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsShrinkScanExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsShrinkScanExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsShrinkScanExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: nr_shrunk
  if (_has_field_[2]) {
    msg->AppendVarInt(2, nr_shrunk_);
  }

  // Field 3: cache_cnt
  if (_has_field_[3]) {
    msg->AppendVarInt(3, cache_cnt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent() = default;
Ext4EsShrinkScanEnterFtraceEvent::~Ext4EsShrinkScanEnterFtraceEvent() = default;
Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(const Ext4EsShrinkScanEnterFtraceEvent&) = default;
Ext4EsShrinkScanEnterFtraceEvent& Ext4EsShrinkScanEnterFtraceEvent::operator=(const Ext4EsShrinkScanEnterFtraceEvent&) = default;
Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(Ext4EsShrinkScanEnterFtraceEvent&&) noexcept = default;
Ext4EsShrinkScanEnterFtraceEvent& Ext4EsShrinkScanEnterFtraceEvent::operator=(Ext4EsShrinkScanEnterFtraceEvent&&) = default;

bool Ext4EsShrinkScanEnterFtraceEvent::operator==(const Ext4EsShrinkScanEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && nr_to_scan_ == other.nr_to_scan_
   && cache_cnt_ == other.cache_cnt_;
}

bool Ext4EsShrinkScanEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* nr_to_scan */:
        field.get(&nr_to_scan_);
        break;
      case 3 /* cache_cnt */:
        field.get(&cache_cnt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsShrinkScanEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsShrinkScanEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsShrinkScanEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: nr_to_scan
  if (_has_field_[2]) {
    msg->AppendVarInt(2, nr_to_scan_);
  }

  // Field 3: cache_cnt
  if (_has_field_[3]) {
    msg->AppendVarInt(3, cache_cnt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent() = default;
Ext4EsShrinkCountFtraceEvent::~Ext4EsShrinkCountFtraceEvent() = default;
Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(const Ext4EsShrinkCountFtraceEvent&) = default;
Ext4EsShrinkCountFtraceEvent& Ext4EsShrinkCountFtraceEvent::operator=(const Ext4EsShrinkCountFtraceEvent&) = default;
Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(Ext4EsShrinkCountFtraceEvent&&) noexcept = default;
Ext4EsShrinkCountFtraceEvent& Ext4EsShrinkCountFtraceEvent::operator=(Ext4EsShrinkCountFtraceEvent&&) = default;

bool Ext4EsShrinkCountFtraceEvent::operator==(const Ext4EsShrinkCountFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && nr_to_scan_ == other.nr_to_scan_
   && cache_cnt_ == other.cache_cnt_;
}

bool Ext4EsShrinkCountFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* nr_to_scan */:
        field.get(&nr_to_scan_);
        break;
      case 3 /* cache_cnt */:
        field.get(&cache_cnt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsShrinkCountFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsShrinkCountFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsShrinkCountFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: nr_to_scan
  if (_has_field_[2]) {
    msg->AppendVarInt(2, nr_to_scan_);
  }

  // Field 3: cache_cnt
  if (_has_field_[3]) {
    msg->AppendVarInt(3, cache_cnt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent() = default;
Ext4EsShrinkFtraceEvent::~Ext4EsShrinkFtraceEvent() = default;
Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(const Ext4EsShrinkFtraceEvent&) = default;
Ext4EsShrinkFtraceEvent& Ext4EsShrinkFtraceEvent::operator=(const Ext4EsShrinkFtraceEvent&) = default;
Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(Ext4EsShrinkFtraceEvent&&) noexcept = default;
Ext4EsShrinkFtraceEvent& Ext4EsShrinkFtraceEvent::operator=(Ext4EsShrinkFtraceEvent&&) = default;

bool Ext4EsShrinkFtraceEvent::operator==(const Ext4EsShrinkFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && nr_shrunk_ == other.nr_shrunk_
   && scan_time_ == other.scan_time_
   && nr_skipped_ == other.nr_skipped_
   && retried_ == other.retried_;
}

bool Ext4EsShrinkFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* nr_shrunk */:
        field.get(&nr_shrunk_);
        break;
      case 3 /* scan_time */:
        field.get(&scan_time_);
        break;
      case 4 /* nr_skipped */:
        field.get(&nr_skipped_);
        break;
      case 5 /* retried */:
        field.get(&retried_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsShrinkFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsShrinkFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsShrinkFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: nr_shrunk
  if (_has_field_[2]) {
    msg->AppendVarInt(2, nr_shrunk_);
  }

  // Field 3: scan_time
  if (_has_field_[3]) {
    msg->AppendVarInt(3, scan_time_);
  }

  // Field 4: nr_skipped
  if (_has_field_[4]) {
    msg->AppendVarInt(4, nr_skipped_);
  }

  // Field 5: retried
  if (_has_field_[5]) {
    msg->AppendVarInt(5, retried_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent() = default;
Ext4EsRemoveExtentFtraceEvent::~Ext4EsRemoveExtentFtraceEvent() = default;
Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(const Ext4EsRemoveExtentFtraceEvent&) = default;
Ext4EsRemoveExtentFtraceEvent& Ext4EsRemoveExtentFtraceEvent::operator=(const Ext4EsRemoveExtentFtraceEvent&) = default;
Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(Ext4EsRemoveExtentFtraceEvent&&) noexcept = default;
Ext4EsRemoveExtentFtraceEvent& Ext4EsRemoveExtentFtraceEvent::operator=(Ext4EsRemoveExtentFtraceEvent&&) = default;

bool Ext4EsRemoveExtentFtraceEvent::operator==(const Ext4EsRemoveExtentFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_;
}

bool Ext4EsRemoveExtentFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsRemoveExtentFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsRemoveExtentFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsRemoveExtentFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent() = default;
Ext4EsLookupExtentExitFtraceEvent::~Ext4EsLookupExtentExitFtraceEvent() = default;
Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(const Ext4EsLookupExtentExitFtraceEvent&) = default;
Ext4EsLookupExtentExitFtraceEvent& Ext4EsLookupExtentExitFtraceEvent::operator=(const Ext4EsLookupExtentExitFtraceEvent&) = default;
Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(Ext4EsLookupExtentExitFtraceEvent&&) noexcept = default;
Ext4EsLookupExtentExitFtraceEvent& Ext4EsLookupExtentExitFtraceEvent::operator=(Ext4EsLookupExtentExitFtraceEvent&&) = default;

bool Ext4EsLookupExtentExitFtraceEvent::operator==(const Ext4EsLookupExtentExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && pblk_ == other.pblk_
   && status_ == other.status_
   && found_ == other.found_;
}

bool Ext4EsLookupExtentExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* pblk */:
        field.get(&pblk_);
        break;
      case 6 /* status */:
        field.get(&status_);
        break;
      case 7 /* found */:
        field.get(&found_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsLookupExtentExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsLookupExtentExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsLookupExtentExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: pblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pblk_);
  }

  // Field 6: status
  if (_has_field_[6]) {
    msg->AppendVarInt(6, status_);
  }

  // Field 7: found
  if (_has_field_[7]) {
    msg->AppendVarInt(7, found_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent() = default;
Ext4EsLookupExtentEnterFtraceEvent::~Ext4EsLookupExtentEnterFtraceEvent() = default;
Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(const Ext4EsLookupExtentEnterFtraceEvent&) = default;
Ext4EsLookupExtentEnterFtraceEvent& Ext4EsLookupExtentEnterFtraceEvent::operator=(const Ext4EsLookupExtentEnterFtraceEvent&) = default;
Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(Ext4EsLookupExtentEnterFtraceEvent&&) noexcept = default;
Ext4EsLookupExtentEnterFtraceEvent& Ext4EsLookupExtentEnterFtraceEvent::operator=(Ext4EsLookupExtentEnterFtraceEvent&&) = default;

bool Ext4EsLookupExtentEnterFtraceEvent::operator==(const Ext4EsLookupExtentEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_;
}

bool Ext4EsLookupExtentEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsLookupExtentEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsLookupExtentEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsLookupExtentEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent() = default;
Ext4EsInsertExtentFtraceEvent::~Ext4EsInsertExtentFtraceEvent() = default;
Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(const Ext4EsInsertExtentFtraceEvent&) = default;
Ext4EsInsertExtentFtraceEvent& Ext4EsInsertExtentFtraceEvent::operator=(const Ext4EsInsertExtentFtraceEvent&) = default;
Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(Ext4EsInsertExtentFtraceEvent&&) noexcept = default;
Ext4EsInsertExtentFtraceEvent& Ext4EsInsertExtentFtraceEvent::operator=(Ext4EsInsertExtentFtraceEvent&&) = default;

bool Ext4EsInsertExtentFtraceEvent::operator==(const Ext4EsInsertExtentFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && pblk_ == other.pblk_
   && status_ == other.status_;
}

bool Ext4EsInsertExtentFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* pblk */:
        field.get(&pblk_);
        break;
      case 6 /* status */:
        field.get(&status_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsInsertExtentFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsInsertExtentFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsInsertExtentFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: pblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pblk_);
  }

  // Field 6: status
  if (_has_field_[6]) {
    msg->AppendVarInt(6, status_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent() = default;
Ext4EsFindDelayedExtentRangeExitFtraceEvent::~Ext4EsFindDelayedExtentRangeExitFtraceEvent() = default;
Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(const Ext4EsFindDelayedExtentRangeExitFtraceEvent&) = default;
Ext4EsFindDelayedExtentRangeExitFtraceEvent& Ext4EsFindDelayedExtentRangeExitFtraceEvent::operator=(const Ext4EsFindDelayedExtentRangeExitFtraceEvent&) = default;
Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(Ext4EsFindDelayedExtentRangeExitFtraceEvent&&) noexcept = default;
Ext4EsFindDelayedExtentRangeExitFtraceEvent& Ext4EsFindDelayedExtentRangeExitFtraceEvent::operator=(Ext4EsFindDelayedExtentRangeExitFtraceEvent&&) = default;

bool Ext4EsFindDelayedExtentRangeExitFtraceEvent::operator==(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && pblk_ == other.pblk_
   && status_ == other.status_;
}

bool Ext4EsFindDelayedExtentRangeExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* pblk */:
        field.get(&pblk_);
        break;
      case 6 /* status */:
        field.get(&status_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsFindDelayedExtentRangeExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsFindDelayedExtentRangeExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: pblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pblk_);
  }

  // Field 6: status
  if (_has_field_[6]) {
    msg->AppendVarInt(6, status_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent() = default;
Ext4EsFindDelayedExtentRangeEnterFtraceEvent::~Ext4EsFindDelayedExtentRangeEnterFtraceEvent() = default;
Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent&) = default;
Ext4EsFindDelayedExtentRangeEnterFtraceEvent& Ext4EsFindDelayedExtentRangeEnterFtraceEvent::operator=(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent&) = default;
Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(Ext4EsFindDelayedExtentRangeEnterFtraceEvent&&) noexcept = default;
Ext4EsFindDelayedExtentRangeEnterFtraceEvent& Ext4EsFindDelayedExtentRangeEnterFtraceEvent::operator=(Ext4EsFindDelayedExtentRangeEnterFtraceEvent&&) = default;

bool Ext4EsFindDelayedExtentRangeEnterFtraceEvent::operator==(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_;
}

bool Ext4EsFindDelayedExtentRangeEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent() = default;
Ext4EsCacheExtentFtraceEvent::~Ext4EsCacheExtentFtraceEvent() = default;
Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(const Ext4EsCacheExtentFtraceEvent&) = default;
Ext4EsCacheExtentFtraceEvent& Ext4EsCacheExtentFtraceEvent::operator=(const Ext4EsCacheExtentFtraceEvent&) = default;
Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(Ext4EsCacheExtentFtraceEvent&&) noexcept = default;
Ext4EsCacheExtentFtraceEvent& Ext4EsCacheExtentFtraceEvent::operator=(Ext4EsCacheExtentFtraceEvent&&) = default;

bool Ext4EsCacheExtentFtraceEvent::operator==(const Ext4EsCacheExtentFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && pblk_ == other.pblk_
   && status_ == other.status_;
}

bool Ext4EsCacheExtentFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* pblk */:
        field.get(&pblk_);
        break;
      case 6 /* status */:
        field.get(&status_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4EsCacheExtentFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4EsCacheExtentFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4EsCacheExtentFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: pblk
  if (_has_field_[5]) {
    msg->AppendVarInt(5, pblk_);
  }

  // Field 6: status
  if (_has_field_[6]) {
    msg->AppendVarInt(6, status_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent() = default;
Ext4DropInodeFtraceEvent::~Ext4DropInodeFtraceEvent() = default;
Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(const Ext4DropInodeFtraceEvent&) = default;
Ext4DropInodeFtraceEvent& Ext4DropInodeFtraceEvent::operator=(const Ext4DropInodeFtraceEvent&) = default;
Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(Ext4DropInodeFtraceEvent&&) noexcept = default;
Ext4DropInodeFtraceEvent& Ext4DropInodeFtraceEvent::operator=(Ext4DropInodeFtraceEvent&&) = default;

bool Ext4DropInodeFtraceEvent::operator==(const Ext4DropInodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && drop_ == other.drop_;
}

bool Ext4DropInodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* drop */:
        field.get(&drop_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DropInodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DropInodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DropInodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: drop
  if (_has_field_[3]) {
    msg->AppendVarInt(3, drop_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent() = default;
Ext4DiscardPreallocationsFtraceEvent::~Ext4DiscardPreallocationsFtraceEvent() = default;
Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(const Ext4DiscardPreallocationsFtraceEvent&) = default;
Ext4DiscardPreallocationsFtraceEvent& Ext4DiscardPreallocationsFtraceEvent::operator=(const Ext4DiscardPreallocationsFtraceEvent&) = default;
Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(Ext4DiscardPreallocationsFtraceEvent&&) noexcept = default;
Ext4DiscardPreallocationsFtraceEvent& Ext4DiscardPreallocationsFtraceEvent::operator=(Ext4DiscardPreallocationsFtraceEvent&&) = default;

bool Ext4DiscardPreallocationsFtraceEvent::operator==(const Ext4DiscardPreallocationsFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_;
}

bool Ext4DiscardPreallocationsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DiscardPreallocationsFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DiscardPreallocationsFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DiscardPreallocationsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent() = default;
Ext4DiscardBlocksFtraceEvent::~Ext4DiscardBlocksFtraceEvent() = default;
Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(const Ext4DiscardBlocksFtraceEvent&) = default;
Ext4DiscardBlocksFtraceEvent& Ext4DiscardBlocksFtraceEvent::operator=(const Ext4DiscardBlocksFtraceEvent&) = default;
Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(Ext4DiscardBlocksFtraceEvent&&) noexcept = default;
Ext4DiscardBlocksFtraceEvent& Ext4DiscardBlocksFtraceEvent::operator=(Ext4DiscardBlocksFtraceEvent&&) = default;

bool Ext4DiscardBlocksFtraceEvent::operator==(const Ext4DiscardBlocksFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && blk_ == other.blk_
   && count_ == other.count_;
}

bool Ext4DiscardBlocksFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* blk */:
        field.get(&blk_);
        break;
      case 3 /* count */:
        field.get(&count_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DiscardBlocksFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DiscardBlocksFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DiscardBlocksFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: blk
  if (_has_field_[2]) {
    msg->AppendVarInt(2, blk_);
  }

  // Field 3: count
  if (_has_field_[3]) {
    msg->AppendVarInt(3, count_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent() = default;
Ext4DirectIOExitFtraceEvent::~Ext4DirectIOExitFtraceEvent() = default;
Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(const Ext4DirectIOExitFtraceEvent&) = default;
Ext4DirectIOExitFtraceEvent& Ext4DirectIOExitFtraceEvent::operator=(const Ext4DirectIOExitFtraceEvent&) = default;
Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(Ext4DirectIOExitFtraceEvent&&) noexcept = default;
Ext4DirectIOExitFtraceEvent& Ext4DirectIOExitFtraceEvent::operator=(Ext4DirectIOExitFtraceEvent&&) = default;

bool Ext4DirectIOExitFtraceEvent::operator==(const Ext4DirectIOExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && rw_ == other.rw_
   && ret_ == other.ret_;
}

bool Ext4DirectIOExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* rw */:
        field.get(&rw_);
        break;
      case 6 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DirectIOExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DirectIOExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DirectIOExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: rw
  if (_has_field_[5]) {
    msg->AppendVarInt(5, rw_);
  }

  // Field 6: ret
  if (_has_field_[6]) {
    msg->AppendVarInt(6, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent() = default;
Ext4DirectIOEnterFtraceEvent::~Ext4DirectIOEnterFtraceEvent() = default;
Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(const Ext4DirectIOEnterFtraceEvent&) = default;
Ext4DirectIOEnterFtraceEvent& Ext4DirectIOEnterFtraceEvent::operator=(const Ext4DirectIOEnterFtraceEvent&) = default;
Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(Ext4DirectIOEnterFtraceEvent&&) noexcept = default;
Ext4DirectIOEnterFtraceEvent& Ext4DirectIOEnterFtraceEvent::operator=(Ext4DirectIOEnterFtraceEvent&&) = default;

bool Ext4DirectIOEnterFtraceEvent::operator==(const Ext4DirectIOEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && rw_ == other.rw_;
}

bool Ext4DirectIOEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* rw */:
        field.get(&rw_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DirectIOEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DirectIOEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DirectIOEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: rw
  if (_has_field_[5]) {
    msg->AppendVarInt(5, rw_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent() = default;
Ext4DaWritePagesExtentFtraceEvent::~Ext4DaWritePagesExtentFtraceEvent() = default;
Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(const Ext4DaWritePagesExtentFtraceEvent&) = default;
Ext4DaWritePagesExtentFtraceEvent& Ext4DaWritePagesExtentFtraceEvent::operator=(const Ext4DaWritePagesExtentFtraceEvent&) = default;
Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(Ext4DaWritePagesExtentFtraceEvent&&) noexcept = default;
Ext4DaWritePagesExtentFtraceEvent& Ext4DaWritePagesExtentFtraceEvent::operator=(Ext4DaWritePagesExtentFtraceEvent&&) = default;

bool Ext4DaWritePagesExtentFtraceEvent::operator==(const Ext4DaWritePagesExtentFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && lblk_ == other.lblk_
   && len_ == other.len_
   && flags_ == other.flags_;
}

bool Ext4DaWritePagesExtentFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* lblk */:
        field.get(&lblk_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DaWritePagesExtentFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DaWritePagesExtentFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DaWritePagesExtentFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: lblk
  if (_has_field_[3]) {
    msg->AppendVarInt(3, lblk_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent() = default;
Ext4DaWritePagesFtraceEvent::~Ext4DaWritePagesFtraceEvent() = default;
Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(const Ext4DaWritePagesFtraceEvent&) = default;
Ext4DaWritePagesFtraceEvent& Ext4DaWritePagesFtraceEvent::operator=(const Ext4DaWritePagesFtraceEvent&) = default;
Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(Ext4DaWritePagesFtraceEvent&&) noexcept = default;
Ext4DaWritePagesFtraceEvent& Ext4DaWritePagesFtraceEvent::operator=(Ext4DaWritePagesFtraceEvent&&) = default;

bool Ext4DaWritePagesFtraceEvent::operator==(const Ext4DaWritePagesFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && first_page_ == other.first_page_
   && nr_to_write_ == other.nr_to_write_
   && sync_mode_ == other.sync_mode_
   && b_blocknr_ == other.b_blocknr_
   && b_size_ == other.b_size_
   && b_state_ == other.b_state_
   && io_done_ == other.io_done_
   && pages_written_ == other.pages_written_;
}

bool Ext4DaWritePagesFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* first_page */:
        field.get(&first_page_);
        break;
      case 4 /* nr_to_write */:
        field.get(&nr_to_write_);
        break;
      case 5 /* sync_mode */:
        field.get(&sync_mode_);
        break;
      case 6 /* b_blocknr */:
        field.get(&b_blocknr_);
        break;
      case 7 /* b_size */:
        field.get(&b_size_);
        break;
      case 8 /* b_state */:
        field.get(&b_state_);
        break;
      case 9 /* io_done */:
        field.get(&io_done_);
        break;
      case 10 /* pages_written */:
        field.get(&pages_written_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DaWritePagesFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DaWritePagesFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DaWritePagesFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: first_page
  if (_has_field_[3]) {
    msg->AppendVarInt(3, first_page_);
  }

  // Field 4: nr_to_write
  if (_has_field_[4]) {
    msg->AppendVarInt(4, nr_to_write_);
  }

  // Field 5: sync_mode
  if (_has_field_[5]) {
    msg->AppendVarInt(5, sync_mode_);
  }

  // Field 6: b_blocknr
  if (_has_field_[6]) {
    msg->AppendVarInt(6, b_blocknr_);
  }

  // Field 7: b_size
  if (_has_field_[7]) {
    msg->AppendVarInt(7, b_size_);
  }

  // Field 8: b_state
  if (_has_field_[8]) {
    msg->AppendVarInt(8, b_state_);
  }

  // Field 9: io_done
  if (_has_field_[9]) {
    msg->AppendVarInt(9, io_done_);
  }

  // Field 10: pages_written
  if (_has_field_[10]) {
    msg->AppendVarInt(10, pages_written_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent() = default;
Ext4DaUpdateReserveSpaceFtraceEvent::~Ext4DaUpdateReserveSpaceFtraceEvent() = default;
Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(const Ext4DaUpdateReserveSpaceFtraceEvent&) = default;
Ext4DaUpdateReserveSpaceFtraceEvent& Ext4DaUpdateReserveSpaceFtraceEvent::operator=(const Ext4DaUpdateReserveSpaceFtraceEvent&) = default;
Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(Ext4DaUpdateReserveSpaceFtraceEvent&&) noexcept = default;
Ext4DaUpdateReserveSpaceFtraceEvent& Ext4DaUpdateReserveSpaceFtraceEvent::operator=(Ext4DaUpdateReserveSpaceFtraceEvent&&) = default;

bool Ext4DaUpdateReserveSpaceFtraceEvent::operator==(const Ext4DaUpdateReserveSpaceFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && i_blocks_ == other.i_blocks_
   && used_blocks_ == other.used_blocks_
   && reserved_data_blocks_ == other.reserved_data_blocks_
   && reserved_meta_blocks_ == other.reserved_meta_blocks_
   && allocated_meta_blocks_ == other.allocated_meta_blocks_
   && quota_claim_ == other.quota_claim_
   && mode_ == other.mode_;
}

bool Ext4DaUpdateReserveSpaceFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* i_blocks */:
        field.get(&i_blocks_);
        break;
      case 4 /* used_blocks */:
        field.get(&used_blocks_);
        break;
      case 5 /* reserved_data_blocks */:
        field.get(&reserved_data_blocks_);
        break;
      case 6 /* reserved_meta_blocks */:
        field.get(&reserved_meta_blocks_);
        break;
      case 7 /* allocated_meta_blocks */:
        field.get(&allocated_meta_blocks_);
        break;
      case 8 /* quota_claim */:
        field.get(&quota_claim_);
        break;
      case 9 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DaUpdateReserveSpaceFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DaUpdateReserveSpaceFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DaUpdateReserveSpaceFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: i_blocks
  if (_has_field_[3]) {
    msg->AppendVarInt(3, i_blocks_);
  }

  // Field 4: used_blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, used_blocks_);
  }

  // Field 5: reserved_data_blocks
  if (_has_field_[5]) {
    msg->AppendVarInt(5, reserved_data_blocks_);
  }

  // Field 6: reserved_meta_blocks
  if (_has_field_[6]) {
    msg->AppendVarInt(6, reserved_meta_blocks_);
  }

  // Field 7: allocated_meta_blocks
  if (_has_field_[7]) {
    msg->AppendVarInt(7, allocated_meta_blocks_);
  }

  // Field 8: quota_claim
  if (_has_field_[8]) {
    msg->AppendVarInt(8, quota_claim_);
  }

  // Field 9: mode
  if (_has_field_[9]) {
    msg->AppendVarInt(9, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent() = default;
Ext4DaReserveSpaceFtraceEvent::~Ext4DaReserveSpaceFtraceEvent() = default;
Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(const Ext4DaReserveSpaceFtraceEvent&) = default;
Ext4DaReserveSpaceFtraceEvent& Ext4DaReserveSpaceFtraceEvent::operator=(const Ext4DaReserveSpaceFtraceEvent&) = default;
Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(Ext4DaReserveSpaceFtraceEvent&&) noexcept = default;
Ext4DaReserveSpaceFtraceEvent& Ext4DaReserveSpaceFtraceEvent::operator=(Ext4DaReserveSpaceFtraceEvent&&) = default;

bool Ext4DaReserveSpaceFtraceEvent::operator==(const Ext4DaReserveSpaceFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && i_blocks_ == other.i_blocks_
   && reserved_data_blocks_ == other.reserved_data_blocks_
   && reserved_meta_blocks_ == other.reserved_meta_blocks_
   && mode_ == other.mode_
   && md_needed_ == other.md_needed_;
}

bool Ext4DaReserveSpaceFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* i_blocks */:
        field.get(&i_blocks_);
        break;
      case 4 /* reserved_data_blocks */:
        field.get(&reserved_data_blocks_);
        break;
      case 5 /* reserved_meta_blocks */:
        field.get(&reserved_meta_blocks_);
        break;
      case 6 /* mode */:
        field.get(&mode_);
        break;
      case 7 /* md_needed */:
        field.get(&md_needed_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DaReserveSpaceFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DaReserveSpaceFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DaReserveSpaceFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: i_blocks
  if (_has_field_[3]) {
    msg->AppendVarInt(3, i_blocks_);
  }

  // Field 4: reserved_data_blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, reserved_data_blocks_);
  }

  // Field 5: reserved_meta_blocks
  if (_has_field_[5]) {
    msg->AppendVarInt(5, reserved_meta_blocks_);
  }

  // Field 6: mode
  if (_has_field_[6]) {
    msg->AppendVarInt(6, mode_);
  }

  // Field 7: md_needed
  if (_has_field_[7]) {
    msg->AppendVarInt(7, md_needed_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent() = default;
Ext4DaReleaseSpaceFtraceEvent::~Ext4DaReleaseSpaceFtraceEvent() = default;
Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(const Ext4DaReleaseSpaceFtraceEvent&) = default;
Ext4DaReleaseSpaceFtraceEvent& Ext4DaReleaseSpaceFtraceEvent::operator=(const Ext4DaReleaseSpaceFtraceEvent&) = default;
Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(Ext4DaReleaseSpaceFtraceEvent&&) noexcept = default;
Ext4DaReleaseSpaceFtraceEvent& Ext4DaReleaseSpaceFtraceEvent::operator=(Ext4DaReleaseSpaceFtraceEvent&&) = default;

bool Ext4DaReleaseSpaceFtraceEvent::operator==(const Ext4DaReleaseSpaceFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && i_blocks_ == other.i_blocks_
   && freed_blocks_ == other.freed_blocks_
   && reserved_data_blocks_ == other.reserved_data_blocks_
   && reserved_meta_blocks_ == other.reserved_meta_blocks_
   && allocated_meta_blocks_ == other.allocated_meta_blocks_
   && mode_ == other.mode_;
}

bool Ext4DaReleaseSpaceFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* i_blocks */:
        field.get(&i_blocks_);
        break;
      case 4 /* freed_blocks */:
        field.get(&freed_blocks_);
        break;
      case 5 /* reserved_data_blocks */:
        field.get(&reserved_data_blocks_);
        break;
      case 6 /* reserved_meta_blocks */:
        field.get(&reserved_meta_blocks_);
        break;
      case 7 /* allocated_meta_blocks */:
        field.get(&allocated_meta_blocks_);
        break;
      case 8 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DaReleaseSpaceFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DaReleaseSpaceFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DaReleaseSpaceFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: i_blocks
  if (_has_field_[3]) {
    msg->AppendVarInt(3, i_blocks_);
  }

  // Field 4: freed_blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, freed_blocks_);
  }

  // Field 5: reserved_data_blocks
  if (_has_field_[5]) {
    msg->AppendVarInt(5, reserved_data_blocks_);
  }

  // Field 6: reserved_meta_blocks
  if (_has_field_[6]) {
    msg->AppendVarInt(6, reserved_meta_blocks_);
  }

  // Field 7: allocated_meta_blocks
  if (_has_field_[7]) {
    msg->AppendVarInt(7, allocated_meta_blocks_);
  }

  // Field 8: mode
  if (_has_field_[8]) {
    msg->AppendVarInt(8, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent() = default;
Ext4CollapseRangeFtraceEvent::~Ext4CollapseRangeFtraceEvent() = default;
Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(const Ext4CollapseRangeFtraceEvent&) = default;
Ext4CollapseRangeFtraceEvent& Ext4CollapseRangeFtraceEvent::operator=(const Ext4CollapseRangeFtraceEvent&) = default;
Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(Ext4CollapseRangeFtraceEvent&&) noexcept = default;
Ext4CollapseRangeFtraceEvent& Ext4CollapseRangeFtraceEvent::operator=(Ext4CollapseRangeFtraceEvent&&) = default;

bool Ext4CollapseRangeFtraceEvent::operator==(const Ext4CollapseRangeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && offset_ == other.offset_
   && len_ == other.len_;
}

bool Ext4CollapseRangeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* offset */:
        field.get(&offset_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4CollapseRangeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4CollapseRangeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4CollapseRangeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: offset
  if (_has_field_[3]) {
    msg->AppendVarInt(3, offset_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent() = default;
Ext4BeginOrderedTruncateFtraceEvent::~Ext4BeginOrderedTruncateFtraceEvent() = default;
Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(const Ext4BeginOrderedTruncateFtraceEvent&) = default;
Ext4BeginOrderedTruncateFtraceEvent& Ext4BeginOrderedTruncateFtraceEvent::operator=(const Ext4BeginOrderedTruncateFtraceEvent&) = default;
Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(Ext4BeginOrderedTruncateFtraceEvent&&) noexcept = default;
Ext4BeginOrderedTruncateFtraceEvent& Ext4BeginOrderedTruncateFtraceEvent::operator=(Ext4BeginOrderedTruncateFtraceEvent&&) = default;

bool Ext4BeginOrderedTruncateFtraceEvent::operator==(const Ext4BeginOrderedTruncateFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && new_size_ == other.new_size_;
}

bool Ext4BeginOrderedTruncateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* new_size */:
        field.get(&new_size_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4BeginOrderedTruncateFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4BeginOrderedTruncateFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4BeginOrderedTruncateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: new_size
  if (_has_field_[3]) {
    msg->AppendVarInt(3, new_size_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent() = default;
Ext4AllocateInodeFtraceEvent::~Ext4AllocateInodeFtraceEvent() = default;
Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(const Ext4AllocateInodeFtraceEvent&) = default;
Ext4AllocateInodeFtraceEvent& Ext4AllocateInodeFtraceEvent::operator=(const Ext4AllocateInodeFtraceEvent&) = default;
Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(Ext4AllocateInodeFtraceEvent&&) noexcept = default;
Ext4AllocateInodeFtraceEvent& Ext4AllocateInodeFtraceEvent::operator=(Ext4AllocateInodeFtraceEvent&&) = default;

bool Ext4AllocateInodeFtraceEvent::operator==(const Ext4AllocateInodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && dir_ == other.dir_
   && mode_ == other.mode_;
}

bool Ext4AllocateInodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* dir */:
        field.get(&dir_);
        break;
      case 4 /* mode */:
        field.get(&mode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4AllocateInodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4AllocateInodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4AllocateInodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: dir
  if (_has_field_[3]) {
    msg->AppendVarInt(3, dir_);
  }

  // Field 4: mode
  if (_has_field_[4]) {
    msg->AppendVarInt(4, mode_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent() = default;
Ext4AllocateBlocksFtraceEvent::~Ext4AllocateBlocksFtraceEvent() = default;
Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(const Ext4AllocateBlocksFtraceEvent&) = default;
Ext4AllocateBlocksFtraceEvent& Ext4AllocateBlocksFtraceEvent::operator=(const Ext4AllocateBlocksFtraceEvent&) = default;
Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(Ext4AllocateBlocksFtraceEvent&&) noexcept = default;
Ext4AllocateBlocksFtraceEvent& Ext4AllocateBlocksFtraceEvent::operator=(Ext4AllocateBlocksFtraceEvent&&) = default;

bool Ext4AllocateBlocksFtraceEvent::operator==(const Ext4AllocateBlocksFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && block_ == other.block_
   && len_ == other.len_
   && logical_ == other.logical_
   && lleft_ == other.lleft_
   && lright_ == other.lright_
   && goal_ == other.goal_
   && pleft_ == other.pleft_
   && pright_ == other.pright_
   && flags_ == other.flags_;
}

bool Ext4AllocateBlocksFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* block */:
        field.get(&block_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* logical */:
        field.get(&logical_);
        break;
      case 6 /* lleft */:
        field.get(&lleft_);
        break;
      case 7 /* lright */:
        field.get(&lright_);
        break;
      case 8 /* goal */:
        field.get(&goal_);
        break;
      case 9 /* pleft */:
        field.get(&pleft_);
        break;
      case 10 /* pright */:
        field.get(&pright_);
        break;
      case 11 /* flags */:
        field.get(&flags_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4AllocateBlocksFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4AllocateBlocksFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4AllocateBlocksFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: block
  if (_has_field_[3]) {
    msg->AppendVarInt(3, block_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: logical
  if (_has_field_[5]) {
    msg->AppendVarInt(5, logical_);
  }

  // Field 6: lleft
  if (_has_field_[6]) {
    msg->AppendVarInt(6, lleft_);
  }

  // Field 7: lright
  if (_has_field_[7]) {
    msg->AppendVarInt(7, lright_);
  }

  // Field 8: goal
  if (_has_field_[8]) {
    msg->AppendVarInt(8, goal_);
  }

  // Field 9: pleft
  if (_has_field_[9]) {
    msg->AppendVarInt(9, pleft_);
  }

  // Field 10: pright
  if (_has_field_[10]) {
    msg->AppendVarInt(10, pright_);
  }

  // Field 11: flags
  if (_has_field_[11]) {
    msg->AppendVarInt(11, flags_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent() = default;
Ext4AllocDaBlocksFtraceEvent::~Ext4AllocDaBlocksFtraceEvent() = default;
Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(const Ext4AllocDaBlocksFtraceEvent&) = default;
Ext4AllocDaBlocksFtraceEvent& Ext4AllocDaBlocksFtraceEvent::operator=(const Ext4AllocDaBlocksFtraceEvent&) = default;
Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(Ext4AllocDaBlocksFtraceEvent&&) noexcept = default;
Ext4AllocDaBlocksFtraceEvent& Ext4AllocDaBlocksFtraceEvent::operator=(Ext4AllocDaBlocksFtraceEvent&&) = default;

bool Ext4AllocDaBlocksFtraceEvent::operator==(const Ext4AllocDaBlocksFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && data_blocks_ == other.data_blocks_
   && meta_blocks_ == other.meta_blocks_;
}

bool Ext4AllocDaBlocksFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* data_blocks */:
        field.get(&data_blocks_);
        break;
      case 4 /* meta_blocks */:
        field.get(&meta_blocks_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4AllocDaBlocksFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4AllocDaBlocksFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4AllocDaBlocksFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: data_blocks
  if (_has_field_[3]) {
    msg->AppendVarInt(3, data_blocks_);
  }

  // Field 4: meta_blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, meta_blocks_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent() = default;
Ext4SyncFileExitFtraceEvent::~Ext4SyncFileExitFtraceEvent() = default;
Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(const Ext4SyncFileExitFtraceEvent&) = default;
Ext4SyncFileExitFtraceEvent& Ext4SyncFileExitFtraceEvent::operator=(const Ext4SyncFileExitFtraceEvent&) = default;
Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(Ext4SyncFileExitFtraceEvent&&) noexcept = default;
Ext4SyncFileExitFtraceEvent& Ext4SyncFileExitFtraceEvent::operator=(Ext4SyncFileExitFtraceEvent&&) = default;

bool Ext4SyncFileExitFtraceEvent::operator==(const Ext4SyncFileExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_;
}

bool Ext4SyncFileExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4SyncFileExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4SyncFileExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4SyncFileExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent() = default;
Ext4SyncFileEnterFtraceEvent::~Ext4SyncFileEnterFtraceEvent() = default;
Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(const Ext4SyncFileEnterFtraceEvent&) = default;
Ext4SyncFileEnterFtraceEvent& Ext4SyncFileEnterFtraceEvent::operator=(const Ext4SyncFileEnterFtraceEvent&) = default;
Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(Ext4SyncFileEnterFtraceEvent&&) noexcept = default;
Ext4SyncFileEnterFtraceEvent& Ext4SyncFileEnterFtraceEvent::operator=(Ext4SyncFileEnterFtraceEvent&&) = default;

bool Ext4SyncFileEnterFtraceEvent::operator==(const Ext4SyncFileEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && parent_ == other.parent_
   && datasync_ == other.datasync_;
}

bool Ext4SyncFileEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* parent */:
        field.get(&parent_);
        break;
      case 4 /* datasync */:
        field.get(&datasync_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4SyncFileEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4SyncFileEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4SyncFileEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: parent
  if (_has_field_[3]) {
    msg->AppendVarInt(3, parent_);
  }

  // Field 4: datasync
  if (_has_field_[4]) {
    msg->AppendVarInt(4, datasync_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent() = default;
Ext4DaWriteEndFtraceEvent::~Ext4DaWriteEndFtraceEvent() = default;
Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(const Ext4DaWriteEndFtraceEvent&) = default;
Ext4DaWriteEndFtraceEvent& Ext4DaWriteEndFtraceEvent::operator=(const Ext4DaWriteEndFtraceEvent&) = default;
Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(Ext4DaWriteEndFtraceEvent&&) noexcept = default;
Ext4DaWriteEndFtraceEvent& Ext4DaWriteEndFtraceEvent::operator=(Ext4DaWriteEndFtraceEvent&&) = default;

bool Ext4DaWriteEndFtraceEvent::operator==(const Ext4DaWriteEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && copied_ == other.copied_;
}

bool Ext4DaWriteEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* copied */:
        field.get(&copied_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DaWriteEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DaWriteEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DaWriteEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: copied
  if (_has_field_[5]) {
    msg->AppendVarInt(5, copied_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent() = default;
Ext4DaWriteBeginFtraceEvent::~Ext4DaWriteBeginFtraceEvent() = default;
Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(const Ext4DaWriteBeginFtraceEvent&) = default;
Ext4DaWriteBeginFtraceEvent& Ext4DaWriteBeginFtraceEvent::operator=(const Ext4DaWriteBeginFtraceEvent&) = default;
Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(Ext4DaWriteBeginFtraceEvent&&) noexcept = default;
Ext4DaWriteBeginFtraceEvent& Ext4DaWriteBeginFtraceEvent::operator=(Ext4DaWriteBeginFtraceEvent&&) = default;

bool Ext4DaWriteBeginFtraceEvent::operator==(const Ext4DaWriteBeginFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && flags_ == other.flags_;
}

bool Ext4DaWriteBeginFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Ext4DaWriteBeginFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Ext4DaWriteBeginFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Ext4DaWriteBeginFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
