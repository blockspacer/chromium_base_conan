// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_I2C_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_I2C_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class SmbusReplyFtraceEvent;
class SmbusResultFtraceEvent;
class SmbusWriteFtraceEvent;
class SmbusReadFtraceEvent;
class I2cReplyFtraceEvent;
class I2cResultFtraceEvent;
class I2cWriteFtraceEvent;
class I2cReadFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT SmbusReplyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kCommandFieldNumber = 4,
    kLenFieldNumber = 5,
    kProtocolFieldNumber = 6,
  };

  SmbusReplyFtraceEvent();
  ~SmbusReplyFtraceEvent() override;
  SmbusReplyFtraceEvent(SmbusReplyFtraceEvent&&) noexcept;
  SmbusReplyFtraceEvent& operator=(SmbusReplyFtraceEvent&&);
  SmbusReplyFtraceEvent(const SmbusReplyFtraceEvent&);
  SmbusReplyFtraceEvent& operator=(const SmbusReplyFtraceEvent&);
  bool operator==(const SmbusReplyFtraceEvent&) const;
  bool operator!=(const SmbusReplyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_adapter_nr() const { return _has_field_[1]; }
  int32_t adapter_nr() const { return adapter_nr_; }
  void set_adapter_nr(int32_t value) { adapter_nr_ = value; _has_field_.set(1); }

  bool has_addr() const { return _has_field_[2]; }
  uint32_t addr() const { return addr_; }
  void set_addr(uint32_t value) { addr_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_command() const { return _has_field_[4]; }
  uint32_t command() const { return command_; }
  void set_command(uint32_t value) { command_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(5); }

  bool has_protocol() const { return _has_field_[6]; }
  uint32_t protocol() const { return protocol_; }
  void set_protocol(uint32_t value) { protocol_ = value; _has_field_.set(6); }

 private:
  int32_t adapter_nr_{};
  uint32_t addr_{};
  uint32_t flags_{};
  uint32_t command_{};
  uint32_t len_{};
  uint32_t protocol_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT SmbusResultFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kReadWriteFieldNumber = 4,
    kCommandFieldNumber = 5,
    kResFieldNumber = 6,
    kProtocolFieldNumber = 7,
  };

  SmbusResultFtraceEvent();
  ~SmbusResultFtraceEvent() override;
  SmbusResultFtraceEvent(SmbusResultFtraceEvent&&) noexcept;
  SmbusResultFtraceEvent& operator=(SmbusResultFtraceEvent&&);
  SmbusResultFtraceEvent(const SmbusResultFtraceEvent&);
  SmbusResultFtraceEvent& operator=(const SmbusResultFtraceEvent&);
  bool operator==(const SmbusResultFtraceEvent&) const;
  bool operator!=(const SmbusResultFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_adapter_nr() const { return _has_field_[1]; }
  int32_t adapter_nr() const { return adapter_nr_; }
  void set_adapter_nr(int32_t value) { adapter_nr_ = value; _has_field_.set(1); }

  bool has_addr() const { return _has_field_[2]; }
  uint32_t addr() const { return addr_; }
  void set_addr(uint32_t value) { addr_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_read_write() const { return _has_field_[4]; }
  uint32_t read_write() const { return read_write_; }
  void set_read_write(uint32_t value) { read_write_ = value; _has_field_.set(4); }

  bool has_command() const { return _has_field_[5]; }
  uint32_t command() const { return command_; }
  void set_command(uint32_t value) { command_ = value; _has_field_.set(5); }

  bool has_res() const { return _has_field_[6]; }
  int32_t res() const { return res_; }
  void set_res(int32_t value) { res_ = value; _has_field_.set(6); }

  bool has_protocol() const { return _has_field_[7]; }
  uint32_t protocol() const { return protocol_; }
  void set_protocol(uint32_t value) { protocol_ = value; _has_field_.set(7); }

 private:
  int32_t adapter_nr_{};
  uint32_t addr_{};
  uint32_t flags_{};
  uint32_t read_write_{};
  uint32_t command_{};
  int32_t res_{};
  uint32_t protocol_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT SmbusWriteFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kCommandFieldNumber = 4,
    kLenFieldNumber = 5,
    kProtocolFieldNumber = 6,
  };

  SmbusWriteFtraceEvent();
  ~SmbusWriteFtraceEvent() override;
  SmbusWriteFtraceEvent(SmbusWriteFtraceEvent&&) noexcept;
  SmbusWriteFtraceEvent& operator=(SmbusWriteFtraceEvent&&);
  SmbusWriteFtraceEvent(const SmbusWriteFtraceEvent&);
  SmbusWriteFtraceEvent& operator=(const SmbusWriteFtraceEvent&);
  bool operator==(const SmbusWriteFtraceEvent&) const;
  bool operator!=(const SmbusWriteFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_adapter_nr() const { return _has_field_[1]; }
  int32_t adapter_nr() const { return adapter_nr_; }
  void set_adapter_nr(int32_t value) { adapter_nr_ = value; _has_field_.set(1); }

  bool has_addr() const { return _has_field_[2]; }
  uint32_t addr() const { return addr_; }
  void set_addr(uint32_t value) { addr_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_command() const { return _has_field_[4]; }
  uint32_t command() const { return command_; }
  void set_command(uint32_t value) { command_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(5); }

  bool has_protocol() const { return _has_field_[6]; }
  uint32_t protocol() const { return protocol_; }
  void set_protocol(uint32_t value) { protocol_ = value; _has_field_.set(6); }

 private:
  int32_t adapter_nr_{};
  uint32_t addr_{};
  uint32_t flags_{};
  uint32_t command_{};
  uint32_t len_{};
  uint32_t protocol_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT SmbusReadFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAdapterNrFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kAddrFieldNumber = 3,
    kCommandFieldNumber = 4,
    kProtocolFieldNumber = 5,
  };

  SmbusReadFtraceEvent();
  ~SmbusReadFtraceEvent() override;
  SmbusReadFtraceEvent(SmbusReadFtraceEvent&&) noexcept;
  SmbusReadFtraceEvent& operator=(SmbusReadFtraceEvent&&);
  SmbusReadFtraceEvent(const SmbusReadFtraceEvent&);
  SmbusReadFtraceEvent& operator=(const SmbusReadFtraceEvent&);
  bool operator==(const SmbusReadFtraceEvent&) const;
  bool operator!=(const SmbusReadFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_adapter_nr() const { return _has_field_[1]; }
  int32_t adapter_nr() const { return adapter_nr_; }
  void set_adapter_nr(int32_t value) { adapter_nr_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(2); }

  bool has_addr() const { return _has_field_[3]; }
  uint32_t addr() const { return addr_; }
  void set_addr(uint32_t value) { addr_ = value; _has_field_.set(3); }

  bool has_command() const { return _has_field_[4]; }
  uint32_t command() const { return command_; }
  void set_command(uint32_t value) { command_ = value; _has_field_.set(4); }

  bool has_protocol() const { return _has_field_[5]; }
  uint32_t protocol() const { return protocol_; }
  void set_protocol(uint32_t value) { protocol_ = value; _has_field_.set(5); }

 private:
  int32_t adapter_nr_{};
  uint32_t flags_{};
  uint32_t addr_{};
  uint32_t command_{};
  uint32_t protocol_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT I2cReplyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
    kBufFieldNumber = 6,
  };

  I2cReplyFtraceEvent();
  ~I2cReplyFtraceEvent() override;
  I2cReplyFtraceEvent(I2cReplyFtraceEvent&&) noexcept;
  I2cReplyFtraceEvent& operator=(I2cReplyFtraceEvent&&);
  I2cReplyFtraceEvent(const I2cReplyFtraceEvent&);
  I2cReplyFtraceEvent& operator=(const I2cReplyFtraceEvent&);
  bool operator==(const I2cReplyFtraceEvent&) const;
  bool operator!=(const I2cReplyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_adapter_nr() const { return _has_field_[1]; }
  int32_t adapter_nr() const { return adapter_nr_; }
  void set_adapter_nr(int32_t value) { adapter_nr_ = value; _has_field_.set(1); }

  bool has_msg_nr() const { return _has_field_[2]; }
  uint32_t msg_nr() const { return msg_nr_; }
  void set_msg_nr(uint32_t value) { msg_nr_ = value; _has_field_.set(2); }

  bool has_addr() const { return _has_field_[3]; }
  uint32_t addr() const { return addr_; }
  void set_addr(uint32_t value) { addr_ = value; _has_field_.set(3); }

  bool has_flags() const { return _has_field_[4]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(5); }

  bool has_buf() const { return _has_field_[6]; }
  uint32_t buf() const { return buf_; }
  void set_buf(uint32_t value) { buf_ = value; _has_field_.set(6); }

 private:
  int32_t adapter_nr_{};
  uint32_t msg_nr_{};
  uint32_t addr_{};
  uint32_t flags_{};
  uint32_t len_{};
  uint32_t buf_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT I2cResultFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAdapterNrFieldNumber = 1,
    kNrMsgsFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  I2cResultFtraceEvent();
  ~I2cResultFtraceEvent() override;
  I2cResultFtraceEvent(I2cResultFtraceEvent&&) noexcept;
  I2cResultFtraceEvent& operator=(I2cResultFtraceEvent&&);
  I2cResultFtraceEvent(const I2cResultFtraceEvent&);
  I2cResultFtraceEvent& operator=(const I2cResultFtraceEvent&);
  bool operator==(const I2cResultFtraceEvent&) const;
  bool operator!=(const I2cResultFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_adapter_nr() const { return _has_field_[1]; }
  int32_t adapter_nr() const { return adapter_nr_; }
  void set_adapter_nr(int32_t value) { adapter_nr_ = value; _has_field_.set(1); }

  bool has_nr_msgs() const { return _has_field_[2]; }
  uint32_t nr_msgs() const { return nr_msgs_; }
  void set_nr_msgs(uint32_t value) { nr_msgs_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  int32_t adapter_nr_{};
  uint32_t nr_msgs_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT I2cWriteFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
    kBufFieldNumber = 6,
  };

  I2cWriteFtraceEvent();
  ~I2cWriteFtraceEvent() override;
  I2cWriteFtraceEvent(I2cWriteFtraceEvent&&) noexcept;
  I2cWriteFtraceEvent& operator=(I2cWriteFtraceEvent&&);
  I2cWriteFtraceEvent(const I2cWriteFtraceEvent&);
  I2cWriteFtraceEvent& operator=(const I2cWriteFtraceEvent&);
  bool operator==(const I2cWriteFtraceEvent&) const;
  bool operator!=(const I2cWriteFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_adapter_nr() const { return _has_field_[1]; }
  int32_t adapter_nr() const { return adapter_nr_; }
  void set_adapter_nr(int32_t value) { adapter_nr_ = value; _has_field_.set(1); }

  bool has_msg_nr() const { return _has_field_[2]; }
  uint32_t msg_nr() const { return msg_nr_; }
  void set_msg_nr(uint32_t value) { msg_nr_ = value; _has_field_.set(2); }

  bool has_addr() const { return _has_field_[3]; }
  uint32_t addr() const { return addr_; }
  void set_addr(uint32_t value) { addr_ = value; _has_field_.set(3); }

  bool has_flags() const { return _has_field_[4]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(5); }

  bool has_buf() const { return _has_field_[6]; }
  uint32_t buf() const { return buf_; }
  void set_buf(uint32_t value) { buf_ = value; _has_field_.set(6); }

 private:
  int32_t adapter_nr_{};
  uint32_t msg_nr_{};
  uint32_t addr_{};
  uint32_t flags_{};
  uint32_t len_{};
  uint32_t buf_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT I2cReadFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
  };

  I2cReadFtraceEvent();
  ~I2cReadFtraceEvent() override;
  I2cReadFtraceEvent(I2cReadFtraceEvent&&) noexcept;
  I2cReadFtraceEvent& operator=(I2cReadFtraceEvent&&);
  I2cReadFtraceEvent(const I2cReadFtraceEvent&);
  I2cReadFtraceEvent& operator=(const I2cReadFtraceEvent&);
  bool operator==(const I2cReadFtraceEvent&) const;
  bool operator!=(const I2cReadFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_adapter_nr() const { return _has_field_[1]; }
  int32_t adapter_nr() const { return adapter_nr_; }
  void set_adapter_nr(int32_t value) { adapter_nr_ = value; _has_field_.set(1); }

  bool has_msg_nr() const { return _has_field_[2]; }
  uint32_t msg_nr() const { return msg_nr_; }
  void set_msg_nr(uint32_t value) { msg_nr_ = value; _has_field_.set(2); }

  bool has_addr() const { return _has_field_[3]; }
  uint32_t addr() const { return addr_; }
  void set_addr(uint32_t value) { addr_ = value; _has_field_.set(3); }

  bool has_flags() const { return _has_field_[4]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(5); }

 private:
  int32_t adapter_nr_{};
  uint32_t msg_nr_{};
  uint32_t addr_{};
  uint32_t flags_{};
  uint32_t len_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_I2C_PROTO_CPP_H_
