// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class GpuFrequencyFtraceEvent;
class SuspendResumeFtraceEvent;
class ClockSetRateFtraceEvent;
class ClockDisableFtraceEvent;
class ClockEnableFtraceEvent;
class CpuIdleFtraceEvent;
class CpuFrequencyLimitsFtraceEvent;
class CpuFrequencyFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT GpuFrequencyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGpuIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };

  GpuFrequencyFtraceEvent();
  ~GpuFrequencyFtraceEvent() override;
  GpuFrequencyFtraceEvent(GpuFrequencyFtraceEvent&&) noexcept;
  GpuFrequencyFtraceEvent& operator=(GpuFrequencyFtraceEvent&&);
  GpuFrequencyFtraceEvent(const GpuFrequencyFtraceEvent&);
  GpuFrequencyFtraceEvent& operator=(const GpuFrequencyFtraceEvent&);
  bool operator==(const GpuFrequencyFtraceEvent&) const;
  bool operator!=(const GpuFrequencyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gpu_id() const { return _has_field_[1]; }
  uint32_t gpu_id() const { return gpu_id_; }
  void set_gpu_id(uint32_t value) { gpu_id_ = value; _has_field_.set(1); }

  bool has_state() const { return _has_field_[2]; }
  uint32_t state() const { return state_; }
  void set_state(uint32_t value) { state_ = value; _has_field_.set(2); }

 private:
  uint32_t gpu_id_{};
  uint32_t state_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT SuspendResumeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kActionFieldNumber = 1,
    kValFieldNumber = 2,
    kStartFieldNumber = 3,
  };

  SuspendResumeFtraceEvent();
  ~SuspendResumeFtraceEvent() override;
  SuspendResumeFtraceEvent(SuspendResumeFtraceEvent&&) noexcept;
  SuspendResumeFtraceEvent& operator=(SuspendResumeFtraceEvent&&);
  SuspendResumeFtraceEvent(const SuspendResumeFtraceEvent&);
  SuspendResumeFtraceEvent& operator=(const SuspendResumeFtraceEvent&);
  bool operator==(const SuspendResumeFtraceEvent&) const;
  bool operator!=(const SuspendResumeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_action() const { return _has_field_[1]; }
  const std::string& action() const { return action_; }
  void set_action(const std::string& value) { action_ = value; _has_field_.set(1); }

  bool has_val() const { return _has_field_[2]; }
  int32_t val() const { return val_; }
  void set_val(int32_t value) { val_ = value; _has_field_.set(2); }

  bool has_start() const { return _has_field_[3]; }
  uint32_t start() const { return start_; }
  void set_start(uint32_t value) { start_ = value; _has_field_.set(3); }

 private:
  std::string action_{};
  int32_t val_{};
  uint32_t start_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT ClockSetRateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };

  ClockSetRateFtraceEvent();
  ~ClockSetRateFtraceEvent() override;
  ClockSetRateFtraceEvent(ClockSetRateFtraceEvent&&) noexcept;
  ClockSetRateFtraceEvent& operator=(ClockSetRateFtraceEvent&&);
  ClockSetRateFtraceEvent(const ClockSetRateFtraceEvent&);
  ClockSetRateFtraceEvent& operator=(const ClockSetRateFtraceEvent&);
  bool operator==(const ClockSetRateFtraceEvent&) const;
  bool operator!=(const ClockSetRateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_state() const { return _has_field_[2]; }
  uint64_t state() const { return state_; }
  void set_state(uint64_t value) { state_ = value; _has_field_.set(2); }

  bool has_cpu_id() const { return _has_field_[3]; }
  uint64_t cpu_id() const { return cpu_id_; }
  void set_cpu_id(uint64_t value) { cpu_id_ = value; _has_field_.set(3); }

 private:
  std::string name_{};
  uint64_t state_{};
  uint64_t cpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT ClockDisableFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };

  ClockDisableFtraceEvent();
  ~ClockDisableFtraceEvent() override;
  ClockDisableFtraceEvent(ClockDisableFtraceEvent&&) noexcept;
  ClockDisableFtraceEvent& operator=(ClockDisableFtraceEvent&&);
  ClockDisableFtraceEvent(const ClockDisableFtraceEvent&);
  ClockDisableFtraceEvent& operator=(const ClockDisableFtraceEvent&);
  bool operator==(const ClockDisableFtraceEvent&) const;
  bool operator!=(const ClockDisableFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_state() const { return _has_field_[2]; }
  uint64_t state() const { return state_; }
  void set_state(uint64_t value) { state_ = value; _has_field_.set(2); }

  bool has_cpu_id() const { return _has_field_[3]; }
  uint64_t cpu_id() const { return cpu_id_; }
  void set_cpu_id(uint64_t value) { cpu_id_ = value; _has_field_.set(3); }

 private:
  std::string name_{};
  uint64_t state_{};
  uint64_t cpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT ClockEnableFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };

  ClockEnableFtraceEvent();
  ~ClockEnableFtraceEvent() override;
  ClockEnableFtraceEvent(ClockEnableFtraceEvent&&) noexcept;
  ClockEnableFtraceEvent& operator=(ClockEnableFtraceEvent&&);
  ClockEnableFtraceEvent(const ClockEnableFtraceEvent&);
  ClockEnableFtraceEvent& operator=(const ClockEnableFtraceEvent&);
  bool operator==(const ClockEnableFtraceEvent&) const;
  bool operator!=(const ClockEnableFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_state() const { return _has_field_[2]; }
  uint64_t state() const { return state_; }
  void set_state(uint64_t value) { state_ = value; _has_field_.set(2); }

  bool has_cpu_id() const { return _has_field_[3]; }
  uint64_t cpu_id() const { return cpu_id_; }
  void set_cpu_id(uint64_t value) { cpu_id_ = value; _has_field_.set(3); }

 private:
  std::string name_{};
  uint64_t state_{};
  uint64_t cpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CpuIdleFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kStateFieldNumber = 1,
    kCpuIdFieldNumber = 2,
  };

  CpuIdleFtraceEvent();
  ~CpuIdleFtraceEvent() override;
  CpuIdleFtraceEvent(CpuIdleFtraceEvent&&) noexcept;
  CpuIdleFtraceEvent& operator=(CpuIdleFtraceEvent&&);
  CpuIdleFtraceEvent(const CpuIdleFtraceEvent&);
  CpuIdleFtraceEvent& operator=(const CpuIdleFtraceEvent&);
  bool operator==(const CpuIdleFtraceEvent&) const;
  bool operator!=(const CpuIdleFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_state() const { return _has_field_[1]; }
  uint32_t state() const { return state_; }
  void set_state(uint32_t value) { state_ = value; _has_field_.set(1); }

  bool has_cpu_id() const { return _has_field_[2]; }
  uint32_t cpu_id() const { return cpu_id_; }
  void set_cpu_id(uint32_t value) { cpu_id_ = value; _has_field_.set(2); }

 private:
  uint32_t state_{};
  uint32_t cpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT CpuFrequencyLimitsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kMinFreqFieldNumber = 1,
    kMaxFreqFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };

  CpuFrequencyLimitsFtraceEvent();
  ~CpuFrequencyLimitsFtraceEvent() override;
  CpuFrequencyLimitsFtraceEvent(CpuFrequencyLimitsFtraceEvent&&) noexcept;
  CpuFrequencyLimitsFtraceEvent& operator=(CpuFrequencyLimitsFtraceEvent&&);
  CpuFrequencyLimitsFtraceEvent(const CpuFrequencyLimitsFtraceEvent&);
  CpuFrequencyLimitsFtraceEvent& operator=(const CpuFrequencyLimitsFtraceEvent&);
  bool operator==(const CpuFrequencyLimitsFtraceEvent&) const;
  bool operator!=(const CpuFrequencyLimitsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_min_freq() const { return _has_field_[1]; }
  uint32_t min_freq() const { return min_freq_; }
  void set_min_freq(uint32_t value) { min_freq_ = value; _has_field_.set(1); }

  bool has_max_freq() const { return _has_field_[2]; }
  uint32_t max_freq() const { return max_freq_; }
  void set_max_freq(uint32_t value) { max_freq_ = value; _has_field_.set(2); }

  bool has_cpu_id() const { return _has_field_[3]; }
  uint32_t cpu_id() const { return cpu_id_; }
  void set_cpu_id(uint32_t value) { cpu_id_ = value; _has_field_.set(3); }

 private:
  uint32_t min_freq_{};
  uint32_t max_freq_{};
  uint32_t cpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CpuFrequencyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kStateFieldNumber = 1,
    kCpuIdFieldNumber = 2,
  };

  CpuFrequencyFtraceEvent();
  ~CpuFrequencyFtraceEvent() override;
  CpuFrequencyFtraceEvent(CpuFrequencyFtraceEvent&&) noexcept;
  CpuFrequencyFtraceEvent& operator=(CpuFrequencyFtraceEvent&&);
  CpuFrequencyFtraceEvent(const CpuFrequencyFtraceEvent&);
  CpuFrequencyFtraceEvent& operator=(const CpuFrequencyFtraceEvent&);
  bool operator==(const CpuFrequencyFtraceEvent&) const;
  bool operator!=(const CpuFrequencyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_state() const { return _has_field_[1]; }
  uint32_t state() const { return state_; }
  void set_state(uint32_t value) { state_ = value; _has_field_.set(1); }

  bool has_cpu_id() const { return _has_field_[2]; }
  uint32_t cpu_id() const { return cpu_id_; }
  void set_cpu_id(uint32_t value) { cpu_id_ = value; _has_field_.set(2); }

 private:
  uint32_t state_{};
  uint32_t cpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_CPP_H_
