// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/kmem.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[44]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace perfetto {
namespace protos {
class AllocPagesIommuEndFtraceEvent;
class AllocPagesIommuEndFtraceEventDefaultTypeInternal;
extern AllocPagesIommuEndFtraceEventDefaultTypeInternal _AllocPagesIommuEndFtraceEvent_default_instance_;
class AllocPagesIommuFailFtraceEvent;
class AllocPagesIommuFailFtraceEventDefaultTypeInternal;
extern AllocPagesIommuFailFtraceEventDefaultTypeInternal _AllocPagesIommuFailFtraceEvent_default_instance_;
class AllocPagesIommuStartFtraceEvent;
class AllocPagesIommuStartFtraceEventDefaultTypeInternal;
extern AllocPagesIommuStartFtraceEventDefaultTypeInternal _AllocPagesIommuStartFtraceEvent_default_instance_;
class AllocPagesSysEndFtraceEvent;
class AllocPagesSysEndFtraceEventDefaultTypeInternal;
extern AllocPagesSysEndFtraceEventDefaultTypeInternal _AllocPagesSysEndFtraceEvent_default_instance_;
class AllocPagesSysFailFtraceEvent;
class AllocPagesSysFailFtraceEventDefaultTypeInternal;
extern AllocPagesSysFailFtraceEventDefaultTypeInternal _AllocPagesSysFailFtraceEvent_default_instance_;
class AllocPagesSysStartFtraceEvent;
class AllocPagesSysStartFtraceEventDefaultTypeInternal;
extern AllocPagesSysStartFtraceEventDefaultTypeInternal _AllocPagesSysStartFtraceEvent_default_instance_;
class DmaAllocContiguousRetryFtraceEvent;
class DmaAllocContiguousRetryFtraceEventDefaultTypeInternal;
extern DmaAllocContiguousRetryFtraceEventDefaultTypeInternal _DmaAllocContiguousRetryFtraceEvent_default_instance_;
class IommuMapRangeFtraceEvent;
class IommuMapRangeFtraceEventDefaultTypeInternal;
extern IommuMapRangeFtraceEventDefaultTypeInternal _IommuMapRangeFtraceEvent_default_instance_;
class IommuSecPtblMapRangeEndFtraceEvent;
class IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal;
extern IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal _IommuSecPtblMapRangeEndFtraceEvent_default_instance_;
class IommuSecPtblMapRangeStartFtraceEvent;
class IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal;
extern IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal _IommuSecPtblMapRangeStartFtraceEvent_default_instance_;
class IonAllocBufferEndFtraceEvent;
class IonAllocBufferEndFtraceEventDefaultTypeInternal;
extern IonAllocBufferEndFtraceEventDefaultTypeInternal _IonAllocBufferEndFtraceEvent_default_instance_;
class IonAllocBufferFailFtraceEvent;
class IonAllocBufferFailFtraceEventDefaultTypeInternal;
extern IonAllocBufferFailFtraceEventDefaultTypeInternal _IonAllocBufferFailFtraceEvent_default_instance_;
class IonAllocBufferFallbackFtraceEvent;
class IonAllocBufferFallbackFtraceEventDefaultTypeInternal;
extern IonAllocBufferFallbackFtraceEventDefaultTypeInternal _IonAllocBufferFallbackFtraceEvent_default_instance_;
class IonAllocBufferStartFtraceEvent;
class IonAllocBufferStartFtraceEventDefaultTypeInternal;
extern IonAllocBufferStartFtraceEventDefaultTypeInternal _IonAllocBufferStartFtraceEvent_default_instance_;
class IonBufferCreateFtraceEvent;
class IonBufferCreateFtraceEventDefaultTypeInternal;
extern IonBufferCreateFtraceEventDefaultTypeInternal _IonBufferCreateFtraceEvent_default_instance_;
class IonBufferDestroyFtraceEvent;
class IonBufferDestroyFtraceEventDefaultTypeInternal;
extern IonBufferDestroyFtraceEventDefaultTypeInternal _IonBufferDestroyFtraceEvent_default_instance_;
class IonCpAllocRetryFtraceEvent;
class IonCpAllocRetryFtraceEventDefaultTypeInternal;
extern IonCpAllocRetryFtraceEventDefaultTypeInternal _IonCpAllocRetryFtraceEvent_default_instance_;
class IonCpSecureBufferEndFtraceEvent;
class IonCpSecureBufferEndFtraceEventDefaultTypeInternal;
extern IonCpSecureBufferEndFtraceEventDefaultTypeInternal _IonCpSecureBufferEndFtraceEvent_default_instance_;
class IonCpSecureBufferStartFtraceEvent;
class IonCpSecureBufferStartFtraceEventDefaultTypeInternal;
extern IonCpSecureBufferStartFtraceEventDefaultTypeInternal _IonCpSecureBufferStartFtraceEvent_default_instance_;
class IonHeapGrowFtraceEvent;
class IonHeapGrowFtraceEventDefaultTypeInternal;
extern IonHeapGrowFtraceEventDefaultTypeInternal _IonHeapGrowFtraceEvent_default_instance_;
class IonHeapShrinkFtraceEvent;
class IonHeapShrinkFtraceEventDefaultTypeInternal;
extern IonHeapShrinkFtraceEventDefaultTypeInternal _IonHeapShrinkFtraceEvent_default_instance_;
class IonPrefetchingFtraceEvent;
class IonPrefetchingFtraceEventDefaultTypeInternal;
extern IonPrefetchingFtraceEventDefaultTypeInternal _IonPrefetchingFtraceEvent_default_instance_;
class IonSecureCmaAddToPoolEndFtraceEvent;
class IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal;
extern IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal _IonSecureCmaAddToPoolEndFtraceEvent_default_instance_;
class IonSecureCmaAddToPoolStartFtraceEvent;
class IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal;
extern IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal _IonSecureCmaAddToPoolStartFtraceEvent_default_instance_;
class IonSecureCmaAllocateEndFtraceEvent;
class IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal;
extern IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal _IonSecureCmaAllocateEndFtraceEvent_default_instance_;
class IonSecureCmaAllocateStartFtraceEvent;
class IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal;
extern IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal _IonSecureCmaAllocateStartFtraceEvent_default_instance_;
class IonSecureCmaShrinkPoolEndFtraceEvent;
class IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal;
extern IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal _IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_;
class IonSecureCmaShrinkPoolStartFtraceEvent;
class IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal;
extern IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal _IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_;
class KfreeFtraceEvent;
class KfreeFtraceEventDefaultTypeInternal;
extern KfreeFtraceEventDefaultTypeInternal _KfreeFtraceEvent_default_instance_;
class KmallocFtraceEvent;
class KmallocFtraceEventDefaultTypeInternal;
extern KmallocFtraceEventDefaultTypeInternal _KmallocFtraceEvent_default_instance_;
class KmallocNodeFtraceEvent;
class KmallocNodeFtraceEventDefaultTypeInternal;
extern KmallocNodeFtraceEventDefaultTypeInternal _KmallocNodeFtraceEvent_default_instance_;
class KmemCacheAllocFtraceEvent;
class KmemCacheAllocFtraceEventDefaultTypeInternal;
extern KmemCacheAllocFtraceEventDefaultTypeInternal _KmemCacheAllocFtraceEvent_default_instance_;
class KmemCacheAllocNodeFtraceEvent;
class KmemCacheAllocNodeFtraceEventDefaultTypeInternal;
extern KmemCacheAllocNodeFtraceEventDefaultTypeInternal _KmemCacheAllocNodeFtraceEvent_default_instance_;
class KmemCacheFreeFtraceEvent;
class KmemCacheFreeFtraceEventDefaultTypeInternal;
extern KmemCacheFreeFtraceEventDefaultTypeInternal _KmemCacheFreeFtraceEvent_default_instance_;
class MigratePagesEndFtraceEvent;
class MigratePagesEndFtraceEventDefaultTypeInternal;
extern MigratePagesEndFtraceEventDefaultTypeInternal _MigratePagesEndFtraceEvent_default_instance_;
class MigratePagesStartFtraceEvent;
class MigratePagesStartFtraceEventDefaultTypeInternal;
extern MigratePagesStartFtraceEventDefaultTypeInternal _MigratePagesStartFtraceEvent_default_instance_;
class MigrateRetryFtraceEvent;
class MigrateRetryFtraceEventDefaultTypeInternal;
extern MigrateRetryFtraceEventDefaultTypeInternal _MigrateRetryFtraceEvent_default_instance_;
class MmPageAllocExtfragFtraceEvent;
class MmPageAllocExtfragFtraceEventDefaultTypeInternal;
extern MmPageAllocExtfragFtraceEventDefaultTypeInternal _MmPageAllocExtfragFtraceEvent_default_instance_;
class MmPageAllocFtraceEvent;
class MmPageAllocFtraceEventDefaultTypeInternal;
extern MmPageAllocFtraceEventDefaultTypeInternal _MmPageAllocFtraceEvent_default_instance_;
class MmPageAllocZoneLockedFtraceEvent;
class MmPageAllocZoneLockedFtraceEventDefaultTypeInternal;
extern MmPageAllocZoneLockedFtraceEventDefaultTypeInternal _MmPageAllocZoneLockedFtraceEvent_default_instance_;
class MmPageFreeBatchedFtraceEvent;
class MmPageFreeBatchedFtraceEventDefaultTypeInternal;
extern MmPageFreeBatchedFtraceEventDefaultTypeInternal _MmPageFreeBatchedFtraceEvent_default_instance_;
class MmPageFreeFtraceEvent;
class MmPageFreeFtraceEventDefaultTypeInternal;
extern MmPageFreeFtraceEventDefaultTypeInternal _MmPageFreeFtraceEvent_default_instance_;
class MmPagePcpuDrainFtraceEvent;
class MmPagePcpuDrainFtraceEventDefaultTypeInternal;
extern MmPagePcpuDrainFtraceEventDefaultTypeInternal _MmPagePcpuDrainFtraceEvent_default_instance_;
class RssStatFtraceEvent;
class RssStatFtraceEventDefaultTypeInternal;
extern RssStatFtraceEventDefaultTypeInternal _RssStatFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> ::perfetto::protos::AllocPagesIommuEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesIommuEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::AllocPagesIommuFailFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesIommuFailFtraceEvent>(Arena*);
template<> ::perfetto::protos::AllocPagesIommuStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesIommuStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::AllocPagesSysEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesSysEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::AllocPagesSysFailFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesSysFailFtraceEvent>(Arena*);
template<> ::perfetto::protos::AllocPagesSysStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesSysStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::DmaAllocContiguousRetryFtraceEvent>(Arena*);
template<> ::perfetto::protos::IommuMapRangeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IommuMapRangeFtraceEvent>(Arena*);
template<> ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonAllocBufferEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonAllocBufferEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonAllocBufferFailFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonAllocBufferFailFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonAllocBufferFallbackFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonAllocBufferFallbackFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonAllocBufferStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonAllocBufferStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonBufferCreateFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonBufferCreateFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonBufferDestroyFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonBufferDestroyFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonCpAllocRetryFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonCpAllocRetryFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonCpSecureBufferEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonCpSecureBufferEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonCpSecureBufferStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonCpSecureBufferStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonHeapGrowFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonHeapGrowFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonHeapShrinkFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonHeapShrinkFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonPrefetchingFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonPrefetchingFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::KfreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KfreeFtraceEvent>(Arena*);
template<> ::perfetto::protos::KmallocFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmallocFtraceEvent>(Arena*);
template<> ::perfetto::protos::KmallocNodeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmallocNodeFtraceEvent>(Arena*);
template<> ::perfetto::protos::KmemCacheAllocFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmemCacheAllocFtraceEvent>(Arena*);
template<> ::perfetto::protos::KmemCacheAllocNodeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmemCacheAllocNodeFtraceEvent>(Arena*);
template<> ::perfetto::protos::KmemCacheFreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmemCacheFreeFtraceEvent>(Arena*);
template<> ::perfetto::protos::MigratePagesEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MigratePagesEndFtraceEvent>(Arena*);
template<> ::perfetto::protos::MigratePagesStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MigratePagesStartFtraceEvent>(Arena*);
template<> ::perfetto::protos::MigrateRetryFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MigrateRetryFtraceEvent>(Arena*);
template<> ::perfetto::protos::MmPageAllocExtfragFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageAllocExtfragFtraceEvent>(Arena*);
template<> ::perfetto::protos::MmPageAllocFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageAllocFtraceEvent>(Arena*);
template<> ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageAllocZoneLockedFtraceEvent>(Arena*);
template<> ::perfetto::protos::MmPageFreeBatchedFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageFreeBatchedFtraceEvent>(Arena*);
template<> ::perfetto::protos::MmPageFreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageFreeFtraceEvent>(Arena*);
template<> ::perfetto::protos::MmPagePcpuDrainFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPagePcpuDrainFtraceEvent>(Arena*);
template<> ::perfetto::protos::RssStatFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::RssStatFtraceEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace perfetto {
namespace protos {

// ===================================================================

class AllocPagesIommuEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesIommuEndFtraceEvent) */ {
 public:
  AllocPagesIommuEndFtraceEvent();
  virtual ~AllocPagesIommuEndFtraceEvent();

  AllocPagesIommuEndFtraceEvent(const AllocPagesIommuEndFtraceEvent& from);
  AllocPagesIommuEndFtraceEvent(AllocPagesIommuEndFtraceEvent&& from) noexcept
    : AllocPagesIommuEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesIommuEndFtraceEvent& operator=(const AllocPagesIommuEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesIommuEndFtraceEvent& operator=(AllocPagesIommuEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AllocPagesIommuEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocPagesIommuEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesIommuEndFtraceEvent*>(
               &_AllocPagesIommuEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AllocPagesIommuEndFtraceEvent& a, AllocPagesIommuEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesIommuEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocPagesIommuEndFtraceEvent* New() const final {
    return CreateMaybeMessage<AllocPagesIommuEndFtraceEvent>(nullptr);
  }

  AllocPagesIommuEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocPagesIommuEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AllocPagesIommuEndFtraceEvent& from);
  void MergeFrom(const AllocPagesIommuEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllocPagesIommuEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.AllocPagesIommuEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesIommuEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class AllocPagesIommuFailFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesIommuFailFtraceEvent) */ {
 public:
  AllocPagesIommuFailFtraceEvent();
  virtual ~AllocPagesIommuFailFtraceEvent();

  AllocPagesIommuFailFtraceEvent(const AllocPagesIommuFailFtraceEvent& from);
  AllocPagesIommuFailFtraceEvent(AllocPagesIommuFailFtraceEvent&& from) noexcept
    : AllocPagesIommuFailFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesIommuFailFtraceEvent& operator=(const AllocPagesIommuFailFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesIommuFailFtraceEvent& operator=(AllocPagesIommuFailFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AllocPagesIommuFailFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocPagesIommuFailFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesIommuFailFtraceEvent*>(
               &_AllocPagesIommuFailFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AllocPagesIommuFailFtraceEvent& a, AllocPagesIommuFailFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesIommuFailFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocPagesIommuFailFtraceEvent* New() const final {
    return CreateMaybeMessage<AllocPagesIommuFailFtraceEvent>(nullptr);
  }

  AllocPagesIommuFailFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocPagesIommuFailFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AllocPagesIommuFailFtraceEvent& from);
  void MergeFrom(const AllocPagesIommuFailFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllocPagesIommuFailFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.AllocPagesIommuFailFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesIommuFailFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class AllocPagesIommuStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesIommuStartFtraceEvent) */ {
 public:
  AllocPagesIommuStartFtraceEvent();
  virtual ~AllocPagesIommuStartFtraceEvent();

  AllocPagesIommuStartFtraceEvent(const AllocPagesIommuStartFtraceEvent& from);
  AllocPagesIommuStartFtraceEvent(AllocPagesIommuStartFtraceEvent&& from) noexcept
    : AllocPagesIommuStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesIommuStartFtraceEvent& operator=(const AllocPagesIommuStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesIommuStartFtraceEvent& operator=(AllocPagesIommuStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AllocPagesIommuStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocPagesIommuStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesIommuStartFtraceEvent*>(
               &_AllocPagesIommuStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AllocPagesIommuStartFtraceEvent& a, AllocPagesIommuStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesIommuStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocPagesIommuStartFtraceEvent* New() const final {
    return CreateMaybeMessage<AllocPagesIommuStartFtraceEvent>(nullptr);
  }

  AllocPagesIommuStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocPagesIommuStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AllocPagesIommuStartFtraceEvent& from);
  void MergeFrom(const AllocPagesIommuStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllocPagesIommuStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.AllocPagesIommuStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesIommuStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class AllocPagesSysEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesSysEndFtraceEvent) */ {
 public:
  AllocPagesSysEndFtraceEvent();
  virtual ~AllocPagesSysEndFtraceEvent();

  AllocPagesSysEndFtraceEvent(const AllocPagesSysEndFtraceEvent& from);
  AllocPagesSysEndFtraceEvent(AllocPagesSysEndFtraceEvent&& from) noexcept
    : AllocPagesSysEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesSysEndFtraceEvent& operator=(const AllocPagesSysEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesSysEndFtraceEvent& operator=(AllocPagesSysEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AllocPagesSysEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocPagesSysEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesSysEndFtraceEvent*>(
               &_AllocPagesSysEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AllocPagesSysEndFtraceEvent& a, AllocPagesSysEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesSysEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocPagesSysEndFtraceEvent* New() const final {
    return CreateMaybeMessage<AllocPagesSysEndFtraceEvent>(nullptr);
  }

  AllocPagesSysEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocPagesSysEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AllocPagesSysEndFtraceEvent& from);
  void MergeFrom(const AllocPagesSysEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllocPagesSysEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.AllocPagesSysEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesSysEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class AllocPagesSysFailFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesSysFailFtraceEvent) */ {
 public:
  AllocPagesSysFailFtraceEvent();
  virtual ~AllocPagesSysFailFtraceEvent();

  AllocPagesSysFailFtraceEvent(const AllocPagesSysFailFtraceEvent& from);
  AllocPagesSysFailFtraceEvent(AllocPagesSysFailFtraceEvent&& from) noexcept
    : AllocPagesSysFailFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesSysFailFtraceEvent& operator=(const AllocPagesSysFailFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesSysFailFtraceEvent& operator=(AllocPagesSysFailFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AllocPagesSysFailFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocPagesSysFailFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesSysFailFtraceEvent*>(
               &_AllocPagesSysFailFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AllocPagesSysFailFtraceEvent& a, AllocPagesSysFailFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesSysFailFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocPagesSysFailFtraceEvent* New() const final {
    return CreateMaybeMessage<AllocPagesSysFailFtraceEvent>(nullptr);
  }

  AllocPagesSysFailFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocPagesSysFailFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AllocPagesSysFailFtraceEvent& from);
  void MergeFrom(const AllocPagesSysFailFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllocPagesSysFailFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.AllocPagesSysFailFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesSysFailFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class AllocPagesSysStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesSysStartFtraceEvent) */ {
 public:
  AllocPagesSysStartFtraceEvent();
  virtual ~AllocPagesSysStartFtraceEvent();

  AllocPagesSysStartFtraceEvent(const AllocPagesSysStartFtraceEvent& from);
  AllocPagesSysStartFtraceEvent(AllocPagesSysStartFtraceEvent&& from) noexcept
    : AllocPagesSysStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesSysStartFtraceEvent& operator=(const AllocPagesSysStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesSysStartFtraceEvent& operator=(AllocPagesSysStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AllocPagesSysStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocPagesSysStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesSysStartFtraceEvent*>(
               &_AllocPagesSysStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AllocPagesSysStartFtraceEvent& a, AllocPagesSysStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesSysStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocPagesSysStartFtraceEvent* New() const final {
    return CreateMaybeMessage<AllocPagesSysStartFtraceEvent>(nullptr);
  }

  AllocPagesSysStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocPagesSysStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AllocPagesSysStartFtraceEvent& from);
  void MergeFrom(const AllocPagesSysStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllocPagesSysStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.AllocPagesSysStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesSysStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class DmaAllocContiguousRetryFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.DmaAllocContiguousRetryFtraceEvent) */ {
 public:
  DmaAllocContiguousRetryFtraceEvent();
  virtual ~DmaAllocContiguousRetryFtraceEvent();

  DmaAllocContiguousRetryFtraceEvent(const DmaAllocContiguousRetryFtraceEvent& from);
  DmaAllocContiguousRetryFtraceEvent(DmaAllocContiguousRetryFtraceEvent&& from) noexcept
    : DmaAllocContiguousRetryFtraceEvent() {
    *this = ::std::move(from);
  }

  inline DmaAllocContiguousRetryFtraceEvent& operator=(const DmaAllocContiguousRetryFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DmaAllocContiguousRetryFtraceEvent& operator=(DmaAllocContiguousRetryFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DmaAllocContiguousRetryFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmaAllocContiguousRetryFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const DmaAllocContiguousRetryFtraceEvent*>(
               &_DmaAllocContiguousRetryFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DmaAllocContiguousRetryFtraceEvent& a, DmaAllocContiguousRetryFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DmaAllocContiguousRetryFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DmaAllocContiguousRetryFtraceEvent* New() const final {
    return CreateMaybeMessage<DmaAllocContiguousRetryFtraceEvent>(nullptr);
  }

  DmaAllocContiguousRetryFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DmaAllocContiguousRetryFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DmaAllocContiguousRetryFtraceEvent& from);
  void MergeFrom(const DmaAllocContiguousRetryFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmaAllocContiguousRetryFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.DmaAllocContiguousRetryFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriesFieldNumber = 1,
  };
  // optional int32 tries = 1;
  bool has_tries() const;
  void clear_tries();
  ::PROTOBUF_NAMESPACE_ID::int32 tries() const;
  void set_tries(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 tries_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IommuMapRangeFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IommuMapRangeFtraceEvent) */ {
 public:
  IommuMapRangeFtraceEvent();
  virtual ~IommuMapRangeFtraceEvent();

  IommuMapRangeFtraceEvent(const IommuMapRangeFtraceEvent& from);
  IommuMapRangeFtraceEvent(IommuMapRangeFtraceEvent&& from) noexcept
    : IommuMapRangeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IommuMapRangeFtraceEvent& operator=(const IommuMapRangeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IommuMapRangeFtraceEvent& operator=(IommuMapRangeFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IommuMapRangeFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IommuMapRangeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IommuMapRangeFtraceEvent*>(
               &_IommuMapRangeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IommuMapRangeFtraceEvent& a, IommuMapRangeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IommuMapRangeFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IommuMapRangeFtraceEvent* New() const final {
    return CreateMaybeMessage<IommuMapRangeFtraceEvent>(nullptr);
  }

  IommuMapRangeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IommuMapRangeFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IommuMapRangeFtraceEvent& from);
  void MergeFrom(const IommuMapRangeFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IommuMapRangeFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IommuMapRangeFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkSizeFieldNumber = 1,
    kLenFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 4,
  };
  // optional uint64 chunk_size = 1;
  bool has_chunk_size() const;
  void clear_chunk_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 chunk_size() const;
  void set_chunk_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 pa = 3;
  bool has_pa() const;
  void clear_pa();
  ::PROTOBUF_NAMESPACE_ID::uint64 pa() const;
  void set_pa(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 va = 4;
  bool has_va() const;
  void clear_va();
  ::PROTOBUF_NAMESPACE_ID::uint64 va() const;
  void set_va(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IommuMapRangeFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 chunk_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pa_;
  ::PROTOBUF_NAMESPACE_ID::uint64 va_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IommuSecPtblMapRangeEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent) */ {
 public:
  IommuSecPtblMapRangeEndFtraceEvent();
  virtual ~IommuSecPtblMapRangeEndFtraceEvent();

  IommuSecPtblMapRangeEndFtraceEvent(const IommuSecPtblMapRangeEndFtraceEvent& from);
  IommuSecPtblMapRangeEndFtraceEvent(IommuSecPtblMapRangeEndFtraceEvent&& from) noexcept
    : IommuSecPtblMapRangeEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IommuSecPtblMapRangeEndFtraceEvent& operator=(const IommuSecPtblMapRangeEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IommuSecPtblMapRangeEndFtraceEvent& operator=(IommuSecPtblMapRangeEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IommuSecPtblMapRangeEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IommuSecPtblMapRangeEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IommuSecPtblMapRangeEndFtraceEvent*>(
               &_IommuSecPtblMapRangeEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IommuSecPtblMapRangeEndFtraceEvent& a, IommuSecPtblMapRangeEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IommuSecPtblMapRangeEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IommuSecPtblMapRangeEndFtraceEvent* New() const final {
    return CreateMaybeMessage<IommuSecPtblMapRangeEndFtraceEvent>(nullptr);
  }

  IommuSecPtblMapRangeEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IommuSecPtblMapRangeEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IommuSecPtblMapRangeEndFtraceEvent& from);
  void MergeFrom(const IommuSecPtblMapRangeEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IommuSecPtblMapRangeEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 5,
    kSecIdFieldNumber = 4,
  };
  // optional uint64 len = 1;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 num = 2;
  bool has_num() const;
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::int32 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 pa = 3;
  bool has_pa() const;
  void clear_pa();
  ::PROTOBUF_NAMESPACE_ID::uint32 pa() const;
  void set_pa(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 va = 5;
  bool has_va() const;
  void clear_va();
  ::PROTOBUF_NAMESPACE_ID::uint64 va() const;
  void set_va(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 sec_id = 4;
  bool has_sec_id() const;
  void clear_sec_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sec_id() const;
  void set_sec_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pa_;
  ::PROTOBUF_NAMESPACE_ID::uint64 va_;
  ::PROTOBUF_NAMESPACE_ID::int32 sec_id_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IommuSecPtblMapRangeStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent) */ {
 public:
  IommuSecPtblMapRangeStartFtraceEvent();
  virtual ~IommuSecPtblMapRangeStartFtraceEvent();

  IommuSecPtblMapRangeStartFtraceEvent(const IommuSecPtblMapRangeStartFtraceEvent& from);
  IommuSecPtblMapRangeStartFtraceEvent(IommuSecPtblMapRangeStartFtraceEvent&& from) noexcept
    : IommuSecPtblMapRangeStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IommuSecPtblMapRangeStartFtraceEvent& operator=(const IommuSecPtblMapRangeStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IommuSecPtblMapRangeStartFtraceEvent& operator=(IommuSecPtblMapRangeStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IommuSecPtblMapRangeStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IommuSecPtblMapRangeStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IommuSecPtblMapRangeStartFtraceEvent*>(
               &_IommuSecPtblMapRangeStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IommuSecPtblMapRangeStartFtraceEvent& a, IommuSecPtblMapRangeStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IommuSecPtblMapRangeStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IommuSecPtblMapRangeStartFtraceEvent* New() const final {
    return CreateMaybeMessage<IommuSecPtblMapRangeStartFtraceEvent>(nullptr);
  }

  IommuSecPtblMapRangeStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IommuSecPtblMapRangeStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IommuSecPtblMapRangeStartFtraceEvent& from);
  void MergeFrom(const IommuSecPtblMapRangeStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IommuSecPtblMapRangeStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 5,
    kSecIdFieldNumber = 4,
  };
  // optional uint64 len = 1;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 num = 2;
  bool has_num() const;
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::int32 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 pa = 3;
  bool has_pa() const;
  void clear_pa();
  ::PROTOBUF_NAMESPACE_ID::uint32 pa() const;
  void set_pa(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 va = 5;
  bool has_va() const;
  void clear_va();
  ::PROTOBUF_NAMESPACE_ID::uint64 va() const;
  void set_va(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 sec_id = 4;
  bool has_sec_id() const;
  void clear_sec_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sec_id() const;
  void set_sec_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pa_;
  ::PROTOBUF_NAMESPACE_ID::uint64 va_;
  ::PROTOBUF_NAMESPACE_ID::int32 sec_id_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonAllocBufferEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonAllocBufferEndFtraceEvent) */ {
 public:
  IonAllocBufferEndFtraceEvent();
  virtual ~IonAllocBufferEndFtraceEvent();

  IonAllocBufferEndFtraceEvent(const IonAllocBufferEndFtraceEvent& from);
  IonAllocBufferEndFtraceEvent(IonAllocBufferEndFtraceEvent&& from) noexcept
    : IonAllocBufferEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonAllocBufferEndFtraceEvent& operator=(const IonAllocBufferEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonAllocBufferEndFtraceEvent& operator=(IonAllocBufferEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonAllocBufferEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonAllocBufferEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonAllocBufferEndFtraceEvent*>(
               &_IonAllocBufferEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IonAllocBufferEndFtraceEvent& a, IonAllocBufferEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonAllocBufferEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonAllocBufferEndFtraceEvent* New() const final {
    return CreateMaybeMessage<IonAllocBufferEndFtraceEvent>(nullptr);
  }

  IonAllocBufferEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonAllocBufferEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonAllocBufferEndFtraceEvent& from);
  void MergeFrom(const IonAllocBufferEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonAllocBufferEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonAllocBufferEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kHeapNameFieldNumber = 3,
    kFlagsFieldNumber = 2,
    kMaskFieldNumber = 5,
    kLenFieldNumber = 4,
  };
  // optional string client_name = 1;
  bool has_client_name() const;
  void clear_client_name();
  const std::string& client_name() const;
  void set_client_name(const std::string& value);
  void set_client_name(std::string&& value);
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  std::string* mutable_client_name();
  std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);

  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional uint32 flags = 2;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 mask = 5;
  bool has_mask() const;
  void clear_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask() const;
  void set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonAllocBufferEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonAllocBufferFailFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonAllocBufferFailFtraceEvent) */ {
 public:
  IonAllocBufferFailFtraceEvent();
  virtual ~IonAllocBufferFailFtraceEvent();

  IonAllocBufferFailFtraceEvent(const IonAllocBufferFailFtraceEvent& from);
  IonAllocBufferFailFtraceEvent(IonAllocBufferFailFtraceEvent&& from) noexcept
    : IonAllocBufferFailFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonAllocBufferFailFtraceEvent& operator=(const IonAllocBufferFailFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonAllocBufferFailFtraceEvent& operator=(IonAllocBufferFailFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonAllocBufferFailFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonAllocBufferFailFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonAllocBufferFailFtraceEvent*>(
               &_IonAllocBufferFailFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IonAllocBufferFailFtraceEvent& a, IonAllocBufferFailFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonAllocBufferFailFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonAllocBufferFailFtraceEvent* New() const final {
    return CreateMaybeMessage<IonAllocBufferFailFtraceEvent>(nullptr);
  }

  IonAllocBufferFailFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonAllocBufferFailFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonAllocBufferFailFtraceEvent& from);
  void MergeFrom(const IonAllocBufferFailFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonAllocBufferFailFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonAllocBufferFailFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kHeapNameFieldNumber = 4,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kMaskFieldNumber = 6,
    kLenFieldNumber = 5,
  };
  // optional string client_name = 1;
  bool has_client_name() const;
  void clear_client_name();
  const std::string& client_name() const;
  void set_client_name(const std::string& value);
  void set_client_name(std::string&& value);
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  std::string* mutable_client_name();
  std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);

  // optional string heap_name = 4;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional int64 error = 2;
  bool has_error() const;
  void clear_error();
  ::PROTOBUF_NAMESPACE_ID::int64 error() const;
  void set_error(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional uint32 flags = 3;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 mask = 6;
  bool has_mask() const;
  void clear_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask() const;
  void set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 len = 5;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonAllocBufferFailFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonAllocBufferFallbackFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonAllocBufferFallbackFtraceEvent) */ {
 public:
  IonAllocBufferFallbackFtraceEvent();
  virtual ~IonAllocBufferFallbackFtraceEvent();

  IonAllocBufferFallbackFtraceEvent(const IonAllocBufferFallbackFtraceEvent& from);
  IonAllocBufferFallbackFtraceEvent(IonAllocBufferFallbackFtraceEvent&& from) noexcept
    : IonAllocBufferFallbackFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonAllocBufferFallbackFtraceEvent& operator=(const IonAllocBufferFallbackFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonAllocBufferFallbackFtraceEvent& operator=(IonAllocBufferFallbackFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonAllocBufferFallbackFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonAllocBufferFallbackFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonAllocBufferFallbackFtraceEvent*>(
               &_IonAllocBufferFallbackFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(IonAllocBufferFallbackFtraceEvent& a, IonAllocBufferFallbackFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonAllocBufferFallbackFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonAllocBufferFallbackFtraceEvent* New() const final {
    return CreateMaybeMessage<IonAllocBufferFallbackFtraceEvent>(nullptr);
  }

  IonAllocBufferFallbackFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonAllocBufferFallbackFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonAllocBufferFallbackFtraceEvent& from);
  void MergeFrom(const IonAllocBufferFallbackFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonAllocBufferFallbackFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonAllocBufferFallbackFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kHeapNameFieldNumber = 4,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kMaskFieldNumber = 6,
    kLenFieldNumber = 5,
  };
  // optional string client_name = 1;
  bool has_client_name() const;
  void clear_client_name();
  const std::string& client_name() const;
  void set_client_name(const std::string& value);
  void set_client_name(std::string&& value);
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  std::string* mutable_client_name();
  std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);

  // optional string heap_name = 4;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional int64 error = 2;
  bool has_error() const;
  void clear_error();
  ::PROTOBUF_NAMESPACE_ID::int64 error() const;
  void set_error(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional uint32 flags = 3;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 mask = 6;
  bool has_mask() const;
  void clear_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask() const;
  void set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 len = 5;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonAllocBufferStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonAllocBufferStartFtraceEvent) */ {
 public:
  IonAllocBufferStartFtraceEvent();
  virtual ~IonAllocBufferStartFtraceEvent();

  IonAllocBufferStartFtraceEvent(const IonAllocBufferStartFtraceEvent& from);
  IonAllocBufferStartFtraceEvent(IonAllocBufferStartFtraceEvent&& from) noexcept
    : IonAllocBufferStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonAllocBufferStartFtraceEvent& operator=(const IonAllocBufferStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonAllocBufferStartFtraceEvent& operator=(IonAllocBufferStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonAllocBufferStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonAllocBufferStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonAllocBufferStartFtraceEvent*>(
               &_IonAllocBufferStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IonAllocBufferStartFtraceEvent& a, IonAllocBufferStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonAllocBufferStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonAllocBufferStartFtraceEvent* New() const final {
    return CreateMaybeMessage<IonAllocBufferStartFtraceEvent>(nullptr);
  }

  IonAllocBufferStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonAllocBufferStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonAllocBufferStartFtraceEvent& from);
  void MergeFrom(const IonAllocBufferStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonAllocBufferStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonAllocBufferStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kHeapNameFieldNumber = 3,
    kFlagsFieldNumber = 2,
    kMaskFieldNumber = 5,
    kLenFieldNumber = 4,
  };
  // optional string client_name = 1;
  bool has_client_name() const;
  void clear_client_name();
  const std::string& client_name() const;
  void set_client_name(const std::string& value);
  void set_client_name(std::string&& value);
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  std::string* mutable_client_name();
  std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);

  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional uint32 flags = 2;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 mask = 5;
  bool has_mask() const;
  void clear_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask() const;
  void set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonAllocBufferStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonCpAllocRetryFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonCpAllocRetryFtraceEvent) */ {
 public:
  IonCpAllocRetryFtraceEvent();
  virtual ~IonCpAllocRetryFtraceEvent();

  IonCpAllocRetryFtraceEvent(const IonCpAllocRetryFtraceEvent& from);
  IonCpAllocRetryFtraceEvent(IonCpAllocRetryFtraceEvent&& from) noexcept
    : IonCpAllocRetryFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonCpAllocRetryFtraceEvent& operator=(const IonCpAllocRetryFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonCpAllocRetryFtraceEvent& operator=(IonCpAllocRetryFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonCpAllocRetryFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonCpAllocRetryFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonCpAllocRetryFtraceEvent*>(
               &_IonCpAllocRetryFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(IonCpAllocRetryFtraceEvent& a, IonCpAllocRetryFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonCpAllocRetryFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonCpAllocRetryFtraceEvent* New() const final {
    return CreateMaybeMessage<IonCpAllocRetryFtraceEvent>(nullptr);
  }

  IonCpAllocRetryFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonCpAllocRetryFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonCpAllocRetryFtraceEvent& from);
  void MergeFrom(const IonCpAllocRetryFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonCpAllocRetryFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonCpAllocRetryFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriesFieldNumber = 1,
  };
  // optional int32 tries = 1;
  bool has_tries() const;
  void clear_tries();
  ::PROTOBUF_NAMESPACE_ID::int32 tries() const;
  void set_tries(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonCpAllocRetryFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 tries_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonCpSecureBufferEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonCpSecureBufferEndFtraceEvent) */ {
 public:
  IonCpSecureBufferEndFtraceEvent();
  virtual ~IonCpSecureBufferEndFtraceEvent();

  IonCpSecureBufferEndFtraceEvent(const IonCpSecureBufferEndFtraceEvent& from);
  IonCpSecureBufferEndFtraceEvent(IonCpSecureBufferEndFtraceEvent&& from) noexcept
    : IonCpSecureBufferEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonCpSecureBufferEndFtraceEvent& operator=(const IonCpSecureBufferEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonCpSecureBufferEndFtraceEvent& operator=(IonCpSecureBufferEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonCpSecureBufferEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonCpSecureBufferEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonCpSecureBufferEndFtraceEvent*>(
               &_IonCpSecureBufferEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(IonCpSecureBufferEndFtraceEvent& a, IonCpSecureBufferEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonCpSecureBufferEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonCpSecureBufferEndFtraceEvent* New() const final {
    return CreateMaybeMessage<IonCpSecureBufferEndFtraceEvent>(nullptr);
  }

  IonCpSecureBufferEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonCpSecureBufferEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonCpSecureBufferEndFtraceEvent& from);
  void MergeFrom(const IonCpSecureBufferEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonCpSecureBufferEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonCpSecureBufferEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 3,
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLenFieldNumber = 4,
  };
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional uint64 align = 1;
  bool has_align() const;
  void clear_align();
  ::PROTOBUF_NAMESPACE_ID::uint64 align() const;
  void set_align(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 flags = 2;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint64 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 align_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonCpSecureBufferStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonCpSecureBufferStartFtraceEvent) */ {
 public:
  IonCpSecureBufferStartFtraceEvent();
  virtual ~IonCpSecureBufferStartFtraceEvent();

  IonCpSecureBufferStartFtraceEvent(const IonCpSecureBufferStartFtraceEvent& from);
  IonCpSecureBufferStartFtraceEvent(IonCpSecureBufferStartFtraceEvent&& from) noexcept
    : IonCpSecureBufferStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonCpSecureBufferStartFtraceEvent& operator=(const IonCpSecureBufferStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonCpSecureBufferStartFtraceEvent& operator=(IonCpSecureBufferStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonCpSecureBufferStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonCpSecureBufferStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonCpSecureBufferStartFtraceEvent*>(
               &_IonCpSecureBufferStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(IonCpSecureBufferStartFtraceEvent& a, IonCpSecureBufferStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonCpSecureBufferStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonCpSecureBufferStartFtraceEvent* New() const final {
    return CreateMaybeMessage<IonCpSecureBufferStartFtraceEvent>(nullptr);
  }

  IonCpSecureBufferStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonCpSecureBufferStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonCpSecureBufferStartFtraceEvent& from);
  void MergeFrom(const IonCpSecureBufferStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonCpSecureBufferStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonCpSecureBufferStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 3,
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLenFieldNumber = 4,
  };
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional uint64 align = 1;
  bool has_align() const;
  void clear_align();
  ::PROTOBUF_NAMESPACE_ID::uint64 align() const;
  void set_align(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 flags = 2;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint64 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 align_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonPrefetchingFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonPrefetchingFtraceEvent) */ {
 public:
  IonPrefetchingFtraceEvent();
  virtual ~IonPrefetchingFtraceEvent();

  IonPrefetchingFtraceEvent(const IonPrefetchingFtraceEvent& from);
  IonPrefetchingFtraceEvent(IonPrefetchingFtraceEvent&& from) noexcept
    : IonPrefetchingFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonPrefetchingFtraceEvent& operator=(const IonPrefetchingFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonPrefetchingFtraceEvent& operator=(IonPrefetchingFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonPrefetchingFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonPrefetchingFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonPrefetchingFtraceEvent*>(
               &_IonPrefetchingFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(IonPrefetchingFtraceEvent& a, IonPrefetchingFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonPrefetchingFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonPrefetchingFtraceEvent* New() const final {
    return CreateMaybeMessage<IonPrefetchingFtraceEvent>(nullptr);
  }

  IonPrefetchingFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonPrefetchingFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonPrefetchingFtraceEvent& from);
  void MergeFrom(const IonPrefetchingFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonPrefetchingFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonPrefetchingFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 1,
  };
  // optional uint64 len = 1;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonPrefetchingFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonSecureCmaAddToPoolEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent) */ {
 public:
  IonSecureCmaAddToPoolEndFtraceEvent();
  virtual ~IonSecureCmaAddToPoolEndFtraceEvent();

  IonSecureCmaAddToPoolEndFtraceEvent(const IonSecureCmaAddToPoolEndFtraceEvent& from);
  IonSecureCmaAddToPoolEndFtraceEvent(IonSecureCmaAddToPoolEndFtraceEvent&& from) noexcept
    : IonSecureCmaAddToPoolEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaAddToPoolEndFtraceEvent& operator=(const IonSecureCmaAddToPoolEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaAddToPoolEndFtraceEvent& operator=(IonSecureCmaAddToPoolEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonSecureCmaAddToPoolEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonSecureCmaAddToPoolEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaAddToPoolEndFtraceEvent*>(
               &_IonSecureCmaAddToPoolEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(IonSecureCmaAddToPoolEndFtraceEvent& a, IonSecureCmaAddToPoolEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaAddToPoolEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonSecureCmaAddToPoolEndFtraceEvent* New() const final {
    return CreateMaybeMessage<IonSecureCmaAddToPoolEndFtraceEvent>(nullptr);
  }

  IonSecureCmaAddToPoolEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonSecureCmaAddToPoolEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonSecureCmaAddToPoolEndFtraceEvent& from);
  void MergeFrom(const IonSecureCmaAddToPoolEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonSecureCmaAddToPoolEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 2,
    kIsPrefetchFieldNumber = 1,
    kPoolTotalFieldNumber = 3,
  };
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 is_prefetch = 1;
  bool has_is_prefetch() const;
  void clear_is_prefetch();
  ::PROTOBUF_NAMESPACE_ID::uint32 is_prefetch() const;
  void set_is_prefetch(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 pool_total = 3;
  bool has_pool_total() const;
  void clear_pool_total();
  ::PROTOBUF_NAMESPACE_ID::int32 pool_total() const;
  void set_pool_total(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  ::PROTOBUF_NAMESPACE_ID::uint32 is_prefetch_;
  ::PROTOBUF_NAMESPACE_ID::int32 pool_total_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonSecureCmaAddToPoolStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent) */ {
 public:
  IonSecureCmaAddToPoolStartFtraceEvent();
  virtual ~IonSecureCmaAddToPoolStartFtraceEvent();

  IonSecureCmaAddToPoolStartFtraceEvent(const IonSecureCmaAddToPoolStartFtraceEvent& from);
  IonSecureCmaAddToPoolStartFtraceEvent(IonSecureCmaAddToPoolStartFtraceEvent&& from) noexcept
    : IonSecureCmaAddToPoolStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaAddToPoolStartFtraceEvent& operator=(const IonSecureCmaAddToPoolStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaAddToPoolStartFtraceEvent& operator=(IonSecureCmaAddToPoolStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonSecureCmaAddToPoolStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonSecureCmaAddToPoolStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaAddToPoolStartFtraceEvent*>(
               &_IonSecureCmaAddToPoolStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IonSecureCmaAddToPoolStartFtraceEvent& a, IonSecureCmaAddToPoolStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaAddToPoolStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonSecureCmaAddToPoolStartFtraceEvent* New() const final {
    return CreateMaybeMessage<IonSecureCmaAddToPoolStartFtraceEvent>(nullptr);
  }

  IonSecureCmaAddToPoolStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonSecureCmaAddToPoolStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonSecureCmaAddToPoolStartFtraceEvent& from);
  void MergeFrom(const IonSecureCmaAddToPoolStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonSecureCmaAddToPoolStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 2,
    kIsPrefetchFieldNumber = 1,
    kPoolTotalFieldNumber = 3,
  };
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 is_prefetch = 1;
  bool has_is_prefetch() const;
  void clear_is_prefetch();
  ::PROTOBUF_NAMESPACE_ID::uint32 is_prefetch() const;
  void set_is_prefetch(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 pool_total = 3;
  bool has_pool_total() const;
  void clear_pool_total();
  ::PROTOBUF_NAMESPACE_ID::int32 pool_total() const;
  void set_pool_total(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  ::PROTOBUF_NAMESPACE_ID::uint32 is_prefetch_;
  ::PROTOBUF_NAMESPACE_ID::int32 pool_total_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonSecureCmaAllocateEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent) */ {
 public:
  IonSecureCmaAllocateEndFtraceEvent();
  virtual ~IonSecureCmaAllocateEndFtraceEvent();

  IonSecureCmaAllocateEndFtraceEvent(const IonSecureCmaAllocateEndFtraceEvent& from);
  IonSecureCmaAllocateEndFtraceEvent(IonSecureCmaAllocateEndFtraceEvent&& from) noexcept
    : IonSecureCmaAllocateEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaAllocateEndFtraceEvent& operator=(const IonSecureCmaAllocateEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaAllocateEndFtraceEvent& operator=(IonSecureCmaAllocateEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonSecureCmaAllocateEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonSecureCmaAllocateEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaAllocateEndFtraceEvent*>(
               &_IonSecureCmaAllocateEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(IonSecureCmaAllocateEndFtraceEvent& a, IonSecureCmaAllocateEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaAllocateEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonSecureCmaAllocateEndFtraceEvent* New() const final {
    return CreateMaybeMessage<IonSecureCmaAllocateEndFtraceEvent>(nullptr);
  }

  IonSecureCmaAllocateEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonSecureCmaAllocateEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonSecureCmaAllocateEndFtraceEvent& from);
  void MergeFrom(const IonSecureCmaAllocateEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonSecureCmaAllocateEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonSecureCmaAllocateEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 3,
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLenFieldNumber = 4,
  };
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional uint64 align = 1;
  bool has_align() const;
  void clear_align();
  ::PROTOBUF_NAMESPACE_ID::uint64 align() const;
  void set_align(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 flags = 2;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint64 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 align_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonSecureCmaAllocateStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent) */ {
 public:
  IonSecureCmaAllocateStartFtraceEvent();
  virtual ~IonSecureCmaAllocateStartFtraceEvent();

  IonSecureCmaAllocateStartFtraceEvent(const IonSecureCmaAllocateStartFtraceEvent& from);
  IonSecureCmaAllocateStartFtraceEvent(IonSecureCmaAllocateStartFtraceEvent&& from) noexcept
    : IonSecureCmaAllocateStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaAllocateStartFtraceEvent& operator=(const IonSecureCmaAllocateStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaAllocateStartFtraceEvent& operator=(IonSecureCmaAllocateStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonSecureCmaAllocateStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonSecureCmaAllocateStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaAllocateStartFtraceEvent*>(
               &_IonSecureCmaAllocateStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IonSecureCmaAllocateStartFtraceEvent& a, IonSecureCmaAllocateStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaAllocateStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonSecureCmaAllocateStartFtraceEvent* New() const final {
    return CreateMaybeMessage<IonSecureCmaAllocateStartFtraceEvent>(nullptr);
  }

  IonSecureCmaAllocateStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonSecureCmaAllocateStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonSecureCmaAllocateStartFtraceEvent& from);
  void MergeFrom(const IonSecureCmaAllocateStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonSecureCmaAllocateStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonSecureCmaAllocateStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 3,
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLenFieldNumber = 4,
  };
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional uint64 align = 1;
  bool has_align() const;
  void clear_align();
  ::PROTOBUF_NAMESPACE_ID::uint64 align() const;
  void set_align(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 flags = 2;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint64 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 align_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonSecureCmaShrinkPoolEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent) */ {
 public:
  IonSecureCmaShrinkPoolEndFtraceEvent();
  virtual ~IonSecureCmaShrinkPoolEndFtraceEvent();

  IonSecureCmaShrinkPoolEndFtraceEvent(const IonSecureCmaShrinkPoolEndFtraceEvent& from);
  IonSecureCmaShrinkPoolEndFtraceEvent(IonSecureCmaShrinkPoolEndFtraceEvent&& from) noexcept
    : IonSecureCmaShrinkPoolEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaShrinkPoolEndFtraceEvent& operator=(const IonSecureCmaShrinkPoolEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaShrinkPoolEndFtraceEvent& operator=(IonSecureCmaShrinkPoolEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonSecureCmaShrinkPoolEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonSecureCmaShrinkPoolEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaShrinkPoolEndFtraceEvent*>(
               &_IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(IonSecureCmaShrinkPoolEndFtraceEvent& a, IonSecureCmaShrinkPoolEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaShrinkPoolEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonSecureCmaShrinkPoolEndFtraceEvent* New() const final {
    return CreateMaybeMessage<IonSecureCmaShrinkPoolEndFtraceEvent>(nullptr);
  }

  IonSecureCmaShrinkPoolEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonSecureCmaShrinkPoolEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonSecureCmaShrinkPoolEndFtraceEvent& from);
  void MergeFrom(const IonSecureCmaShrinkPoolEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonSecureCmaShrinkPoolEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  // optional uint64 drained_size = 1;
  bool has_drained_size() const;
  void clear_drained_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 drained_size() const;
  void set_drained_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 skipped_size = 2;
  bool has_skipped_size() const;
  void clear_skipped_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 skipped_size() const;
  void set_skipped_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 drained_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 skipped_size_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonSecureCmaShrinkPoolStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent) */ {
 public:
  IonSecureCmaShrinkPoolStartFtraceEvent();
  virtual ~IonSecureCmaShrinkPoolStartFtraceEvent();

  IonSecureCmaShrinkPoolStartFtraceEvent(const IonSecureCmaShrinkPoolStartFtraceEvent& from);
  IonSecureCmaShrinkPoolStartFtraceEvent(IonSecureCmaShrinkPoolStartFtraceEvent&& from) noexcept
    : IonSecureCmaShrinkPoolStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaShrinkPoolStartFtraceEvent& operator=(const IonSecureCmaShrinkPoolStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaShrinkPoolStartFtraceEvent& operator=(IonSecureCmaShrinkPoolStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonSecureCmaShrinkPoolStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonSecureCmaShrinkPoolStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaShrinkPoolStartFtraceEvent*>(
               &_IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(IonSecureCmaShrinkPoolStartFtraceEvent& a, IonSecureCmaShrinkPoolStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaShrinkPoolStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonSecureCmaShrinkPoolStartFtraceEvent* New() const final {
    return CreateMaybeMessage<IonSecureCmaShrinkPoolStartFtraceEvent>(nullptr);
  }

  IonSecureCmaShrinkPoolStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonSecureCmaShrinkPoolStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonSecureCmaShrinkPoolStartFtraceEvent& from);
  void MergeFrom(const IonSecureCmaShrinkPoolStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonSecureCmaShrinkPoolStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  // optional uint64 drained_size = 1;
  bool has_drained_size() const;
  void clear_drained_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 drained_size() const;
  void set_drained_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 skipped_size = 2;
  bool has_skipped_size() const;
  void clear_skipped_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 skipped_size() const;
  void set_skipped_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 drained_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 skipped_size_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class KfreeFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.KfreeFtraceEvent) */ {
 public:
  KfreeFtraceEvent();
  virtual ~KfreeFtraceEvent();

  KfreeFtraceEvent(const KfreeFtraceEvent& from);
  KfreeFtraceEvent(KfreeFtraceEvent&& from) noexcept
    : KfreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KfreeFtraceEvent& operator=(const KfreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KfreeFtraceEvent& operator=(KfreeFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const KfreeFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KfreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KfreeFtraceEvent*>(
               &_KfreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(KfreeFtraceEvent& a, KfreeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KfreeFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KfreeFtraceEvent* New() const final {
    return CreateMaybeMessage<KfreeFtraceEvent>(nullptr);
  }

  KfreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KfreeFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const KfreeFtraceEvent& from);
  void MergeFrom(const KfreeFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KfreeFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.KfreeFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  // optional uint64 call_site = 1;
  bool has_call_site() const;
  void clear_call_site();
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site() const;
  void set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 ptr = 2;
  bool has_ptr() const;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.KfreeFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class KmallocFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.KmallocFtraceEvent) */ {
 public:
  KmallocFtraceEvent();
  virtual ~KmallocFtraceEvent();

  KmallocFtraceEvent(const KmallocFtraceEvent& from);
  KmallocFtraceEvent(KmallocFtraceEvent&& from) noexcept
    : KmallocFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmallocFtraceEvent& operator=(const KmallocFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmallocFtraceEvent& operator=(KmallocFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const KmallocFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KmallocFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmallocFtraceEvent*>(
               &_KmallocFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(KmallocFtraceEvent& a, KmallocFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmallocFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KmallocFtraceEvent* New() const final {
    return CreateMaybeMessage<KmallocFtraceEvent>(nullptr);
  }

  KmallocFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KmallocFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const KmallocFtraceEvent& from);
  void MergeFrom(const KmallocFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KmallocFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.KmallocFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kPtrFieldNumber = 5,
    kGfpFlagsFieldNumber = 4,
  };
  // optional uint64 bytes_alloc = 1;
  bool has_bytes_alloc() const;
  void clear_bytes_alloc();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_alloc() const;
  void set_bytes_alloc(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 bytes_req = 2;
  bool has_bytes_req() const;
  void clear_bytes_req();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_req() const;
  void set_bytes_req(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 call_site = 3;
  bool has_call_site() const;
  void clear_call_site();
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site() const;
  void set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 ptr = 5;
  bool has_ptr() const;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 gfp_flags = 4;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.KmallocFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_alloc_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_req_;
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class KmallocNodeFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.KmallocNodeFtraceEvent) */ {
 public:
  KmallocNodeFtraceEvent();
  virtual ~KmallocNodeFtraceEvent();

  KmallocNodeFtraceEvent(const KmallocNodeFtraceEvent& from);
  KmallocNodeFtraceEvent(KmallocNodeFtraceEvent&& from) noexcept
    : KmallocNodeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmallocNodeFtraceEvent& operator=(const KmallocNodeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmallocNodeFtraceEvent& operator=(KmallocNodeFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const KmallocNodeFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KmallocNodeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmallocNodeFtraceEvent*>(
               &_KmallocNodeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(KmallocNodeFtraceEvent& a, KmallocNodeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmallocNodeFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KmallocNodeFtraceEvent* New() const final {
    return CreateMaybeMessage<KmallocNodeFtraceEvent>(nullptr);
  }

  KmallocNodeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KmallocNodeFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const KmallocNodeFtraceEvent& from);
  void MergeFrom(const KmallocNodeFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KmallocNodeFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.KmallocNodeFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  // optional uint64 bytes_alloc = 1;
  bool has_bytes_alloc() const;
  void clear_bytes_alloc();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_alloc() const;
  void set_bytes_alloc(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 bytes_req = 2;
  bool has_bytes_req() const;
  void clear_bytes_req();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_req() const;
  void set_bytes_req(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 call_site = 3;
  bool has_call_site() const;
  void clear_call_site();
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site() const;
  void set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 gfp_flags = 4;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 node = 5;
  bool has_node() const;
  void clear_node();
  ::PROTOBUF_NAMESPACE_ID::int32 node() const;
  void set_node(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint64 ptr = 6;
  bool has_ptr() const;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.KmallocNodeFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_alloc_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_req_;
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class KmemCacheAllocFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.KmemCacheAllocFtraceEvent) */ {
 public:
  KmemCacheAllocFtraceEvent();
  virtual ~KmemCacheAllocFtraceEvent();

  KmemCacheAllocFtraceEvent(const KmemCacheAllocFtraceEvent& from);
  KmemCacheAllocFtraceEvent(KmemCacheAllocFtraceEvent&& from) noexcept
    : KmemCacheAllocFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmemCacheAllocFtraceEvent& operator=(const KmemCacheAllocFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmemCacheAllocFtraceEvent& operator=(KmemCacheAllocFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const KmemCacheAllocFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KmemCacheAllocFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmemCacheAllocFtraceEvent*>(
               &_KmemCacheAllocFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(KmemCacheAllocFtraceEvent& a, KmemCacheAllocFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmemCacheAllocFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KmemCacheAllocFtraceEvent* New() const final {
    return CreateMaybeMessage<KmemCacheAllocFtraceEvent>(nullptr);
  }

  KmemCacheAllocFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KmemCacheAllocFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const KmemCacheAllocFtraceEvent& from);
  void MergeFrom(const KmemCacheAllocFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KmemCacheAllocFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.KmemCacheAllocFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kPtrFieldNumber = 5,
    kGfpFlagsFieldNumber = 4,
  };
  // optional uint64 bytes_alloc = 1;
  bool has_bytes_alloc() const;
  void clear_bytes_alloc();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_alloc() const;
  void set_bytes_alloc(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 bytes_req = 2;
  bool has_bytes_req() const;
  void clear_bytes_req();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_req() const;
  void set_bytes_req(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 call_site = 3;
  bool has_call_site() const;
  void clear_call_site();
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site() const;
  void set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 ptr = 5;
  bool has_ptr() const;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 gfp_flags = 4;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.KmemCacheAllocFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_alloc_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_req_;
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class KmemCacheAllocNodeFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.KmemCacheAllocNodeFtraceEvent) */ {
 public:
  KmemCacheAllocNodeFtraceEvent();
  virtual ~KmemCacheAllocNodeFtraceEvent();

  KmemCacheAllocNodeFtraceEvent(const KmemCacheAllocNodeFtraceEvent& from);
  KmemCacheAllocNodeFtraceEvent(KmemCacheAllocNodeFtraceEvent&& from) noexcept
    : KmemCacheAllocNodeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmemCacheAllocNodeFtraceEvent& operator=(const KmemCacheAllocNodeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmemCacheAllocNodeFtraceEvent& operator=(KmemCacheAllocNodeFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const KmemCacheAllocNodeFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KmemCacheAllocNodeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmemCacheAllocNodeFtraceEvent*>(
               &_KmemCacheAllocNodeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(KmemCacheAllocNodeFtraceEvent& a, KmemCacheAllocNodeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmemCacheAllocNodeFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KmemCacheAllocNodeFtraceEvent* New() const final {
    return CreateMaybeMessage<KmemCacheAllocNodeFtraceEvent>(nullptr);
  }

  KmemCacheAllocNodeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KmemCacheAllocNodeFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const KmemCacheAllocNodeFtraceEvent& from);
  void MergeFrom(const KmemCacheAllocNodeFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KmemCacheAllocNodeFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.KmemCacheAllocNodeFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  // optional uint64 bytes_alloc = 1;
  bool has_bytes_alloc() const;
  void clear_bytes_alloc();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_alloc() const;
  void set_bytes_alloc(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 bytes_req = 2;
  bool has_bytes_req() const;
  void clear_bytes_req();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_req() const;
  void set_bytes_req(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 call_site = 3;
  bool has_call_site() const;
  void clear_call_site();
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site() const;
  void set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 gfp_flags = 4;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 node = 5;
  bool has_node() const;
  void clear_node();
  ::PROTOBUF_NAMESPACE_ID::int32 node() const;
  void set_node(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint64 ptr = 6;
  bool has_ptr() const;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_alloc_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_req_;
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class KmemCacheFreeFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.KmemCacheFreeFtraceEvent) */ {
 public:
  KmemCacheFreeFtraceEvent();
  virtual ~KmemCacheFreeFtraceEvent();

  KmemCacheFreeFtraceEvent(const KmemCacheFreeFtraceEvent& from);
  KmemCacheFreeFtraceEvent(KmemCacheFreeFtraceEvent&& from) noexcept
    : KmemCacheFreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmemCacheFreeFtraceEvent& operator=(const KmemCacheFreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmemCacheFreeFtraceEvent& operator=(KmemCacheFreeFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const KmemCacheFreeFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KmemCacheFreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmemCacheFreeFtraceEvent*>(
               &_KmemCacheFreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(KmemCacheFreeFtraceEvent& a, KmemCacheFreeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmemCacheFreeFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KmemCacheFreeFtraceEvent* New() const final {
    return CreateMaybeMessage<KmemCacheFreeFtraceEvent>(nullptr);
  }

  KmemCacheFreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KmemCacheFreeFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const KmemCacheFreeFtraceEvent& from);
  void MergeFrom(const KmemCacheFreeFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KmemCacheFreeFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.KmemCacheFreeFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  // optional uint64 call_site = 1;
  bool has_call_site() const;
  void clear_call_site();
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site() const;
  void set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 ptr = 2;
  bool has_ptr() const;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.KmemCacheFreeFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 call_site_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MigratePagesEndFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MigratePagesEndFtraceEvent) */ {
 public:
  MigratePagesEndFtraceEvent();
  virtual ~MigratePagesEndFtraceEvent();

  MigratePagesEndFtraceEvent(const MigratePagesEndFtraceEvent& from);
  MigratePagesEndFtraceEvent(MigratePagesEndFtraceEvent&& from) noexcept
    : MigratePagesEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MigratePagesEndFtraceEvent& operator=(const MigratePagesEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigratePagesEndFtraceEvent& operator=(MigratePagesEndFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MigratePagesEndFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MigratePagesEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MigratePagesEndFtraceEvent*>(
               &_MigratePagesEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MigratePagesEndFtraceEvent& a, MigratePagesEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MigratePagesEndFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MigratePagesEndFtraceEvent* New() const final {
    return CreateMaybeMessage<MigratePagesEndFtraceEvent>(nullptr);
  }

  MigratePagesEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MigratePagesEndFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MigratePagesEndFtraceEvent& from);
  void MergeFrom(const MigratePagesEndFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MigratePagesEndFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MigratePagesEndFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // optional int32 mode = 1;
  bool has_mode() const;
  void clear_mode();
  ::PROTOBUF_NAMESPACE_ID::int32 mode() const;
  void set_mode(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MigratePagesEndFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 mode_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MigratePagesStartFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MigratePagesStartFtraceEvent) */ {
 public:
  MigratePagesStartFtraceEvent();
  virtual ~MigratePagesStartFtraceEvent();

  MigratePagesStartFtraceEvent(const MigratePagesStartFtraceEvent& from);
  MigratePagesStartFtraceEvent(MigratePagesStartFtraceEvent&& from) noexcept
    : MigratePagesStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MigratePagesStartFtraceEvent& operator=(const MigratePagesStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigratePagesStartFtraceEvent& operator=(MigratePagesStartFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MigratePagesStartFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MigratePagesStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MigratePagesStartFtraceEvent*>(
               &_MigratePagesStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MigratePagesStartFtraceEvent& a, MigratePagesStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MigratePagesStartFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MigratePagesStartFtraceEvent* New() const final {
    return CreateMaybeMessage<MigratePagesStartFtraceEvent>(nullptr);
  }

  MigratePagesStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MigratePagesStartFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MigratePagesStartFtraceEvent& from);
  void MergeFrom(const MigratePagesStartFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MigratePagesStartFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MigratePagesStartFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // optional int32 mode = 1;
  bool has_mode() const;
  void clear_mode();
  ::PROTOBUF_NAMESPACE_ID::int32 mode() const;
  void set_mode(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MigratePagesStartFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 mode_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MigrateRetryFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MigrateRetryFtraceEvent) */ {
 public:
  MigrateRetryFtraceEvent();
  virtual ~MigrateRetryFtraceEvent();

  MigrateRetryFtraceEvent(const MigrateRetryFtraceEvent& from);
  MigrateRetryFtraceEvent(MigrateRetryFtraceEvent&& from) noexcept
    : MigrateRetryFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MigrateRetryFtraceEvent& operator=(const MigrateRetryFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateRetryFtraceEvent& operator=(MigrateRetryFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MigrateRetryFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MigrateRetryFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MigrateRetryFtraceEvent*>(
               &_MigrateRetryFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MigrateRetryFtraceEvent& a, MigrateRetryFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrateRetryFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MigrateRetryFtraceEvent* New() const final {
    return CreateMaybeMessage<MigrateRetryFtraceEvent>(nullptr);
  }

  MigrateRetryFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MigrateRetryFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MigrateRetryFtraceEvent& from);
  void MergeFrom(const MigrateRetryFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MigrateRetryFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MigrateRetryFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriesFieldNumber = 1,
  };
  // optional int32 tries = 1;
  bool has_tries() const;
  void clear_tries();
  ::PROTOBUF_NAMESPACE_ID::int32 tries() const;
  void set_tries(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MigrateRetryFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 tries_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MmPageAllocFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageAllocFtraceEvent) */ {
 public:
  MmPageAllocFtraceEvent();
  virtual ~MmPageAllocFtraceEvent();

  MmPageAllocFtraceEvent(const MmPageAllocFtraceEvent& from);
  MmPageAllocFtraceEvent(MmPageAllocFtraceEvent&& from) noexcept
    : MmPageAllocFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageAllocFtraceEvent& operator=(const MmPageAllocFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageAllocFtraceEvent& operator=(MmPageAllocFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MmPageAllocFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MmPageAllocFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageAllocFtraceEvent*>(
               &_MmPageAllocFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MmPageAllocFtraceEvent& a, MmPageAllocFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageAllocFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MmPageAllocFtraceEvent* New() const final {
    return CreateMaybeMessage<MmPageAllocFtraceEvent>(nullptr);
  }

  MmPageAllocFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MmPageAllocFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MmPageAllocFtraceEvent& from);
  void MergeFrom(const MmPageAllocFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MmPageAllocFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MmPageAllocFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kMigratetypeFieldNumber = 2,
    kPageFieldNumber = 4,
    kPfnFieldNumber = 5,
    kOrderFieldNumber = 3,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags() const;
  void set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 migratetype = 2;
  bool has_migratetype() const;
  void clear_migratetype();
  ::PROTOBUF_NAMESPACE_ID::int32 migratetype() const;
  void set_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint64 page = 4;
  bool has_page() const;
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::uint64 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 pfn = 5;
  bool has_pfn() const;
  void clear_pfn();
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn() const;
  void set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 order = 3;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageAllocFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gfp_flags_;
  ::PROTOBUF_NAMESPACE_ID::int32 migratetype_;
  ::PROTOBUF_NAMESPACE_ID::uint64 page_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MmPageAllocExtfragFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageAllocExtfragFtraceEvent) */ {
 public:
  MmPageAllocExtfragFtraceEvent();
  virtual ~MmPageAllocExtfragFtraceEvent();

  MmPageAllocExtfragFtraceEvent(const MmPageAllocExtfragFtraceEvent& from);
  MmPageAllocExtfragFtraceEvent(MmPageAllocExtfragFtraceEvent&& from) noexcept
    : MmPageAllocExtfragFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageAllocExtfragFtraceEvent& operator=(const MmPageAllocExtfragFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageAllocExtfragFtraceEvent& operator=(MmPageAllocExtfragFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MmPageAllocExtfragFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MmPageAllocExtfragFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageAllocExtfragFtraceEvent*>(
               &_MmPageAllocExtfragFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(MmPageAllocExtfragFtraceEvent& a, MmPageAllocExtfragFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageAllocExtfragFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MmPageAllocExtfragFtraceEvent* New() const final {
    return CreateMaybeMessage<MmPageAllocExtfragFtraceEvent>(nullptr);
  }

  MmPageAllocExtfragFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MmPageAllocExtfragFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MmPageAllocExtfragFtraceEvent& from);
  void MergeFrom(const MmPageAllocExtfragFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MmPageAllocExtfragFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MmPageAllocExtfragFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocMigratetypeFieldNumber = 1,
    kAllocOrderFieldNumber = 2,
    kFallbackMigratetypeFieldNumber = 3,
    kFallbackOrderFieldNumber = 4,
    kPageFieldNumber = 5,
    kPfnFieldNumber = 7,
    kChangeOwnershipFieldNumber = 6,
  };
  // optional int32 alloc_migratetype = 1;
  bool has_alloc_migratetype() const;
  void clear_alloc_migratetype();
  ::PROTOBUF_NAMESPACE_ID::int32 alloc_migratetype() const;
  void set_alloc_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 alloc_order = 2;
  bool has_alloc_order() const;
  void clear_alloc_order();
  ::PROTOBUF_NAMESPACE_ID::int32 alloc_order() const;
  void set_alloc_order(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fallback_migratetype = 3;
  bool has_fallback_migratetype() const;
  void clear_fallback_migratetype();
  ::PROTOBUF_NAMESPACE_ID::int32 fallback_migratetype() const;
  void set_fallback_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fallback_order = 4;
  bool has_fallback_order() const;
  void clear_fallback_order();
  ::PROTOBUF_NAMESPACE_ID::int32 fallback_order() const;
  void set_fallback_order(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint64 page = 5;
  bool has_page() const;
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::uint64 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 pfn = 7;
  bool has_pfn() const;
  void clear_pfn();
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn() const;
  void set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 change_ownership = 6;
  bool has_change_ownership() const;
  void clear_change_ownership();
  ::PROTOBUF_NAMESPACE_ID::int32 change_ownership() const;
  void set_change_ownership(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageAllocExtfragFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 alloc_migratetype_;
  ::PROTOBUF_NAMESPACE_ID::int32 alloc_order_;
  ::PROTOBUF_NAMESPACE_ID::int32 fallback_migratetype_;
  ::PROTOBUF_NAMESPACE_ID::int32 fallback_order_;
  ::PROTOBUF_NAMESPACE_ID::uint64 page_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn_;
  ::PROTOBUF_NAMESPACE_ID::int32 change_ownership_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MmPageAllocZoneLockedFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageAllocZoneLockedFtraceEvent) */ {
 public:
  MmPageAllocZoneLockedFtraceEvent();
  virtual ~MmPageAllocZoneLockedFtraceEvent();

  MmPageAllocZoneLockedFtraceEvent(const MmPageAllocZoneLockedFtraceEvent& from);
  MmPageAllocZoneLockedFtraceEvent(MmPageAllocZoneLockedFtraceEvent&& from) noexcept
    : MmPageAllocZoneLockedFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageAllocZoneLockedFtraceEvent& operator=(const MmPageAllocZoneLockedFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageAllocZoneLockedFtraceEvent& operator=(MmPageAllocZoneLockedFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MmPageAllocZoneLockedFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MmPageAllocZoneLockedFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageAllocZoneLockedFtraceEvent*>(
               &_MmPageAllocZoneLockedFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(MmPageAllocZoneLockedFtraceEvent& a, MmPageAllocZoneLockedFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageAllocZoneLockedFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MmPageAllocZoneLockedFtraceEvent* New() const final {
    return CreateMaybeMessage<MmPageAllocZoneLockedFtraceEvent>(nullptr);
  }

  MmPageAllocZoneLockedFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MmPageAllocZoneLockedFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MmPageAllocZoneLockedFtraceEvent& from);
  void MergeFrom(const MmPageAllocZoneLockedFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MmPageAllocZoneLockedFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MmPageAllocZoneLockedFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  // optional int32 migratetype = 1;
  bool has_migratetype() const;
  void clear_migratetype();
  ::PROTOBUF_NAMESPACE_ID::int32 migratetype() const;
  void set_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 page = 3;
  bool has_page() const;
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::uint64 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 pfn = 4;
  bool has_pfn() const;
  void clear_pfn();
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn() const;
  void set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 migratetype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  ::PROTOBUF_NAMESPACE_ID::uint64 page_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MmPageFreeFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageFreeFtraceEvent) */ {
 public:
  MmPageFreeFtraceEvent();
  virtual ~MmPageFreeFtraceEvent();

  MmPageFreeFtraceEvent(const MmPageFreeFtraceEvent& from);
  MmPageFreeFtraceEvent(MmPageFreeFtraceEvent&& from) noexcept
    : MmPageFreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageFreeFtraceEvent& operator=(const MmPageFreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageFreeFtraceEvent& operator=(MmPageFreeFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MmPageFreeFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MmPageFreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageFreeFtraceEvent*>(
               &_MmPageFreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MmPageFreeFtraceEvent& a, MmPageFreeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageFreeFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MmPageFreeFtraceEvent* New() const final {
    return CreateMaybeMessage<MmPageFreeFtraceEvent>(nullptr);
  }

  MmPageFreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MmPageFreeFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MmPageFreeFtraceEvent& from);
  void MergeFrom(const MmPageFreeFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MmPageFreeFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MmPageFreeFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
    kOrderFieldNumber = 1,
  };
  // optional uint64 page = 2;
  bool has_page() const;
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::uint64 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 pfn = 3;
  bool has_pfn() const;
  void clear_pfn();
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn() const;
  void set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 order = 1;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageFreeFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 page_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MmPageFreeBatchedFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageFreeBatchedFtraceEvent) */ {
 public:
  MmPageFreeBatchedFtraceEvent();
  virtual ~MmPageFreeBatchedFtraceEvent();

  MmPageFreeBatchedFtraceEvent(const MmPageFreeBatchedFtraceEvent& from);
  MmPageFreeBatchedFtraceEvent(MmPageFreeBatchedFtraceEvent&& from) noexcept
    : MmPageFreeBatchedFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageFreeBatchedFtraceEvent& operator=(const MmPageFreeBatchedFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageFreeBatchedFtraceEvent& operator=(MmPageFreeBatchedFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MmPageFreeBatchedFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MmPageFreeBatchedFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageFreeBatchedFtraceEvent*>(
               &_MmPageFreeBatchedFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(MmPageFreeBatchedFtraceEvent& a, MmPageFreeBatchedFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageFreeBatchedFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MmPageFreeBatchedFtraceEvent* New() const final {
    return CreateMaybeMessage<MmPageFreeBatchedFtraceEvent>(nullptr);
  }

  MmPageFreeBatchedFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MmPageFreeBatchedFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MmPageFreeBatchedFtraceEvent& from);
  void MergeFrom(const MmPageFreeBatchedFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MmPageFreeBatchedFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MmPageFreeBatchedFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
    kColdFieldNumber = 1,
  };
  // optional uint64 page = 2;
  bool has_page() const;
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::uint64 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 pfn = 3;
  bool has_pfn() const;
  void clear_pfn();
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn() const;
  void set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 cold = 1;
  bool has_cold() const;
  void clear_cold();
  ::PROTOBUF_NAMESPACE_ID::int32 cold() const;
  void set_cold(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageFreeBatchedFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 page_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn_;
  ::PROTOBUF_NAMESPACE_ID::int32 cold_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class MmPagePcpuDrainFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPagePcpuDrainFtraceEvent) */ {
 public:
  MmPagePcpuDrainFtraceEvent();
  virtual ~MmPagePcpuDrainFtraceEvent();

  MmPagePcpuDrainFtraceEvent(const MmPagePcpuDrainFtraceEvent& from);
  MmPagePcpuDrainFtraceEvent(MmPagePcpuDrainFtraceEvent&& from) noexcept
    : MmPagePcpuDrainFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPagePcpuDrainFtraceEvent& operator=(const MmPagePcpuDrainFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPagePcpuDrainFtraceEvent& operator=(MmPagePcpuDrainFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MmPagePcpuDrainFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MmPagePcpuDrainFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPagePcpuDrainFtraceEvent*>(
               &_MmPagePcpuDrainFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(MmPagePcpuDrainFtraceEvent& a, MmPagePcpuDrainFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPagePcpuDrainFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MmPagePcpuDrainFtraceEvent* New() const final {
    return CreateMaybeMessage<MmPagePcpuDrainFtraceEvent>(nullptr);
  }

  MmPagePcpuDrainFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MmPagePcpuDrainFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MmPagePcpuDrainFtraceEvent& from);
  void MergeFrom(const MmPagePcpuDrainFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MmPagePcpuDrainFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.MmPagePcpuDrainFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  // optional int32 migratetype = 1;
  bool has_migratetype() const;
  void clear_migratetype();
  ::PROTOBUF_NAMESPACE_ID::int32 migratetype() const;
  void set_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::uint32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 page = 3;
  bool has_page() const;
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::uint64 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 pfn = 4;
  bool has_pfn() const;
  void clear_pfn();
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn() const;
  void set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPagePcpuDrainFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 migratetype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_;
  ::PROTOBUF_NAMESPACE_ID::uint64 page_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pfn_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class RssStatFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.RssStatFtraceEvent) */ {
 public:
  RssStatFtraceEvent();
  virtual ~RssStatFtraceEvent();

  RssStatFtraceEvent(const RssStatFtraceEvent& from);
  RssStatFtraceEvent(RssStatFtraceEvent&& from) noexcept
    : RssStatFtraceEvent() {
    *this = ::std::move(from);
  }

  inline RssStatFtraceEvent& operator=(const RssStatFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RssStatFtraceEvent& operator=(RssStatFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RssStatFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RssStatFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const RssStatFtraceEvent*>(
               &_RssStatFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RssStatFtraceEvent& a, RssStatFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RssStatFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RssStatFtraceEvent* New() const final {
    return CreateMaybeMessage<RssStatFtraceEvent>(nullptr);
  }

  RssStatFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RssStatFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RssStatFtraceEvent& from);
  void MergeFrom(const RssStatFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RssStatFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.RssStatFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 2,
    kMemberFieldNumber = 1,
    kCurrFieldNumber = 3,
    kMmIdFieldNumber = 4,
  };
  // optional int64 size = 2;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 member = 1;
  bool has_member() const;
  void clear_member();
  ::PROTOBUF_NAMESPACE_ID::int32 member() const;
  void set_member(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 curr = 3;
  bool has_curr() const;
  void clear_curr();
  ::PROTOBUF_NAMESPACE_ID::uint32 curr() const;
  void set_curr(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 mm_id = 4;
  bool has_mm_id() const;
  void clear_mm_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 mm_id() const;
  void set_mm_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RssStatFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  ::PROTOBUF_NAMESPACE_ID::int32 member_;
  ::PROTOBUF_NAMESPACE_ID::uint32 curr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mm_id_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonHeapShrinkFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonHeapShrinkFtraceEvent) */ {
 public:
  IonHeapShrinkFtraceEvent();
  virtual ~IonHeapShrinkFtraceEvent();

  IonHeapShrinkFtraceEvent(const IonHeapShrinkFtraceEvent& from);
  IonHeapShrinkFtraceEvent(IonHeapShrinkFtraceEvent&& from) noexcept
    : IonHeapShrinkFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonHeapShrinkFtraceEvent& operator=(const IonHeapShrinkFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonHeapShrinkFtraceEvent& operator=(IonHeapShrinkFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonHeapShrinkFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonHeapShrinkFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonHeapShrinkFtraceEvent*>(
               &_IonHeapShrinkFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(IonHeapShrinkFtraceEvent& a, IonHeapShrinkFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonHeapShrinkFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonHeapShrinkFtraceEvent* New() const final {
    return CreateMaybeMessage<IonHeapShrinkFtraceEvent>(nullptr);
  }

  IonHeapShrinkFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonHeapShrinkFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonHeapShrinkFtraceEvent& from);
  void MergeFrom(const IonHeapShrinkFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonHeapShrinkFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonHeapShrinkFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  // optional string heap_name = 1;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int64 total_allocated = 3;
  bool has_total_allocated() const;
  void clear_total_allocated();
  ::PROTOBUF_NAMESPACE_ID::int64 total_allocated() const;
  void set_total_allocated(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonHeapShrinkFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_allocated_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonHeapGrowFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonHeapGrowFtraceEvent) */ {
 public:
  IonHeapGrowFtraceEvent();
  virtual ~IonHeapGrowFtraceEvent();

  IonHeapGrowFtraceEvent(const IonHeapGrowFtraceEvent& from);
  IonHeapGrowFtraceEvent(IonHeapGrowFtraceEvent&& from) noexcept
    : IonHeapGrowFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonHeapGrowFtraceEvent& operator=(const IonHeapGrowFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonHeapGrowFtraceEvent& operator=(IonHeapGrowFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonHeapGrowFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonHeapGrowFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonHeapGrowFtraceEvent*>(
               &_IonHeapGrowFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(IonHeapGrowFtraceEvent& a, IonHeapGrowFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonHeapGrowFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonHeapGrowFtraceEvent* New() const final {
    return CreateMaybeMessage<IonHeapGrowFtraceEvent>(nullptr);
  }

  IonHeapGrowFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonHeapGrowFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonHeapGrowFtraceEvent& from);
  void MergeFrom(const IonHeapGrowFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonHeapGrowFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonHeapGrowFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  // optional string heap_name = 1;
  bool has_heap_name() const;
  void clear_heap_name();
  const std::string& heap_name() const;
  void set_heap_name(const std::string& value);
  void set_heap_name(std::string&& value);
  void set_heap_name(const char* value);
  void set_heap_name(const char* value, size_t size);
  std::string* mutable_heap_name();
  std::string* release_heap_name();
  void set_allocated_heap_name(std::string* heap_name);

  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int64 total_allocated = 3;
  bool has_total_allocated() const;
  void clear_total_allocated();
  ::PROTOBUF_NAMESPACE_ID::int64 total_allocated() const;
  void set_total_allocated(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonHeapGrowFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_allocated_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonBufferCreateFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonBufferCreateFtraceEvent) */ {
 public:
  IonBufferCreateFtraceEvent();
  virtual ~IonBufferCreateFtraceEvent();

  IonBufferCreateFtraceEvent(const IonBufferCreateFtraceEvent& from);
  IonBufferCreateFtraceEvent(IonBufferCreateFtraceEvent&& from) noexcept
    : IonBufferCreateFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonBufferCreateFtraceEvent& operator=(const IonBufferCreateFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonBufferCreateFtraceEvent& operator=(IonBufferCreateFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonBufferCreateFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonBufferCreateFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonBufferCreateFtraceEvent*>(
               &_IonBufferCreateFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(IonBufferCreateFtraceEvent& a, IonBufferCreateFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonBufferCreateFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonBufferCreateFtraceEvent* New() const final {
    return CreateMaybeMessage<IonBufferCreateFtraceEvent>(nullptr);
  }

  IonBufferCreateFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonBufferCreateFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonBufferCreateFtraceEvent& from);
  void MergeFrom(const IonBufferCreateFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonBufferCreateFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonBufferCreateFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  // optional uint64 addr = 1;
  bool has_addr() const;
  void clear_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonBufferCreateFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 addr_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// -------------------------------------------------------------------

class IonBufferDestroyFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.IonBufferDestroyFtraceEvent) */ {
 public:
  IonBufferDestroyFtraceEvent();
  virtual ~IonBufferDestroyFtraceEvent();

  IonBufferDestroyFtraceEvent(const IonBufferDestroyFtraceEvent& from);
  IonBufferDestroyFtraceEvent(IonBufferDestroyFtraceEvent&& from) noexcept
    : IonBufferDestroyFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonBufferDestroyFtraceEvent& operator=(const IonBufferDestroyFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonBufferDestroyFtraceEvent& operator=(IonBufferDestroyFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IonBufferDestroyFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IonBufferDestroyFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonBufferDestroyFtraceEvent*>(
               &_IonBufferDestroyFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(IonBufferDestroyFtraceEvent& a, IonBufferDestroyFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonBufferDestroyFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IonBufferDestroyFtraceEvent* New() const final {
    return CreateMaybeMessage<IonBufferDestroyFtraceEvent>(nullptr);
  }

  IonBufferDestroyFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IonBufferDestroyFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IonBufferDestroyFtraceEvent& from);
  void MergeFrom(const IonBufferDestroyFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IonBufferDestroyFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.IonBufferDestroyFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  // optional uint64 addr = 1;
  bool has_addr() const;
  void clear_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.IonBufferDestroyFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 addr_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AllocPagesIommuEndFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesIommuEndFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocPagesIommuEndFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesIommuEndFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuEndFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void AllocPagesIommuEndFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuEndFtraceEvent.gfp_flags)
}

// optional uint32 order = 2;
inline bool AllocPagesIommuEndFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocPagesIommuEndFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesIommuEndFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuEndFtraceEvent.order)
  return order_;
}
inline void AllocPagesIommuEndFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuEndFtraceEvent.order)
}

// -------------------------------------------------------------------

// AllocPagesIommuFailFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesIommuFailFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocPagesIommuFailFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesIommuFailFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuFailFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void AllocPagesIommuFailFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuFailFtraceEvent.gfp_flags)
}

// optional uint32 order = 2;
inline bool AllocPagesIommuFailFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocPagesIommuFailFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesIommuFailFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuFailFtraceEvent.order)
  return order_;
}
inline void AllocPagesIommuFailFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuFailFtraceEvent.order)
}

// -------------------------------------------------------------------

// AllocPagesIommuStartFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesIommuStartFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocPagesIommuStartFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesIommuStartFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuStartFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void AllocPagesIommuStartFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuStartFtraceEvent.gfp_flags)
}

// optional uint32 order = 2;
inline bool AllocPagesIommuStartFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocPagesIommuStartFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesIommuStartFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuStartFtraceEvent.order)
  return order_;
}
inline void AllocPagesIommuStartFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuStartFtraceEvent.order)
}

// -------------------------------------------------------------------

// AllocPagesSysEndFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesSysEndFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocPagesSysEndFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesSysEndFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysEndFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void AllocPagesSysEndFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysEndFtraceEvent.gfp_flags)
}

// optional uint32 order = 2;
inline bool AllocPagesSysEndFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocPagesSysEndFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesSysEndFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysEndFtraceEvent.order)
  return order_;
}
inline void AllocPagesSysEndFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysEndFtraceEvent.order)
}

// -------------------------------------------------------------------

// AllocPagesSysFailFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesSysFailFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocPagesSysFailFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesSysFailFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysFailFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void AllocPagesSysFailFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysFailFtraceEvent.gfp_flags)
}

// optional uint32 order = 2;
inline bool AllocPagesSysFailFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocPagesSysFailFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesSysFailFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysFailFtraceEvent.order)
  return order_;
}
inline void AllocPagesSysFailFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysFailFtraceEvent.order)
}

// -------------------------------------------------------------------

// AllocPagesSysStartFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesSysStartFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocPagesSysStartFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesSysStartFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysStartFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void AllocPagesSysStartFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysStartFtraceEvent.gfp_flags)
}

// optional uint32 order = 2;
inline bool AllocPagesSysStartFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocPagesSysStartFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AllocPagesSysStartFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysStartFtraceEvent.order)
  return order_;
}
inline void AllocPagesSysStartFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysStartFtraceEvent.order)
}

// -------------------------------------------------------------------

// DmaAllocContiguousRetryFtraceEvent

// optional int32 tries = 1;
inline bool DmaAllocContiguousRetryFtraceEvent::has_tries() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DmaAllocContiguousRetryFtraceEvent::clear_tries() {
  tries_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DmaAllocContiguousRetryFtraceEvent::tries() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DmaAllocContiguousRetryFtraceEvent.tries)
  return tries_;
}
inline void DmaAllocContiguousRetryFtraceEvent::set_tries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  tries_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DmaAllocContiguousRetryFtraceEvent.tries)
}

// -------------------------------------------------------------------

// IommuMapRangeFtraceEvent

// optional uint64 chunk_size = 1;
inline bool IommuMapRangeFtraceEvent::has_chunk_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IommuMapRangeFtraceEvent::clear_chunk_size() {
  chunk_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IommuMapRangeFtraceEvent::chunk_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuMapRangeFtraceEvent.chunk_size)
  return chunk_size_;
}
inline void IommuMapRangeFtraceEvent::set_chunk_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  chunk_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuMapRangeFtraceEvent.chunk_size)
}

// optional uint64 len = 2;
inline bool IommuMapRangeFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IommuMapRangeFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IommuMapRangeFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuMapRangeFtraceEvent.len)
  return len_;
}
inline void IommuMapRangeFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuMapRangeFtraceEvent.len)
}

// optional uint64 pa = 3;
inline bool IommuMapRangeFtraceEvent::has_pa() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IommuMapRangeFtraceEvent::clear_pa() {
  pa_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IommuMapRangeFtraceEvent::pa() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuMapRangeFtraceEvent.pa)
  return pa_;
}
inline void IommuMapRangeFtraceEvent::set_pa(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  pa_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuMapRangeFtraceEvent.pa)
}

// optional uint64 va = 4;
inline bool IommuMapRangeFtraceEvent::has_va() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IommuMapRangeFtraceEvent::clear_va() {
  va_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IommuMapRangeFtraceEvent::va() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuMapRangeFtraceEvent.va)
  return va_;
}
inline void IommuMapRangeFtraceEvent::set_va(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  va_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuMapRangeFtraceEvent.va)
}

// -------------------------------------------------------------------

// IommuSecPtblMapRangeEndFtraceEvent

// optional uint64 len = 1;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IommuSecPtblMapRangeEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.len)
  return len_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.len)
}

// optional int32 num = 2;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_num() {
  num_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IommuSecPtblMapRangeEndFtraceEvent::num() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.num)
  return num_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.num)
}

// optional uint32 pa = 3;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_pa() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_pa() {
  pa_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IommuSecPtblMapRangeEndFtraceEvent::pa() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.pa)
  return pa_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_pa(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  pa_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.pa)
}

// optional int32 sec_id = 4;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_sec_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_sec_id() {
  sec_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IommuSecPtblMapRangeEndFtraceEvent::sec_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.sec_id)
  return sec_id_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_sec_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  sec_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.sec_id)
}

// optional uint64 va = 5;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_va() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_va() {
  va_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IommuSecPtblMapRangeEndFtraceEvent::va() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.va)
  return va_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_va(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  va_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.va)
}

// -------------------------------------------------------------------

// IommuSecPtblMapRangeStartFtraceEvent

// optional uint64 len = 1;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IommuSecPtblMapRangeStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.len)
  return len_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.len)
}

// optional int32 num = 2;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_num() {
  num_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IommuSecPtblMapRangeStartFtraceEvent::num() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.num)
  return num_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.num)
}

// optional uint32 pa = 3;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_pa() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_pa() {
  pa_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IommuSecPtblMapRangeStartFtraceEvent::pa() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.pa)
  return pa_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_pa(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  pa_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.pa)
}

// optional int32 sec_id = 4;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_sec_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_sec_id() {
  sec_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IommuSecPtblMapRangeStartFtraceEvent::sec_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.sec_id)
  return sec_id_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_sec_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  sec_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.sec_id)
}

// optional uint64 va = 5;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_va() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_va() {
  va_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IommuSecPtblMapRangeStartFtraceEvent::va() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.va)
  return va_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_va(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  va_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.va)
}

// -------------------------------------------------------------------

// IonAllocBufferEndFtraceEvent

// optional string client_name = 1;
inline bool IonAllocBufferEndFtraceEvent::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonAllocBufferEndFtraceEvent::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonAllocBufferEndFtraceEvent::client_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
  return client_name_.GetNoArena();
}
inline void IonAllocBufferEndFtraceEvent::set_client_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
}
inline void IonAllocBufferEndFtraceEvent::set_client_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
}
inline void IonAllocBufferEndFtraceEvent::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
}
inline void IonAllocBufferEndFtraceEvent::set_client_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
}
inline std::string* IonAllocBufferEndFtraceEvent::mutable_client_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
  return client_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonAllocBufferEndFtraceEvent::release_client_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
  if (!has_client_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonAllocBufferEndFtraceEvent::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
}

// optional uint32 flags = 2;
inline bool IonAllocBufferEndFtraceEvent::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonAllocBufferEndFtraceEvent::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonAllocBufferEndFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.flags)
  return flags_;
}
inline void IonAllocBufferEndFtraceEvent::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.flags)
}

// optional string heap_name = 3;
inline bool IonAllocBufferEndFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonAllocBufferEndFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IonAllocBufferEndFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonAllocBufferEndFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
}
inline void IonAllocBufferEndFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
}
inline void IonAllocBufferEndFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
}
inline void IonAllocBufferEndFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
}
inline std::string* IonAllocBufferEndFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonAllocBufferEndFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonAllocBufferEndFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonAllocBufferEndFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IonAllocBufferEndFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonAllocBufferEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.len)
  return len_;
}
inline void IonAllocBufferEndFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.len)
}

// optional uint32 mask = 5;
inline bool IonAllocBufferEndFtraceEvent::has_mask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IonAllocBufferEndFtraceEvent::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonAllocBufferEndFtraceEvent::mask() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.mask)
  return mask_;
}
inline void IonAllocBufferEndFtraceEvent::set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  mask_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.mask)
}

// -------------------------------------------------------------------

// IonAllocBufferFailFtraceEvent

// optional string client_name = 1;
inline bool IonAllocBufferFailFtraceEvent::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonAllocBufferFailFtraceEvent::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonAllocBufferFailFtraceEvent::client_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
  return client_name_.GetNoArena();
}
inline void IonAllocBufferFailFtraceEvent::set_client_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
}
inline void IonAllocBufferFailFtraceEvent::set_client_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
}
inline void IonAllocBufferFailFtraceEvent::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
}
inline void IonAllocBufferFailFtraceEvent::set_client_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
}
inline std::string* IonAllocBufferFailFtraceEvent::mutable_client_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
  return client_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonAllocBufferFailFtraceEvent::release_client_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
  if (!has_client_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonAllocBufferFailFtraceEvent::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
}

// optional int64 error = 2;
inline bool IonAllocBufferFailFtraceEvent::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonAllocBufferFailFtraceEvent::clear_error() {
  error_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IonAllocBufferFailFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.error)
  return error_;
}
inline void IonAllocBufferFailFtraceEvent::set_error(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  error_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.error)
}

// optional uint32 flags = 3;
inline bool IonAllocBufferFailFtraceEvent::has_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IonAllocBufferFailFtraceEvent::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonAllocBufferFailFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.flags)
  return flags_;
}
inline void IonAllocBufferFailFtraceEvent::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.flags)
}

// optional string heap_name = 4;
inline bool IonAllocBufferFailFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonAllocBufferFailFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IonAllocBufferFailFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonAllocBufferFailFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
}
inline void IonAllocBufferFailFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
}
inline void IonAllocBufferFailFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
}
inline void IonAllocBufferFailFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
}
inline std::string* IonAllocBufferFailFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonAllocBufferFailFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonAllocBufferFailFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
}

// optional uint64 len = 5;
inline bool IonAllocBufferFailFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IonAllocBufferFailFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonAllocBufferFailFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.len)
  return len_;
}
inline void IonAllocBufferFailFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.len)
}

// optional uint32 mask = 6;
inline bool IonAllocBufferFailFtraceEvent::has_mask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IonAllocBufferFailFtraceEvent::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonAllocBufferFailFtraceEvent::mask() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.mask)
  return mask_;
}
inline void IonAllocBufferFailFtraceEvent::set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  mask_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.mask)
}

// -------------------------------------------------------------------

// IonAllocBufferFallbackFtraceEvent

// optional string client_name = 1;
inline bool IonAllocBufferFallbackFtraceEvent::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonAllocBufferFallbackFtraceEvent::client_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
  return client_name_.GetNoArena();
}
inline void IonAllocBufferFallbackFtraceEvent::set_client_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
}
inline void IonAllocBufferFallbackFtraceEvent::set_client_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
}
inline void IonAllocBufferFallbackFtraceEvent::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
}
inline void IonAllocBufferFallbackFtraceEvent::set_client_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
}
inline std::string* IonAllocBufferFallbackFtraceEvent::mutable_client_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
  return client_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonAllocBufferFallbackFtraceEvent::release_client_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
  if (!has_client_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonAllocBufferFallbackFtraceEvent::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
}

// optional int64 error = 2;
inline bool IonAllocBufferFallbackFtraceEvent::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_error() {
  error_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IonAllocBufferFallbackFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.error)
  return error_;
}
inline void IonAllocBufferFallbackFtraceEvent::set_error(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  error_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.error)
}

// optional uint32 flags = 3;
inline bool IonAllocBufferFallbackFtraceEvent::has_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonAllocBufferFallbackFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.flags)
  return flags_;
}
inline void IonAllocBufferFallbackFtraceEvent::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.flags)
}

// optional string heap_name = 4;
inline bool IonAllocBufferFallbackFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IonAllocBufferFallbackFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonAllocBufferFallbackFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
}
inline void IonAllocBufferFallbackFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
}
inline void IonAllocBufferFallbackFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
}
inline void IonAllocBufferFallbackFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
}
inline std::string* IonAllocBufferFallbackFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonAllocBufferFallbackFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonAllocBufferFallbackFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
}

// optional uint64 len = 5;
inline bool IonAllocBufferFallbackFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonAllocBufferFallbackFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.len)
  return len_;
}
inline void IonAllocBufferFallbackFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.len)
}

// optional uint32 mask = 6;
inline bool IonAllocBufferFallbackFtraceEvent::has_mask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonAllocBufferFallbackFtraceEvent::mask() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.mask)
  return mask_;
}
inline void IonAllocBufferFallbackFtraceEvent::set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  mask_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.mask)
}

// -------------------------------------------------------------------

// IonAllocBufferStartFtraceEvent

// optional string client_name = 1;
inline bool IonAllocBufferStartFtraceEvent::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonAllocBufferStartFtraceEvent::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonAllocBufferStartFtraceEvent::client_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
  return client_name_.GetNoArena();
}
inline void IonAllocBufferStartFtraceEvent::set_client_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
}
inline void IonAllocBufferStartFtraceEvent::set_client_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
}
inline void IonAllocBufferStartFtraceEvent::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
}
inline void IonAllocBufferStartFtraceEvent::set_client_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
}
inline std::string* IonAllocBufferStartFtraceEvent::mutable_client_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
  return client_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonAllocBufferStartFtraceEvent::release_client_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
  if (!has_client_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonAllocBufferStartFtraceEvent::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
}

// optional uint32 flags = 2;
inline bool IonAllocBufferStartFtraceEvent::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonAllocBufferStartFtraceEvent::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonAllocBufferStartFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.flags)
  return flags_;
}
inline void IonAllocBufferStartFtraceEvent::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.flags)
}

// optional string heap_name = 3;
inline bool IonAllocBufferStartFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonAllocBufferStartFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IonAllocBufferStartFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonAllocBufferStartFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
}
inline void IonAllocBufferStartFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
}
inline void IonAllocBufferStartFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
}
inline void IonAllocBufferStartFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
}
inline std::string* IonAllocBufferStartFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonAllocBufferStartFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonAllocBufferStartFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonAllocBufferStartFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IonAllocBufferStartFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonAllocBufferStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.len)
  return len_;
}
inline void IonAllocBufferStartFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.len)
}

// optional uint32 mask = 5;
inline bool IonAllocBufferStartFtraceEvent::has_mask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IonAllocBufferStartFtraceEvent::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonAllocBufferStartFtraceEvent::mask() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.mask)
  return mask_;
}
inline void IonAllocBufferStartFtraceEvent::set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  mask_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.mask)
}

// -------------------------------------------------------------------

// IonCpAllocRetryFtraceEvent

// optional int32 tries = 1;
inline bool IonCpAllocRetryFtraceEvent::has_tries() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonCpAllocRetryFtraceEvent::clear_tries() {
  tries_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IonCpAllocRetryFtraceEvent::tries() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpAllocRetryFtraceEvent.tries)
  return tries_;
}
inline void IonCpAllocRetryFtraceEvent::set_tries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  tries_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpAllocRetryFtraceEvent.tries)
}

// -------------------------------------------------------------------

// IonCpSecureBufferEndFtraceEvent

// optional uint64 align = 1;
inline bool IonCpSecureBufferEndFtraceEvent::has_align() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonCpSecureBufferEndFtraceEvent::clear_align() {
  align_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonCpSecureBufferEndFtraceEvent::align() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferEndFtraceEvent.align)
  return align_;
}
inline void IonCpSecureBufferEndFtraceEvent::set_align(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  align_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferEndFtraceEvent.align)
}

// optional uint64 flags = 2;
inline bool IonCpSecureBufferEndFtraceEvent::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonCpSecureBufferEndFtraceEvent::clear_flags() {
  flags_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonCpSecureBufferEndFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferEndFtraceEvent.flags)
  return flags_;
}
inline void IonCpSecureBufferEndFtraceEvent::set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferEndFtraceEvent.flags)
}

// optional string heap_name = 3;
inline bool IonCpSecureBufferEndFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonCpSecureBufferEndFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonCpSecureBufferEndFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonCpSecureBufferEndFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
}
inline void IonCpSecureBufferEndFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
}
inline void IonCpSecureBufferEndFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
}
inline void IonCpSecureBufferEndFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
}
inline std::string* IonCpSecureBufferEndFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonCpSecureBufferEndFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonCpSecureBufferEndFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonCpSecureBufferEndFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IonCpSecureBufferEndFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonCpSecureBufferEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferEndFtraceEvent.len)
  return len_;
}
inline void IonCpSecureBufferEndFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferEndFtraceEvent.len)
}

// -------------------------------------------------------------------

// IonCpSecureBufferStartFtraceEvent

// optional uint64 align = 1;
inline bool IonCpSecureBufferStartFtraceEvent::has_align() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonCpSecureBufferStartFtraceEvent::clear_align() {
  align_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonCpSecureBufferStartFtraceEvent::align() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferStartFtraceEvent.align)
  return align_;
}
inline void IonCpSecureBufferStartFtraceEvent::set_align(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  align_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferStartFtraceEvent.align)
}

// optional uint64 flags = 2;
inline bool IonCpSecureBufferStartFtraceEvent::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonCpSecureBufferStartFtraceEvent::clear_flags() {
  flags_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonCpSecureBufferStartFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferStartFtraceEvent.flags)
  return flags_;
}
inline void IonCpSecureBufferStartFtraceEvent::set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferStartFtraceEvent.flags)
}

// optional string heap_name = 3;
inline bool IonCpSecureBufferStartFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonCpSecureBufferStartFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonCpSecureBufferStartFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonCpSecureBufferStartFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
}
inline void IonCpSecureBufferStartFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
}
inline void IonCpSecureBufferStartFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
}
inline void IonCpSecureBufferStartFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
}
inline std::string* IonCpSecureBufferStartFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonCpSecureBufferStartFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonCpSecureBufferStartFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonCpSecureBufferStartFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IonCpSecureBufferStartFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonCpSecureBufferStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferStartFtraceEvent.len)
  return len_;
}
inline void IonCpSecureBufferStartFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferStartFtraceEvent.len)
}

// -------------------------------------------------------------------

// IonPrefetchingFtraceEvent

// optional uint64 len = 1;
inline bool IonPrefetchingFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonPrefetchingFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonPrefetchingFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonPrefetchingFtraceEvent.len)
  return len_;
}
inline void IonPrefetchingFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonPrefetchingFtraceEvent.len)
}

// -------------------------------------------------------------------

// IonSecureCmaAddToPoolEndFtraceEvent

// optional uint32 is_prefetch = 1;
inline bool IonSecureCmaAddToPoolEndFtraceEvent::has_is_prefetch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::clear_is_prefetch() {
  is_prefetch_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonSecureCmaAddToPoolEndFtraceEvent::is_prefetch() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.is_prefetch)
  return is_prefetch_;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::set_is_prefetch(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  is_prefetch_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.is_prefetch)
}

// optional uint64 len = 2;
inline bool IonSecureCmaAddToPoolEndFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaAddToPoolEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.len)
  return len_;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.len)
}

// optional int32 pool_total = 3;
inline bool IonSecureCmaAddToPoolEndFtraceEvent::has_pool_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::clear_pool_total() {
  pool_total_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IonSecureCmaAddToPoolEndFtraceEvent::pool_total() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.pool_total)
  return pool_total_;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::set_pool_total(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  pool_total_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.pool_total)
}

// -------------------------------------------------------------------

// IonSecureCmaAddToPoolStartFtraceEvent

// optional uint32 is_prefetch = 1;
inline bool IonSecureCmaAddToPoolStartFtraceEvent::has_is_prefetch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::clear_is_prefetch() {
  is_prefetch_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IonSecureCmaAddToPoolStartFtraceEvent::is_prefetch() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.is_prefetch)
  return is_prefetch_;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::set_is_prefetch(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  is_prefetch_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.is_prefetch)
}

// optional uint64 len = 2;
inline bool IonSecureCmaAddToPoolStartFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaAddToPoolStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.len)
  return len_;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.len)
}

// optional int32 pool_total = 3;
inline bool IonSecureCmaAddToPoolStartFtraceEvent::has_pool_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::clear_pool_total() {
  pool_total_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IonSecureCmaAddToPoolStartFtraceEvent::pool_total() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.pool_total)
  return pool_total_;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::set_pool_total(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  pool_total_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.pool_total)
}

// -------------------------------------------------------------------

// IonSecureCmaAllocateEndFtraceEvent

// optional uint64 align = 1;
inline bool IonSecureCmaAllocateEndFtraceEvent::has_align() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonSecureCmaAllocateEndFtraceEvent::clear_align() {
  align_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaAllocateEndFtraceEvent::align() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.align)
  return align_;
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_align(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  align_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.align)
}

// optional uint64 flags = 2;
inline bool IonSecureCmaAllocateEndFtraceEvent::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonSecureCmaAllocateEndFtraceEvent::clear_flags() {
  flags_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaAllocateEndFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.flags)
  return flags_;
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.flags)
}

// optional string heap_name = 3;
inline bool IonSecureCmaAllocateEndFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonSecureCmaAllocateEndFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonSecureCmaAllocateEndFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
}
inline std::string* IonSecureCmaAllocateEndFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonSecureCmaAllocateEndFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonSecureCmaAllocateEndFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IonSecureCmaAllocateEndFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaAllocateEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.len)
  return len_;
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.len)
}

// -------------------------------------------------------------------

// IonSecureCmaAllocateStartFtraceEvent

// optional uint64 align = 1;
inline bool IonSecureCmaAllocateStartFtraceEvent::has_align() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonSecureCmaAllocateStartFtraceEvent::clear_align() {
  align_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaAllocateStartFtraceEvent::align() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.align)
  return align_;
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_align(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  align_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.align)
}

// optional uint64 flags = 2;
inline bool IonSecureCmaAllocateStartFtraceEvent::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonSecureCmaAllocateStartFtraceEvent::clear_flags() {
  flags_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaAllocateStartFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.flags)
  return flags_;
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.flags)
}

// optional string heap_name = 3;
inline bool IonSecureCmaAllocateStartFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonSecureCmaAllocateStartFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonSecureCmaAllocateStartFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
}
inline std::string* IonSecureCmaAllocateStartFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonSecureCmaAllocateStartFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonSecureCmaAllocateStartFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IonSecureCmaAllocateStartFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaAllocateStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.len)
  return len_;
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.len)
}

// -------------------------------------------------------------------

// IonSecureCmaShrinkPoolEndFtraceEvent

// optional uint64 drained_size = 1;
inline bool IonSecureCmaShrinkPoolEndFtraceEvent::has_drained_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::clear_drained_size() {
  drained_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaShrinkPoolEndFtraceEvent::drained_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent.drained_size)
  return drained_size_;
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::set_drained_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  drained_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent.drained_size)
}

// optional uint64 skipped_size = 2;
inline bool IonSecureCmaShrinkPoolEndFtraceEvent::has_skipped_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::clear_skipped_size() {
  skipped_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaShrinkPoolEndFtraceEvent::skipped_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent.skipped_size)
  return skipped_size_;
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::set_skipped_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  skipped_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent.skipped_size)
}

// -------------------------------------------------------------------

// IonSecureCmaShrinkPoolStartFtraceEvent

// optional uint64 drained_size = 1;
inline bool IonSecureCmaShrinkPoolStartFtraceEvent::has_drained_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::clear_drained_size() {
  drained_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaShrinkPoolStartFtraceEvent::drained_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent.drained_size)
  return drained_size_;
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::set_drained_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  drained_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent.drained_size)
}

// optional uint64 skipped_size = 2;
inline bool IonSecureCmaShrinkPoolStartFtraceEvent::has_skipped_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::clear_skipped_size() {
  skipped_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonSecureCmaShrinkPoolStartFtraceEvent::skipped_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent.skipped_size)
  return skipped_size_;
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::set_skipped_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  skipped_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent.skipped_size)
}

// -------------------------------------------------------------------

// KfreeFtraceEvent

// optional uint64 call_site = 1;
inline bool KfreeFtraceEvent::has_call_site() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KfreeFtraceEvent::clear_call_site() {
  call_site_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KfreeFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KfreeFtraceEvent.call_site)
  return call_site_;
}
inline void KfreeFtraceEvent::set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  call_site_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KfreeFtraceEvent.call_site)
}

// optional uint64 ptr = 2;
inline bool KfreeFtraceEvent::has_ptr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KfreeFtraceEvent::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KfreeFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KfreeFtraceEvent.ptr)
  return ptr_;
}
inline void KfreeFtraceEvent::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KfreeFtraceEvent.ptr)
}

// -------------------------------------------------------------------

// KmallocFtraceEvent

// optional uint64 bytes_alloc = 1;
inline bool KmallocFtraceEvent::has_bytes_alloc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KmallocFtraceEvent::clear_bytes_alloc() {
  bytes_alloc_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmallocFtraceEvent::bytes_alloc() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.bytes_alloc)
  return bytes_alloc_;
}
inline void KmallocFtraceEvent::set_bytes_alloc(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  bytes_alloc_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.bytes_alloc)
}

// optional uint64 bytes_req = 2;
inline bool KmallocFtraceEvent::has_bytes_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KmallocFtraceEvent::clear_bytes_req() {
  bytes_req_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmallocFtraceEvent::bytes_req() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.bytes_req)
  return bytes_req_;
}
inline void KmallocFtraceEvent::set_bytes_req(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  bytes_req_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.bytes_req)
}

// optional uint64 call_site = 3;
inline bool KmallocFtraceEvent::has_call_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KmallocFtraceEvent::clear_call_site() {
  call_site_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmallocFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.call_site)
  return call_site_;
}
inline void KmallocFtraceEvent::set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  call_site_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.call_site)
}

// optional uint32 gfp_flags = 4;
inline bool KmallocFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KmallocFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KmallocFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void KmallocFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.gfp_flags)
}

// optional uint64 ptr = 5;
inline bool KmallocFtraceEvent::has_ptr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KmallocFtraceEvent::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmallocFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.ptr)
  return ptr_;
}
inline void KmallocFtraceEvent::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.ptr)
}

// -------------------------------------------------------------------

// KmallocNodeFtraceEvent

// optional uint64 bytes_alloc = 1;
inline bool KmallocNodeFtraceEvent::has_bytes_alloc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KmallocNodeFtraceEvent::clear_bytes_alloc() {
  bytes_alloc_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmallocNodeFtraceEvent::bytes_alloc() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.bytes_alloc)
  return bytes_alloc_;
}
inline void KmallocNodeFtraceEvent::set_bytes_alloc(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  bytes_alloc_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.bytes_alloc)
}

// optional uint64 bytes_req = 2;
inline bool KmallocNodeFtraceEvent::has_bytes_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KmallocNodeFtraceEvent::clear_bytes_req() {
  bytes_req_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmallocNodeFtraceEvent::bytes_req() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.bytes_req)
  return bytes_req_;
}
inline void KmallocNodeFtraceEvent::set_bytes_req(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  bytes_req_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.bytes_req)
}

// optional uint64 call_site = 3;
inline bool KmallocNodeFtraceEvent::has_call_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KmallocNodeFtraceEvent::clear_call_site() {
  call_site_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmallocNodeFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.call_site)
  return call_site_;
}
inline void KmallocNodeFtraceEvent::set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  call_site_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.call_site)
}

// optional uint32 gfp_flags = 4;
inline bool KmallocNodeFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KmallocNodeFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KmallocNodeFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void KmallocNodeFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.gfp_flags)
}

// optional int32 node = 5;
inline bool KmallocNodeFtraceEvent::has_node() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KmallocNodeFtraceEvent::clear_node() {
  node_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KmallocNodeFtraceEvent::node() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.node)
  return node_;
}
inline void KmallocNodeFtraceEvent::set_node(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  node_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.node)
}

// optional uint64 ptr = 6;
inline bool KmallocNodeFtraceEvent::has_ptr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KmallocNodeFtraceEvent::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmallocNodeFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.ptr)
  return ptr_;
}
inline void KmallocNodeFtraceEvent::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.ptr)
}

// -------------------------------------------------------------------

// KmemCacheAllocFtraceEvent

// optional uint64 bytes_alloc = 1;
inline bool KmemCacheAllocFtraceEvent::has_bytes_alloc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KmemCacheAllocFtraceEvent::clear_bytes_alloc() {
  bytes_alloc_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheAllocFtraceEvent::bytes_alloc() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.bytes_alloc)
  return bytes_alloc_;
}
inline void KmemCacheAllocFtraceEvent::set_bytes_alloc(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  bytes_alloc_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.bytes_alloc)
}

// optional uint64 bytes_req = 2;
inline bool KmemCacheAllocFtraceEvent::has_bytes_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KmemCacheAllocFtraceEvent::clear_bytes_req() {
  bytes_req_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheAllocFtraceEvent::bytes_req() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.bytes_req)
  return bytes_req_;
}
inline void KmemCacheAllocFtraceEvent::set_bytes_req(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  bytes_req_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.bytes_req)
}

// optional uint64 call_site = 3;
inline bool KmemCacheAllocFtraceEvent::has_call_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KmemCacheAllocFtraceEvent::clear_call_site() {
  call_site_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheAllocFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.call_site)
  return call_site_;
}
inline void KmemCacheAllocFtraceEvent::set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  call_site_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.call_site)
}

// optional uint32 gfp_flags = 4;
inline bool KmemCacheAllocFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KmemCacheAllocFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KmemCacheAllocFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void KmemCacheAllocFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.gfp_flags)
}

// optional uint64 ptr = 5;
inline bool KmemCacheAllocFtraceEvent::has_ptr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KmemCacheAllocFtraceEvent::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheAllocFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.ptr)
  return ptr_;
}
inline void KmemCacheAllocFtraceEvent::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.ptr)
}

// -------------------------------------------------------------------

// KmemCacheAllocNodeFtraceEvent

// optional uint64 bytes_alloc = 1;
inline bool KmemCacheAllocNodeFtraceEvent::has_bytes_alloc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_bytes_alloc() {
  bytes_alloc_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheAllocNodeFtraceEvent::bytes_alloc() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.bytes_alloc)
  return bytes_alloc_;
}
inline void KmemCacheAllocNodeFtraceEvent::set_bytes_alloc(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  bytes_alloc_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.bytes_alloc)
}

// optional uint64 bytes_req = 2;
inline bool KmemCacheAllocNodeFtraceEvent::has_bytes_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_bytes_req() {
  bytes_req_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheAllocNodeFtraceEvent::bytes_req() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.bytes_req)
  return bytes_req_;
}
inline void KmemCacheAllocNodeFtraceEvent::set_bytes_req(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  bytes_req_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.bytes_req)
}

// optional uint64 call_site = 3;
inline bool KmemCacheAllocNodeFtraceEvent::has_call_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_call_site() {
  call_site_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheAllocNodeFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.call_site)
  return call_site_;
}
inline void KmemCacheAllocNodeFtraceEvent::set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  call_site_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.call_site)
}

// optional uint32 gfp_flags = 4;
inline bool KmemCacheAllocNodeFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KmemCacheAllocNodeFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void KmemCacheAllocNodeFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.gfp_flags)
}

// optional int32 node = 5;
inline bool KmemCacheAllocNodeFtraceEvent::has_node() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_node() {
  node_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KmemCacheAllocNodeFtraceEvent::node() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.node)
  return node_;
}
inline void KmemCacheAllocNodeFtraceEvent::set_node(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  node_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.node)
}

// optional uint64 ptr = 6;
inline bool KmemCacheAllocNodeFtraceEvent::has_ptr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheAllocNodeFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.ptr)
  return ptr_;
}
inline void KmemCacheAllocNodeFtraceEvent::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.ptr)
}

// -------------------------------------------------------------------

// KmemCacheFreeFtraceEvent

// optional uint64 call_site = 1;
inline bool KmemCacheFreeFtraceEvent::has_call_site() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KmemCacheFreeFtraceEvent::clear_call_site() {
  call_site_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheFreeFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheFreeFtraceEvent.call_site)
  return call_site_;
}
inline void KmemCacheFreeFtraceEvent::set_call_site(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  call_site_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheFreeFtraceEvent.call_site)
}

// optional uint64 ptr = 2;
inline bool KmemCacheFreeFtraceEvent::has_ptr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KmemCacheFreeFtraceEvent::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KmemCacheFreeFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheFreeFtraceEvent.ptr)
  return ptr_;
}
inline void KmemCacheFreeFtraceEvent::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheFreeFtraceEvent.ptr)
}

// -------------------------------------------------------------------

// MigratePagesEndFtraceEvent

// optional int32 mode = 1;
inline bool MigratePagesEndFtraceEvent::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MigratePagesEndFtraceEvent::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MigratePagesEndFtraceEvent::mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MigratePagesEndFtraceEvent.mode)
  return mode_;
}
inline void MigratePagesEndFtraceEvent::set_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MigratePagesEndFtraceEvent.mode)
}

// -------------------------------------------------------------------

// MigratePagesStartFtraceEvent

// optional int32 mode = 1;
inline bool MigratePagesStartFtraceEvent::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MigratePagesStartFtraceEvent::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MigratePagesStartFtraceEvent::mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MigratePagesStartFtraceEvent.mode)
  return mode_;
}
inline void MigratePagesStartFtraceEvent::set_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MigratePagesStartFtraceEvent.mode)
}

// -------------------------------------------------------------------

// MigrateRetryFtraceEvent

// optional int32 tries = 1;
inline bool MigrateRetryFtraceEvent::has_tries() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MigrateRetryFtraceEvent::clear_tries() {
  tries_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MigrateRetryFtraceEvent::tries() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MigrateRetryFtraceEvent.tries)
  return tries_;
}
inline void MigrateRetryFtraceEvent::set_tries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  tries_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MigrateRetryFtraceEvent.tries)
}

// -------------------------------------------------------------------

// MmPageAllocFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool MmPageAllocFtraceEvent::has_gfp_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MmPageAllocFtraceEvent::clear_gfp_flags() {
  gfp_flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MmPageAllocFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.gfp_flags)
  return gfp_flags_;
}
inline void MmPageAllocFtraceEvent::set_gfp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gfp_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.gfp_flags)
}

// optional int32 migratetype = 2;
inline bool MmPageAllocFtraceEvent::has_migratetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MmPageAllocFtraceEvent::clear_migratetype() {
  migratetype_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPageAllocFtraceEvent::migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.migratetype)
  return migratetype_;
}
inline void MmPageAllocFtraceEvent::set_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  migratetype_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.migratetype)
}

// optional uint32 order = 3;
inline bool MmPageAllocFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MmPageAllocFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MmPageAllocFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.order)
  return order_;
}
inline void MmPageAllocFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.order)
}

// optional uint64 page = 4;
inline bool MmPageAllocFtraceEvent::has_page() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MmPageAllocFtraceEvent::clear_page() {
  page_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageAllocFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.page)
  return page_;
}
inline void MmPageAllocFtraceEvent::set_page(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.page)
}

// optional uint64 pfn = 5;
inline bool MmPageAllocFtraceEvent::has_pfn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MmPageAllocFtraceEvent::clear_pfn() {
  pfn_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageAllocFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.pfn)
  return pfn_;
}
inline void MmPageAllocFtraceEvent::set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  pfn_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.pfn)
}

// -------------------------------------------------------------------

// MmPageAllocExtfragFtraceEvent

// optional int32 alloc_migratetype = 1;
inline bool MmPageAllocExtfragFtraceEvent::has_alloc_migratetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MmPageAllocExtfragFtraceEvent::clear_alloc_migratetype() {
  alloc_migratetype_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPageAllocExtfragFtraceEvent::alloc_migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.alloc_migratetype)
  return alloc_migratetype_;
}
inline void MmPageAllocExtfragFtraceEvent::set_alloc_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  alloc_migratetype_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.alloc_migratetype)
}

// optional int32 alloc_order = 2;
inline bool MmPageAllocExtfragFtraceEvent::has_alloc_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MmPageAllocExtfragFtraceEvent::clear_alloc_order() {
  alloc_order_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPageAllocExtfragFtraceEvent::alloc_order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.alloc_order)
  return alloc_order_;
}
inline void MmPageAllocExtfragFtraceEvent::set_alloc_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  alloc_order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.alloc_order)
}

// optional int32 fallback_migratetype = 3;
inline bool MmPageAllocExtfragFtraceEvent::has_fallback_migratetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MmPageAllocExtfragFtraceEvent::clear_fallback_migratetype() {
  fallback_migratetype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPageAllocExtfragFtraceEvent::fallback_migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.fallback_migratetype)
  return fallback_migratetype_;
}
inline void MmPageAllocExtfragFtraceEvent::set_fallback_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  fallback_migratetype_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.fallback_migratetype)
}

// optional int32 fallback_order = 4;
inline bool MmPageAllocExtfragFtraceEvent::has_fallback_order() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MmPageAllocExtfragFtraceEvent::clear_fallback_order() {
  fallback_order_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPageAllocExtfragFtraceEvent::fallback_order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.fallback_order)
  return fallback_order_;
}
inline void MmPageAllocExtfragFtraceEvent::set_fallback_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  fallback_order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.fallback_order)
}

// optional uint64 page = 5;
inline bool MmPageAllocExtfragFtraceEvent::has_page() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MmPageAllocExtfragFtraceEvent::clear_page() {
  page_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageAllocExtfragFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.page)
  return page_;
}
inline void MmPageAllocExtfragFtraceEvent::set_page(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.page)
}

// optional int32 change_ownership = 6;
inline bool MmPageAllocExtfragFtraceEvent::has_change_ownership() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MmPageAllocExtfragFtraceEvent::clear_change_ownership() {
  change_ownership_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPageAllocExtfragFtraceEvent::change_ownership() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.change_ownership)
  return change_ownership_;
}
inline void MmPageAllocExtfragFtraceEvent::set_change_ownership(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  change_ownership_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.change_ownership)
}

// optional uint64 pfn = 7;
inline bool MmPageAllocExtfragFtraceEvent::has_pfn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MmPageAllocExtfragFtraceEvent::clear_pfn() {
  pfn_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageAllocExtfragFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.pfn)
  return pfn_;
}
inline void MmPageAllocExtfragFtraceEvent::set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  pfn_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.pfn)
}

// -------------------------------------------------------------------

// MmPageAllocZoneLockedFtraceEvent

// optional int32 migratetype = 1;
inline bool MmPageAllocZoneLockedFtraceEvent::has_migratetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MmPageAllocZoneLockedFtraceEvent::clear_migratetype() {
  migratetype_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPageAllocZoneLockedFtraceEvent::migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.migratetype)
  return migratetype_;
}
inline void MmPageAllocZoneLockedFtraceEvent::set_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  migratetype_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.migratetype)
}

// optional uint32 order = 2;
inline bool MmPageAllocZoneLockedFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MmPageAllocZoneLockedFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MmPageAllocZoneLockedFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.order)
  return order_;
}
inline void MmPageAllocZoneLockedFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.order)
}

// optional uint64 page = 3;
inline bool MmPageAllocZoneLockedFtraceEvent::has_page() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MmPageAllocZoneLockedFtraceEvent::clear_page() {
  page_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageAllocZoneLockedFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.page)
  return page_;
}
inline void MmPageAllocZoneLockedFtraceEvent::set_page(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.page)
}

// optional uint64 pfn = 4;
inline bool MmPageAllocZoneLockedFtraceEvent::has_pfn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MmPageAllocZoneLockedFtraceEvent::clear_pfn() {
  pfn_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageAllocZoneLockedFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.pfn)
  return pfn_;
}
inline void MmPageAllocZoneLockedFtraceEvent::set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  pfn_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.pfn)
}

// -------------------------------------------------------------------

// MmPageFreeFtraceEvent

// optional uint32 order = 1;
inline bool MmPageFreeFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MmPageFreeFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MmPageFreeFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeFtraceEvent.order)
  return order_;
}
inline void MmPageFreeFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeFtraceEvent.order)
}

// optional uint64 page = 2;
inline bool MmPageFreeFtraceEvent::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MmPageFreeFtraceEvent::clear_page() {
  page_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageFreeFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeFtraceEvent.page)
  return page_;
}
inline void MmPageFreeFtraceEvent::set_page(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeFtraceEvent.page)
}

// optional uint64 pfn = 3;
inline bool MmPageFreeFtraceEvent::has_pfn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MmPageFreeFtraceEvent::clear_pfn() {
  pfn_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageFreeFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeFtraceEvent.pfn)
  return pfn_;
}
inline void MmPageFreeFtraceEvent::set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  pfn_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeFtraceEvent.pfn)
}

// -------------------------------------------------------------------

// MmPageFreeBatchedFtraceEvent

// optional int32 cold = 1;
inline bool MmPageFreeBatchedFtraceEvent::has_cold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MmPageFreeBatchedFtraceEvent::clear_cold() {
  cold_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPageFreeBatchedFtraceEvent::cold() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeBatchedFtraceEvent.cold)
  return cold_;
}
inline void MmPageFreeBatchedFtraceEvent::set_cold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  cold_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeBatchedFtraceEvent.cold)
}

// optional uint64 page = 2;
inline bool MmPageFreeBatchedFtraceEvent::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MmPageFreeBatchedFtraceEvent::clear_page() {
  page_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageFreeBatchedFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeBatchedFtraceEvent.page)
  return page_;
}
inline void MmPageFreeBatchedFtraceEvent::set_page(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeBatchedFtraceEvent.page)
}

// optional uint64 pfn = 3;
inline bool MmPageFreeBatchedFtraceEvent::has_pfn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MmPageFreeBatchedFtraceEvent::clear_pfn() {
  pfn_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPageFreeBatchedFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeBatchedFtraceEvent.pfn)
  return pfn_;
}
inline void MmPageFreeBatchedFtraceEvent::set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  pfn_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeBatchedFtraceEvent.pfn)
}

// -------------------------------------------------------------------

// MmPagePcpuDrainFtraceEvent

// optional int32 migratetype = 1;
inline bool MmPagePcpuDrainFtraceEvent::has_migratetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MmPagePcpuDrainFtraceEvent::clear_migratetype() {
  migratetype_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MmPagePcpuDrainFtraceEvent::migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPagePcpuDrainFtraceEvent.migratetype)
  return migratetype_;
}
inline void MmPagePcpuDrainFtraceEvent::set_migratetype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  migratetype_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPagePcpuDrainFtraceEvent.migratetype)
}

// optional uint32 order = 2;
inline bool MmPagePcpuDrainFtraceEvent::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MmPagePcpuDrainFtraceEvent::clear_order() {
  order_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MmPagePcpuDrainFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPagePcpuDrainFtraceEvent.order)
  return order_;
}
inline void MmPagePcpuDrainFtraceEvent::set_order(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPagePcpuDrainFtraceEvent.order)
}

// optional uint64 page = 3;
inline bool MmPagePcpuDrainFtraceEvent::has_page() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MmPagePcpuDrainFtraceEvent::clear_page() {
  page_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPagePcpuDrainFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPagePcpuDrainFtraceEvent.page)
  return page_;
}
inline void MmPagePcpuDrainFtraceEvent::set_page(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPagePcpuDrainFtraceEvent.page)
}

// optional uint64 pfn = 4;
inline bool MmPagePcpuDrainFtraceEvent::has_pfn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MmPagePcpuDrainFtraceEvent::clear_pfn() {
  pfn_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MmPagePcpuDrainFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPagePcpuDrainFtraceEvent.pfn)
  return pfn_;
}
inline void MmPagePcpuDrainFtraceEvent::set_pfn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  pfn_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPagePcpuDrainFtraceEvent.pfn)
}

// -------------------------------------------------------------------

// RssStatFtraceEvent

// optional int32 member = 1;
inline bool RssStatFtraceEvent::has_member() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RssStatFtraceEvent::clear_member() {
  member_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RssStatFtraceEvent::member() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RssStatFtraceEvent.member)
  return member_;
}
inline void RssStatFtraceEvent::set_member(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  member_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RssStatFtraceEvent.member)
}

// optional int64 size = 2;
inline bool RssStatFtraceEvent::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RssStatFtraceEvent::clear_size() {
  size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RssStatFtraceEvent::size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RssStatFtraceEvent.size)
  return size_;
}
inline void RssStatFtraceEvent::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RssStatFtraceEvent.size)
}

// optional uint32 curr = 3;
inline bool RssStatFtraceEvent::has_curr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RssStatFtraceEvent::clear_curr() {
  curr_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RssStatFtraceEvent::curr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RssStatFtraceEvent.curr)
  return curr_;
}
inline void RssStatFtraceEvent::set_curr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  curr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RssStatFtraceEvent.curr)
}

// optional uint32 mm_id = 4;
inline bool RssStatFtraceEvent::has_mm_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RssStatFtraceEvent::clear_mm_id() {
  mm_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RssStatFtraceEvent::mm_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RssStatFtraceEvent.mm_id)
  return mm_id_;
}
inline void RssStatFtraceEvent::set_mm_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  mm_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RssStatFtraceEvent.mm_id)
}

// -------------------------------------------------------------------

// IonHeapShrinkFtraceEvent

// optional string heap_name = 1;
inline bool IonHeapShrinkFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonHeapShrinkFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonHeapShrinkFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonHeapShrinkFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
}
inline void IonHeapShrinkFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
}
inline void IonHeapShrinkFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
}
inline void IonHeapShrinkFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
}
inline std::string* IonHeapShrinkFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonHeapShrinkFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonHeapShrinkFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
}

// optional uint64 len = 2;
inline bool IonHeapShrinkFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonHeapShrinkFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonHeapShrinkFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapShrinkFtraceEvent.len)
  return len_;
}
inline void IonHeapShrinkFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapShrinkFtraceEvent.len)
}

// optional int64 total_allocated = 3;
inline bool IonHeapShrinkFtraceEvent::has_total_allocated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonHeapShrinkFtraceEvent::clear_total_allocated() {
  total_allocated_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IonHeapShrinkFtraceEvent::total_allocated() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapShrinkFtraceEvent.total_allocated)
  return total_allocated_;
}
inline void IonHeapShrinkFtraceEvent::set_total_allocated(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  total_allocated_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapShrinkFtraceEvent.total_allocated)
}

// -------------------------------------------------------------------

// IonHeapGrowFtraceEvent

// optional string heap_name = 1;
inline bool IonHeapGrowFtraceEvent::has_heap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonHeapGrowFtraceEvent::clear_heap_name() {
  heap_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonHeapGrowFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
  return heap_name_.GetNoArena();
}
inline void IonHeapGrowFtraceEvent::set_heap_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
}
inline void IonHeapGrowFtraceEvent::set_heap_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
}
inline void IonHeapGrowFtraceEvent::set_heap_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
}
inline void IonHeapGrowFtraceEvent::set_heap_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  heap_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
}
inline std::string* IonHeapGrowFtraceEvent::mutable_heap_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
  return heap_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IonHeapGrowFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
  if (!has_heap_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return heap_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IonHeapGrowFtraceEvent::set_allocated_heap_name(std::string* heap_name) {
  if (heap_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  heap_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heap_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
}

// optional uint64 len = 2;
inline bool IonHeapGrowFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonHeapGrowFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonHeapGrowFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapGrowFtraceEvent.len)
  return len_;
}
inline void IonHeapGrowFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapGrowFtraceEvent.len)
}

// optional int64 total_allocated = 3;
inline bool IonHeapGrowFtraceEvent::has_total_allocated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IonHeapGrowFtraceEvent::clear_total_allocated() {
  total_allocated_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IonHeapGrowFtraceEvent::total_allocated() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapGrowFtraceEvent.total_allocated)
  return total_allocated_;
}
inline void IonHeapGrowFtraceEvent::set_total_allocated(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  total_allocated_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapGrowFtraceEvent.total_allocated)
}

// -------------------------------------------------------------------

// IonBufferCreateFtraceEvent

// optional uint64 addr = 1;
inline bool IonBufferCreateFtraceEvent::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonBufferCreateFtraceEvent::clear_addr() {
  addr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonBufferCreateFtraceEvent::addr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonBufferCreateFtraceEvent.addr)
  return addr_;
}
inline void IonBufferCreateFtraceEvent::set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  addr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonBufferCreateFtraceEvent.addr)
}

// optional uint64 len = 2;
inline bool IonBufferCreateFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonBufferCreateFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonBufferCreateFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonBufferCreateFtraceEvent.len)
  return len_;
}
inline void IonBufferCreateFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonBufferCreateFtraceEvent.len)
}

// -------------------------------------------------------------------

// IonBufferDestroyFtraceEvent

// optional uint64 addr = 1;
inline bool IonBufferDestroyFtraceEvent::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IonBufferDestroyFtraceEvent::clear_addr() {
  addr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonBufferDestroyFtraceEvent::addr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonBufferDestroyFtraceEvent.addr)
  return addr_;
}
inline void IonBufferDestroyFtraceEvent::set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  addr_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonBufferDestroyFtraceEvent.addr)
}

// optional uint64 len = 2;
inline bool IonBufferDestroyFtraceEvent::has_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IonBufferDestroyFtraceEvent::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IonBufferDestroyFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonBufferDestroyFtraceEvent.len)
  return len_;
}
inline void IonBufferDestroyFtraceEvent::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  len_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.IonBufferDestroyFtraceEvent.len)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto
