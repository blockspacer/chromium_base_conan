// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BLOCK_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BLOCK_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class BlockUnplugFtraceEvent;
class BlockTouchBufferFtraceEvent;
class BlockSplitFtraceEvent;
class BlockSleeprqFtraceEvent;
class BlockRqRequeueFtraceEvent;
class BlockRqRemapFtraceEvent;
class BlockRqInsertFtraceEvent;
class BlockRqCompleteFtraceEvent;
class BlockRqAbortFtraceEvent;
class BlockPlugFtraceEvent;
class BlockGetrqFtraceEvent;
class BlockDirtyBufferFtraceEvent;
class BlockBioRemapFtraceEvent;
class BlockBioQueueFtraceEvent;
class BlockBioFrontmergeFtraceEvent;
class BlockBioCompleteFtraceEvent;
class BlockBioBounceFtraceEvent;
class BlockBioBackmergeFtraceEvent;
class BlockRqIssueFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT BlockUnplugFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNrRqFieldNumber = 1,
    kCommFieldNumber = 2,
  };

  BlockUnplugFtraceEvent();
  ~BlockUnplugFtraceEvent() override;
  BlockUnplugFtraceEvent(BlockUnplugFtraceEvent&&) noexcept;
  BlockUnplugFtraceEvent& operator=(BlockUnplugFtraceEvent&&);
  BlockUnplugFtraceEvent(const BlockUnplugFtraceEvent&);
  BlockUnplugFtraceEvent& operator=(const BlockUnplugFtraceEvent&);
  bool operator==(const BlockUnplugFtraceEvent&) const;
  bool operator!=(const BlockUnplugFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_nr_rq() const { return _has_field_[1]; }
  int32_t nr_rq() const { return nr_rq_; }
  void set_nr_rq(int32_t value) { nr_rq_ = value; _has_field_.set(1); }

  bool has_comm() const { return _has_field_[2]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(2); }

 private:
  int32_t nr_rq_{};
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT BlockTouchBufferFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kSizeFieldNumber = 3,
  };

  BlockTouchBufferFtraceEvent();
  ~BlockTouchBufferFtraceEvent() override;
  BlockTouchBufferFtraceEvent(BlockTouchBufferFtraceEvent&&) noexcept;
  BlockTouchBufferFtraceEvent& operator=(BlockTouchBufferFtraceEvent&&);
  BlockTouchBufferFtraceEvent(const BlockTouchBufferFtraceEvent&);
  BlockTouchBufferFtraceEvent& operator=(const BlockTouchBufferFtraceEvent&);
  bool operator==(const BlockTouchBufferFtraceEvent&) const;
  bool operator!=(const BlockTouchBufferFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_size() const { return _has_field_[3]; }
  uint64_t size() const { return size_; }
  void set_size(uint64_t value) { size_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint64_t size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT BlockSplitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNewSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };

  BlockSplitFtraceEvent();
  ~BlockSplitFtraceEvent() override;
  BlockSplitFtraceEvent(BlockSplitFtraceEvent&&) noexcept;
  BlockSplitFtraceEvent& operator=(BlockSplitFtraceEvent&&);
  BlockSplitFtraceEvent(const BlockSplitFtraceEvent&);
  BlockSplitFtraceEvent& operator=(const BlockSplitFtraceEvent&);
  bool operator==(const BlockSplitFtraceEvent&) const;
  bool operator!=(const BlockSplitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_new_sector() const { return _has_field_[3]; }
  uint64_t new_sector() const { return new_sector_; }
  void set_new_sector(uint64_t value) { new_sector_ = value; _has_field_.set(3); }

  bool has_rwbs() const { return _has_field_[4]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(4); }

  bool has_comm() const { return _has_field_[5]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint64_t new_sector_{};
  std::string rwbs_{};
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT BlockSleeprqFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };

  BlockSleeprqFtraceEvent();
  ~BlockSleeprqFtraceEvent() override;
  BlockSleeprqFtraceEvent(BlockSleeprqFtraceEvent&&) noexcept;
  BlockSleeprqFtraceEvent& operator=(BlockSleeprqFtraceEvent&&);
  BlockSleeprqFtraceEvent(const BlockSleeprqFtraceEvent&);
  BlockSleeprqFtraceEvent& operator=(const BlockSleeprqFtraceEvent&);
  bool operator==(const BlockSleeprqFtraceEvent&) const;
  bool operator!=(const BlockSleeprqFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_rwbs() const { return _has_field_[4]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(4); }

  bool has_comm() const { return _has_field_[5]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  std::string rwbs_{};
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT BlockRqRequeueFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };

  BlockRqRequeueFtraceEvent();
  ~BlockRqRequeueFtraceEvent() override;
  BlockRqRequeueFtraceEvent(BlockRqRequeueFtraceEvent&&) noexcept;
  BlockRqRequeueFtraceEvent& operator=(BlockRqRequeueFtraceEvent&&);
  BlockRqRequeueFtraceEvent(const BlockRqRequeueFtraceEvent&);
  BlockRqRequeueFtraceEvent& operator=(const BlockRqRequeueFtraceEvent&);
  bool operator==(const BlockRqRequeueFtraceEvent&) const;
  bool operator!=(const BlockRqRequeueFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_errors() const { return _has_field_[4]; }
  int32_t errors() const { return errors_; }
  void set_errors(int32_t value) { errors_ = value; _has_field_.set(4); }

  bool has_rwbs() const { return _has_field_[5]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(5); }

  bool has_cmd() const { return _has_field_[6]; }
  const std::string& cmd() const { return cmd_; }
  void set_cmd(const std::string& value) { cmd_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  int32_t errors_{};
  std::string rwbs_{};
  std::string cmd_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT BlockRqRemapFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kOldDevFieldNumber = 4,
    kOldSectorFieldNumber = 5,
    kNrBiosFieldNumber = 6,
    kRwbsFieldNumber = 7,
  };

  BlockRqRemapFtraceEvent();
  ~BlockRqRemapFtraceEvent() override;
  BlockRqRemapFtraceEvent(BlockRqRemapFtraceEvent&&) noexcept;
  BlockRqRemapFtraceEvent& operator=(BlockRqRemapFtraceEvent&&);
  BlockRqRemapFtraceEvent(const BlockRqRemapFtraceEvent&);
  BlockRqRemapFtraceEvent& operator=(const BlockRqRemapFtraceEvent&);
  bool operator==(const BlockRqRemapFtraceEvent&) const;
  bool operator!=(const BlockRqRemapFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_old_dev() const { return _has_field_[4]; }
  uint64_t old_dev() const { return old_dev_; }
  void set_old_dev(uint64_t value) { old_dev_ = value; _has_field_.set(4); }

  bool has_old_sector() const { return _has_field_[5]; }
  uint64_t old_sector() const { return old_sector_; }
  void set_old_sector(uint64_t value) { old_sector_ = value; _has_field_.set(5); }

  bool has_nr_bios() const { return _has_field_[6]; }
  uint32_t nr_bios() const { return nr_bios_; }
  void set_nr_bios(uint32_t value) { nr_bios_ = value; _has_field_.set(6); }

  bool has_rwbs() const { return _has_field_[7]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  uint64_t old_dev_{};
  uint64_t old_sector_{};
  uint32_t nr_bios_{};
  std::string rwbs_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT BlockRqInsertFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kBytesFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCommFieldNumber = 6,
    kCmdFieldNumber = 7,
  };

  BlockRqInsertFtraceEvent();
  ~BlockRqInsertFtraceEvent() override;
  BlockRqInsertFtraceEvent(BlockRqInsertFtraceEvent&&) noexcept;
  BlockRqInsertFtraceEvent& operator=(BlockRqInsertFtraceEvent&&);
  BlockRqInsertFtraceEvent(const BlockRqInsertFtraceEvent&);
  BlockRqInsertFtraceEvent& operator=(const BlockRqInsertFtraceEvent&);
  bool operator==(const BlockRqInsertFtraceEvent&) const;
  bool operator!=(const BlockRqInsertFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_bytes() const { return _has_field_[4]; }
  uint32_t bytes() const { return bytes_; }
  void set_bytes(uint32_t value) { bytes_ = value; _has_field_.set(4); }

  bool has_rwbs() const { return _has_field_[5]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(5); }

  bool has_comm() const { return _has_field_[6]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(6); }

  bool has_cmd() const { return _has_field_[7]; }
  const std::string& cmd() const { return cmd_; }
  void set_cmd(const std::string& value) { cmd_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  uint32_t bytes_{};
  std::string rwbs_{};
  std::string comm_{};
  std::string cmd_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT BlockRqCompleteFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };

  BlockRqCompleteFtraceEvent();
  ~BlockRqCompleteFtraceEvent() override;
  BlockRqCompleteFtraceEvent(BlockRqCompleteFtraceEvent&&) noexcept;
  BlockRqCompleteFtraceEvent& operator=(BlockRqCompleteFtraceEvent&&);
  BlockRqCompleteFtraceEvent(const BlockRqCompleteFtraceEvent&);
  BlockRqCompleteFtraceEvent& operator=(const BlockRqCompleteFtraceEvent&);
  bool operator==(const BlockRqCompleteFtraceEvent&) const;
  bool operator!=(const BlockRqCompleteFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_errors() const { return _has_field_[4]; }
  int32_t errors() const { return errors_; }
  void set_errors(int32_t value) { errors_ = value; _has_field_.set(4); }

  bool has_rwbs() const { return _has_field_[5]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(5); }

  bool has_cmd() const { return _has_field_[6]; }
  const std::string& cmd() const { return cmd_; }
  void set_cmd(const std::string& value) { cmd_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  int32_t errors_{};
  std::string rwbs_{};
  std::string cmd_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT BlockRqAbortFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };

  BlockRqAbortFtraceEvent();
  ~BlockRqAbortFtraceEvent() override;
  BlockRqAbortFtraceEvent(BlockRqAbortFtraceEvent&&) noexcept;
  BlockRqAbortFtraceEvent& operator=(BlockRqAbortFtraceEvent&&);
  BlockRqAbortFtraceEvent(const BlockRqAbortFtraceEvent&);
  BlockRqAbortFtraceEvent& operator=(const BlockRqAbortFtraceEvent&);
  bool operator==(const BlockRqAbortFtraceEvent&) const;
  bool operator!=(const BlockRqAbortFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_errors() const { return _has_field_[4]; }
  int32_t errors() const { return errors_; }
  void set_errors(int32_t value) { errors_ = value; _has_field_.set(4); }

  bool has_rwbs() const { return _has_field_[5]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(5); }

  bool has_cmd() const { return _has_field_[6]; }
  const std::string& cmd() const { return cmd_; }
  void set_cmd(const std::string& value) { cmd_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  int32_t errors_{};
  std::string rwbs_{};
  std::string cmd_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT BlockPlugFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
  };

  BlockPlugFtraceEvent();
  ~BlockPlugFtraceEvent() override;
  BlockPlugFtraceEvent(BlockPlugFtraceEvent&&) noexcept;
  BlockPlugFtraceEvent& operator=(BlockPlugFtraceEvent&&);
  BlockPlugFtraceEvent(const BlockPlugFtraceEvent&);
  BlockPlugFtraceEvent& operator=(const BlockPlugFtraceEvent&);
  bool operator==(const BlockPlugFtraceEvent&) const;
  bool operator!=(const BlockPlugFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

 private:
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT BlockGetrqFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };

  BlockGetrqFtraceEvent();
  ~BlockGetrqFtraceEvent() override;
  BlockGetrqFtraceEvent(BlockGetrqFtraceEvent&&) noexcept;
  BlockGetrqFtraceEvent& operator=(BlockGetrqFtraceEvent&&);
  BlockGetrqFtraceEvent(const BlockGetrqFtraceEvent&);
  BlockGetrqFtraceEvent& operator=(const BlockGetrqFtraceEvent&);
  bool operator==(const BlockGetrqFtraceEvent&) const;
  bool operator!=(const BlockGetrqFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_rwbs() const { return _has_field_[4]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(4); }

  bool has_comm() const { return _has_field_[5]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  std::string rwbs_{};
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT BlockDirtyBufferFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kSizeFieldNumber = 3,
  };

  BlockDirtyBufferFtraceEvent();
  ~BlockDirtyBufferFtraceEvent() override;
  BlockDirtyBufferFtraceEvent(BlockDirtyBufferFtraceEvent&&) noexcept;
  BlockDirtyBufferFtraceEvent& operator=(BlockDirtyBufferFtraceEvent&&);
  BlockDirtyBufferFtraceEvent(const BlockDirtyBufferFtraceEvent&);
  BlockDirtyBufferFtraceEvent& operator=(const BlockDirtyBufferFtraceEvent&);
  bool operator==(const BlockDirtyBufferFtraceEvent&) const;
  bool operator!=(const BlockDirtyBufferFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_size() const { return _has_field_[3]; }
  uint64_t size() const { return size_; }
  void set_size(uint64_t value) { size_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint64_t size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT BlockBioRemapFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kOldDevFieldNumber = 4,
    kOldSectorFieldNumber = 5,
    kRwbsFieldNumber = 6,
  };

  BlockBioRemapFtraceEvent();
  ~BlockBioRemapFtraceEvent() override;
  BlockBioRemapFtraceEvent(BlockBioRemapFtraceEvent&&) noexcept;
  BlockBioRemapFtraceEvent& operator=(BlockBioRemapFtraceEvent&&);
  BlockBioRemapFtraceEvent(const BlockBioRemapFtraceEvent&);
  BlockBioRemapFtraceEvent& operator=(const BlockBioRemapFtraceEvent&);
  bool operator==(const BlockBioRemapFtraceEvent&) const;
  bool operator!=(const BlockBioRemapFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_old_dev() const { return _has_field_[4]; }
  uint64_t old_dev() const { return old_dev_; }
  void set_old_dev(uint64_t value) { old_dev_ = value; _has_field_.set(4); }

  bool has_old_sector() const { return _has_field_[5]; }
  uint64_t old_sector() const { return old_sector_; }
  void set_old_sector(uint64_t value) { old_sector_ = value; _has_field_.set(5); }

  bool has_rwbs() const { return _has_field_[6]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  uint64_t old_dev_{};
  uint64_t old_sector_{};
  std::string rwbs_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT BlockBioQueueFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };

  BlockBioQueueFtraceEvent();
  ~BlockBioQueueFtraceEvent() override;
  BlockBioQueueFtraceEvent(BlockBioQueueFtraceEvent&&) noexcept;
  BlockBioQueueFtraceEvent& operator=(BlockBioQueueFtraceEvent&&);
  BlockBioQueueFtraceEvent(const BlockBioQueueFtraceEvent&);
  BlockBioQueueFtraceEvent& operator=(const BlockBioQueueFtraceEvent&);
  bool operator==(const BlockBioQueueFtraceEvent&) const;
  bool operator!=(const BlockBioQueueFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_rwbs() const { return _has_field_[4]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(4); }

  bool has_comm() const { return _has_field_[5]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  std::string rwbs_{};
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT BlockBioFrontmergeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };

  BlockBioFrontmergeFtraceEvent();
  ~BlockBioFrontmergeFtraceEvent() override;
  BlockBioFrontmergeFtraceEvent(BlockBioFrontmergeFtraceEvent&&) noexcept;
  BlockBioFrontmergeFtraceEvent& operator=(BlockBioFrontmergeFtraceEvent&&);
  BlockBioFrontmergeFtraceEvent(const BlockBioFrontmergeFtraceEvent&);
  BlockBioFrontmergeFtraceEvent& operator=(const BlockBioFrontmergeFtraceEvent&);
  bool operator==(const BlockBioFrontmergeFtraceEvent&) const;
  bool operator!=(const BlockBioFrontmergeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_rwbs() const { return _has_field_[4]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(4); }

  bool has_comm() const { return _has_field_[5]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  std::string rwbs_{};
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT BlockBioCompleteFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorFieldNumber = 4,
    kRwbsFieldNumber = 5,
  };

  BlockBioCompleteFtraceEvent();
  ~BlockBioCompleteFtraceEvent() override;
  BlockBioCompleteFtraceEvent(BlockBioCompleteFtraceEvent&&) noexcept;
  BlockBioCompleteFtraceEvent& operator=(BlockBioCompleteFtraceEvent&&);
  BlockBioCompleteFtraceEvent(const BlockBioCompleteFtraceEvent&);
  BlockBioCompleteFtraceEvent& operator=(const BlockBioCompleteFtraceEvent&);
  bool operator==(const BlockBioCompleteFtraceEvent&) const;
  bool operator!=(const BlockBioCompleteFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_error() const { return _has_field_[4]; }
  int32_t error() const { return error_; }
  void set_error(int32_t value) { error_ = value; _has_field_.set(4); }

  bool has_rwbs() const { return _has_field_[5]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  int32_t error_{};
  std::string rwbs_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT BlockBioBounceFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };

  BlockBioBounceFtraceEvent();
  ~BlockBioBounceFtraceEvent() override;
  BlockBioBounceFtraceEvent(BlockBioBounceFtraceEvent&&) noexcept;
  BlockBioBounceFtraceEvent& operator=(BlockBioBounceFtraceEvent&&);
  BlockBioBounceFtraceEvent(const BlockBioBounceFtraceEvent&);
  BlockBioBounceFtraceEvent& operator=(const BlockBioBounceFtraceEvent&);
  bool operator==(const BlockBioBounceFtraceEvent&) const;
  bool operator!=(const BlockBioBounceFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_rwbs() const { return _has_field_[4]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(4); }

  bool has_comm() const { return _has_field_[5]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  std::string rwbs_{};
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT BlockBioBackmergeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };

  BlockBioBackmergeFtraceEvent();
  ~BlockBioBackmergeFtraceEvent() override;
  BlockBioBackmergeFtraceEvent(BlockBioBackmergeFtraceEvent&&) noexcept;
  BlockBioBackmergeFtraceEvent& operator=(BlockBioBackmergeFtraceEvent&&);
  BlockBioBackmergeFtraceEvent(const BlockBioBackmergeFtraceEvent&);
  BlockBioBackmergeFtraceEvent& operator=(const BlockBioBackmergeFtraceEvent&);
  bool operator==(const BlockBioBackmergeFtraceEvent&) const;
  bool operator!=(const BlockBioBackmergeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_rwbs() const { return _has_field_[4]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(4); }

  bool has_comm() const { return _has_field_[5]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  std::string rwbs_{};
  std::string comm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT BlockRqIssueFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kBytesFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCommFieldNumber = 6,
    kCmdFieldNumber = 7,
  };

  BlockRqIssueFtraceEvent();
  ~BlockRqIssueFtraceEvent() override;
  BlockRqIssueFtraceEvent(BlockRqIssueFtraceEvent&&) noexcept;
  BlockRqIssueFtraceEvent& operator=(BlockRqIssueFtraceEvent&&);
  BlockRqIssueFtraceEvent(const BlockRqIssueFtraceEvent&);
  BlockRqIssueFtraceEvent& operator=(const BlockRqIssueFtraceEvent&);
  bool operator==(const BlockRqIssueFtraceEvent&) const;
  bool operator!=(const BlockRqIssueFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sector() const { return _has_field_[2]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(2); }

  bool has_nr_sector() const { return _has_field_[3]; }
  uint32_t nr_sector() const { return nr_sector_; }
  void set_nr_sector(uint32_t value) { nr_sector_ = value; _has_field_.set(3); }

  bool has_bytes() const { return _has_field_[4]; }
  uint32_t bytes() const { return bytes_; }
  void set_bytes(uint32_t value) { bytes_ = value; _has_field_.set(4); }

  bool has_rwbs() const { return _has_field_[5]; }
  const std::string& rwbs() const { return rwbs_; }
  void set_rwbs(const std::string& value) { rwbs_ = value; _has_field_.set(5); }

  bool has_comm() const { return _has_field_[6]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(6); }

  bool has_cmd() const { return _has_field_[7]; }
  const std::string& cmd() const { return cmd_; }
  void set_cmd(const std::string& value) { cmd_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t sector_{};
  uint32_t nr_sector_{};
  uint32_t bytes_{};
  std::string rwbs_{};
  std::string comm_{};
  std::string cmd_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BLOCK_PROTO_CPP_H_
