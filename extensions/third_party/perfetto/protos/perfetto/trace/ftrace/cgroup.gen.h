// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CGROUP_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CGROUP_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class CgroupSetupRootFtraceEvent;
class CgroupRenameFtraceEvent;
class CgroupReleaseFtraceEvent;
class CgroupDestroyRootFtraceEvent;
class CgroupTransferTasksFtraceEvent;
class CgroupRmdirFtraceEvent;
class CgroupRemountFtraceEvent;
class CgroupMkdirFtraceEvent;
class CgroupAttachTaskFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT CgroupSetupRootFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };

  CgroupSetupRootFtraceEvent();
  ~CgroupSetupRootFtraceEvent() override;
  CgroupSetupRootFtraceEvent(CgroupSetupRootFtraceEvent&&) noexcept;
  CgroupSetupRootFtraceEvent& operator=(CgroupSetupRootFtraceEvent&&);
  CgroupSetupRootFtraceEvent(const CgroupSetupRootFtraceEvent&);
  CgroupSetupRootFtraceEvent& operator=(const CgroupSetupRootFtraceEvent&);
  bool operator==(const CgroupSetupRootFtraceEvent&) const;
  bool operator!=(const CgroupSetupRootFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_root() const { return _has_field_[1]; }
  int32_t root() const { return root_; }
  void set_root(int32_t value) { root_ = value; _has_field_.set(1); }

  bool has_ss_mask() const { return _has_field_[2]; }
  uint32_t ss_mask() const { return ss_mask_; }
  void set_ss_mask(uint32_t value) { ss_mask_ = value; _has_field_.set(2); }

  bool has_name() const { return _has_field_[3]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(3); }

 private:
  int32_t root_{};
  uint32_t ss_mask_{};
  std::string name_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CgroupRenameFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };

  CgroupRenameFtraceEvent();
  ~CgroupRenameFtraceEvent() override;
  CgroupRenameFtraceEvent(CgroupRenameFtraceEvent&&) noexcept;
  CgroupRenameFtraceEvent& operator=(CgroupRenameFtraceEvent&&);
  CgroupRenameFtraceEvent(const CgroupRenameFtraceEvent&);
  CgroupRenameFtraceEvent& operator=(const CgroupRenameFtraceEvent&);
  bool operator==(const CgroupRenameFtraceEvent&) const;
  bool operator!=(const CgroupRenameFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_root() const { return _has_field_[1]; }
  int32_t root() const { return root_; }
  void set_root(int32_t value) { root_ = value; _has_field_.set(1); }

  bool has_id() const { return _has_field_[2]; }
  int32_t id() const { return id_; }
  void set_id(int32_t value) { id_ = value; _has_field_.set(2); }

  bool has_cname() const { return _has_field_[3]; }
  const std::string& cname() const { return cname_; }
  void set_cname(const std::string& value) { cname_ = value; _has_field_.set(3); }

 private:
  int32_t root_{};
  int32_t id_{};
  std::string cname_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CgroupReleaseFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };

  CgroupReleaseFtraceEvent();
  ~CgroupReleaseFtraceEvent() override;
  CgroupReleaseFtraceEvent(CgroupReleaseFtraceEvent&&) noexcept;
  CgroupReleaseFtraceEvent& operator=(CgroupReleaseFtraceEvent&&);
  CgroupReleaseFtraceEvent(const CgroupReleaseFtraceEvent&);
  CgroupReleaseFtraceEvent& operator=(const CgroupReleaseFtraceEvent&);
  bool operator==(const CgroupReleaseFtraceEvent&) const;
  bool operator!=(const CgroupReleaseFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_root() const { return _has_field_[1]; }
  int32_t root() const { return root_; }
  void set_root(int32_t value) { root_ = value; _has_field_.set(1); }

  bool has_id() const { return _has_field_[2]; }
  int32_t id() const { return id_; }
  void set_id(int32_t value) { id_ = value; _has_field_.set(2); }

  bool has_cname() const { return _has_field_[3]; }
  const std::string& cname() const { return cname_; }
  void set_cname(const std::string& value) { cname_ = value; _has_field_.set(3); }

 private:
  int32_t root_{};
  int32_t id_{};
  std::string cname_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CgroupDestroyRootFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };

  CgroupDestroyRootFtraceEvent();
  ~CgroupDestroyRootFtraceEvent() override;
  CgroupDestroyRootFtraceEvent(CgroupDestroyRootFtraceEvent&&) noexcept;
  CgroupDestroyRootFtraceEvent& operator=(CgroupDestroyRootFtraceEvent&&);
  CgroupDestroyRootFtraceEvent(const CgroupDestroyRootFtraceEvent&);
  CgroupDestroyRootFtraceEvent& operator=(const CgroupDestroyRootFtraceEvent&);
  bool operator==(const CgroupDestroyRootFtraceEvent&) const;
  bool operator!=(const CgroupDestroyRootFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_root() const { return _has_field_[1]; }
  int32_t root() const { return root_; }
  void set_root(int32_t value) { root_ = value; _has_field_.set(1); }

  bool has_ss_mask() const { return _has_field_[2]; }
  uint32_t ss_mask() const { return ss_mask_; }
  void set_ss_mask(uint32_t value) { ss_mask_ = value; _has_field_.set(2); }

  bool has_name() const { return _has_field_[3]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(3); }

 private:
  int32_t root_{};
  uint32_t ss_mask_{};
  std::string name_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CgroupTransferTasksFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDstRootFieldNumber = 1,
    kDstIdFieldNumber = 2,
    kPidFieldNumber = 3,
    kCommFieldNumber = 4,
    kCnameFieldNumber = 5,
  };

  CgroupTransferTasksFtraceEvent();
  ~CgroupTransferTasksFtraceEvent() override;
  CgroupTransferTasksFtraceEvent(CgroupTransferTasksFtraceEvent&&) noexcept;
  CgroupTransferTasksFtraceEvent& operator=(CgroupTransferTasksFtraceEvent&&);
  CgroupTransferTasksFtraceEvent(const CgroupTransferTasksFtraceEvent&);
  CgroupTransferTasksFtraceEvent& operator=(const CgroupTransferTasksFtraceEvent&);
  bool operator==(const CgroupTransferTasksFtraceEvent&) const;
  bool operator!=(const CgroupTransferTasksFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dst_root() const { return _has_field_[1]; }
  int32_t dst_root() const { return dst_root_; }
  void set_dst_root(int32_t value) { dst_root_ = value; _has_field_.set(1); }

  bool has_dst_id() const { return _has_field_[2]; }
  int32_t dst_id() const { return dst_id_; }
  void set_dst_id(int32_t value) { dst_id_ = value; _has_field_.set(2); }

  bool has_pid() const { return _has_field_[3]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(3); }

  bool has_comm() const { return _has_field_[4]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(4); }

  bool has_cname() const { return _has_field_[5]; }
  const std::string& cname() const { return cname_; }
  void set_cname(const std::string& value) { cname_ = value; _has_field_.set(5); }

 private:
  int32_t dst_root_{};
  int32_t dst_id_{};
  int32_t pid_{};
  std::string comm_{};
  std::string cname_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT CgroupRmdirFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };

  CgroupRmdirFtraceEvent();
  ~CgroupRmdirFtraceEvent() override;
  CgroupRmdirFtraceEvent(CgroupRmdirFtraceEvent&&) noexcept;
  CgroupRmdirFtraceEvent& operator=(CgroupRmdirFtraceEvent&&);
  CgroupRmdirFtraceEvent(const CgroupRmdirFtraceEvent&);
  CgroupRmdirFtraceEvent& operator=(const CgroupRmdirFtraceEvent&);
  bool operator==(const CgroupRmdirFtraceEvent&) const;
  bool operator!=(const CgroupRmdirFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_root() const { return _has_field_[1]; }
  int32_t root() const { return root_; }
  void set_root(int32_t value) { root_ = value; _has_field_.set(1); }

  bool has_id() const { return _has_field_[2]; }
  int32_t id() const { return id_; }
  void set_id(int32_t value) { id_ = value; _has_field_.set(2); }

  bool has_cname() const { return _has_field_[3]; }
  const std::string& cname() const { return cname_; }
  void set_cname(const std::string& value) { cname_ = value; _has_field_.set(3); }

 private:
  int32_t root_{};
  int32_t id_{};
  std::string cname_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CgroupRemountFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };

  CgroupRemountFtraceEvent();
  ~CgroupRemountFtraceEvent() override;
  CgroupRemountFtraceEvent(CgroupRemountFtraceEvent&&) noexcept;
  CgroupRemountFtraceEvent& operator=(CgroupRemountFtraceEvent&&);
  CgroupRemountFtraceEvent(const CgroupRemountFtraceEvent&);
  CgroupRemountFtraceEvent& operator=(const CgroupRemountFtraceEvent&);
  bool operator==(const CgroupRemountFtraceEvent&) const;
  bool operator!=(const CgroupRemountFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_root() const { return _has_field_[1]; }
  int32_t root() const { return root_; }
  void set_root(int32_t value) { root_ = value; _has_field_.set(1); }

  bool has_ss_mask() const { return _has_field_[2]; }
  uint32_t ss_mask() const { return ss_mask_; }
  void set_ss_mask(uint32_t value) { ss_mask_ = value; _has_field_.set(2); }

  bool has_name() const { return _has_field_[3]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(3); }

 private:
  int32_t root_{};
  uint32_t ss_mask_{};
  std::string name_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CgroupMkdirFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };

  CgroupMkdirFtraceEvent();
  ~CgroupMkdirFtraceEvent() override;
  CgroupMkdirFtraceEvent(CgroupMkdirFtraceEvent&&) noexcept;
  CgroupMkdirFtraceEvent& operator=(CgroupMkdirFtraceEvent&&);
  CgroupMkdirFtraceEvent(const CgroupMkdirFtraceEvent&);
  CgroupMkdirFtraceEvent& operator=(const CgroupMkdirFtraceEvent&);
  bool operator==(const CgroupMkdirFtraceEvent&) const;
  bool operator!=(const CgroupMkdirFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_root() const { return _has_field_[1]; }
  int32_t root() const { return root_; }
  void set_root(int32_t value) { root_ = value; _has_field_.set(1); }

  bool has_id() const { return _has_field_[2]; }
  int32_t id() const { return id_; }
  void set_id(int32_t value) { id_ = value; _has_field_.set(2); }

  bool has_cname() const { return _has_field_[3]; }
  const std::string& cname() const { return cname_; }
  void set_cname(const std::string& value) { cname_ = value; _has_field_.set(3); }

 private:
  int32_t root_{};
  int32_t id_{};
  std::string cname_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT CgroupAttachTaskFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDstRootFieldNumber = 1,
    kDstIdFieldNumber = 2,
    kPidFieldNumber = 3,
    kCommFieldNumber = 4,
    kCnameFieldNumber = 5,
  };

  CgroupAttachTaskFtraceEvent();
  ~CgroupAttachTaskFtraceEvent() override;
  CgroupAttachTaskFtraceEvent(CgroupAttachTaskFtraceEvent&&) noexcept;
  CgroupAttachTaskFtraceEvent& operator=(CgroupAttachTaskFtraceEvent&&);
  CgroupAttachTaskFtraceEvent(const CgroupAttachTaskFtraceEvent&);
  CgroupAttachTaskFtraceEvent& operator=(const CgroupAttachTaskFtraceEvent&);
  bool operator==(const CgroupAttachTaskFtraceEvent&) const;
  bool operator!=(const CgroupAttachTaskFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dst_root() const { return _has_field_[1]; }
  int32_t dst_root() const { return dst_root_; }
  void set_dst_root(int32_t value) { dst_root_ = value; _has_field_.set(1); }

  bool has_dst_id() const { return _has_field_[2]; }
  int32_t dst_id() const { return dst_id_; }
  void set_dst_id(int32_t value) { dst_id_ = value; _has_field_.set(2); }

  bool has_pid() const { return _has_field_[3]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(3); }

  bool has_comm() const { return _has_field_[4]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(4); }

  bool has_cname() const { return _has_field_[5]; }
  const std::string& cname() const { return cname_; }
  void set_cname(const std::string& value) { cname_ = value; _has_field_.set(5); }

 private:
  int32_t dst_root_{};
  int32_t dst_id_{};
  int32_t pid_{};
  std::string comm_{};
  std::string cname_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CGROUP_PROTO_CPP_H_
