// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/sched.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace perfetto {
namespace protos {
class SchedBlockedReasonFtraceEvent;
class SchedBlockedReasonFtraceEventDefaultTypeInternal;
extern SchedBlockedReasonFtraceEventDefaultTypeInternal _SchedBlockedReasonFtraceEvent_default_instance_;
class SchedCpuHotplugFtraceEvent;
class SchedCpuHotplugFtraceEventDefaultTypeInternal;
extern SchedCpuHotplugFtraceEventDefaultTypeInternal _SchedCpuHotplugFtraceEvent_default_instance_;
class SchedProcessExecFtraceEvent;
class SchedProcessExecFtraceEventDefaultTypeInternal;
extern SchedProcessExecFtraceEventDefaultTypeInternal _SchedProcessExecFtraceEvent_default_instance_;
class SchedProcessExitFtraceEvent;
class SchedProcessExitFtraceEventDefaultTypeInternal;
extern SchedProcessExitFtraceEventDefaultTypeInternal _SchedProcessExitFtraceEvent_default_instance_;
class SchedProcessForkFtraceEvent;
class SchedProcessForkFtraceEventDefaultTypeInternal;
extern SchedProcessForkFtraceEventDefaultTypeInternal _SchedProcessForkFtraceEvent_default_instance_;
class SchedProcessFreeFtraceEvent;
class SchedProcessFreeFtraceEventDefaultTypeInternal;
extern SchedProcessFreeFtraceEventDefaultTypeInternal _SchedProcessFreeFtraceEvent_default_instance_;
class SchedProcessHangFtraceEvent;
class SchedProcessHangFtraceEventDefaultTypeInternal;
extern SchedProcessHangFtraceEventDefaultTypeInternal _SchedProcessHangFtraceEvent_default_instance_;
class SchedProcessWaitFtraceEvent;
class SchedProcessWaitFtraceEventDefaultTypeInternal;
extern SchedProcessWaitFtraceEventDefaultTypeInternal _SchedProcessWaitFtraceEvent_default_instance_;
class SchedSwitchFtraceEvent;
class SchedSwitchFtraceEventDefaultTypeInternal;
extern SchedSwitchFtraceEventDefaultTypeInternal _SchedSwitchFtraceEvent_default_instance_;
class SchedWakeupFtraceEvent;
class SchedWakeupFtraceEventDefaultTypeInternal;
extern SchedWakeupFtraceEventDefaultTypeInternal _SchedWakeupFtraceEvent_default_instance_;
class SchedWakeupNewFtraceEvent;
class SchedWakeupNewFtraceEventDefaultTypeInternal;
extern SchedWakeupNewFtraceEventDefaultTypeInternal _SchedWakeupNewFtraceEvent_default_instance_;
class SchedWakingFtraceEvent;
class SchedWakingFtraceEventDefaultTypeInternal;
extern SchedWakingFtraceEventDefaultTypeInternal _SchedWakingFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> ::perfetto::protos::SchedBlockedReasonFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedBlockedReasonFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedCpuHotplugFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedCpuHotplugFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessExecFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessExecFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessExitFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessExitFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessForkFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessForkFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessFreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessFreeFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessHangFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessHangFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessWaitFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessWaitFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedSwitchFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedSwitchFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedWakeupFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakeupFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedWakeupNewFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakeupNewFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedWakingFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakingFtraceEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace perfetto {
namespace protos {

// ===================================================================

class SchedSwitchFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedSwitchFtraceEvent) */ {
 public:
  SchedSwitchFtraceEvent();
  virtual ~SchedSwitchFtraceEvent();

  SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent& from);
  SchedSwitchFtraceEvent(SchedSwitchFtraceEvent&& from) noexcept
    : SchedSwitchFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedSwitchFtraceEvent& operator=(const SchedSwitchFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedSwitchFtraceEvent& operator=(SchedSwitchFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedSwitchFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedSwitchFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedSwitchFtraceEvent*>(
               &_SchedSwitchFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SchedSwitchFtraceEvent& a, SchedSwitchFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedSwitchFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedSwitchFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedSwitchFtraceEvent>(nullptr);
  }

  SchedSwitchFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedSwitchFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedSwitchFtraceEvent& from);
  void MergeFrom(const SchedSwitchFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedSwitchFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedSwitchFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrevCommFieldNumber = 1,
    kNextCommFieldNumber = 5,
    kPrevPidFieldNumber = 2,
    kPrevPrioFieldNumber = 3,
    kPrevStateFieldNumber = 4,
    kNextPidFieldNumber = 6,
    kNextPrioFieldNumber = 7,
  };
  // optional string prev_comm = 1;
  bool has_prev_comm() const;
  void clear_prev_comm();
  const std::string& prev_comm() const;
  void set_prev_comm(const std::string& value);
  void set_prev_comm(std::string&& value);
  void set_prev_comm(const char* value);
  void set_prev_comm(const char* value, size_t size);
  std::string* mutable_prev_comm();
  std::string* release_prev_comm();
  void set_allocated_prev_comm(std::string* prev_comm);

  // optional string next_comm = 5;
  bool has_next_comm() const;
  void clear_next_comm();
  const std::string& next_comm() const;
  void set_next_comm(const std::string& value);
  void set_next_comm(std::string&& value);
  void set_next_comm(const char* value);
  void set_next_comm(const char* value, size_t size);
  std::string* mutable_next_comm();
  std::string* release_next_comm();
  void set_allocated_next_comm(std::string* next_comm);

  // optional int32 prev_pid = 2;
  bool has_prev_pid() const;
  void clear_prev_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 prev_pid() const;
  void set_prev_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 prev_prio = 3;
  bool has_prev_prio() const;
  void clear_prev_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 prev_prio() const;
  void set_prev_prio(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 prev_state = 4;
  bool has_prev_state() const;
  void clear_prev_state();
  ::PROTOBUF_NAMESPACE_ID::int64 prev_state() const;
  void set_prev_state(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 next_pid = 6;
  bool has_next_pid() const;
  void clear_next_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 next_pid() const;
  void set_next_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 next_prio = 7;
  bool has_next_prio() const;
  void clear_next_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 next_prio() const;
  void set_next_prio(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedSwitchFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prev_comm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 prev_pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 prev_prio_;
  ::PROTOBUF_NAMESPACE_ID::int64 prev_state_;
  ::PROTOBUF_NAMESPACE_ID::int32 next_pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 next_prio_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedWakeupFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakeupFtraceEvent) */ {
 public:
  SchedWakeupFtraceEvent();
  virtual ~SchedWakeupFtraceEvent();

  SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent& from);
  SchedWakeupFtraceEvent(SchedWakeupFtraceEvent&& from) noexcept
    : SchedWakeupFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakeupFtraceEvent& operator=(const SchedWakeupFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakeupFtraceEvent& operator=(SchedWakeupFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedWakeupFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedWakeupFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakeupFtraceEvent*>(
               &_SchedWakeupFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SchedWakeupFtraceEvent& a, SchedWakeupFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedWakeupFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedWakeupFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedWakeupFtraceEvent>(nullptr);
  }

  SchedWakeupFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedWakeupFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedWakeupFtraceEvent& from);
  void MergeFrom(const SchedWakeupFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedWakeupFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedWakeupFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm();
  const std::string& comm() const;
  void set_comm(const std::string& value);
  void set_comm(std::string&& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  std::string* mutable_comm();
  std::string* release_comm();
  void set_allocated_comm(std::string* comm);

  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 prio() const;
  void set_prio(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 success = 4;
  bool has_success() const;
  void clear_success();
  ::PROTOBUF_NAMESPACE_ID::int32 success() const;
  void set_success(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  void clear_target_cpu();
  ::PROTOBUF_NAMESPACE_ID::int32 target_cpu() const;
  void set_target_cpu(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakeupFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 prio_;
  ::PROTOBUF_NAMESPACE_ID::int32 success_;
  ::PROTOBUF_NAMESPACE_ID::int32 target_cpu_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedBlockedReasonFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedBlockedReasonFtraceEvent) */ {
 public:
  SchedBlockedReasonFtraceEvent();
  virtual ~SchedBlockedReasonFtraceEvent();

  SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent& from);
  SchedBlockedReasonFtraceEvent(SchedBlockedReasonFtraceEvent&& from) noexcept
    : SchedBlockedReasonFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedBlockedReasonFtraceEvent& operator=(const SchedBlockedReasonFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedBlockedReasonFtraceEvent& operator=(SchedBlockedReasonFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedBlockedReasonFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedBlockedReasonFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedBlockedReasonFtraceEvent*>(
               &_SchedBlockedReasonFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SchedBlockedReasonFtraceEvent& a, SchedBlockedReasonFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedBlockedReasonFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedBlockedReasonFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedBlockedReasonFtraceEvent>(nullptr);
  }

  SchedBlockedReasonFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedBlockedReasonFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedBlockedReasonFtraceEvent& from);
  void MergeFrom(const SchedBlockedReasonFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedBlockedReasonFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedBlockedReasonFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallerFieldNumber = 2,
    kPidFieldNumber = 1,
    kIoWaitFieldNumber = 3,
  };
  // optional uint64 caller = 2;
  bool has_caller() const;
  void clear_caller();
  ::PROTOBUF_NAMESPACE_ID::uint64 caller() const;
  void set_caller(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 pid = 1;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 io_wait = 3;
  bool has_io_wait() const;
  void clear_io_wait();
  ::PROTOBUF_NAMESPACE_ID::uint32 io_wait() const;
  void set_io_wait(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedBlockedReasonFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 caller_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 io_wait_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedCpuHotplugFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedCpuHotplugFtraceEvent) */ {
 public:
  SchedCpuHotplugFtraceEvent();
  virtual ~SchedCpuHotplugFtraceEvent();

  SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent& from);
  SchedCpuHotplugFtraceEvent(SchedCpuHotplugFtraceEvent&& from) noexcept
    : SchedCpuHotplugFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedCpuHotplugFtraceEvent& operator=(const SchedCpuHotplugFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedCpuHotplugFtraceEvent& operator=(SchedCpuHotplugFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedCpuHotplugFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedCpuHotplugFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedCpuHotplugFtraceEvent*>(
               &_SchedCpuHotplugFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SchedCpuHotplugFtraceEvent& a, SchedCpuHotplugFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedCpuHotplugFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedCpuHotplugFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedCpuHotplugFtraceEvent>(nullptr);
  }

  SchedCpuHotplugFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedCpuHotplugFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedCpuHotplugFtraceEvent& from);
  void MergeFrom(const SchedCpuHotplugFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedCpuHotplugFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedCpuHotplugFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedCpuFieldNumber = 1,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional int32 affected_cpu = 1;
  bool has_affected_cpu() const;
  void clear_affected_cpu();
  ::PROTOBUF_NAMESPACE_ID::int32 affected_cpu() const;
  void set_affected_cpu(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 error = 2;
  bool has_error() const;
  void clear_error();
  ::PROTOBUF_NAMESPACE_ID::int32 error() const;
  void set_error(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 status = 3;
  bool has_status() const;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedCpuHotplugFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 affected_cpu_;
  ::PROTOBUF_NAMESPACE_ID::int32 error_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedWakingFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakingFtraceEvent) */ {
 public:
  SchedWakingFtraceEvent();
  virtual ~SchedWakingFtraceEvent();

  SchedWakingFtraceEvent(const SchedWakingFtraceEvent& from);
  SchedWakingFtraceEvent(SchedWakingFtraceEvent&& from) noexcept
    : SchedWakingFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakingFtraceEvent& operator=(const SchedWakingFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakingFtraceEvent& operator=(SchedWakingFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedWakingFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedWakingFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakingFtraceEvent*>(
               &_SchedWakingFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SchedWakingFtraceEvent& a, SchedWakingFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedWakingFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedWakingFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedWakingFtraceEvent>(nullptr);
  }

  SchedWakingFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedWakingFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedWakingFtraceEvent& from);
  void MergeFrom(const SchedWakingFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedWakingFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedWakingFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm();
  const std::string& comm() const;
  void set_comm(const std::string& value);
  void set_comm(std::string&& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  std::string* mutable_comm();
  std::string* release_comm();
  void set_allocated_comm(std::string* comm);

  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 prio() const;
  void set_prio(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 success = 4;
  bool has_success() const;
  void clear_success();
  ::PROTOBUF_NAMESPACE_ID::int32 success() const;
  void set_success(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  void clear_target_cpu();
  ::PROTOBUF_NAMESPACE_ID::int32 target_cpu() const;
  void set_target_cpu(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakingFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 prio_;
  ::PROTOBUF_NAMESPACE_ID::int32 success_;
  ::PROTOBUF_NAMESPACE_ID::int32 target_cpu_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedWakeupNewFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakeupNewFtraceEvent) */ {
 public:
  SchedWakeupNewFtraceEvent();
  virtual ~SchedWakeupNewFtraceEvent();

  SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent& from);
  SchedWakeupNewFtraceEvent(SchedWakeupNewFtraceEvent&& from) noexcept
    : SchedWakeupNewFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakeupNewFtraceEvent& operator=(const SchedWakeupNewFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakeupNewFtraceEvent& operator=(SchedWakeupNewFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedWakeupNewFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedWakeupNewFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakeupNewFtraceEvent*>(
               &_SchedWakeupNewFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SchedWakeupNewFtraceEvent& a, SchedWakeupNewFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedWakeupNewFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedWakeupNewFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedWakeupNewFtraceEvent>(nullptr);
  }

  SchedWakeupNewFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedWakeupNewFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedWakeupNewFtraceEvent& from);
  void MergeFrom(const SchedWakeupNewFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedWakeupNewFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedWakeupNewFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm();
  const std::string& comm() const;
  void set_comm(const std::string& value);
  void set_comm(std::string&& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  std::string* mutable_comm();
  std::string* release_comm();
  void set_allocated_comm(std::string* comm);

  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 prio() const;
  void set_prio(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 success = 4;
  bool has_success() const;
  void clear_success();
  ::PROTOBUF_NAMESPACE_ID::int32 success() const;
  void set_success(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  void clear_target_cpu();
  ::PROTOBUF_NAMESPACE_ID::int32 target_cpu() const;
  void set_target_cpu(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakeupNewFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 prio_;
  ::PROTOBUF_NAMESPACE_ID::int32 success_;
  ::PROTOBUF_NAMESPACE_ID::int32 target_cpu_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessExecFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessExecFtraceEvent) */ {
 public:
  SchedProcessExecFtraceEvent();
  virtual ~SchedProcessExecFtraceEvent();

  SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent& from);
  SchedProcessExecFtraceEvent(SchedProcessExecFtraceEvent&& from) noexcept
    : SchedProcessExecFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessExecFtraceEvent& operator=(const SchedProcessExecFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessExecFtraceEvent& operator=(SchedProcessExecFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedProcessExecFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedProcessExecFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessExecFtraceEvent*>(
               &_SchedProcessExecFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SchedProcessExecFtraceEvent& a, SchedProcessExecFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessExecFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedProcessExecFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedProcessExecFtraceEvent>(nullptr);
  }

  SchedProcessExecFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedProcessExecFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedProcessExecFtraceEvent& from);
  void MergeFrom(const SchedProcessExecFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessExecFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessExecFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kPidFieldNumber = 2,
    kOldPidFieldNumber = 3,
  };
  // optional string filename = 1;
  bool has_filename() const;
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);

  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 old_pid = 3;
  bool has_old_pid() const;
  void clear_old_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 old_pid() const;
  void set_old_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessExecFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 old_pid_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessExitFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessExitFtraceEvent) */ {
 public:
  SchedProcessExitFtraceEvent();
  virtual ~SchedProcessExitFtraceEvent();

  SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent& from);
  SchedProcessExitFtraceEvent(SchedProcessExitFtraceEvent&& from) noexcept
    : SchedProcessExitFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessExitFtraceEvent& operator=(const SchedProcessExitFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessExitFtraceEvent& operator=(SchedProcessExitFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedProcessExitFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedProcessExitFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessExitFtraceEvent*>(
               &_SchedProcessExitFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SchedProcessExitFtraceEvent& a, SchedProcessExitFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessExitFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedProcessExitFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedProcessExitFtraceEvent>(nullptr);
  }

  SchedProcessExitFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedProcessExitFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedProcessExitFtraceEvent& from);
  void MergeFrom(const SchedProcessExitFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessExitFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessExitFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kTgidFieldNumber = 3,
    kPrioFieldNumber = 4,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm();
  const std::string& comm() const;
  void set_comm(const std::string& value);
  void set_comm(std::string&& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  std::string* mutable_comm();
  std::string* release_comm();
  void set_allocated_comm(std::string* comm);

  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 tgid = 3;
  bool has_tgid() const;
  void clear_tgid();
  ::PROTOBUF_NAMESPACE_ID::int32 tgid() const;
  void set_tgid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 prio = 4;
  bool has_prio() const;
  void clear_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 prio() const;
  void set_prio(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessExitFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 tgid_;
  ::PROTOBUF_NAMESPACE_ID::int32 prio_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessForkFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessForkFtraceEvent) */ {
 public:
  SchedProcessForkFtraceEvent();
  virtual ~SchedProcessForkFtraceEvent();

  SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent& from);
  SchedProcessForkFtraceEvent(SchedProcessForkFtraceEvent&& from) noexcept
    : SchedProcessForkFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessForkFtraceEvent& operator=(const SchedProcessForkFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessForkFtraceEvent& operator=(SchedProcessForkFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedProcessForkFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedProcessForkFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessForkFtraceEvent*>(
               &_SchedProcessForkFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SchedProcessForkFtraceEvent& a, SchedProcessForkFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessForkFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedProcessForkFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedProcessForkFtraceEvent>(nullptr);
  }

  SchedProcessForkFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedProcessForkFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedProcessForkFtraceEvent& from);
  void MergeFrom(const SchedProcessForkFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessForkFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessForkFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentCommFieldNumber = 1,
    kChildCommFieldNumber = 3,
    kParentPidFieldNumber = 2,
    kChildPidFieldNumber = 4,
  };
  // optional string parent_comm = 1;
  bool has_parent_comm() const;
  void clear_parent_comm();
  const std::string& parent_comm() const;
  void set_parent_comm(const std::string& value);
  void set_parent_comm(std::string&& value);
  void set_parent_comm(const char* value);
  void set_parent_comm(const char* value, size_t size);
  std::string* mutable_parent_comm();
  std::string* release_parent_comm();
  void set_allocated_parent_comm(std::string* parent_comm);

  // optional string child_comm = 3;
  bool has_child_comm() const;
  void clear_child_comm();
  const std::string& child_comm() const;
  void set_child_comm(const std::string& value);
  void set_child_comm(std::string&& value);
  void set_child_comm(const char* value);
  void set_child_comm(const char* value, size_t size);
  std::string* mutable_child_comm();
  std::string* release_child_comm();
  void set_allocated_child_comm(std::string* child_comm);

  // optional int32 parent_pid = 2;
  bool has_parent_pid() const;
  void clear_parent_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 parent_pid() const;
  void set_parent_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 child_pid = 4;
  bool has_child_pid() const;
  void clear_child_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 child_pid() const;
  void set_child_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessForkFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_comm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 parent_pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 child_pid_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessFreeFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessFreeFtraceEvent) */ {
 public:
  SchedProcessFreeFtraceEvent();
  virtual ~SchedProcessFreeFtraceEvent();

  SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent& from);
  SchedProcessFreeFtraceEvent(SchedProcessFreeFtraceEvent&& from) noexcept
    : SchedProcessFreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessFreeFtraceEvent& operator=(const SchedProcessFreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessFreeFtraceEvent& operator=(SchedProcessFreeFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedProcessFreeFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedProcessFreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessFreeFtraceEvent*>(
               &_SchedProcessFreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SchedProcessFreeFtraceEvent& a, SchedProcessFreeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessFreeFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedProcessFreeFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedProcessFreeFtraceEvent>(nullptr);
  }

  SchedProcessFreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedProcessFreeFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedProcessFreeFtraceEvent& from);
  void MergeFrom(const SchedProcessFreeFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessFreeFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessFreeFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm();
  const std::string& comm() const;
  void set_comm(const std::string& value);
  void set_comm(std::string&& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  std::string* mutable_comm();
  std::string* release_comm();
  void set_allocated_comm(std::string* comm);

  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 prio() const;
  void set_prio(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessFreeFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 prio_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessHangFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessHangFtraceEvent) */ {
 public:
  SchedProcessHangFtraceEvent();
  virtual ~SchedProcessHangFtraceEvent();

  SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent& from);
  SchedProcessHangFtraceEvent(SchedProcessHangFtraceEvent&& from) noexcept
    : SchedProcessHangFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessHangFtraceEvent& operator=(const SchedProcessHangFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessHangFtraceEvent& operator=(SchedProcessHangFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedProcessHangFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedProcessHangFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessHangFtraceEvent*>(
               &_SchedProcessHangFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SchedProcessHangFtraceEvent& a, SchedProcessHangFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessHangFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedProcessHangFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedProcessHangFtraceEvent>(nullptr);
  }

  SchedProcessHangFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedProcessHangFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedProcessHangFtraceEvent& from);
  void MergeFrom(const SchedProcessHangFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessHangFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessHangFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm();
  const std::string& comm() const;
  void set_comm(const std::string& value);
  void set_comm(std::string&& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  std::string* mutable_comm();
  std::string* release_comm();
  void set_allocated_comm(std::string* comm);

  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessHangFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessWaitFtraceEvent :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessWaitFtraceEvent) */ {
 public:
  SchedProcessWaitFtraceEvent();
  virtual ~SchedProcessWaitFtraceEvent();

  SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent& from);
  SchedProcessWaitFtraceEvent(SchedProcessWaitFtraceEvent&& from) noexcept
    : SchedProcessWaitFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessWaitFtraceEvent& operator=(const SchedProcessWaitFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessWaitFtraceEvent& operator=(SchedProcessWaitFtraceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SchedProcessWaitFtraceEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedProcessWaitFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessWaitFtraceEvent*>(
               &_SchedProcessWaitFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SchedProcessWaitFtraceEvent& a, SchedProcessWaitFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessWaitFtraceEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedProcessWaitFtraceEvent* New() const final {
    return CreateMaybeMessage<SchedProcessWaitFtraceEvent>(nullptr);
  }

  SchedProcessWaitFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedProcessWaitFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SchedProcessWaitFtraceEvent& from);
  void MergeFrom(const SchedProcessWaitFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessWaitFtraceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessWaitFtraceEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm();
  const std::string& comm() const;
  void set_comm(const std::string& value);
  void set_comm(std::string&& value);
  void set_comm(const char* value);
  void set_comm(const char* value, size_t size);
  std::string* mutable_comm();
  std::string* release_comm();
  void set_allocated_comm(std::string* comm);

  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 prio() const;
  void set_prio(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessWaitFtraceEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
  ::PROTOBUF_NAMESPACE_ID::int32 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 prio_;
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SchedSwitchFtraceEvent

// optional string prev_comm = 1;
inline bool SchedSwitchFtraceEvent::has_prev_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedSwitchFtraceEvent::clear_prev_comm() {
  prev_comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedSwitchFtraceEvent::prev_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  return prev_comm_.GetNoArena();
}
inline void SchedSwitchFtraceEvent::set_prev_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prev_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}
inline void SchedSwitchFtraceEvent::set_prev_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  prev_comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}
inline void SchedSwitchFtraceEvent::set_prev_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  prev_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}
inline void SchedSwitchFtraceEvent::set_prev_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  prev_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}
inline std::string* SchedSwitchFtraceEvent::mutable_prev_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  return prev_comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedSwitchFtraceEvent::release_prev_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  if (!has_prev_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return prev_comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedSwitchFtraceEvent::set_allocated_prev_comm(std::string* prev_comm) {
  if (prev_comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prev_comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prev_comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}

// optional int32 prev_pid = 2;
inline bool SchedSwitchFtraceEvent::has_prev_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedSwitchFtraceEvent::clear_prev_pid() {
  prev_pid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedSwitchFtraceEvent::prev_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_pid)
  return prev_pid_;
}
inline void SchedSwitchFtraceEvent::set_prev_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  prev_pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_pid)
}

// optional int32 prev_prio = 3;
inline bool SchedSwitchFtraceEvent::has_prev_prio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchedSwitchFtraceEvent::clear_prev_prio() {
  prev_prio_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedSwitchFtraceEvent::prev_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_prio)
  return prev_prio_;
}
inline void SchedSwitchFtraceEvent::set_prev_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  prev_prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_prio)
}

// optional int64 prev_state = 4;
inline bool SchedSwitchFtraceEvent::has_prev_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchedSwitchFtraceEvent::clear_prev_state() {
  prev_state_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchedSwitchFtraceEvent::prev_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_state)
  return prev_state_;
}
inline void SchedSwitchFtraceEvent::set_prev_state(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  prev_state_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_state)
}

// optional string next_comm = 5;
inline bool SchedSwitchFtraceEvent::has_next_comm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedSwitchFtraceEvent::clear_next_comm() {
  next_comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchedSwitchFtraceEvent::next_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  return next_comm_.GetNoArena();
}
inline void SchedSwitchFtraceEvent::set_next_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  next_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}
inline void SchedSwitchFtraceEvent::set_next_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  next_comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}
inline void SchedSwitchFtraceEvent::set_next_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  next_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}
inline void SchedSwitchFtraceEvent::set_next_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  next_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}
inline std::string* SchedSwitchFtraceEvent::mutable_next_comm() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  return next_comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedSwitchFtraceEvent::release_next_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  if (!has_next_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return next_comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedSwitchFtraceEvent::set_allocated_next_comm(std::string* next_comm) {
  if (next_comm != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  next_comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}

// optional int32 next_pid = 6;
inline bool SchedSwitchFtraceEvent::has_next_pid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchedSwitchFtraceEvent::clear_next_pid() {
  next_pid_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedSwitchFtraceEvent::next_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_pid)
  return next_pid_;
}
inline void SchedSwitchFtraceEvent::set_next_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  next_pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_pid)
}

// optional int32 next_prio = 7;
inline bool SchedSwitchFtraceEvent::has_next_prio() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchedSwitchFtraceEvent::clear_next_prio() {
  next_prio_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedSwitchFtraceEvent::next_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_prio)
  return next_prio_;
}
inline void SchedSwitchFtraceEvent::set_next_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  next_prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_prio)
}

// -------------------------------------------------------------------

// SchedWakeupFtraceEvent

// optional string comm = 1;
inline bool SchedWakeupFtraceEvent::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedWakeupFtraceEvent::clear_comm() {
  comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakeupFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.comm)
  return comm_.GetNoArena();
}
inline void SchedWakeupFtraceEvent::set_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.comm)
}
inline void SchedWakeupFtraceEvent::set_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedWakeupFtraceEvent.comm)
}
inline void SchedWakeupFtraceEvent::set_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedWakeupFtraceEvent.comm)
}
inline void SchedWakeupFtraceEvent::set_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedWakeupFtraceEvent.comm)
}
inline std::string* SchedWakeupFtraceEvent::mutable_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakeupFtraceEvent.comm)
  return comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedWakeupFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakeupFtraceEvent.comm)
  if (!has_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedWakeupFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakeupFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakeupFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedWakeupFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakeupFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.pid)
  return pid_;
}
inline void SchedWakeupFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedWakeupFtraceEvent::has_prio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedWakeupFtraceEvent::clear_prio() {
  prio_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakeupFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.prio)
  return prio_;
}
inline void SchedWakeupFtraceEvent::set_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.prio)
}

// optional int32 success = 4;
inline bool SchedWakeupFtraceEvent::has_success() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchedWakeupFtraceEvent::clear_success() {
  success_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakeupFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.success)
  return success_;
}
inline void SchedWakeupFtraceEvent::set_success(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.success)
}

// optional int32 target_cpu = 5;
inline bool SchedWakeupFtraceEvent::has_target_cpu() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchedWakeupFtraceEvent::clear_target_cpu() {
  target_cpu_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakeupFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.target_cpu)
  return target_cpu_;
}
inline void SchedWakeupFtraceEvent::set_target_cpu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  target_cpu_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.target_cpu)
}

// -------------------------------------------------------------------

// SchedBlockedReasonFtraceEvent

// optional int32 pid = 1;
inline bool SchedBlockedReasonFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedBlockedReasonFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedBlockedReasonFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.pid)
  return pid_;
}
inline void SchedBlockedReasonFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.pid)
}

// optional uint64 caller = 2;
inline bool SchedBlockedReasonFtraceEvent::has_caller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedBlockedReasonFtraceEvent::clear_caller() {
  caller_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SchedBlockedReasonFtraceEvent::caller() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.caller)
  return caller_;
}
inline void SchedBlockedReasonFtraceEvent::set_caller(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  caller_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.caller)
}

// optional uint32 io_wait = 3;
inline bool SchedBlockedReasonFtraceEvent::has_io_wait() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedBlockedReasonFtraceEvent::clear_io_wait() {
  io_wait_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SchedBlockedReasonFtraceEvent::io_wait() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.io_wait)
  return io_wait_;
}
inline void SchedBlockedReasonFtraceEvent::set_io_wait(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  io_wait_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.io_wait)
}

// -------------------------------------------------------------------

// SchedCpuHotplugFtraceEvent

// optional int32 affected_cpu = 1;
inline bool SchedCpuHotplugFtraceEvent::has_affected_cpu() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedCpuHotplugFtraceEvent::clear_affected_cpu() {
  affected_cpu_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedCpuHotplugFtraceEvent::affected_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.affected_cpu)
  return affected_cpu_;
}
inline void SchedCpuHotplugFtraceEvent::set_affected_cpu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  affected_cpu_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.affected_cpu)
}

// optional int32 error = 2;
inline bool SchedCpuHotplugFtraceEvent::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedCpuHotplugFtraceEvent::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedCpuHotplugFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.error)
  return error_;
}
inline void SchedCpuHotplugFtraceEvent::set_error(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  error_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.error)
}

// optional int32 status = 3;
inline bool SchedCpuHotplugFtraceEvent::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedCpuHotplugFtraceEvent::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedCpuHotplugFtraceEvent::status() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.status)
  return status_;
}
inline void SchedCpuHotplugFtraceEvent::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.status)
}

// -------------------------------------------------------------------

// SchedWakingFtraceEvent

// optional string comm = 1;
inline bool SchedWakingFtraceEvent::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedWakingFtraceEvent::clear_comm() {
  comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakingFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.comm)
  return comm_.GetNoArena();
}
inline void SchedWakingFtraceEvent::set_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.comm)
}
inline void SchedWakingFtraceEvent::set_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedWakingFtraceEvent.comm)
}
inline void SchedWakingFtraceEvent::set_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedWakingFtraceEvent.comm)
}
inline void SchedWakingFtraceEvent::set_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedWakingFtraceEvent.comm)
}
inline std::string* SchedWakingFtraceEvent::mutable_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakingFtraceEvent.comm)
  return comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedWakingFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakingFtraceEvent.comm)
  if (!has_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedWakingFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakingFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakingFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedWakingFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakingFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.pid)
  return pid_;
}
inline void SchedWakingFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedWakingFtraceEvent::has_prio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedWakingFtraceEvent::clear_prio() {
  prio_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakingFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.prio)
  return prio_;
}
inline void SchedWakingFtraceEvent::set_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.prio)
}

// optional int32 success = 4;
inline bool SchedWakingFtraceEvent::has_success() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchedWakingFtraceEvent::clear_success() {
  success_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakingFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.success)
  return success_;
}
inline void SchedWakingFtraceEvent::set_success(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.success)
}

// optional int32 target_cpu = 5;
inline bool SchedWakingFtraceEvent::has_target_cpu() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchedWakingFtraceEvent::clear_target_cpu() {
  target_cpu_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakingFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.target_cpu)
  return target_cpu_;
}
inline void SchedWakingFtraceEvent::set_target_cpu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  target_cpu_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.target_cpu)
}

// -------------------------------------------------------------------

// SchedWakeupNewFtraceEvent

// optional string comm = 1;
inline bool SchedWakeupNewFtraceEvent::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedWakeupNewFtraceEvent::clear_comm() {
  comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakeupNewFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  return comm_.GetNoArena();
}
inline void SchedWakeupNewFtraceEvent::set_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}
inline void SchedWakeupNewFtraceEvent::set_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}
inline void SchedWakeupNewFtraceEvent::set_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}
inline void SchedWakeupNewFtraceEvent::set_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}
inline std::string* SchedWakeupNewFtraceEvent::mutable_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  return comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedWakeupNewFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  if (!has_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedWakeupNewFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakeupNewFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedWakeupNewFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakeupNewFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.pid)
  return pid_;
}
inline void SchedWakeupNewFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedWakeupNewFtraceEvent::has_prio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedWakeupNewFtraceEvent::clear_prio() {
  prio_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakeupNewFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.prio)
  return prio_;
}
inline void SchedWakeupNewFtraceEvent::set_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.prio)
}

// optional int32 success = 4;
inline bool SchedWakeupNewFtraceEvent::has_success() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchedWakeupNewFtraceEvent::clear_success() {
  success_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakeupNewFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.success)
  return success_;
}
inline void SchedWakeupNewFtraceEvent::set_success(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.success)
}

// optional int32 target_cpu = 5;
inline bool SchedWakeupNewFtraceEvent::has_target_cpu() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchedWakeupNewFtraceEvent::clear_target_cpu() {
  target_cpu_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedWakeupNewFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.target_cpu)
  return target_cpu_;
}
inline void SchedWakeupNewFtraceEvent::set_target_cpu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  target_cpu_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.target_cpu)
}

// -------------------------------------------------------------------

// SchedProcessExecFtraceEvent

// optional string filename = 1;
inline bool SchedProcessExecFtraceEvent::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedProcessExecFtraceEvent::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessExecFtraceEvent::filename() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  return filename_.GetNoArena();
}
inline void SchedProcessExecFtraceEvent::set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}
inline void SchedProcessExecFtraceEvent::set_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}
inline void SchedProcessExecFtraceEvent::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}
inline void SchedProcessExecFtraceEvent::set_filename(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}
inline std::string* SchedProcessExecFtraceEvent::mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedProcessExecFtraceEvent::release_filename() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  if (!has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filename_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedProcessExecFtraceEvent::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}

// optional int32 pid = 2;
inline bool SchedProcessExecFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedProcessExecFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessExecFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.pid)
  return pid_;
}
inline void SchedProcessExecFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.pid)
}

// optional int32 old_pid = 3;
inline bool SchedProcessExecFtraceEvent::has_old_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedProcessExecFtraceEvent::clear_old_pid() {
  old_pid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessExecFtraceEvent::old_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.old_pid)
  return old_pid_;
}
inline void SchedProcessExecFtraceEvent::set_old_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  old_pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.old_pid)
}

// -------------------------------------------------------------------

// SchedProcessExitFtraceEvent

// optional string comm = 1;
inline bool SchedProcessExitFtraceEvent::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedProcessExitFtraceEvent::clear_comm() {
  comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessExitFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  return comm_.GetNoArena();
}
inline void SchedProcessExitFtraceEvent::set_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}
inline void SchedProcessExitFtraceEvent::set_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}
inline void SchedProcessExitFtraceEvent::set_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}
inline void SchedProcessExitFtraceEvent::set_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}
inline std::string* SchedProcessExitFtraceEvent::mutable_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  return comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedProcessExitFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  if (!has_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedProcessExitFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessExitFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedProcessExitFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessExitFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.pid)
  return pid_;
}
inline void SchedProcessExitFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.pid)
}

// optional int32 tgid = 3;
inline bool SchedProcessExitFtraceEvent::has_tgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedProcessExitFtraceEvent::clear_tgid() {
  tgid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessExitFtraceEvent::tgid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.tgid)
  return tgid_;
}
inline void SchedProcessExitFtraceEvent::set_tgid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  tgid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.tgid)
}

// optional int32 prio = 4;
inline bool SchedProcessExitFtraceEvent::has_prio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchedProcessExitFtraceEvent::clear_prio() {
  prio_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessExitFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.prio)
  return prio_;
}
inline void SchedProcessExitFtraceEvent::set_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.prio)
}

// -------------------------------------------------------------------

// SchedProcessForkFtraceEvent

// optional string parent_comm = 1;
inline bool SchedProcessForkFtraceEvent::has_parent_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedProcessForkFtraceEvent::clear_parent_comm() {
  parent_comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessForkFtraceEvent::parent_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  return parent_comm_.GetNoArena();
}
inline void SchedProcessForkFtraceEvent::set_parent_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  parent_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}
inline void SchedProcessForkFtraceEvent::set_parent_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  parent_comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}
inline void SchedProcessForkFtraceEvent::set_parent_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  parent_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}
inline void SchedProcessForkFtraceEvent::set_parent_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  parent_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}
inline std::string* SchedProcessForkFtraceEvent::mutable_parent_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  return parent_comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedProcessForkFtraceEvent::release_parent_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  if (!has_parent_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return parent_comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedProcessForkFtraceEvent::set_allocated_parent_comm(std::string* parent_comm) {
  if (parent_comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parent_comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}

// optional int32 parent_pid = 2;
inline bool SchedProcessForkFtraceEvent::has_parent_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedProcessForkFtraceEvent::clear_parent_pid() {
  parent_pid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessForkFtraceEvent::parent_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.parent_pid)
  return parent_pid_;
}
inline void SchedProcessForkFtraceEvent::set_parent_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  parent_pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.parent_pid)
}

// optional string child_comm = 3;
inline bool SchedProcessForkFtraceEvent::has_child_comm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedProcessForkFtraceEvent::clear_child_comm() {
  child_comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchedProcessForkFtraceEvent::child_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  return child_comm_.GetNoArena();
}
inline void SchedProcessForkFtraceEvent::set_child_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  child_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}
inline void SchedProcessForkFtraceEvent::set_child_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  child_comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}
inline void SchedProcessForkFtraceEvent::set_child_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  child_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}
inline void SchedProcessForkFtraceEvent::set_child_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  child_comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}
inline std::string* SchedProcessForkFtraceEvent::mutable_child_comm() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  return child_comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedProcessForkFtraceEvent::release_child_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  if (!has_child_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return child_comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedProcessForkFtraceEvent::set_allocated_child_comm(std::string* child_comm) {
  if (child_comm != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  child_comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), child_comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}

// optional int32 child_pid = 4;
inline bool SchedProcessForkFtraceEvent::has_child_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchedProcessForkFtraceEvent::clear_child_pid() {
  child_pid_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessForkFtraceEvent::child_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.child_pid)
  return child_pid_;
}
inline void SchedProcessForkFtraceEvent::set_child_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  child_pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.child_pid)
}

// -------------------------------------------------------------------

// SchedProcessFreeFtraceEvent

// optional string comm = 1;
inline bool SchedProcessFreeFtraceEvent::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedProcessFreeFtraceEvent::clear_comm() {
  comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessFreeFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  return comm_.GetNoArena();
}
inline void SchedProcessFreeFtraceEvent::set_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}
inline void SchedProcessFreeFtraceEvent::set_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}
inline void SchedProcessFreeFtraceEvent::set_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}
inline void SchedProcessFreeFtraceEvent::set_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}
inline std::string* SchedProcessFreeFtraceEvent::mutable_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  return comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedProcessFreeFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  if (!has_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedProcessFreeFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessFreeFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedProcessFreeFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessFreeFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.pid)
  return pid_;
}
inline void SchedProcessFreeFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedProcessFreeFtraceEvent::has_prio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedProcessFreeFtraceEvent::clear_prio() {
  prio_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessFreeFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.prio)
  return prio_;
}
inline void SchedProcessFreeFtraceEvent::set_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.prio)
}

// -------------------------------------------------------------------

// SchedProcessHangFtraceEvent

// optional string comm = 1;
inline bool SchedProcessHangFtraceEvent::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedProcessHangFtraceEvent::clear_comm() {
  comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessHangFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  return comm_.GetNoArena();
}
inline void SchedProcessHangFtraceEvent::set_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}
inline void SchedProcessHangFtraceEvent::set_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}
inline void SchedProcessHangFtraceEvent::set_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}
inline void SchedProcessHangFtraceEvent::set_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}
inline std::string* SchedProcessHangFtraceEvent::mutable_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  return comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedProcessHangFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  if (!has_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedProcessHangFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessHangFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedProcessHangFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessHangFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessHangFtraceEvent.pid)
  return pid_;
}
inline void SchedProcessHangFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessHangFtraceEvent.pid)
}

// -------------------------------------------------------------------

// SchedProcessWaitFtraceEvent

// optional string comm = 1;
inline bool SchedProcessWaitFtraceEvent::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedProcessWaitFtraceEvent::clear_comm() {
  comm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessWaitFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  return comm_.GetNoArena();
}
inline void SchedProcessWaitFtraceEvent::set_comm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}
inline void SchedProcessWaitFtraceEvent::set_comm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}
inline void SchedProcessWaitFtraceEvent::set_comm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}
inline void SchedProcessWaitFtraceEvent::set_comm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  comm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}
inline std::string* SchedProcessWaitFtraceEvent::mutable_comm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  return comm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SchedProcessWaitFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  if (!has_comm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return comm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SchedProcessWaitFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comm);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessWaitFtraceEvent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedProcessWaitFtraceEvent::clear_pid() {
  pid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessWaitFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.pid)
  return pid_;
}
inline void SchedProcessWaitFtraceEvent::set_pid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedProcessWaitFtraceEvent::has_prio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedProcessWaitFtraceEvent::clear_prio() {
  prio_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchedProcessWaitFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.prio)
  return prio_;
}
inline void SchedProcessWaitFtraceEvent::set_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.prio)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto
