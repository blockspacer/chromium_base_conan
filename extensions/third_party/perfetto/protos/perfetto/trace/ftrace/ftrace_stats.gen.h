// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class FtraceStats;
class FtraceCpuStats;
enum FtraceStats_Phase : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum FtraceStats_Phase : int {
  FtraceStats_Phase_UNSPECIFIED = 0,
  FtraceStats_Phase_START_OF_TRACE = 1,
  FtraceStats_Phase_END_OF_TRACE = 2,
};

class PERFETTO_EXPORT FtraceStats : public ::protozero::CppMessageObj {
 public:
  using Phase = FtraceStats_Phase;
  static constexpr auto UNSPECIFIED = FtraceStats_Phase_UNSPECIFIED;
  static constexpr auto START_OF_TRACE = FtraceStats_Phase_START_OF_TRACE;
  static constexpr auto END_OF_TRACE = FtraceStats_Phase_END_OF_TRACE;
  static constexpr auto Phase_MIN = FtraceStats_Phase_UNSPECIFIED;
  static constexpr auto Phase_MAX = FtraceStats_Phase_END_OF_TRACE;
  enum FieldNumbers {
    kPhaseFieldNumber = 1,
    kCpuStatsFieldNumber = 2,
    kKernelSymbolsParsedFieldNumber = 3,
    kKernelSymbolsMemKbFieldNumber = 4,
  };

  FtraceStats();
  ~FtraceStats() override;
  FtraceStats(FtraceStats&&) noexcept;
  FtraceStats& operator=(FtraceStats&&);
  FtraceStats(const FtraceStats&);
  FtraceStats& operator=(const FtraceStats&);
  bool operator==(const FtraceStats&) const;
  bool operator!=(const FtraceStats& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_phase() const { return _has_field_[1]; }
  FtraceStats_Phase phase() const { return phase_; }
  void set_phase(FtraceStats_Phase value) { phase_ = value; _has_field_.set(1); }

  const std::vector<FtraceCpuStats>& cpu_stats() const { return cpu_stats_; }
  std::vector<FtraceCpuStats>* mutable_cpu_stats() { return &cpu_stats_; }
  int cpu_stats_size() const;
  void clear_cpu_stats();
  FtraceCpuStats* add_cpu_stats();

  bool has_kernel_symbols_parsed() const { return _has_field_[3]; }
  uint32_t kernel_symbols_parsed() const { return kernel_symbols_parsed_; }
  void set_kernel_symbols_parsed(uint32_t value) { kernel_symbols_parsed_ = value; _has_field_.set(3); }

  bool has_kernel_symbols_mem_kb() const { return _has_field_[4]; }
  uint32_t kernel_symbols_mem_kb() const { return kernel_symbols_mem_kb_; }
  void set_kernel_symbols_mem_kb(uint32_t value) { kernel_symbols_mem_kb_ = value; _has_field_.set(4); }

 private:
  FtraceStats_Phase phase_{};
  std::vector<FtraceCpuStats> cpu_stats_;
  uint32_t kernel_symbols_parsed_{};
  uint32_t kernel_symbols_mem_kb_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT FtraceCpuStats : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCpuFieldNumber = 1,
    kEntriesFieldNumber = 2,
    kOverrunFieldNumber = 3,
    kCommitOverrunFieldNumber = 4,
    kBytesReadFieldNumber = 5,
    kOldestEventTsFieldNumber = 6,
    kNowTsFieldNumber = 7,
    kDroppedEventsFieldNumber = 8,
    kReadEventsFieldNumber = 9,
  };

  FtraceCpuStats();
  ~FtraceCpuStats() override;
  FtraceCpuStats(FtraceCpuStats&&) noexcept;
  FtraceCpuStats& operator=(FtraceCpuStats&&);
  FtraceCpuStats(const FtraceCpuStats&);
  FtraceCpuStats& operator=(const FtraceCpuStats&);
  bool operator==(const FtraceCpuStats&) const;
  bool operator!=(const FtraceCpuStats& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cpu() const { return _has_field_[1]; }
  uint64_t cpu() const { return cpu_; }
  void set_cpu(uint64_t value) { cpu_ = value; _has_field_.set(1); }

  bool has_entries() const { return _has_field_[2]; }
  uint64_t entries() const { return entries_; }
  void set_entries(uint64_t value) { entries_ = value; _has_field_.set(2); }

  bool has_overrun() const { return _has_field_[3]; }
  uint64_t overrun() const { return overrun_; }
  void set_overrun(uint64_t value) { overrun_ = value; _has_field_.set(3); }

  bool has_commit_overrun() const { return _has_field_[4]; }
  uint64_t commit_overrun() const { return commit_overrun_; }
  void set_commit_overrun(uint64_t value) { commit_overrun_ = value; _has_field_.set(4); }

  bool has_bytes_read() const { return _has_field_[5]; }
  uint64_t bytes_read() const { return bytes_read_; }
  void set_bytes_read(uint64_t value) { bytes_read_ = value; _has_field_.set(5); }

  bool has_oldest_event_ts() const { return _has_field_[6]; }
  double oldest_event_ts() const { return oldest_event_ts_; }
  void set_oldest_event_ts(double value) { oldest_event_ts_ = value; _has_field_.set(6); }

  bool has_now_ts() const { return _has_field_[7]; }
  double now_ts() const { return now_ts_; }
  void set_now_ts(double value) { now_ts_ = value; _has_field_.set(7); }

  bool has_dropped_events() const { return _has_field_[8]; }
  uint64_t dropped_events() const { return dropped_events_; }
  void set_dropped_events(uint64_t value) { dropped_events_ = value; _has_field_.set(8); }

  bool has_read_events() const { return _has_field_[9]; }
  uint64_t read_events() const { return read_events_; }
  void set_read_events(uint64_t value) { read_events_ = value; _has_field_.set(9); }

 private:
  uint64_t cpu_{};
  uint64_t entries_{};
  uint64_t overrun_{};
  uint64_t commit_overrun_{};
  uint64_t bytes_read_{};
  double oldest_event_ts_{};
  double now_ts_{};
  uint64_t dropped_events_{};
  uint64_t read_events_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_CPP_H_
