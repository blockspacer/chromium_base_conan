// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/ext4.proto

#include "protos/perfetto/trace/ftrace/ext4.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace perfetto {
namespace protos {
class Ext4DaWriteBeginFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DaWriteBeginFtraceEvent> _instance;
} _Ext4DaWriteBeginFtraceEvent_default_instance_;
class Ext4DaWriteEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DaWriteEndFtraceEvent> _instance;
} _Ext4DaWriteEndFtraceEvent_default_instance_;
class Ext4SyncFileEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4SyncFileEnterFtraceEvent> _instance;
} _Ext4SyncFileEnterFtraceEvent_default_instance_;
class Ext4SyncFileExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4SyncFileExitFtraceEvent> _instance;
} _Ext4SyncFileExitFtraceEvent_default_instance_;
class Ext4AllocDaBlocksFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4AllocDaBlocksFtraceEvent> _instance;
} _Ext4AllocDaBlocksFtraceEvent_default_instance_;
class Ext4AllocateBlocksFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4AllocateBlocksFtraceEvent> _instance;
} _Ext4AllocateBlocksFtraceEvent_default_instance_;
class Ext4AllocateInodeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4AllocateInodeFtraceEvent> _instance;
} _Ext4AllocateInodeFtraceEvent_default_instance_;
class Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4BeginOrderedTruncateFtraceEvent> _instance;
} _Ext4BeginOrderedTruncateFtraceEvent_default_instance_;
class Ext4CollapseRangeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4CollapseRangeFtraceEvent> _instance;
} _Ext4CollapseRangeFtraceEvent_default_instance_;
class Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DaReleaseSpaceFtraceEvent> _instance;
} _Ext4DaReleaseSpaceFtraceEvent_default_instance_;
class Ext4DaReserveSpaceFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DaReserveSpaceFtraceEvent> _instance;
} _Ext4DaReserveSpaceFtraceEvent_default_instance_;
class Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DaUpdateReserveSpaceFtraceEvent> _instance;
} _Ext4DaUpdateReserveSpaceFtraceEvent_default_instance_;
class Ext4DaWritePagesFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DaWritePagesFtraceEvent> _instance;
} _Ext4DaWritePagesFtraceEvent_default_instance_;
class Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DaWritePagesExtentFtraceEvent> _instance;
} _Ext4DaWritePagesExtentFtraceEvent_default_instance_;
class Ext4DirectIOEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DirectIOEnterFtraceEvent> _instance;
} _Ext4DirectIOEnterFtraceEvent_default_instance_;
class Ext4DirectIOExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DirectIOExitFtraceEvent> _instance;
} _Ext4DirectIOExitFtraceEvent_default_instance_;
class Ext4DiscardBlocksFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DiscardBlocksFtraceEvent> _instance;
} _Ext4DiscardBlocksFtraceEvent_default_instance_;
class Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DiscardPreallocationsFtraceEvent> _instance;
} _Ext4DiscardPreallocationsFtraceEvent_default_instance_;
class Ext4DropInodeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4DropInodeFtraceEvent> _instance;
} _Ext4DropInodeFtraceEvent_default_instance_;
class Ext4EsCacheExtentFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsCacheExtentFtraceEvent> _instance;
} _Ext4EsCacheExtentFtraceEvent_default_instance_;
class Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsFindDelayedExtentRangeEnterFtraceEvent> _instance;
} _Ext4EsFindDelayedExtentRangeEnterFtraceEvent_default_instance_;
class Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsFindDelayedExtentRangeExitFtraceEvent> _instance;
} _Ext4EsFindDelayedExtentRangeExitFtraceEvent_default_instance_;
class Ext4EsInsertExtentFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsInsertExtentFtraceEvent> _instance;
} _Ext4EsInsertExtentFtraceEvent_default_instance_;
class Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsLookupExtentEnterFtraceEvent> _instance;
} _Ext4EsLookupExtentEnterFtraceEvent_default_instance_;
class Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsLookupExtentExitFtraceEvent> _instance;
} _Ext4EsLookupExtentExitFtraceEvent_default_instance_;
class Ext4EsRemoveExtentFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsRemoveExtentFtraceEvent> _instance;
} _Ext4EsRemoveExtentFtraceEvent_default_instance_;
class Ext4EsShrinkFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsShrinkFtraceEvent> _instance;
} _Ext4EsShrinkFtraceEvent_default_instance_;
class Ext4EsShrinkCountFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsShrinkCountFtraceEvent> _instance;
} _Ext4EsShrinkCountFtraceEvent_default_instance_;
class Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsShrinkScanEnterFtraceEvent> _instance;
} _Ext4EsShrinkScanEnterFtraceEvent_default_instance_;
class Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EsShrinkScanExitFtraceEvent> _instance;
} _Ext4EsShrinkScanExitFtraceEvent_default_instance_;
class Ext4EvictInodeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4EvictInodeFtraceEvent> _instance;
} _Ext4EvictInodeFtraceEvent_default_instance_;
class Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtConvertToInitializedEnterFtraceEvent> _instance;
} _Ext4ExtConvertToInitializedEnterFtraceEvent_default_instance_;
class Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtConvertToInitializedFastpathFtraceEvent> _instance;
} _Ext4ExtConvertToInitializedFastpathFtraceEvent_default_instance_;
class Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtHandleUnwrittenExtentsFtraceEvent> _instance;
} _Ext4ExtHandleUnwrittenExtentsFtraceEvent_default_instance_;
class Ext4ExtInCacheFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtInCacheFtraceEvent> _instance;
} _Ext4ExtInCacheFtraceEvent_default_instance_;
class Ext4ExtLoadExtentFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtLoadExtentFtraceEvent> _instance;
} _Ext4ExtLoadExtentFtraceEvent_default_instance_;
class Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtMapBlocksEnterFtraceEvent> _instance;
} _Ext4ExtMapBlocksEnterFtraceEvent_default_instance_;
class Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtMapBlocksExitFtraceEvent> _instance;
} _Ext4ExtMapBlocksExitFtraceEvent_default_instance_;
class Ext4ExtPutInCacheFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtPutInCacheFtraceEvent> _instance;
} _Ext4ExtPutInCacheFtraceEvent_default_instance_;
class Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtRemoveSpaceFtraceEvent> _instance;
} _Ext4ExtRemoveSpaceFtraceEvent_default_instance_;
class Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtRemoveSpaceDoneFtraceEvent> _instance;
} _Ext4ExtRemoveSpaceDoneFtraceEvent_default_instance_;
class Ext4ExtRmIdxFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtRmIdxFtraceEvent> _instance;
} _Ext4ExtRmIdxFtraceEvent_default_instance_;
class Ext4ExtRmLeafFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtRmLeafFtraceEvent> _instance;
} _Ext4ExtRmLeafFtraceEvent_default_instance_;
class Ext4ExtShowExtentFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ExtShowExtentFtraceEvent> _instance;
} _Ext4ExtShowExtentFtraceEvent_default_instance_;
class Ext4FallocateEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4FallocateEnterFtraceEvent> _instance;
} _Ext4FallocateEnterFtraceEvent_default_instance_;
class Ext4FallocateExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4FallocateExitFtraceEvent> _instance;
} _Ext4FallocateExitFtraceEvent_default_instance_;
class Ext4FindDelallocRangeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4FindDelallocRangeFtraceEvent> _instance;
} _Ext4FindDelallocRangeFtraceEvent_default_instance_;
class Ext4ForgetFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ForgetFtraceEvent> _instance;
} _Ext4ForgetFtraceEvent_default_instance_;
class Ext4FreeBlocksFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4FreeBlocksFtraceEvent> _instance;
} _Ext4FreeBlocksFtraceEvent_default_instance_;
class Ext4FreeInodeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4FreeInodeFtraceEvent> _instance;
} _Ext4FreeInodeFtraceEvent_default_instance_;
class Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4GetImpliedClusterAllocExitFtraceEvent> _instance;
} _Ext4GetImpliedClusterAllocExitFtraceEvent_default_instance_;
class Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4GetReservedClusterAllocFtraceEvent> _instance;
} _Ext4GetReservedClusterAllocFtraceEvent_default_instance_;
class Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4IndMapBlocksEnterFtraceEvent> _instance;
} _Ext4IndMapBlocksEnterFtraceEvent_default_instance_;
class Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4IndMapBlocksExitFtraceEvent> _instance;
} _Ext4IndMapBlocksExitFtraceEvent_default_instance_;
class Ext4InsertRangeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4InsertRangeFtraceEvent> _instance;
} _Ext4InsertRangeFtraceEvent_default_instance_;
class Ext4InvalidatepageFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4InvalidatepageFtraceEvent> _instance;
} _Ext4InvalidatepageFtraceEvent_default_instance_;
class Ext4JournalStartFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4JournalStartFtraceEvent> _instance;
} _Ext4JournalStartFtraceEvent_default_instance_;
class Ext4JournalStartReservedFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4JournalStartReservedFtraceEvent> _instance;
} _Ext4JournalStartReservedFtraceEvent_default_instance_;
class Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4JournalledInvalidatepageFtraceEvent> _instance;
} _Ext4JournalledInvalidatepageFtraceEvent_default_instance_;
class Ext4JournalledWriteEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4JournalledWriteEndFtraceEvent> _instance;
} _Ext4JournalledWriteEndFtraceEvent_default_instance_;
class Ext4LoadInodeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4LoadInodeFtraceEvent> _instance;
} _Ext4LoadInodeFtraceEvent_default_instance_;
class Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4LoadInodeBitmapFtraceEvent> _instance;
} _Ext4LoadInodeBitmapFtraceEvent_default_instance_;
class Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MarkInodeDirtyFtraceEvent> _instance;
} _Ext4MarkInodeDirtyFtraceEvent_default_instance_;
class Ext4MbBitmapLoadFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MbBitmapLoadFtraceEvent> _instance;
} _Ext4MbBitmapLoadFtraceEvent_default_instance_;
class Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MbBuddyBitmapLoadFtraceEvent> _instance;
} _Ext4MbBuddyBitmapLoadFtraceEvent_default_instance_;
class Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MbDiscardPreallocationsFtraceEvent> _instance;
} _Ext4MbDiscardPreallocationsFtraceEvent_default_instance_;
class Ext4MbNewGroupPaFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MbNewGroupPaFtraceEvent> _instance;
} _Ext4MbNewGroupPaFtraceEvent_default_instance_;
class Ext4MbNewInodePaFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MbNewInodePaFtraceEvent> _instance;
} _Ext4MbNewInodePaFtraceEvent_default_instance_;
class Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MbReleaseGroupPaFtraceEvent> _instance;
} _Ext4MbReleaseGroupPaFtraceEvent_default_instance_;
class Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MbReleaseInodePaFtraceEvent> _instance;
} _Ext4MbReleaseInodePaFtraceEvent_default_instance_;
class Ext4MballocAllocFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MballocAllocFtraceEvent> _instance;
} _Ext4MballocAllocFtraceEvent_default_instance_;
class Ext4MballocDiscardFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MballocDiscardFtraceEvent> _instance;
} _Ext4MballocDiscardFtraceEvent_default_instance_;
class Ext4MballocFreeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MballocFreeFtraceEvent> _instance;
} _Ext4MballocFreeFtraceEvent_default_instance_;
class Ext4MballocPreallocFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4MballocPreallocFtraceEvent> _instance;
} _Ext4MballocPreallocFtraceEvent_default_instance_;
class Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4OtherInodeUpdateTimeFtraceEvent> _instance;
} _Ext4OtherInodeUpdateTimeFtraceEvent_default_instance_;
class Ext4PunchHoleFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4PunchHoleFtraceEvent> _instance;
} _Ext4PunchHoleFtraceEvent_default_instance_;
class Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ReadBlockBitmapLoadFtraceEvent> _instance;
} _Ext4ReadBlockBitmapLoadFtraceEvent_default_instance_;
class Ext4ReadpageFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ReadpageFtraceEvent> _instance;
} _Ext4ReadpageFtraceEvent_default_instance_;
class Ext4ReleasepageFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ReleasepageFtraceEvent> _instance;
} _Ext4ReleasepageFtraceEvent_default_instance_;
class Ext4RemoveBlocksFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4RemoveBlocksFtraceEvent> _instance;
} _Ext4RemoveBlocksFtraceEvent_default_instance_;
class Ext4RequestBlocksFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4RequestBlocksFtraceEvent> _instance;
} _Ext4RequestBlocksFtraceEvent_default_instance_;
class Ext4RequestInodeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4RequestInodeFtraceEvent> _instance;
} _Ext4RequestInodeFtraceEvent_default_instance_;
class Ext4SyncFsFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4SyncFsFtraceEvent> _instance;
} _Ext4SyncFsFtraceEvent_default_instance_;
class Ext4TrimAllFreeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4TrimAllFreeFtraceEvent> _instance;
} _Ext4TrimAllFreeFtraceEvent_default_instance_;
class Ext4TrimExtentFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4TrimExtentFtraceEvent> _instance;
} _Ext4TrimExtentFtraceEvent_default_instance_;
class Ext4TruncateEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4TruncateEnterFtraceEvent> _instance;
} _Ext4TruncateEnterFtraceEvent_default_instance_;
class Ext4TruncateExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4TruncateExitFtraceEvent> _instance;
} _Ext4TruncateExitFtraceEvent_default_instance_;
class Ext4UnlinkEnterFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4UnlinkEnterFtraceEvent> _instance;
} _Ext4UnlinkEnterFtraceEvent_default_instance_;
class Ext4UnlinkExitFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4UnlinkExitFtraceEvent> _instance;
} _Ext4UnlinkExitFtraceEvent_default_instance_;
class Ext4WriteBeginFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4WriteBeginFtraceEvent> _instance;
} _Ext4WriteBeginFtraceEvent_default_instance_;
class Ext4WriteEndFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4WriteEndFtraceEvent> _instance;
} _Ext4WriteEndFtraceEvent_default_instance_;
class Ext4WritepageFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4WritepageFtraceEvent> _instance;
} _Ext4WritepageFtraceEvent_default_instance_;
class Ext4WritepagesFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4WritepagesFtraceEvent> _instance;
} _Ext4WritepagesFtraceEvent_default_instance_;
class Ext4WritepagesResultFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4WritepagesResultFtraceEvent> _instance;
} _Ext4WritepagesResultFtraceEvent_default_instance_;
class Ext4ZeroRangeFtraceEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Ext4ZeroRangeFtraceEvent> _instance;
} _Ext4ZeroRangeFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
static void InitDefaultsscc_info_Ext4AllocDaBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4AllocDaBlocksFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4AllocDaBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4AllocDaBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4AllocateBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4AllocateBlocksFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4AllocateBlocksFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4AllocateBlocksFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4AllocateBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4AllocateBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4AllocateInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4AllocateInodeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4AllocateInodeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4AllocateInodeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4AllocateInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4AllocateInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4BeginOrderedTruncateFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4BeginOrderedTruncateFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4BeginOrderedTruncateFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4BeginOrderedTruncateFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4CollapseRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4CollapseRangeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4CollapseRangeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4CollapseRangeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4CollapseRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4CollapseRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DaReleaseSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DaReleaseSpaceFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DaReleaseSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DaReleaseSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DaReserveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DaReserveSpaceFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DaReserveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DaReserveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DaUpdateReserveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DaUpdateReserveSpaceFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DaUpdateReserveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DaUpdateReserveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DaWriteBeginFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DaWriteBeginFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DaWriteBeginFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DaWriteBeginFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DaWriteBeginFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DaWriteBeginFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DaWriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DaWriteEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DaWriteEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DaWriteEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DaWriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DaWriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DaWritePagesExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DaWritePagesExtentFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DaWritePagesExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DaWritePagesExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DaWritePagesFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DaWritePagesFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DaWritePagesFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DaWritePagesFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DaWritePagesFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DaWritePagesFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DirectIOEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DirectIOEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DirectIOEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DirectIOEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DirectIOEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DirectIOEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DirectIOExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DirectIOExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DirectIOExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DirectIOExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DirectIOExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DirectIOExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DiscardBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DiscardBlocksFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DiscardBlocksFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DiscardBlocksFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DiscardBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DiscardBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DiscardPreallocationsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DiscardPreallocationsFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DiscardPreallocationsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DiscardPreallocationsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4DropInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4DropInodeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4DropInodeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4DropInodeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4DropInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4DropInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsCacheExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsCacheExtentFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsCacheExtentFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsCacheExtentFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsCacheExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsCacheExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsFindDelayedExtentRangeEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsFindDelayedExtentRangeEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsFindDelayedExtentRangeEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsFindDelayedExtentRangeEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsFindDelayedExtentRangeExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsFindDelayedExtentRangeExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsFindDelayedExtentRangeExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsFindDelayedExtentRangeExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsInsertExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsInsertExtentFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsInsertExtentFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsInsertExtentFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsInsertExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsInsertExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsLookupExtentEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsLookupExtentEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsLookupExtentEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsLookupExtentEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsLookupExtentExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsLookupExtentExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsLookupExtentExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsLookupExtentExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsRemoveExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsRemoveExtentFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsRemoveExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsRemoveExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsShrinkCountFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsShrinkCountFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsShrinkCountFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsShrinkCountFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsShrinkCountFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsShrinkCountFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsShrinkFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsShrinkFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsShrinkFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsShrinkScanEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsShrinkScanEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsShrinkScanEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsShrinkScanEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EsShrinkScanExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EsShrinkScanExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EsShrinkScanExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EsShrinkScanExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4EvictInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4EvictInodeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4EvictInodeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4EvictInodeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4EvictInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4EvictInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtConvertToInitializedEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtConvertToInitializedEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtConvertToInitializedEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtConvertToInitializedEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtConvertToInitializedFastpathFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtConvertToInitializedFastpathFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtConvertToInitializedFastpathFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtConvertToInitializedFastpathFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtHandleUnwrittenExtentsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtHandleUnwrittenExtentsFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtHandleUnwrittenExtentsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtHandleUnwrittenExtentsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtInCacheFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtInCacheFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtInCacheFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtInCacheFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtInCacheFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtInCacheFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtLoadExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtLoadExtentFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtLoadExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtLoadExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtMapBlocksEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtMapBlocksEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtMapBlocksEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtMapBlocksEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtMapBlocksExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtMapBlocksExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtMapBlocksExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtMapBlocksExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtPutInCacheFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtPutInCacheFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtPutInCacheFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtPutInCacheFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtRemoveSpaceDoneFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtRemoveSpaceDoneFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtRemoveSpaceDoneFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtRemoveSpaceDoneFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtRemoveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtRemoveSpaceFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtRemoveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtRemoveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtRmIdxFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtRmIdxFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtRmIdxFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtRmIdxFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtRmIdxFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtRmIdxFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtRmLeafFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtRmLeafFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtRmLeafFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtRmLeafFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtRmLeafFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtRmLeafFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ExtShowExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ExtShowExtentFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ExtShowExtentFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ExtShowExtentFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ExtShowExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ExtShowExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4FallocateEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4FallocateEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4FallocateEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4FallocateEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4FallocateEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4FallocateEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4FallocateExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4FallocateExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4FallocateExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4FallocateExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4FallocateExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4FallocateExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4FindDelallocRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4FindDelallocRangeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4FindDelallocRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4FindDelallocRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ForgetFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ForgetFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ForgetFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ForgetFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ForgetFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ForgetFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4FreeBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4FreeBlocksFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4FreeBlocksFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4FreeBlocksFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4FreeBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4FreeBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4FreeInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4FreeInodeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4FreeInodeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4FreeInodeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4FreeInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4FreeInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4GetImpliedClusterAllocExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4GetImpliedClusterAllocExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4GetImpliedClusterAllocExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4GetImpliedClusterAllocExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4GetReservedClusterAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4GetReservedClusterAllocFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4GetReservedClusterAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4GetReservedClusterAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4IndMapBlocksEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4IndMapBlocksEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4IndMapBlocksEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4IndMapBlocksEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4IndMapBlocksExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4IndMapBlocksExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4IndMapBlocksExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4IndMapBlocksExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4InsertRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4InsertRangeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4InsertRangeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4InsertRangeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4InsertRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4InsertRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4InvalidatepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4InvalidatepageFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4InvalidatepageFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4InvalidatepageFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4InvalidatepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4InvalidatepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4JournalStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4JournalStartFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4JournalStartFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4JournalStartFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4JournalStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4JournalStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4JournalStartReservedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4JournalStartReservedFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4JournalStartReservedFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4JournalStartReservedFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4JournalStartReservedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4JournalStartReservedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4JournalledInvalidatepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4JournalledInvalidatepageFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4JournalledInvalidatepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4JournalledInvalidatepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4JournalledWriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4JournalledWriteEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4JournalledWriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4JournalledWriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4LoadInodeBitmapFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4LoadInodeBitmapFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4LoadInodeBitmapFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4LoadInodeBitmapFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4LoadInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4LoadInodeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4LoadInodeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4LoadInodeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4LoadInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4LoadInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MarkInodeDirtyFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MarkInodeDirtyFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MarkInodeDirtyFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MarkInodeDirtyFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MbBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MbBitmapLoadFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MbBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MbBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MbBuddyBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MbBuddyBitmapLoadFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MbBuddyBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MbBuddyBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MbDiscardPreallocationsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MbDiscardPreallocationsFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MbDiscardPreallocationsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MbDiscardPreallocationsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MbNewGroupPaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MbNewGroupPaFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MbNewGroupPaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MbNewGroupPaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MbNewInodePaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MbNewInodePaFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MbNewInodePaFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MbNewInodePaFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MbNewInodePaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MbNewInodePaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MbReleaseGroupPaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MbReleaseGroupPaFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MbReleaseGroupPaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MbReleaseGroupPaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MbReleaseInodePaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MbReleaseInodePaFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MbReleaseInodePaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MbReleaseInodePaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MballocAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MballocAllocFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MballocAllocFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MballocAllocFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MballocAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MballocAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MballocDiscardFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MballocDiscardFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MballocDiscardFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MballocDiscardFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MballocDiscardFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MballocDiscardFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MballocFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MballocFreeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MballocFreeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MballocFreeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MballocFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MballocFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4MballocPreallocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4MballocPreallocFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4MballocPreallocFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4MballocPreallocFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4MballocPreallocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4MballocPreallocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4OtherInodeUpdateTimeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4OtherInodeUpdateTimeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4OtherInodeUpdateTimeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4OtherInodeUpdateTimeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4PunchHoleFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4PunchHoleFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4PunchHoleFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4PunchHoleFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4PunchHoleFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4PunchHoleFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ReadBlockBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ReadBlockBitmapLoadFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ReadBlockBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ReadBlockBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ReadpageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ReadpageFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ReadpageFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ReadpageFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ReadpageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ReadpageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ReleasepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ReleasepageFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ReleasepageFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ReleasepageFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ReleasepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ReleasepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4RemoveBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4RemoveBlocksFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4RemoveBlocksFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4RemoveBlocksFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4RemoveBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4RemoveBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4RequestBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4RequestBlocksFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4RequestBlocksFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4RequestBlocksFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4RequestBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4RequestBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4RequestInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4RequestInodeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4RequestInodeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4RequestInodeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4RequestInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4RequestInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4SyncFileEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4SyncFileEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4SyncFileEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4SyncFileEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4SyncFileEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4SyncFileEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4SyncFileExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4SyncFileExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4SyncFileExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4SyncFileExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4SyncFileExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4SyncFileExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4SyncFsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4SyncFsFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4SyncFsFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4SyncFsFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4SyncFsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4SyncFsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4TrimAllFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4TrimAllFreeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4TrimAllFreeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4TrimAllFreeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4TrimAllFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4TrimAllFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4TrimExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4TrimExtentFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4TrimExtentFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4TrimExtentFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4TrimExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4TrimExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4TruncateEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4TruncateEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4TruncateEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4TruncateEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4TruncateEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4TruncateEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4TruncateExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4TruncateExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4TruncateExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4TruncateExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4TruncateExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4TruncateExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4UnlinkEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4UnlinkEnterFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4UnlinkEnterFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4UnlinkEnterFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4UnlinkEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4UnlinkEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4UnlinkExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4UnlinkExitFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4UnlinkExitFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4UnlinkExitFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4UnlinkExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4UnlinkExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4WriteBeginFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4WriteBeginFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4WriteBeginFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4WriteBeginFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4WriteBeginFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4WriteBeginFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4WriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4WriteEndFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4WriteEndFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4WriteEndFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4WriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4WriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4WritepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4WritepageFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4WritepageFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4WritepageFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4WritepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4WritepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4WritepagesFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4WritepagesFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4WritepagesFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4WritepagesFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4WritepagesFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4WritepagesFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4WritepagesResultFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4WritepagesResultFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4WritepagesResultFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4WritepagesResultFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4WritepagesResultFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4WritepagesResultFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

static void InitDefaultsscc_info_Ext4ZeroRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perfetto::protos::_Ext4ZeroRangeFtraceEvent_default_instance_;
    new (ptr) ::perfetto::protos::Ext4ZeroRangeFtraceEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perfetto::protos::Ext4ZeroRangeFtraceEvent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Ext4ZeroRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Ext4ZeroRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto}, {}};

namespace perfetto {
namespace protos {

// ===================================================================

void Ext4DaWriteBeginFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DaWriteBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWriteBeginFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
}
Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(const Ext4DaWriteBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
}

void Ext4DaWriteBeginFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4DaWriteBeginFtraceEvent::~Ext4DaWriteBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  SharedDtor();
}

void Ext4DaWriteBeginFtraceEvent::SharedDtor() {
}

void Ext4DaWriteBeginFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DaWriteBeginFtraceEvent& Ext4DaWriteBeginFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DaWriteBeginFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DaWriteBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DaWriteBeginFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DaWriteBeginFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DaWriteBeginFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->pos(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->flags(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
}

size_t Ext4DaWriteBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaWriteBeginFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DaWriteBeginFtraceEvent*>(
      &from));
}

void Ext4DaWriteBeginFtraceEvent::MergeFrom(const Ext4DaWriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DaWriteBeginFtraceEvent::CopyFrom(const Ext4DaWriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWriteBeginFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWriteBeginFtraceEvent::InternalSwap(Ext4DaWriteBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pos_, other->pos_);
  swap(len_, other->len_);
  swap(flags_, other->flags_);
}

std::string Ext4DaWriteBeginFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaWriteBeginFtraceEvent";
}


// ===================================================================

void Ext4DaWriteEndFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DaWriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWriteEndFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
}
Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(const Ext4DaWriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
}

void Ext4DaWriteEndFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&copied_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
}

Ext4DaWriteEndFtraceEvent::~Ext4DaWriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  SharedDtor();
}

void Ext4DaWriteEndFtraceEvent::SharedDtor() {
}

void Ext4DaWriteEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DaWriteEndFtraceEvent& Ext4DaWriteEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DaWriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DaWriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&copied_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DaWriteEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DaWriteEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 copied = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_copied(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &copied_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DaWriteEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->pos(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->copied(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DaWriteEndFtraceEvent)
}

size_t Ext4DaWriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->copied());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaWriteEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DaWriteEndFtraceEvent*>(
      &from));
}

void Ext4DaWriteEndFtraceEvent::MergeFrom(const Ext4DaWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      copied_ = from.copied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DaWriteEndFtraceEvent::CopyFrom(const Ext4DaWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWriteEndFtraceEvent::InternalSwap(Ext4DaWriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pos_, other->pos_);
  swap(len_, other->len_);
  swap(copied_, other->copied_);
}

std::string Ext4DaWriteEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaWriteEndFtraceEvent";
}


// ===================================================================

void Ext4SyncFileEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4SyncFileEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFileEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_datasync(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
}
Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(const Ext4SyncFileEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&datasync_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(datasync_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
}

void Ext4SyncFileEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&datasync_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(datasync_));
}

Ext4SyncFileEnterFtraceEvent::~Ext4SyncFileEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  SharedDtor();
}

void Ext4SyncFileEnterFtraceEvent::SharedDtor() {
}

void Ext4SyncFileEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4SyncFileEnterFtraceEvent& Ext4SyncFileEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4SyncFileEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4SyncFileEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&datasync_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(datasync_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4SyncFileEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_parent(&has_bits);
          parent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 datasync = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_datasync(&has_bits);
          datasync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4SyncFileEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 parent = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_parent(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &parent_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 datasync = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_datasync(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &datasync_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4SyncFileEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 parent = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->parent(), output);
  }

  // optional int32 datasync = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->datasync(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
}

size_t Ext4SyncFileEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 parent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->parent());
    }

    // optional int32 datasync = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->datasync());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4SyncFileEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4SyncFileEnterFtraceEvent*>(
      &from));
}

void Ext4SyncFileEnterFtraceEvent::MergeFrom(const Ext4SyncFileEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      parent_ = from.parent_;
    }
    if (cached_has_bits & 0x00000008u) {
      datasync_ = from.datasync_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4SyncFileEnterFtraceEvent::CopyFrom(const Ext4SyncFileEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFileEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFileEnterFtraceEvent::InternalSwap(Ext4SyncFileEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(parent_, other->parent_);
  swap(datasync_, other->datasync_);
}

std::string Ext4SyncFileEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4SyncFileEnterFtraceEvent";
}


// ===================================================================

void Ext4SyncFileExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4SyncFileExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFileExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
}
Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(const Ext4SyncFileExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
}

void Ext4SyncFileExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ret_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4SyncFileExitFtraceEvent::~Ext4SyncFileExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  SharedDtor();
}

void Ext4SyncFileExitFtraceEvent::SharedDtor() {
}

void Ext4SyncFileExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4SyncFileExitFtraceEvent& Ext4SyncFileExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4SyncFileExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4SyncFileExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4SyncFileExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4SyncFileExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4SyncFileExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->ret(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4SyncFileExitFtraceEvent)
}

size_t Ext4SyncFileExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4SyncFileExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4SyncFileExitFtraceEvent*>(
      &from));
}

void Ext4SyncFileExitFtraceEvent::MergeFrom(const Ext4SyncFileExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4SyncFileExitFtraceEvent::CopyFrom(const Ext4SyncFileExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFileExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFileExitFtraceEvent::InternalSwap(Ext4SyncFileExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(ret_, other->ret_);
}

std::string Ext4SyncFileExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4SyncFileExitFtraceEvent";
}


// ===================================================================

void Ext4AllocDaBlocksFtraceEvent::InitAsDefaultInstance() {
}
class Ext4AllocDaBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocDaBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
}
Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(const Ext4AllocDaBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&meta_blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(meta_blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
}

void Ext4AllocDaBlocksFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&meta_blocks_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(meta_blocks_));
}

Ext4AllocDaBlocksFtraceEvent::~Ext4AllocDaBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  SharedDtor();
}

void Ext4AllocDaBlocksFtraceEvent::SharedDtor() {
}

void Ext4AllocDaBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4AllocDaBlocksFtraceEvent& Ext4AllocDaBlocksFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4AllocDaBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4AllocDaBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&meta_blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(meta_blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4AllocDaBlocksFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 data_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_data_blocks(&has_bits);
          data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 meta_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_meta_blocks(&has_bits);
          meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4AllocDaBlocksFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 data_blocks = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_data_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 meta_blocks = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_meta_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &meta_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4AllocDaBlocksFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 data_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->data_blocks(), output);
  }

  // optional uint32 meta_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->meta_blocks(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
}

size_t Ext4AllocDaBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 data_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->data_blocks());
    }

    // optional uint32 meta_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->meta_blocks());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4AllocDaBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4AllocDaBlocksFtraceEvent*>(
      &from));
}

void Ext4AllocDaBlocksFtraceEvent::MergeFrom(const Ext4AllocDaBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      data_blocks_ = from.data_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      meta_blocks_ = from.meta_blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4AllocDaBlocksFtraceEvent::CopyFrom(const Ext4AllocDaBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocDaBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocDaBlocksFtraceEvent::InternalSwap(Ext4AllocDaBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(data_blocks_, other->data_blocks_);
  swap(meta_blocks_, other->meta_blocks_);
}

std::string Ext4AllocDaBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4AllocDaBlocksFtraceEvent";
}


// ===================================================================

void Ext4AllocateBlocksFtraceEvent::InitAsDefaultInstance() {
}
class Ext4AllocateBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocateBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lleft(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lright(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pleft(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pright(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
}
Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(const Ext4AllocateBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
}

void Ext4AllocateBlocksFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4AllocateBlocksFtraceEvent::~Ext4AllocateBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  SharedDtor();
}

void Ext4AllocateBlocksFtraceEvent::SharedDtor() {
}

void Ext4AllocateBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4AllocateBlocksFtraceEvent& Ext4AllocateBlocksFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4AllocateBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4AllocateBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&goal_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(goal_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&pleft_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&pleft_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4AllocateBlocksFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 logical = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_logical(&has_bits);
          logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lleft = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_lleft(&has_bits);
          lleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lright = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_lright(&has_bits);
          lright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 goal = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_goal(&has_bits);
          goal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pleft = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_pleft(&has_bits);
          pleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pright = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_pright(&has_bits);
          pright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4AllocateBlocksFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 block = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_block(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 logical = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_logical(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &logical_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lleft = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_lleft(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lleft_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lright = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_lright(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lright_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 goal = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_goal(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &goal_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pleft = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_pleft(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pleft_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pright = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_pright(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pright_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4AllocateBlocksFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->block(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 logical = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->logical(), output);
  }

  // optional uint32 lleft = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->lleft(), output);
  }

  // optional uint32 lright = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->lright(), output);
  }

  // optional uint64 goal = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(8, this->goal(), output);
  }

  // optional uint64 pleft = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(9, this->pleft(), output);
  }

  // optional uint64 pright = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(10, this->pright(), output);
  }

  // optional uint32 flags = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->flags(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
}

size_t Ext4AllocateBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->block());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 logical = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->logical());
    }

    // optional uint32 lleft = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lleft());
    }

    // optional uint32 lright = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lright());
    }

    // optional uint64 goal = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->goal());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint64 pleft = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pleft());
    }

    // optional uint64 pright = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pright());
    }

    // optional uint32 flags = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4AllocateBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4AllocateBlocksFtraceEvent*>(
      &from));
}

void Ext4AllocateBlocksFtraceEvent::MergeFrom(const Ext4AllocateBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      block_ = from.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      logical_ = from.logical_;
    }
    if (cached_has_bits & 0x00000020u) {
      lleft_ = from.lleft_;
    }
    if (cached_has_bits & 0x00000040u) {
      lright_ = from.lright_;
    }
    if (cached_has_bits & 0x00000080u) {
      goal_ = from.goal_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      pleft_ = from.pleft_;
    }
    if (cached_has_bits & 0x00000200u) {
      pright_ = from.pright_;
    }
    if (cached_has_bits & 0x00000400u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4AllocateBlocksFtraceEvent::CopyFrom(const Ext4AllocateBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocateBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocateBlocksFtraceEvent::InternalSwap(Ext4AllocateBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(block_, other->block_);
  swap(len_, other->len_);
  swap(logical_, other->logical_);
  swap(lleft_, other->lleft_);
  swap(lright_, other->lright_);
  swap(goal_, other->goal_);
  swap(pleft_, other->pleft_);
  swap(pright_, other->pright_);
  swap(flags_, other->flags_);
}

std::string Ext4AllocateBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4AllocateBlocksFtraceEvent";
}


// ===================================================================

void Ext4AllocateInodeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4AllocateInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocateInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
}
Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(const Ext4AllocateInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
}

void Ext4AllocateInodeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4AllocateInodeFtraceEvent::~Ext4AllocateInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  SharedDtor();
}

void Ext4AllocateInodeFtraceEvent::SharedDtor() {
}

void Ext4AllocateInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4AllocateInodeFtraceEvent& Ext4AllocateInodeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4AllocateInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4AllocateInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4AllocateInodeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 dir = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_dir(&has_bits);
          dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4AllocateInodeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 dir = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_dir(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dir_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4AllocateInodeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 dir = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->dir(), output);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4AllocateInodeFtraceEvent)
}

size_t Ext4AllocateInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 dir = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dir());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4AllocateInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4AllocateInodeFtraceEvent*>(
      &from));
}

void Ext4AllocateInodeFtraceEvent::MergeFrom(const Ext4AllocateInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      dir_ = from.dir_;
    }
    if (cached_has_bits & 0x00000008u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4AllocateInodeFtraceEvent::CopyFrom(const Ext4AllocateInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocateInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocateInodeFtraceEvent::InternalSwap(Ext4AllocateInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(dir_, other->dir_);
  swap(mode_, other->mode_);
}

std::string Ext4AllocateInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4AllocateInodeFtraceEvent";
}


// ===================================================================

void Ext4BeginOrderedTruncateFtraceEvent::InitAsDefaultInstance() {
}
class Ext4BeginOrderedTruncateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4BeginOrderedTruncateFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
}
Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(const Ext4BeginOrderedTruncateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&new_size_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(new_size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
}

void Ext4BeginOrderedTruncateFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&new_size_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(new_size_));
}

Ext4BeginOrderedTruncateFtraceEvent::~Ext4BeginOrderedTruncateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  SharedDtor();
}

void Ext4BeginOrderedTruncateFtraceEvent::SharedDtor() {
}

void Ext4BeginOrderedTruncateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4BeginOrderedTruncateFtraceEvent& Ext4BeginOrderedTruncateFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4BeginOrderedTruncateFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4BeginOrderedTruncateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&new_size_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(new_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4BeginOrderedTruncateFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 new_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_new_size(&has_bits);
          new_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4BeginOrderedTruncateFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 new_size = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_new_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &new_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4BeginOrderedTruncateFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 new_size = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->new_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
}

size_t Ext4BeginOrderedTruncateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 new_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->new_size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4BeginOrderedTruncateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4BeginOrderedTruncateFtraceEvent*>(
      &from));
}

void Ext4BeginOrderedTruncateFtraceEvent::MergeFrom(const Ext4BeginOrderedTruncateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      new_size_ = from.new_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4BeginOrderedTruncateFtraceEvent::CopyFrom(const Ext4BeginOrderedTruncateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4BeginOrderedTruncateFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4BeginOrderedTruncateFtraceEvent::InternalSwap(Ext4BeginOrderedTruncateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(new_size_, other->new_size_);
}

std::string Ext4BeginOrderedTruncateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent";
}


// ===================================================================

void Ext4CollapseRangeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4CollapseRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4CollapseRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
}
Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(const Ext4CollapseRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
}

void Ext4CollapseRangeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4CollapseRangeFtraceEvent::~Ext4CollapseRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  SharedDtor();
}

void Ext4CollapseRangeFtraceEvent::SharedDtor() {
}

void Ext4CollapseRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4CollapseRangeFtraceEvent& Ext4CollapseRangeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4CollapseRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4CollapseRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4CollapseRangeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4CollapseRangeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 offset = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4CollapseRangeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->offset(), output);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4CollapseRangeFtraceEvent)
}

size_t Ext4CollapseRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4CollapseRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4CollapseRangeFtraceEvent*>(
      &from));
}

void Ext4CollapseRangeFtraceEvent::MergeFrom(const Ext4CollapseRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4CollapseRangeFtraceEvent::CopyFrom(const Ext4CollapseRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4CollapseRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4CollapseRangeFtraceEvent::InternalSwap(Ext4CollapseRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(offset_, other->offset_);
  swap(len_, other->len_);
}

std::string Ext4CollapseRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4CollapseRangeFtraceEvent";
}


// ===================================================================

void Ext4DaReleaseSpaceFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DaReleaseSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaReleaseSpaceFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_freed_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
}
Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(const Ext4DaReleaseSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
}

void Ext4DaReleaseSpaceFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4DaReleaseSpaceFtraceEvent::~Ext4DaReleaseSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  SharedDtor();
}

void Ext4DaReleaseSpaceFtraceEvent::SharedDtor() {
}

void Ext4DaReleaseSpaceFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DaReleaseSpaceFtraceEvent& Ext4DaReleaseSpaceFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DaReleaseSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DaReleaseSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DaReleaseSpaceFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 freed_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_freed_blocks(&has_bits);
          freed_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 reserved_data_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 reserved_meta_blocks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 allocated_meta_blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_allocated_meta_blocks(&has_bits);
          allocated_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DaReleaseSpaceFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 i_blocks = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_i_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &i_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 freed_blocks = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_freed_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &freed_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 reserved_data_blocks = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_reserved_data_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_data_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 reserved_meta_blocks = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_reserved_meta_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_meta_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 allocated_meta_blocks = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_allocated_meta_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &allocated_meta_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DaReleaseSpaceFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->i_blocks(), output);
  }

  // optional int32 freed_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->freed_blocks(), output);
  }

  // optional int32 reserved_data_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->reserved_data_blocks(), output);
  }

  // optional int32 reserved_meta_blocks = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->reserved_meta_blocks(), output);
  }

  // optional int32 allocated_meta_blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->allocated_meta_blocks(), output);
  }

  // optional uint32 mode = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
}

size_t Ext4DaReleaseSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->i_blocks());
    }

    // optional int32 freed_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->freed_blocks());
    }

    // optional int32 reserved_data_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->reserved_meta_blocks());
    }

    // optional int32 allocated_meta_blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->allocated_meta_blocks());
    }

    // optional uint32 mode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaReleaseSpaceFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DaReleaseSpaceFtraceEvent*>(
      &from));
}

void Ext4DaReleaseSpaceFtraceEvent::MergeFrom(const Ext4DaReleaseSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      i_blocks_ = from.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      freed_blocks_ = from.freed_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      reserved_data_blocks_ = from.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      reserved_meta_blocks_ = from.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000040u) {
      allocated_meta_blocks_ = from.allocated_meta_blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DaReleaseSpaceFtraceEvent::CopyFrom(const Ext4DaReleaseSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaReleaseSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaReleaseSpaceFtraceEvent::InternalSwap(Ext4DaReleaseSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(i_blocks_, other->i_blocks_);
  swap(freed_blocks_, other->freed_blocks_);
  swap(reserved_data_blocks_, other->reserved_data_blocks_);
  swap(reserved_meta_blocks_, other->reserved_meta_blocks_);
  swap(allocated_meta_blocks_, other->allocated_meta_blocks_);
  swap(mode_, other->mode_);
}

std::string Ext4DaReleaseSpaceFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaReleaseSpaceFtraceEvent";
}


// ===================================================================

void Ext4DaReserveSpaceFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DaReserveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaReserveSpaceFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_md_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
}
Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(const Ext4DaReserveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&md_needed_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(md_needed_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
}

void Ext4DaReserveSpaceFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&md_needed_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(md_needed_));
}

Ext4DaReserveSpaceFtraceEvent::~Ext4DaReserveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  SharedDtor();
}

void Ext4DaReserveSpaceFtraceEvent::SharedDtor() {
}

void Ext4DaReserveSpaceFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DaReserveSpaceFtraceEvent& Ext4DaReserveSpaceFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DaReserveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DaReserveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&md_needed_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(md_needed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DaReserveSpaceFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 reserved_data_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 reserved_meta_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 md_needed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_md_needed(&has_bits);
          md_needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DaReserveSpaceFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 i_blocks = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_i_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &i_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 reserved_data_blocks = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_reserved_data_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_data_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 reserved_meta_blocks = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_reserved_meta_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_meta_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 md_needed = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_md_needed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &md_needed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DaReserveSpaceFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->i_blocks(), output);
  }

  // optional int32 reserved_data_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->reserved_data_blocks(), output);
  }

  // optional int32 reserved_meta_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->reserved_meta_blocks(), output);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->mode(), output);
  }

  // optional int32 md_needed = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->md_needed(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
}

size_t Ext4DaReserveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->i_blocks());
    }

    // optional int32 reserved_data_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->reserved_meta_blocks());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

    // optional int32 md_needed = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->md_needed());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaReserveSpaceFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DaReserveSpaceFtraceEvent*>(
      &from));
}

void Ext4DaReserveSpaceFtraceEvent::MergeFrom(const Ext4DaReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      i_blocks_ = from.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      reserved_data_blocks_ = from.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      reserved_meta_blocks_ = from.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000040u) {
      md_needed_ = from.md_needed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DaReserveSpaceFtraceEvent::CopyFrom(const Ext4DaReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaReserveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaReserveSpaceFtraceEvent::InternalSwap(Ext4DaReserveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(i_blocks_, other->i_blocks_);
  swap(reserved_data_blocks_, other->reserved_data_blocks_);
  swap(reserved_meta_blocks_, other->reserved_meta_blocks_);
  swap(mode_, other->mode_);
  swap(md_needed_, other->md_needed_);
}

std::string Ext4DaReserveSpaceFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaReserveSpaceFtraceEvent";
}


// ===================================================================

void Ext4DaUpdateReserveSpaceFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DaUpdateReserveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaUpdateReserveSpaceFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_used_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_quota_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
}
Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(const Ext4DaUpdateReserveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
}

void Ext4DaUpdateReserveSpaceFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4DaUpdateReserveSpaceFtraceEvent::~Ext4DaUpdateReserveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  SharedDtor();
}

void Ext4DaUpdateReserveSpaceFtraceEvent::SharedDtor() {
}

void Ext4DaUpdateReserveSpaceFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DaUpdateReserveSpaceFtraceEvent& Ext4DaUpdateReserveSpaceFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DaUpdateReserveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DaUpdateReserveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&quota_claim_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(quota_claim_));
  }
  mode_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DaUpdateReserveSpaceFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 used_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_used_blocks(&has_bits);
          used_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 reserved_data_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 reserved_meta_blocks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 allocated_meta_blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_allocated_meta_blocks(&has_bits);
          allocated_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 quota_claim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_quota_claim(&has_bits);
          quota_claim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DaUpdateReserveSpaceFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 i_blocks = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_i_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &i_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 used_blocks = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_used_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &used_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 reserved_data_blocks = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_reserved_data_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_data_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 reserved_meta_blocks = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_reserved_meta_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_meta_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 allocated_meta_blocks = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_allocated_meta_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &allocated_meta_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 quota_claim = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_quota_claim(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &quota_claim_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DaUpdateReserveSpaceFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->i_blocks(), output);
  }

  // optional int32 used_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->used_blocks(), output);
  }

  // optional int32 reserved_data_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->reserved_data_blocks(), output);
  }

  // optional int32 reserved_meta_blocks = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->reserved_meta_blocks(), output);
  }

  // optional int32 allocated_meta_blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->allocated_meta_blocks(), output);
  }

  // optional int32 quota_claim = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->quota_claim(), output);
  }

  // optional uint32 mode = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
}

size_t Ext4DaUpdateReserveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->i_blocks());
    }

    // optional int32 used_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->used_blocks());
    }

    // optional int32 reserved_data_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->reserved_meta_blocks());
    }

    // optional int32 allocated_meta_blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->allocated_meta_blocks());
    }

    // optional int32 quota_claim = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->quota_claim());
    }

  }
  // optional uint32 mode = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->mode());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaUpdateReserveSpaceFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DaUpdateReserveSpaceFtraceEvent*>(
      &from));
}

void Ext4DaUpdateReserveSpaceFtraceEvent::MergeFrom(const Ext4DaUpdateReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      i_blocks_ = from.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      used_blocks_ = from.used_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      reserved_data_blocks_ = from.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      reserved_meta_blocks_ = from.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000040u) {
      allocated_meta_blocks_ = from.allocated_meta_blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      quota_claim_ = from.quota_claim_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_mode(from.mode());
  }
}

void Ext4DaUpdateReserveSpaceFtraceEvent::CopyFrom(const Ext4DaUpdateReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaUpdateReserveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaUpdateReserveSpaceFtraceEvent::InternalSwap(Ext4DaUpdateReserveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(i_blocks_, other->i_blocks_);
  swap(used_blocks_, other->used_blocks_);
  swap(reserved_data_blocks_, other->reserved_data_blocks_);
  swap(reserved_meta_blocks_, other->reserved_meta_blocks_);
  swap(allocated_meta_blocks_, other->allocated_meta_blocks_);
  swap(quota_claim_, other->quota_claim_);
  swap(mode_, other->mode_);
}

std::string Ext4DaUpdateReserveSpaceFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent";
}


// ===================================================================

void Ext4DaWritePagesFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DaWritePagesFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWritePagesFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_first_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nr_to_write(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_b_blocknr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_b_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_b_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_io_done(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pages_written(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
}
Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(const Ext4DaWritePagesFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pages_written_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pages_written_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
}

void Ext4DaWritePagesFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pages_written_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(pages_written_));
}

Ext4DaWritePagesFtraceEvent::~Ext4DaWritePagesFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  SharedDtor();
}

void Ext4DaWritePagesFtraceEvent::SharedDtor() {
}

void Ext4DaWritePagesFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DaWritePagesFtraceEvent& Ext4DaWritePagesFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DaWritePagesFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DaWritePagesFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&b_state_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(b_state_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&io_done_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pages_written_) -
        reinterpret_cast<char*>(&io_done_)) + sizeof(pages_written_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DaWritePagesFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 first_page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_first_page(&has_bits);
          first_page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 nr_to_write = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_nr_to_write(&has_bits);
          nr_to_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 sync_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_sync_mode(&has_bits);
          sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 b_blocknr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_b_blocknr(&has_bits);
          b_blocknr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 b_size = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_b_size(&has_bits);
          b_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 b_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_b_state(&has_bits);
          b_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 io_done = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_io_done(&has_bits);
          io_done_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pages_written = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_pages_written(&has_bits);
          pages_written_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DaWritePagesFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 first_page = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_first_page(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &first_page_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 nr_to_write = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_nr_to_write(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &nr_to_write_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sync_mode = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_sync_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &sync_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 b_blocknr = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_b_blocknr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &b_blocknr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 b_size = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_b_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &b_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 b_state = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_b_state(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &b_state_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 io_done = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_io_done(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &io_done_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pages_written = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_pages_written(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pages_written_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DaWritePagesFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 first_page = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->first_page(), output);
  }

  // optional int64 nr_to_write = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->nr_to_write(), output);
  }

  // optional int32 sync_mode = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->sync_mode(), output);
  }

  // optional uint64 b_blocknr = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->b_blocknr(), output);
  }

  // optional uint32 b_size = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->b_size(), output);
  }

  // optional uint32 b_state = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->b_state(), output);
  }

  // optional int32 io_done = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(9, this->io_done(), output);
  }

  // optional int32 pages_written = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(10, this->pages_written(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DaWritePagesFtraceEvent)
}

size_t Ext4DaWritePagesFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 first_page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->first_page());
    }

    // optional int64 nr_to_write = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->nr_to_write());
    }

    // optional uint64 b_blocknr = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->b_blocknr());
    }

    // optional int32 sync_mode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->sync_mode());
    }

    // optional uint32 b_size = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->b_size());
    }

    // optional uint32 b_state = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->b_state());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 io_done = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->io_done());
    }

    // optional int32 pages_written = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pages_written());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaWritePagesFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DaWritePagesFtraceEvent*>(
      &from));
}

void Ext4DaWritePagesFtraceEvent::MergeFrom(const Ext4DaWritePagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      first_page_ = from.first_page_;
    }
    if (cached_has_bits & 0x00000008u) {
      nr_to_write_ = from.nr_to_write_;
    }
    if (cached_has_bits & 0x00000010u) {
      b_blocknr_ = from.b_blocknr_;
    }
    if (cached_has_bits & 0x00000020u) {
      sync_mode_ = from.sync_mode_;
    }
    if (cached_has_bits & 0x00000040u) {
      b_size_ = from.b_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      b_state_ = from.b_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      io_done_ = from.io_done_;
    }
    if (cached_has_bits & 0x00000200u) {
      pages_written_ = from.pages_written_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DaWritePagesFtraceEvent::CopyFrom(const Ext4DaWritePagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWritePagesFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWritePagesFtraceEvent::InternalSwap(Ext4DaWritePagesFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(first_page_, other->first_page_);
  swap(nr_to_write_, other->nr_to_write_);
  swap(b_blocknr_, other->b_blocknr_);
  swap(sync_mode_, other->sync_mode_);
  swap(b_size_, other->b_size_);
  swap(b_state_, other->b_state_);
  swap(io_done_, other->io_done_);
  swap(pages_written_, other->pages_written_);
}

std::string Ext4DaWritePagesFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaWritePagesFtraceEvent";
}


// ===================================================================

void Ext4DaWritePagesExtentFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DaWritePagesExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWritePagesExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
}
Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(const Ext4DaWritePagesExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
}

void Ext4DaWritePagesExtentFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4DaWritePagesExtentFtraceEvent::~Ext4DaWritePagesExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  SharedDtor();
}

void Ext4DaWritePagesExtentFtraceEvent::SharedDtor() {
}

void Ext4DaWritePagesExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DaWritePagesExtentFtraceEvent& Ext4DaWritePagesExtentFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DaWritePagesExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DaWritePagesExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DaWritePagesExtentFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DaWritePagesExtentFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DaWritePagesExtentFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->flags(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
}

size_t Ext4DaWritePagesExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaWritePagesExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DaWritePagesExtentFtraceEvent*>(
      &from));
}

void Ext4DaWritePagesExtentFtraceEvent::MergeFrom(const Ext4DaWritePagesExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DaWritePagesExtentFtraceEvent::CopyFrom(const Ext4DaWritePagesExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWritePagesExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWritePagesExtentFtraceEvent::InternalSwap(Ext4DaWritePagesExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(flags_, other->flags_);
}

std::string Ext4DaWritePagesExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaWritePagesExtentFtraceEvent";
}


// ===================================================================

void Ext4DirectIOEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DirectIOEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DirectIOEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rw(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
}
Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(const Ext4DirectIOEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&rw_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(rw_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
}

void Ext4DirectIOEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rw_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(rw_));
}

Ext4DirectIOEnterFtraceEvent::~Ext4DirectIOEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  SharedDtor();
}

void Ext4DirectIOEnterFtraceEvent::SharedDtor() {
}

void Ext4DirectIOEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DirectIOEnterFtraceEvent& Ext4DirectIOEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DirectIOEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DirectIOEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rw_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(rw_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DirectIOEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 rw = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_rw(&has_bits);
          rw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DirectIOEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 rw = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_rw(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &rw_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DirectIOEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->pos(), output);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->len(), output);
  }

  // optional int32 rw = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->rw(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
}

size_t Ext4DirectIOEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional int32 rw = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->rw());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DirectIOEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DirectIOEnterFtraceEvent*>(
      &from));
}

void Ext4DirectIOEnterFtraceEvent::MergeFrom(const Ext4DirectIOEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      rw_ = from.rw_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DirectIOEnterFtraceEvent::CopyFrom(const Ext4DirectIOEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DirectIOEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DirectIOEnterFtraceEvent::InternalSwap(Ext4DirectIOEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pos_, other->pos_);
  swap(len_, other->len_);
  swap(rw_, other->rw_);
}

std::string Ext4DirectIOEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DirectIOEnterFtraceEvent";
}


// ===================================================================

void Ext4DirectIOExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DirectIOExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DirectIOExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rw(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
}
Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(const Ext4DirectIOExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
}

void Ext4DirectIOExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ret_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4DirectIOExitFtraceEvent::~Ext4DirectIOExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  SharedDtor();
}

void Ext4DirectIOExitFtraceEvent::SharedDtor() {
}

void Ext4DirectIOExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DirectIOExitFtraceEvent& Ext4DirectIOExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DirectIOExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DirectIOExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DirectIOExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 rw = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_rw(&has_bits);
          rw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DirectIOExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 rw = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_rw(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &rw_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DirectIOExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->pos(), output);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->len(), output);
  }

  // optional int32 rw = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->rw(), output);
  }

  // optional int32 ret = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->ret(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DirectIOExitFtraceEvent)
}

size_t Ext4DirectIOExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional int32 rw = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->rw());
    }

    // optional int32 ret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DirectIOExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DirectIOExitFtraceEvent*>(
      &from));
}

void Ext4DirectIOExitFtraceEvent::MergeFrom(const Ext4DirectIOExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      rw_ = from.rw_;
    }
    if (cached_has_bits & 0x00000020u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DirectIOExitFtraceEvent::CopyFrom(const Ext4DirectIOExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DirectIOExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DirectIOExitFtraceEvent::InternalSwap(Ext4DirectIOExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pos_, other->pos_);
  swap(len_, other->len_);
  swap(rw_, other->rw_);
  swap(ret_, other->ret_);
}

std::string Ext4DirectIOExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DirectIOExitFtraceEvent";
}


// ===================================================================

void Ext4DiscardBlocksFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DiscardBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DiscardBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
}
Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(const Ext4DiscardBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
}

void Ext4DiscardBlocksFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(count_));
}

Ext4DiscardBlocksFtraceEvent::~Ext4DiscardBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  SharedDtor();
}

void Ext4DiscardBlocksFtraceEvent::SharedDtor() {
}

void Ext4DiscardBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DiscardBlocksFtraceEvent& Ext4DiscardBlocksFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DiscardBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DiscardBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DiscardBlocksFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 blk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_blk(&has_bits);
          blk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DiscardBlocksFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 blk = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_blk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 count = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DiscardBlocksFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 blk = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->blk(), output);
  }

  // optional uint64 count = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->count(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
}

size_t Ext4DiscardBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 blk = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->blk());
    }

    // optional uint64 count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->count());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DiscardBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DiscardBlocksFtraceEvent*>(
      &from));
}

void Ext4DiscardBlocksFtraceEvent::MergeFrom(const Ext4DiscardBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      blk_ = from.blk_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DiscardBlocksFtraceEvent::CopyFrom(const Ext4DiscardBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DiscardBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DiscardBlocksFtraceEvent::InternalSwap(Ext4DiscardBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(blk_, other->blk_);
  swap(count_, other->count_);
}

std::string Ext4DiscardBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DiscardBlocksFtraceEvent";
}


// ===================================================================

void Ext4DiscardPreallocationsFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DiscardPreallocationsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DiscardPreallocationsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
}
Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(const Ext4DiscardPreallocationsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ino_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
}

void Ext4DiscardPreallocationsFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ino_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
}

Ext4DiscardPreallocationsFtraceEvent::~Ext4DiscardPreallocationsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  SharedDtor();
}

void Ext4DiscardPreallocationsFtraceEvent::SharedDtor() {
}

void Ext4DiscardPreallocationsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DiscardPreallocationsFtraceEvent& Ext4DiscardPreallocationsFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DiscardPreallocationsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DiscardPreallocationsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ino_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DiscardPreallocationsFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DiscardPreallocationsFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DiscardPreallocationsFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
}

size_t Ext4DiscardPreallocationsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DiscardPreallocationsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DiscardPreallocationsFtraceEvent*>(
      &from));
}

void Ext4DiscardPreallocationsFtraceEvent::MergeFrom(const Ext4DiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DiscardPreallocationsFtraceEvent::CopyFrom(const Ext4DiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DiscardPreallocationsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DiscardPreallocationsFtraceEvent::InternalSwap(Ext4DiscardPreallocationsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
}

std::string Ext4DiscardPreallocationsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DiscardPreallocationsFtraceEvent";
}


// ===================================================================

void Ext4DropInodeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4DropInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DropInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_drop(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4DropInodeFtraceEvent)
}
Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(const Ext4DropInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&drop_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(drop_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DropInodeFtraceEvent)
}

void Ext4DropInodeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&drop_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(drop_));
}

Ext4DropInodeFtraceEvent::~Ext4DropInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DropInodeFtraceEvent)
  SharedDtor();
}

void Ext4DropInodeFtraceEvent::SharedDtor() {
}

void Ext4DropInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4DropInodeFtraceEvent& Ext4DropInodeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4DropInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4DropInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&drop_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(drop_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4DropInodeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 drop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_drop(&has_bits);
          drop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4DropInodeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 drop = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_drop(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &drop_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4DropInodeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4DropInodeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4DropInodeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int32 drop = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->drop(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4DropInodeFtraceEvent)
}

size_t Ext4DropInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int32 drop = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->drop());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DropInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4DropInodeFtraceEvent*>(
      &from));
}

void Ext4DropInodeFtraceEvent::MergeFrom(const Ext4DropInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      drop_ = from.drop_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4DropInodeFtraceEvent::CopyFrom(const Ext4DropInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DropInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DropInodeFtraceEvent::InternalSwap(Ext4DropInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(drop_, other->drop_);
}

std::string Ext4DropInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DropInodeFtraceEvent";
}


// ===================================================================

void Ext4EsCacheExtentFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsCacheExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsCacheExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
}
Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(const Ext4EsCacheExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
}

void Ext4EsCacheExtentFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(status_));
}

Ext4EsCacheExtentFtraceEvent::~Ext4EsCacheExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  SharedDtor();
}

void Ext4EsCacheExtentFtraceEvent::SharedDtor() {
}

void Ext4EsCacheExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsCacheExtentFtraceEvent& Ext4EsCacheExtentFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsCacheExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsCacheExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsCacheExtentFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsCacheExtentFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsCacheExtentFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->pblk(), output);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->status(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
}

size_t Ext4EsCacheExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint32 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->status());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsCacheExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsCacheExtentFtraceEvent*>(
      &from));
}

void Ext4EsCacheExtentFtraceEvent::MergeFrom(const Ext4EsCacheExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsCacheExtentFtraceEvent::CopyFrom(const Ext4EsCacheExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsCacheExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsCacheExtentFtraceEvent::InternalSwap(Ext4EsCacheExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(pblk_, other->pblk_);
  swap(status_, other->status_);
}

std::string Ext4EsCacheExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsCacheExtentFtraceEvent";
}


// ===================================================================

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsFindDelayedExtentRangeEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
}
Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lblk_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
}

Ext4EsFindDelayedExtentRangeEnterFtraceEvent::~Ext4EsFindDelayedExtentRangeEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  SharedDtor();
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SharedDtor() {
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& Ext4EsFindDelayedExtentRangeEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsFindDelayedExtentRangeEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsFindDelayedExtentRangeEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
}

size_t Ext4EsFindDelayedExtentRangeEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsFindDelayedExtentRangeEnterFtraceEvent*>(
      &from));
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::MergeFrom(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::CopyFrom(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsFindDelayedExtentRangeEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::InternalSwap(Ext4EsFindDelayedExtentRangeEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
}

std::string Ext4EsFindDelayedExtentRangeEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent";
}


// ===================================================================

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsFindDelayedExtentRangeExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsFindDelayedExtentRangeExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
}
Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(status_));
}

Ext4EsFindDelayedExtentRangeExitFtraceEvent::~Ext4EsFindDelayedExtentRangeExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  SharedDtor();
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SharedDtor() {
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsFindDelayedExtentRangeExitFtraceEvent& Ext4EsFindDelayedExtentRangeExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsFindDelayedExtentRangeExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsFindDelayedExtentRangeExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsFindDelayedExtentRangeExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsFindDelayedExtentRangeExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->pblk(), output);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->status(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
}

size_t Ext4EsFindDelayedExtentRangeExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->status());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsFindDelayedExtentRangeExitFtraceEvent*>(
      &from));
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::MergeFrom(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::CopyFrom(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsFindDelayedExtentRangeExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::InternalSwap(Ext4EsFindDelayedExtentRangeExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(pblk_, other->pblk_);
  swap(status_, other->status_);
}

std::string Ext4EsFindDelayedExtentRangeExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent";
}


// ===================================================================

void Ext4EsInsertExtentFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsInsertExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsInsertExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
}
Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(const Ext4EsInsertExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
}

void Ext4EsInsertExtentFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(status_));
}

Ext4EsInsertExtentFtraceEvent::~Ext4EsInsertExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  SharedDtor();
}

void Ext4EsInsertExtentFtraceEvent::SharedDtor() {
}

void Ext4EsInsertExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsInsertExtentFtraceEvent& Ext4EsInsertExtentFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsInsertExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsInsertExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsInsertExtentFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsInsertExtentFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsInsertExtentFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->pblk(), output);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->status(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
}

size_t Ext4EsInsertExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->status());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsInsertExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsInsertExtentFtraceEvent*>(
      &from));
}

void Ext4EsInsertExtentFtraceEvent::MergeFrom(const Ext4EsInsertExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsInsertExtentFtraceEvent::CopyFrom(const Ext4EsInsertExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsInsertExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsInsertExtentFtraceEvent::InternalSwap(Ext4EsInsertExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(pblk_, other->pblk_);
  swap(status_, other->status_);
}

std::string Ext4EsInsertExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsInsertExtentFtraceEvent";
}


// ===================================================================

void Ext4EsLookupExtentEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsLookupExtentEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsLookupExtentEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
}
Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(const Ext4EsLookupExtentEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
}

void Ext4EsLookupExtentEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lblk_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
}

Ext4EsLookupExtentEnterFtraceEvent::~Ext4EsLookupExtentEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  SharedDtor();
}

void Ext4EsLookupExtentEnterFtraceEvent::SharedDtor() {
}

void Ext4EsLookupExtentEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsLookupExtentEnterFtraceEvent& Ext4EsLookupExtentEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsLookupExtentEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsLookupExtentEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsLookupExtentEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsLookupExtentEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsLookupExtentEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
}

size_t Ext4EsLookupExtentEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsLookupExtentEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsLookupExtentEnterFtraceEvent*>(
      &from));
}

void Ext4EsLookupExtentEnterFtraceEvent::MergeFrom(const Ext4EsLookupExtentEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsLookupExtentEnterFtraceEvent::CopyFrom(const Ext4EsLookupExtentEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsLookupExtentEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsLookupExtentEnterFtraceEvent::InternalSwap(Ext4EsLookupExtentEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
}

std::string Ext4EsLookupExtentEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent";
}


// ===================================================================

void Ext4EsLookupExtentExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsLookupExtentExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsLookupExtentExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
}
Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(const Ext4EsLookupExtentExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&found_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(found_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
}

void Ext4EsLookupExtentExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&found_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(found_));
}

Ext4EsLookupExtentExitFtraceEvent::~Ext4EsLookupExtentExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  SharedDtor();
}

void Ext4EsLookupExtentExitFtraceEvent::SharedDtor() {
}

void Ext4EsLookupExtentExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsLookupExtentExitFtraceEvent& Ext4EsLookupExtentExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsLookupExtentExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsLookupExtentExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&found_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(found_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsLookupExtentExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 found = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_found(&has_bits);
          found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsLookupExtentExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 found = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_found(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &found_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsLookupExtentExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->pblk(), output);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->status(), output);
  }

  // optional int32 found = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->found(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
}

size_t Ext4EsLookupExtentExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->status());
    }

    // optional int32 found = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->found());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsLookupExtentExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsLookupExtentExitFtraceEvent*>(
      &from));
}

void Ext4EsLookupExtentExitFtraceEvent::MergeFrom(const Ext4EsLookupExtentExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000040u) {
      found_ = from.found_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsLookupExtentExitFtraceEvent::CopyFrom(const Ext4EsLookupExtentExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsLookupExtentExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsLookupExtentExitFtraceEvent::InternalSwap(Ext4EsLookupExtentExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(pblk_, other->pblk_);
  swap(status_, other->status_);
  swap(found_, other->found_);
}

std::string Ext4EsLookupExtentExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsLookupExtentExitFtraceEvent";
}


// ===================================================================

void Ext4EsRemoveExtentFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsRemoveExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsRemoveExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
}
Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(const Ext4EsRemoveExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
}

void Ext4EsRemoveExtentFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4EsRemoveExtentFtraceEvent::~Ext4EsRemoveExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  SharedDtor();
}

void Ext4EsRemoveExtentFtraceEvent::SharedDtor() {
}

void Ext4EsRemoveExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsRemoveExtentFtraceEvent& Ext4EsRemoveExtentFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsRemoveExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsRemoveExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsRemoveExtentFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsRemoveExtentFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsRemoveExtentFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->lblk(), output);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
}

size_t Ext4EsRemoveExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->lblk());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsRemoveExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsRemoveExtentFtraceEvent*>(
      &from));
}

void Ext4EsRemoveExtentFtraceEvent::MergeFrom(const Ext4EsRemoveExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsRemoveExtentFtraceEvent::CopyFrom(const Ext4EsRemoveExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsRemoveExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsRemoveExtentFtraceEvent::InternalSwap(Ext4EsRemoveExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
}

std::string Ext4EsRemoveExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsRemoveExtentFtraceEvent";
}


// ===================================================================

void Ext4EsShrinkFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsShrinkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_shrunk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_scan_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nr_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_retried(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
}
Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(const Ext4EsShrinkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&retried_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(retried_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
}

void Ext4EsShrinkFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&retried_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(retried_));
}

Ext4EsShrinkFtraceEvent::~Ext4EsShrinkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
  SharedDtor();
}

void Ext4EsShrinkFtraceEvent::SharedDtor() {
}

void Ext4EsShrinkFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsShrinkFtraceEvent& Ext4EsShrinkFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsShrinkFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsShrinkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&retried_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(retried_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsShrinkFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nr_shrunk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_nr_shrunk(&has_bits);
          nr_shrunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 scan_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_scan_time(&has_bits);
          scan_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nr_skipped = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_nr_skipped(&has_bits);
          nr_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 retried = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_retried(&has_bits);
          retried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsShrinkFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nr_shrunk = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_nr_shrunk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &nr_shrunk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 scan_time = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_scan_time(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &scan_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nr_skipped = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_nr_skipped(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &nr_skipped_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 retried = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_retried(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &retried_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsShrinkFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsShrinkFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsShrinkFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional int32 nr_shrunk = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->nr_shrunk(), output);
  }

  // optional uint64 scan_time = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->scan_time(), output);
  }

  // optional int32 nr_skipped = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->nr_skipped(), output);
  }

  // optional int32 retried = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->retried(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsShrinkFtraceEvent)
}

size_t Ext4EsShrinkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 scan_time = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->scan_time());
    }

    // optional int32 nr_shrunk = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->nr_shrunk());
    }

    // optional int32 nr_skipped = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->nr_skipped());
    }

    // optional int32 retried = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->retried());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsShrinkFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsShrinkFtraceEvent*>(
      &from));
}

void Ext4EsShrinkFtraceEvent::MergeFrom(const Ext4EsShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      scan_time_ = from.scan_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      nr_shrunk_ = from.nr_shrunk_;
    }
    if (cached_has_bits & 0x00000008u) {
      nr_skipped_ = from.nr_skipped_;
    }
    if (cached_has_bits & 0x00000010u) {
      retried_ = from.retried_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsShrinkFtraceEvent::CopyFrom(const Ext4EsShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkFtraceEvent::InternalSwap(Ext4EsShrinkFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(scan_time_, other->scan_time_);
  swap(nr_shrunk_, other->nr_shrunk_);
  swap(nr_skipped_, other->nr_skipped_);
  swap(retried_, other->retried_);
}

std::string Ext4EsShrinkFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsShrinkFtraceEvent";
}


// ===================================================================

void Ext4EsShrinkCountFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsShrinkCountFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkCountFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_to_scan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
}
Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(const Ext4EsShrinkCountFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
}

void Ext4EsShrinkCountFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cache_cnt_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
}

Ext4EsShrinkCountFtraceEvent::~Ext4EsShrinkCountFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  SharedDtor();
}

void Ext4EsShrinkCountFtraceEvent::SharedDtor() {
}

void Ext4EsShrinkCountFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsShrinkCountFtraceEvent& Ext4EsShrinkCountFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsShrinkCountFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsShrinkCountFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cache_cnt_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsShrinkCountFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nr_to_scan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_nr_to_scan(&has_bits);
          nr_to_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsShrinkCountFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nr_to_scan = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_nr_to_scan(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &nr_to_scan_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 cache_cnt = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_cache_cnt(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &cache_cnt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsShrinkCountFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional int32 nr_to_scan = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->nr_to_scan(), output);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->cache_cnt(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
}

size_t Ext4EsShrinkCountFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional int32 nr_to_scan = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->nr_to_scan());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->cache_cnt());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsShrinkCountFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsShrinkCountFtraceEvent*>(
      &from));
}

void Ext4EsShrinkCountFtraceEvent::MergeFrom(const Ext4EsShrinkCountFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      nr_to_scan_ = from.nr_to_scan_;
    }
    if (cached_has_bits & 0x00000004u) {
      cache_cnt_ = from.cache_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsShrinkCountFtraceEvent::CopyFrom(const Ext4EsShrinkCountFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkCountFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkCountFtraceEvent::InternalSwap(Ext4EsShrinkCountFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(nr_to_scan_, other->nr_to_scan_);
  swap(cache_cnt_, other->cache_cnt_);
}

std::string Ext4EsShrinkCountFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsShrinkCountFtraceEvent";
}


// ===================================================================

void Ext4EsShrinkScanEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsShrinkScanEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkScanEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_to_scan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
}
Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(const Ext4EsShrinkScanEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
}

void Ext4EsShrinkScanEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cache_cnt_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
}

Ext4EsShrinkScanEnterFtraceEvent::~Ext4EsShrinkScanEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  SharedDtor();
}

void Ext4EsShrinkScanEnterFtraceEvent::SharedDtor() {
}

void Ext4EsShrinkScanEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsShrinkScanEnterFtraceEvent& Ext4EsShrinkScanEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsShrinkScanEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsShrinkScanEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cache_cnt_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsShrinkScanEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nr_to_scan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_nr_to_scan(&has_bits);
          nr_to_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsShrinkScanEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nr_to_scan = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_nr_to_scan(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &nr_to_scan_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 cache_cnt = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_cache_cnt(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &cache_cnt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsShrinkScanEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional int32 nr_to_scan = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->nr_to_scan(), output);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->cache_cnt(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
}

size_t Ext4EsShrinkScanEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional int32 nr_to_scan = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->nr_to_scan());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->cache_cnt());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsShrinkScanEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsShrinkScanEnterFtraceEvent*>(
      &from));
}

void Ext4EsShrinkScanEnterFtraceEvent::MergeFrom(const Ext4EsShrinkScanEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      nr_to_scan_ = from.nr_to_scan_;
    }
    if (cached_has_bits & 0x00000004u) {
      cache_cnt_ = from.cache_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsShrinkScanEnterFtraceEvent::CopyFrom(const Ext4EsShrinkScanEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkScanEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkScanEnterFtraceEvent::InternalSwap(Ext4EsShrinkScanEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(nr_to_scan_, other->nr_to_scan_);
  swap(cache_cnt_, other->cache_cnt_);
}

std::string Ext4EsShrinkScanEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent";
}


// ===================================================================

void Ext4EsShrinkScanExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EsShrinkScanExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkScanExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_shrunk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
}
Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(const Ext4EsShrinkScanExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
}

void Ext4EsShrinkScanExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cache_cnt_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
}

Ext4EsShrinkScanExitFtraceEvent::~Ext4EsShrinkScanExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  SharedDtor();
}

void Ext4EsShrinkScanExitFtraceEvent::SharedDtor() {
}

void Ext4EsShrinkScanExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EsShrinkScanExitFtraceEvent& Ext4EsShrinkScanExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EsShrinkScanExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EsShrinkScanExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cache_cnt_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EsShrinkScanExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nr_shrunk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_nr_shrunk(&has_bits);
          nr_shrunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EsShrinkScanExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nr_shrunk = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_nr_shrunk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &nr_shrunk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 cache_cnt = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_cache_cnt(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &cache_cnt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EsShrinkScanExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional int32 nr_shrunk = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->nr_shrunk(), output);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->cache_cnt(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
}

size_t Ext4EsShrinkScanExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional int32 nr_shrunk = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->nr_shrunk());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->cache_cnt());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsShrinkScanExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EsShrinkScanExitFtraceEvent*>(
      &from));
}

void Ext4EsShrinkScanExitFtraceEvent::MergeFrom(const Ext4EsShrinkScanExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      nr_shrunk_ = from.nr_shrunk_;
    }
    if (cached_has_bits & 0x00000004u) {
      cache_cnt_ = from.cache_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EsShrinkScanExitFtraceEvent::CopyFrom(const Ext4EsShrinkScanExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkScanExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkScanExitFtraceEvent::InternalSwap(Ext4EsShrinkScanExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(nr_shrunk_, other->nr_shrunk_);
  swap(cache_cnt_, other->cache_cnt_);
}

std::string Ext4EsShrinkScanExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsShrinkScanExitFtraceEvent";
}


// ===================================================================

void Ext4EvictInodeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4EvictInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EvictInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
}
Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(const Ext4EvictInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&nlink_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(nlink_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
}

void Ext4EvictInodeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nlink_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(nlink_));
}

Ext4EvictInodeFtraceEvent::~Ext4EvictInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
  SharedDtor();
}

void Ext4EvictInodeFtraceEvent::SharedDtor() {
}

void Ext4EvictInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4EvictInodeFtraceEvent& Ext4EvictInodeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4EvictInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4EvictInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nlink_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(nlink_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4EvictInodeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nlink = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_nlink(&has_bits);
          nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4EvictInodeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nlink = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_nlink(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &nlink_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4EvictInodeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4EvictInodeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4EvictInodeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int32 nlink = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->nlink(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4EvictInodeFtraceEvent)
}

size_t Ext4EvictInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int32 nlink = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->nlink());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EvictInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4EvictInodeFtraceEvent*>(
      &from));
}

void Ext4EvictInodeFtraceEvent::MergeFrom(const Ext4EvictInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      nlink_ = from.nlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4EvictInodeFtraceEvent::CopyFrom(const Ext4EvictInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EvictInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EvictInodeFtraceEvent::InternalSwap(Ext4EvictInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(nlink_, other->nlink_);
}

std::string Ext4EvictInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EvictInodeFtraceEvent";
}


// ===================================================================

void Ext4ExtConvertToInitializedEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtConvertToInitializedEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtConvertToInitializedEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_u_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_u_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_u_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
}
Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(const Ext4ExtConvertToInitializedEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&u_pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(u_pblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&u_pblk_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(u_pblk_));
}

Ext4ExtConvertToInitializedEnterFtraceEvent::~Ext4ExtConvertToInitializedEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  SharedDtor();
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::SharedDtor() {
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtConvertToInitializedEnterFtraceEvent& Ext4ExtConvertToInitializedEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtConvertToInitializedEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtConvertToInitializedEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&u_pblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(u_pblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtConvertToInitializedEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 m_lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_m_lblk(&has_bits);
          m_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 m_len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_m_len(&has_bits);
          m_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 u_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_u_lblk(&has_bits);
          u_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 u_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_u_len(&has_bits);
          u_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 u_pblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_u_pblk(&has_bits);
          u_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtConvertToInitializedEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 m_lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_m_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 m_len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_m_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 u_lblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_u_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &u_lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 u_len = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_u_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &u_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 u_pblk = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_u_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &u_pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtConvertToInitializedEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 m_lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->m_lblk(), output);
  }

  // optional uint32 m_len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->m_len(), output);
  }

  // optional uint32 u_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->u_lblk(), output);
  }

  // optional uint32 u_len = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->u_len(), output);
  }

  // optional uint64 u_pblk = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(7, this->u_pblk(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
}

size_t Ext4ExtConvertToInitializedEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 m_lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->m_lblk());
    }

    // optional uint32 m_len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->m_len());
    }

    // optional uint32 u_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->u_lblk());
    }

    // optional uint32 u_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->u_len());
    }

    // optional uint64 u_pblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->u_pblk());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtConvertToInitializedEnterFtraceEvent*>(
      &from));
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::MergeFrom(const Ext4ExtConvertToInitializedEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      m_lblk_ = from.m_lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      m_len_ = from.m_len_;
    }
    if (cached_has_bits & 0x00000010u) {
      u_lblk_ = from.u_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      u_len_ = from.u_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      u_pblk_ = from.u_pblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::CopyFrom(const Ext4ExtConvertToInitializedEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtConvertToInitializedEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::InternalSwap(Ext4ExtConvertToInitializedEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(m_lblk_, other->m_lblk_);
  swap(m_len_, other->m_len_);
  swap(u_lblk_, other->u_lblk_);
  swap(u_len_, other->u_len_);
  swap(u_pblk_, other->u_pblk_);
}

std::string Ext4ExtConvertToInitializedEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent";
}


// ===================================================================

void Ext4ExtConvertToInitializedFastpathFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtConvertToInitializedFastpathFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtConvertToInitializedFastpathFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_u_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_u_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_u_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_i_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_i_len(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_i_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
}
Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(const Ext4ExtConvertToInitializedFastpathFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&i_pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(i_pblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&i_pblk_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(i_pblk_));
}

Ext4ExtConvertToInitializedFastpathFtraceEvent::~Ext4ExtConvertToInitializedFastpathFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  SharedDtor();
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::SharedDtor() {
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtConvertToInitializedFastpathFtraceEvent& Ext4ExtConvertToInitializedFastpathFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtConvertToInitializedFastpathFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtConvertToInitializedFastpathFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&i_lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(i_lblk_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&i_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&i_pblk_) -
        reinterpret_cast<char*>(&i_len_)) + sizeof(i_pblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtConvertToInitializedFastpathFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 m_lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_m_lblk(&has_bits);
          m_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 m_len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_m_len(&has_bits);
          m_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 u_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_u_lblk(&has_bits);
          u_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 u_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_u_len(&has_bits);
          u_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 u_pblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_u_pblk(&has_bits);
          u_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 i_lblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_i_lblk(&has_bits);
          i_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 i_len = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_i_len(&has_bits);
          i_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 i_pblk = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_i_pblk(&has_bits);
          i_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtConvertToInitializedFastpathFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 m_lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_m_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 m_len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_m_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 u_lblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_u_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &u_lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 u_len = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_u_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &u_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 u_pblk = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_u_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &u_pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 i_lblk = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_i_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &i_lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 i_len = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_i_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &i_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 i_pblk = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_i_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &i_pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtConvertToInitializedFastpathFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 m_lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->m_lblk(), output);
  }

  // optional uint32 m_len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->m_len(), output);
  }

  // optional uint32 u_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->u_lblk(), output);
  }

  // optional uint32 u_len = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->u_len(), output);
  }

  // optional uint64 u_pblk = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(7, this->u_pblk(), output);
  }

  // optional uint32 i_lblk = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->i_lblk(), output);
  }

  // optional uint32 i_len = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->i_len(), output);
  }

  // optional uint64 i_pblk = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(10, this->i_pblk(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
}

size_t Ext4ExtConvertToInitializedFastpathFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 m_lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->m_lblk());
    }

    // optional uint32 m_len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->m_len());
    }

    // optional uint32 u_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->u_lblk());
    }

    // optional uint32 u_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->u_len());
    }

    // optional uint64 u_pblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->u_pblk());
    }

    // optional uint32 i_lblk = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->i_lblk());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 i_len = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->i_len());
    }

    // optional uint64 i_pblk = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->i_pblk());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtConvertToInitializedFastpathFtraceEvent*>(
      &from));
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::MergeFrom(const Ext4ExtConvertToInitializedFastpathFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      m_lblk_ = from.m_lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      m_len_ = from.m_len_;
    }
    if (cached_has_bits & 0x00000010u) {
      u_lblk_ = from.u_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      u_len_ = from.u_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      u_pblk_ = from.u_pblk_;
    }
    if (cached_has_bits & 0x00000080u) {
      i_lblk_ = from.i_lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      i_len_ = from.i_len_;
    }
    if (cached_has_bits & 0x00000200u) {
      i_pblk_ = from.i_pblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::CopyFrom(const Ext4ExtConvertToInitializedFastpathFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtConvertToInitializedFastpathFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::InternalSwap(Ext4ExtConvertToInitializedFastpathFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(m_lblk_, other->m_lblk_);
  swap(m_len_, other->m_len_);
  swap(u_lblk_, other->u_lblk_);
  swap(u_len_, other->u_len_);
  swap(u_pblk_, other->u_pblk_);
  swap(i_lblk_, other->i_lblk_);
  swap(i_len_, other->i_len_);
  swap(i_pblk_, other->i_pblk_);
}

std::string Ext4ExtConvertToInitializedFastpathFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent";
}


// ===================================================================

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtHandleUnwrittenExtentsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtHandleUnwrittenExtentsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_newblk(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
}
Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&newblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(newblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&newblk_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(newblk_));
}

Ext4ExtHandleUnwrittenExtentsFtraceEvent::~Ext4ExtHandleUnwrittenExtentsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  SharedDtor();
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SharedDtor() {
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtHandleUnwrittenExtentsFtraceEvent& Ext4ExtHandleUnwrittenExtentsFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtHandleUnwrittenExtentsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtHandleUnwrittenExtentsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&newblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(newblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtHandleUnwrittenExtentsFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 allocated = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_allocated(&has_bits);
          allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 newblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_newblk(&has_bits);
          newblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtHandleUnwrittenExtentsFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 flags = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 allocated = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_allocated(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &allocated_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 newblk = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_newblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &newblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int32 flags = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->flags(), output);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->lblk(), output);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->pblk(), output);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->len(), output);
  }

  // optional uint32 allocated = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->allocated(), output);
  }

  // optional uint64 newblk = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(8, this->newblk(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
}

size_t Ext4ExtHandleUnwrittenExtentsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int32 flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->flags());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 allocated = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->allocated());
    }

    // optional uint64 newblk = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->newblk());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtHandleUnwrittenExtentsFtraceEvent*>(
      &from));
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::MergeFrom(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      allocated_ = from.allocated_;
    }
    if (cached_has_bits & 0x00000080u) {
      newblk_ = from.newblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::CopyFrom(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtHandleUnwrittenExtentsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::InternalSwap(Ext4ExtHandleUnwrittenExtentsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(flags_, other->flags_);
  swap(lblk_, other->lblk_);
  swap(pblk_, other->pblk_);
  swap(len_, other->len_);
  swap(allocated_, other->allocated_);
  swap(newblk_, other->newblk_);
}

std::string Ext4ExtHandleUnwrittenExtentsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent";
}


// ===================================================================

void Ext4ExtInCacheFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtInCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtInCacheFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
}
Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(const Ext4ExtInCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
}

void Ext4ExtInCacheFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ret_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4ExtInCacheFtraceEvent::~Ext4ExtInCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  SharedDtor();
}

void Ext4ExtInCacheFtraceEvent::SharedDtor() {
}

void Ext4ExtInCacheFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtInCacheFtraceEvent& Ext4ExtInCacheFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtInCacheFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtInCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtInCacheFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtInCacheFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtInCacheFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional int32 ret = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->ret(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtInCacheFtraceEvent)
}

size_t Ext4ExtInCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional int32 ret = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtInCacheFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtInCacheFtraceEvent*>(
      &from));
}

void Ext4ExtInCacheFtraceEvent::MergeFrom(const Ext4ExtInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtInCacheFtraceEvent::CopyFrom(const Ext4ExtInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtInCacheFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtInCacheFtraceEvent::InternalSwap(Ext4ExtInCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(ret_, other->ret_);
}

std::string Ext4ExtInCacheFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtInCacheFtraceEvent";
}


// ===================================================================

void Ext4ExtLoadExtentFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtLoadExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtLoadExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
}
Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(const Ext4ExtLoadExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
}

void Ext4ExtLoadExtentFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lblk_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
}

Ext4ExtLoadExtentFtraceEvent::~Ext4ExtLoadExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  SharedDtor();
}

void Ext4ExtLoadExtentFtraceEvent::SharedDtor() {
}

void Ext4ExtLoadExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtLoadExtentFtraceEvent& Ext4ExtLoadExtentFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtLoadExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtLoadExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtLoadExtentFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtLoadExtentFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtLoadExtentFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pblk(), output);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->lblk(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
}

size_t Ext4ExtLoadExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtLoadExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtLoadExtentFtraceEvent*>(
      &from));
}

void Ext4ExtLoadExtentFtraceEvent::MergeFrom(const Ext4ExtLoadExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      lblk_ = from.lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtLoadExtentFtraceEvent::CopyFrom(const Ext4ExtLoadExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtLoadExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtLoadExtentFtraceEvent::InternalSwap(Ext4ExtLoadExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pblk_, other->pblk_);
  swap(lblk_, other->lblk_);
}

std::string Ext4ExtLoadExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtLoadExtentFtraceEvent";
}


// ===================================================================

void Ext4ExtMapBlocksEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtMapBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtMapBlocksEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
}
Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(const Ext4ExtMapBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
}

void Ext4ExtMapBlocksEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4ExtMapBlocksEnterFtraceEvent::~Ext4ExtMapBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  SharedDtor();
}

void Ext4ExtMapBlocksEnterFtraceEvent::SharedDtor() {
}

void Ext4ExtMapBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtMapBlocksEnterFtraceEvent& Ext4ExtMapBlocksEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtMapBlocksEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtMapBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtMapBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtMapBlocksEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtMapBlocksEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->flags(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
}

size_t Ext4ExtMapBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtMapBlocksEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtMapBlocksEnterFtraceEvent*>(
      &from));
}

void Ext4ExtMapBlocksEnterFtraceEvent::MergeFrom(const Ext4ExtMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtMapBlocksEnterFtraceEvent::CopyFrom(const Ext4ExtMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtMapBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtMapBlocksEnterFtraceEvent::InternalSwap(Ext4ExtMapBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(flags_, other->flags_);
}

std::string Ext4ExtMapBlocksEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent";
}


// ===================================================================

void Ext4ExtMapBlocksExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtMapBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtMapBlocksExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mflags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
}
Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(const Ext4ExtMapBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
}

void Ext4ExtMapBlocksExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ret_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4ExtMapBlocksExitFtraceEvent::~Ext4ExtMapBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  SharedDtor();
}

void Ext4ExtMapBlocksExitFtraceEvent::SharedDtor() {
}

void Ext4ExtMapBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtMapBlocksExitFtraceEvent& Ext4ExtMapBlocksExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtMapBlocksExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtMapBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtMapBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mflags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_mflags(&has_bits);
          mflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtMapBlocksExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mflags = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_mflags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mflags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtMapBlocksExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->flags(), output);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->pblk(), output);
  }

  // optional uint32 lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->lblk(), output);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->len(), output);
  }

  // optional uint32 mflags = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->mflags(), output);
  }

  // optional int32 ret = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->ret(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
}

size_t Ext4ExtMapBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 mflags = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mflags());
    }

    // optional int32 ret = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtMapBlocksExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtMapBlocksExitFtraceEvent*>(
      &from));
}

void Ext4ExtMapBlocksExitFtraceEvent::MergeFrom(const Ext4ExtMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      mflags_ = from.mflags_;
    }
    if (cached_has_bits & 0x00000080u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtMapBlocksExitFtraceEvent::CopyFrom(const Ext4ExtMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtMapBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtMapBlocksExitFtraceEvent::InternalSwap(Ext4ExtMapBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pblk_, other->pblk_);
  swap(flags_, other->flags_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(mflags_, other->mflags_);
  swap(ret_, other->ret_);
}

std::string Ext4ExtMapBlocksExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent";
}


// ===================================================================

void Ext4ExtPutInCacheFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtPutInCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtPutInCacheFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
}
Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(const Ext4ExtPutInCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&start_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(start_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
}

void Ext4ExtPutInCacheFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&start_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(start_));
}

Ext4ExtPutInCacheFtraceEvent::~Ext4ExtPutInCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  SharedDtor();
}

void Ext4ExtPutInCacheFtraceEvent::SharedDtor() {
}

void Ext4ExtPutInCacheFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtPutInCacheFtraceEvent& Ext4ExtPutInCacheFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtPutInCacheFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtPutInCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&start_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(start_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtPutInCacheFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtPutInCacheFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 start = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtPutInCacheFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint64 start = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->start(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
}

size_t Ext4ExtPutInCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint64 start = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->start());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtPutInCacheFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtPutInCacheFtraceEvent*>(
      &from));
}

void Ext4ExtPutInCacheFtraceEvent::MergeFrom(const Ext4ExtPutInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      start_ = from.start_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtPutInCacheFtraceEvent::CopyFrom(const Ext4ExtPutInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtPutInCacheFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtPutInCacheFtraceEvent::InternalSwap(Ext4ExtPutInCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(start_, other->start_);
}

std::string Ext4ExtPutInCacheFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtPutInCacheFtraceEvent";
}


// ===================================================================

void Ext4ExtRemoveSpaceFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtRemoveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRemoveSpaceFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
}
Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(const Ext4ExtRemoveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&depth_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(depth_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
}

void Ext4ExtRemoveSpaceFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&depth_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(depth_));
}

Ext4ExtRemoveSpaceFtraceEvent::~Ext4ExtRemoveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  SharedDtor();
}

void Ext4ExtRemoveSpaceFtraceEvent::SharedDtor() {
}

void Ext4ExtRemoveSpaceFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtRemoveSpaceFtraceEvent& Ext4ExtRemoveSpaceFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtRemoveSpaceFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtRemoveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&depth_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(depth_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtRemoveSpaceFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_end(&has_bits);
          end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 depth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtRemoveSpaceFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 start = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 end = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_end(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 depth = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_depth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &depth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtRemoveSpaceFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 start = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->start(), output);
  }

  // optional uint32 end = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->end(), output);
  }

  // optional int32 depth = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->depth(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
}

size_t Ext4ExtRemoveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->start());
    }

    // optional uint32 end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->end());
    }

    // optional int32 depth = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->depth());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtRemoveSpaceFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtRemoveSpaceFtraceEvent*>(
      &from));
}

void Ext4ExtRemoveSpaceFtraceEvent::MergeFrom(const Ext4ExtRemoveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000008u) {
      end_ = from.end_;
    }
    if (cached_has_bits & 0x00000010u) {
      depth_ = from.depth_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtRemoveSpaceFtraceEvent::CopyFrom(const Ext4ExtRemoveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRemoveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRemoveSpaceFtraceEvent::InternalSwap(Ext4ExtRemoveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(start_, other->start_);
  swap(end_, other->end_);
  swap(depth_, other->depth_);
}

std::string Ext4ExtRemoveSpaceFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent";
}


// ===================================================================

void Ext4ExtRemoveSpaceDoneFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtRemoveSpaceDoneFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRemoveSpaceDoneFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_eh_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
}
Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(const Ext4ExtRemoveSpaceDoneFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&eh_entries_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(eh_entries_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&eh_entries_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(eh_entries_));
}

Ext4ExtRemoveSpaceDoneFtraceEvent::~Ext4ExtRemoveSpaceDoneFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  SharedDtor();
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::SharedDtor() {
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtRemoveSpaceDoneFtraceEvent& Ext4ExtRemoveSpaceDoneFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtRemoveSpaceDoneFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtRemoveSpaceDoneFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&eh_entries_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(eh_entries_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtRemoveSpaceDoneFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_end(&has_bits);
          end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 depth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 partial = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_partial(&has_bits);
          partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 eh_entries = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_eh_entries(&has_bits);
          eh_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtRemoveSpaceDoneFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 start = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 end = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_end(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 depth = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_depth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &depth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 partial = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_partial(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &partial_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 eh_entries = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_eh_entries(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &eh_entries_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtRemoveSpaceDoneFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 start = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->start(), output);
  }

  // optional uint32 end = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->end(), output);
  }

  // optional int32 depth = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->depth(), output);
  }

  // optional int64 partial = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(6, this->partial(), output);
  }

  // optional uint32 eh_entries = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->eh_entries(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
}

size_t Ext4ExtRemoveSpaceDoneFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->start());
    }

    // optional uint32 end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->end());
    }

    // optional int64 partial = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->partial());
    }

    // optional int32 depth = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->depth());
    }

    // optional uint32 eh_entries = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->eh_entries());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtRemoveSpaceDoneFtraceEvent*>(
      &from));
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::MergeFrom(const Ext4ExtRemoveSpaceDoneFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000008u) {
      end_ = from.end_;
    }
    if (cached_has_bits & 0x00000010u) {
      partial_ = from.partial_;
    }
    if (cached_has_bits & 0x00000020u) {
      depth_ = from.depth_;
    }
    if (cached_has_bits & 0x00000040u) {
      eh_entries_ = from.eh_entries_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::CopyFrom(const Ext4ExtRemoveSpaceDoneFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRemoveSpaceDoneFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::InternalSwap(Ext4ExtRemoveSpaceDoneFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(start_, other->start_);
  swap(end_, other->end_);
  swap(partial_, other->partial_);
  swap(depth_, other->depth_);
  swap(eh_entries_, other->eh_entries_);
}

std::string Ext4ExtRemoveSpaceDoneFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent";
}


// ===================================================================

void Ext4ExtRmIdxFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtRmIdxFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRmIdxFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
}
Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(const Ext4ExtRmIdxFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
}

void Ext4ExtRmIdxFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pblk_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(pblk_));
}

Ext4ExtRmIdxFtraceEvent::~Ext4ExtRmIdxFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  SharedDtor();
}

void Ext4ExtRmIdxFtraceEvent::SharedDtor() {
}

void Ext4ExtRmIdxFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtRmIdxFtraceEvent& Ext4ExtRmIdxFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtRmIdxFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtRmIdxFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtRmIdxFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtRmIdxFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtRmIdxFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pblk(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
}

size_t Ext4ExtRmIdxFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtRmIdxFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtRmIdxFtraceEvent*>(
      &from));
}

void Ext4ExtRmIdxFtraceEvent::MergeFrom(const Ext4ExtRmIdxFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtRmIdxFtraceEvent::CopyFrom(const Ext4ExtRmIdxFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRmIdxFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRmIdxFtraceEvent::InternalSwap(Ext4ExtRmIdxFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pblk_, other->pblk_);
}

std::string Ext4ExtRmIdxFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtRmIdxFtraceEvent";
}


// ===================================================================

void Ext4ExtRmLeafFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtRmLeafFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRmLeafFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ee_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ee_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ee_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
}
Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(const Ext4ExtRmLeafFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ee_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ee_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
}

void Ext4ExtRmLeafFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ee_len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ee_len_));
}

Ext4ExtRmLeafFtraceEvent::~Ext4ExtRmLeafFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  SharedDtor();
}

void Ext4ExtRmLeafFtraceEvent::SharedDtor() {
}

void Ext4ExtRmLeafFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtRmLeafFtraceEvent& Ext4ExtRmLeafFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtRmLeafFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtRmLeafFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ee_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ee_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtRmLeafFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 partial = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_partial(&has_bits);
          partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ee_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ee_lblk(&has_bits);
          ee_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ee_pblk = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ee_pblk(&has_bits);
          ee_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ee_len = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_ee_len(&has_bits);
          ee_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtRmLeafFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 partial = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_partial(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &partial_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 start = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ee_lblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_ee_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ee_lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ee_pblk = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_ee_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ee_pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ee_len = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_ee_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ee_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtRmLeafFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 partial = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->partial(), output);
  }

  // optional uint32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->start(), output);
  }

  // optional uint32 ee_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->ee_lblk(), output);
  }

  // optional uint64 ee_pblk = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->ee_pblk(), output);
  }

  // optional int32 ee_len = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->ee_len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
}

size_t Ext4ExtRmLeafFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 partial = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->partial());
    }

    // optional uint32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->start());
    }

    // optional uint32 ee_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ee_lblk());
    }

    // optional uint64 ee_pblk = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ee_pblk());
    }

    // optional int32 ee_len = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ee_len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtRmLeafFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtRmLeafFtraceEvent*>(
      &from));
}

void Ext4ExtRmLeafFtraceEvent::MergeFrom(const Ext4ExtRmLeafFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      partial_ = from.partial_;
    }
    if (cached_has_bits & 0x00000008u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      ee_lblk_ = from.ee_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      ee_pblk_ = from.ee_pblk_;
    }
    if (cached_has_bits & 0x00000040u) {
      ee_len_ = from.ee_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtRmLeafFtraceEvent::CopyFrom(const Ext4ExtRmLeafFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRmLeafFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRmLeafFtraceEvent::InternalSwap(Ext4ExtRmLeafFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(partial_, other->partial_);
  swap(start_, other->start_);
  swap(ee_lblk_, other->ee_lblk_);
  swap(ee_pblk_, other->ee_pblk_);
  swap(ee_len_, other->ee_len_);
}

std::string Ext4ExtRmLeafFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtRmLeafFtraceEvent";
}


// ===================================================================

void Ext4ExtShowExtentFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ExtShowExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtShowExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
}
Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(const Ext4ExtShowExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
}

void Ext4ExtShowExtentFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4ExtShowExtentFtraceEvent::~Ext4ExtShowExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  SharedDtor();
}

void Ext4ExtShowExtentFtraceEvent::SharedDtor() {
}

void Ext4ExtShowExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ExtShowExtentFtraceEvent& Ext4ExtShowExtentFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ExtShowExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ExtShowExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ExtShowExtentFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ExtShowExtentFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ExtShowExtentFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pblk(), output);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->lblk(), output);
  }

  // optional uint32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
}

size_t Ext4ExtShowExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtShowExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ExtShowExtentFtraceEvent*>(
      &from));
}

void Ext4ExtShowExtentFtraceEvent::MergeFrom(const Ext4ExtShowExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ExtShowExtentFtraceEvent::CopyFrom(const Ext4ExtShowExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtShowExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtShowExtentFtraceEvent::InternalSwap(Ext4ExtShowExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pblk_, other->pblk_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
}

std::string Ext4ExtShowExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtShowExtentFtraceEvent";
}


// ===================================================================

void Ext4FallocateEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4FallocateEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FallocateEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
}
Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(const Ext4FallocateEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
}

void Ext4FallocateEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4FallocateEnterFtraceEvent::~Ext4FallocateEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  SharedDtor();
}

void Ext4FallocateEnterFtraceEvent::SharedDtor() {
}

void Ext4FallocateEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4FallocateEnterFtraceEvent& Ext4FallocateEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4FallocateEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4FallocateEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4FallocateEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4FallocateEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 offset = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 mode = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4FallocateEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->offset(), output);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->len(), output);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->mode(), output);
  }

  // optional int64 pos = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(6, this->pos(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4FallocateEnterFtraceEvent)
}

size_t Ext4FallocateEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->len());
    }

    // optional int64 pos = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FallocateEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4FallocateEnterFtraceEvent*>(
      &from));
}

void Ext4FallocateEnterFtraceEvent::MergeFrom(const Ext4FallocateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4FallocateEnterFtraceEvent::CopyFrom(const Ext4FallocateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FallocateEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FallocateEnterFtraceEvent::InternalSwap(Ext4FallocateEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(offset_, other->offset_);
  swap(len_, other->len_);
  swap(pos_, other->pos_);
  swap(mode_, other->mode_);
}

std::string Ext4FallocateEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FallocateEnterFtraceEvent";
}


// ===================================================================

void Ext4FallocateExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4FallocateExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FallocateExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
}
Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(const Ext4FallocateExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
}

void Ext4FallocateExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ret_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4FallocateExitFtraceEvent::~Ext4FallocateExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
  SharedDtor();
}

void Ext4FallocateExitFtraceEvent::SharedDtor() {
}

void Ext4FallocateExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4FallocateExitFtraceEvent& Ext4FallocateExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4FallocateExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4FallocateExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4FallocateExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4FallocateExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 blocks = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4FallocateExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4FallocateExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4FallocateExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->pos(), output);
  }

  // optional uint32 blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->blocks(), output);
  }

  // optional int32 ret = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->ret(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4FallocateExitFtraceEvent)
}

size_t Ext4FallocateExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional uint32 blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->blocks());
    }

    // optional int32 ret = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FallocateExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4FallocateExitFtraceEvent*>(
      &from));
}

void Ext4FallocateExitFtraceEvent::MergeFrom(const Ext4FallocateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4FallocateExitFtraceEvent::CopyFrom(const Ext4FallocateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FallocateExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FallocateExitFtraceEvent::InternalSwap(Ext4FallocateExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pos_, other->pos_);
  swap(blocks_, other->blocks_);
  swap(ret_, other->ret_);
}

std::string Ext4FallocateExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FallocateExitFtraceEvent";
}


// ===================================================================

void Ext4FindDelallocRangeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4FindDelallocRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FindDelallocRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_found_blk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
}
Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(const Ext4FindDelallocRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&found_blk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(found_blk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
}

void Ext4FindDelallocRangeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&found_blk_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(found_blk_));
}

Ext4FindDelallocRangeFtraceEvent::~Ext4FindDelallocRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  SharedDtor();
}

void Ext4FindDelallocRangeFtraceEvent::SharedDtor() {
}

void Ext4FindDelallocRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4FindDelallocRangeFtraceEvent& Ext4FindDelallocRangeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4FindDelallocRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4FindDelallocRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&found_blk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(found_blk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4FindDelallocRangeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_from(&has_bits);
          from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_to(&has_bits);
          to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 reverse = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_reverse(&has_bits);
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 found = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_found(&has_bits);
          found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 found_blk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_found_blk(&has_bits);
          found_blk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4FindDelallocRangeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 from = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_from(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 to = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_to(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 reverse = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_reverse(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &reverse_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 found = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_found(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &found_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 found_blk = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_found_blk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &found_blk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4FindDelallocRangeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 from = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->from(), output);
  }

  // optional uint32 to = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->to(), output);
  }

  // optional int32 reverse = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->reverse(), output);
  }

  // optional int32 found = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->found(), output);
  }

  // optional uint32 found_blk = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->found_blk(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
}

size_t Ext4FindDelallocRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 from = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->from());
    }

    // optional uint32 to = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->to());
    }

    // optional int32 reverse = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->reverse());
    }

    // optional int32 found = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->found());
    }

    // optional uint32 found_blk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->found_blk());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FindDelallocRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4FindDelallocRangeFtraceEvent*>(
      &from));
}

void Ext4FindDelallocRangeFtraceEvent::MergeFrom(const Ext4FindDelallocRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      from_ = from.from_;
    }
    if (cached_has_bits & 0x00000008u) {
      to_ = from.to_;
    }
    if (cached_has_bits & 0x00000010u) {
      reverse_ = from.reverse_;
    }
    if (cached_has_bits & 0x00000020u) {
      found_ = from.found_;
    }
    if (cached_has_bits & 0x00000040u) {
      found_blk_ = from.found_blk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4FindDelallocRangeFtraceEvent::CopyFrom(const Ext4FindDelallocRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FindDelallocRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FindDelallocRangeFtraceEvent::InternalSwap(Ext4FindDelallocRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(from_, other->from_);
  swap(to_, other->to_);
  swap(reverse_, other->reverse_);
  swap(found_, other->found_);
  swap(found_blk_, other->found_blk_);
}

std::string Ext4FindDelallocRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FindDelallocRangeFtraceEvent";
}


// ===================================================================

void Ext4ForgetFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ForgetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ForgetFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ForgetFtraceEvent)
}
Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(const Ext4ForgetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ForgetFtraceEvent)
}

void Ext4ForgetFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4ForgetFtraceEvent::~Ext4ForgetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ForgetFtraceEvent)
  SharedDtor();
}

void Ext4ForgetFtraceEvent::SharedDtor() {
}

void Ext4ForgetFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ForgetFtraceEvent& Ext4ForgetFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ForgetFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ForgetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ForgetFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ForgetFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 is_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_is_metadata(&has_bits);
          is_metadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ForgetFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ForgetFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 block = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_block(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 is_metadata = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_is_metadata(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_metadata_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ForgetFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ForgetFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ForgetFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ForgetFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->block(), output);
  }

  // optional int32 is_metadata = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->is_metadata(), output);
  }

  // optional uint32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ForgetFtraceEvent)
}

size_t Ext4ForgetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ForgetFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->block());
    }

    // optional int32 is_metadata = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->is_metadata());
    }

    // optional uint32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ForgetFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ForgetFtraceEvent*>(
      &from));
}

void Ext4ForgetFtraceEvent::MergeFrom(const Ext4ForgetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ForgetFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      block_ = from.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_metadata_ = from.is_metadata_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ForgetFtraceEvent::CopyFrom(const Ext4ForgetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ForgetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ForgetFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ForgetFtraceEvent::InternalSwap(Ext4ForgetFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(block_, other->block_);
  swap(is_metadata_, other->is_metadata_);
  swap(mode_, other->mode_);
}

std::string Ext4ForgetFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ForgetFtraceEvent";
}


// ===================================================================

void Ext4FreeBlocksFtraceEvent::InitAsDefaultInstance() {
}
class Ext4FreeBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FreeBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
}
Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(const Ext4FreeBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
}

void Ext4FreeBlocksFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4FreeBlocksFtraceEvent::~Ext4FreeBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  SharedDtor();
}

void Ext4FreeBlocksFtraceEvent::SharedDtor() {
}

void Ext4FreeBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4FreeBlocksFtraceEvent& Ext4FreeBlocksFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4FreeBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4FreeBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4FreeBlocksFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4FreeBlocksFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 block = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_block(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 count = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 flags = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4FreeBlocksFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->block(), output);
  }

  // optional uint64 count = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->count(), output);
  }

  // optional int32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->flags(), output);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4FreeBlocksFtraceEvent)
}

size_t Ext4FreeBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->block());
    }

    // optional uint64 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->count());
    }

    // optional int32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->flags());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FreeBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4FreeBlocksFtraceEvent*>(
      &from));
}

void Ext4FreeBlocksFtraceEvent::MergeFrom(const Ext4FreeBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      block_ = from.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4FreeBlocksFtraceEvent::CopyFrom(const Ext4FreeBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FreeBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FreeBlocksFtraceEvent::InternalSwap(Ext4FreeBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(block_, other->block_);
  swap(count_, other->count_);
  swap(flags_, other->flags_);
  swap(mode_, other->mode_);
}

std::string Ext4FreeBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FreeBlocksFtraceEvent";
}


// ===================================================================

void Ext4FreeInodeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4FreeInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FreeInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
}
Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(const Ext4FreeInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
}

void Ext4FreeInodeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4FreeInodeFtraceEvent::~Ext4FreeInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
  SharedDtor();
}

void Ext4FreeInodeFtraceEvent::SharedDtor() {
}

void Ext4FreeInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4FreeInodeFtraceEvent& Ext4FreeInodeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4FreeInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4FreeInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4FreeInodeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 uid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_uid(&has_bits);
          uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gid(&has_bits);
          gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4FreeInodeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 uid = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_uid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gid = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_gid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 blocks = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4FreeInodeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4FreeInodeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4FreeInodeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 uid = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->uid(), output);
  }

  // optional uint32 gid = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->gid(), output);
  }

  // optional uint64 blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(5, this->blocks(), output);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4FreeInodeFtraceEvent)
}

size_t Ext4FreeInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 uid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // optional uint32 gid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gid());
    }

    // optional uint64 blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->blocks());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FreeInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4FreeInodeFtraceEvent*>(
      &from));
}

void Ext4FreeInodeFtraceEvent::MergeFrom(const Ext4FreeInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      uid_ = from.uid_;
    }
    if (cached_has_bits & 0x00000008u) {
      gid_ = from.gid_;
    }
    if (cached_has_bits & 0x00000010u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4FreeInodeFtraceEvent::CopyFrom(const Ext4FreeInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FreeInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FreeInodeFtraceEvent::InternalSwap(Ext4FreeInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(uid_, other->uid_);
  swap(gid_, other->gid_);
  swap(blocks_, other->blocks_);
  swap(mode_, other->mode_);
}

std::string Ext4FreeInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FreeInodeFtraceEvent";
}


// ===================================================================

void Ext4GetImpliedClusterAllocExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4GetImpliedClusterAllocExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4GetImpliedClusterAllocExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
}
Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(const Ext4GetImpliedClusterAllocExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ret_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4GetImpliedClusterAllocExitFtraceEvent::~Ext4GetImpliedClusterAllocExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  SharedDtor();
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::SharedDtor() {
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4GetImpliedClusterAllocExitFtraceEvent& Ext4GetImpliedClusterAllocExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4GetImpliedClusterAllocExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4GetImpliedClusterAllocExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4GetImpliedClusterAllocExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4GetImpliedClusterAllocExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4GetImpliedClusterAllocExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->flags(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->pblk(), output);
  }

  // optional uint32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->len(), output);
  }

  // optional int32 ret = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->ret(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
}

size_t Ext4GetImpliedClusterAllocExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional int32 ret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4GetImpliedClusterAllocExitFtraceEvent*>(
      &from));
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::MergeFrom(const Ext4GetImpliedClusterAllocExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000020u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::CopyFrom(const Ext4GetImpliedClusterAllocExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4GetImpliedClusterAllocExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::InternalSwap(Ext4GetImpliedClusterAllocExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(flags_, other->flags_);
  swap(lblk_, other->lblk_);
  swap(pblk_, other->pblk_);
  swap(len_, other->len_);
  swap(ret_, other->ret_);
}

std::string Ext4GetImpliedClusterAllocExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent";
}


// ===================================================================

void Ext4GetReservedClusterAllocFtraceEvent::InitAsDefaultInstance() {
}
class Ext4GetReservedClusterAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4GetReservedClusterAllocFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
}
Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(const Ext4GetReservedClusterAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
}

void Ext4GetReservedClusterAllocFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4GetReservedClusterAllocFtraceEvent::~Ext4GetReservedClusterAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  SharedDtor();
}

void Ext4GetReservedClusterAllocFtraceEvent::SharedDtor() {
}

void Ext4GetReservedClusterAllocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4GetReservedClusterAllocFtraceEvent& Ext4GetReservedClusterAllocFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4GetReservedClusterAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4GetReservedClusterAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4GetReservedClusterAllocFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4GetReservedClusterAllocFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4GetReservedClusterAllocFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
}

size_t Ext4GetReservedClusterAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4GetReservedClusterAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4GetReservedClusterAllocFtraceEvent*>(
      &from));
}

void Ext4GetReservedClusterAllocFtraceEvent::MergeFrom(const Ext4GetReservedClusterAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4GetReservedClusterAllocFtraceEvent::CopyFrom(const Ext4GetReservedClusterAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4GetReservedClusterAllocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4GetReservedClusterAllocFtraceEvent::InternalSwap(Ext4GetReservedClusterAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
}

std::string Ext4GetReservedClusterAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent";
}


// ===================================================================

void Ext4IndMapBlocksEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4IndMapBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4IndMapBlocksEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
}
Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(const Ext4IndMapBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
}

void Ext4IndMapBlocksEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4IndMapBlocksEnterFtraceEvent::~Ext4IndMapBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  SharedDtor();
}

void Ext4IndMapBlocksEnterFtraceEvent::SharedDtor() {
}

void Ext4IndMapBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4IndMapBlocksEnterFtraceEvent& Ext4IndMapBlocksEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4IndMapBlocksEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4IndMapBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4IndMapBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4IndMapBlocksEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4IndMapBlocksEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->lblk(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->flags(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
}

size_t Ext4IndMapBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4IndMapBlocksEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4IndMapBlocksEnterFtraceEvent*>(
      &from));
}

void Ext4IndMapBlocksEnterFtraceEvent::MergeFrom(const Ext4IndMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4IndMapBlocksEnterFtraceEvent::CopyFrom(const Ext4IndMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4IndMapBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4IndMapBlocksEnterFtraceEvent::InternalSwap(Ext4IndMapBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(flags_, other->flags_);
}

std::string Ext4IndMapBlocksEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent";
}


// ===================================================================

void Ext4IndMapBlocksExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4IndMapBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4IndMapBlocksExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mflags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
}
Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(const Ext4IndMapBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
}

void Ext4IndMapBlocksExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ret_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4IndMapBlocksExitFtraceEvent::~Ext4IndMapBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  SharedDtor();
}

void Ext4IndMapBlocksExitFtraceEvent::SharedDtor() {
}

void Ext4IndMapBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4IndMapBlocksExitFtraceEvent& Ext4IndMapBlocksExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4IndMapBlocksExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4IndMapBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4IndMapBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mflags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_mflags(&has_bits);
          mflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4IndMapBlocksExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pblk = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lblk = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mflags = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_mflags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mflags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4IndMapBlocksExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->flags(), output);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->pblk(), output);
  }

  // optional uint32 lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->lblk(), output);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->len(), output);
  }

  // optional uint32 mflags = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->mflags(), output);
  }

  // optional int32 ret = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->ret(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
}

size_t Ext4IndMapBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pblk());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 mflags = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mflags());
    }

    // optional int32 ret = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4IndMapBlocksExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4IndMapBlocksExitFtraceEvent*>(
      &from));
}

void Ext4IndMapBlocksExitFtraceEvent::MergeFrom(const Ext4IndMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      mflags_ = from.mflags_;
    }
    if (cached_has_bits & 0x00000080u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4IndMapBlocksExitFtraceEvent::CopyFrom(const Ext4IndMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4IndMapBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4IndMapBlocksExitFtraceEvent::InternalSwap(Ext4IndMapBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pblk_, other->pblk_);
  swap(flags_, other->flags_);
  swap(lblk_, other->lblk_);
  swap(len_, other->len_);
  swap(mflags_, other->mflags_);
  swap(ret_, other->ret_);
}

std::string Ext4IndMapBlocksExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4IndMapBlocksExitFtraceEvent";
}


// ===================================================================

void Ext4InsertRangeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4InsertRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4InsertRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
}
Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(const Ext4InsertRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
}

void Ext4InsertRangeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4InsertRangeFtraceEvent::~Ext4InsertRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
  SharedDtor();
}

void Ext4InsertRangeFtraceEvent::SharedDtor() {
}

void Ext4InsertRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4InsertRangeFtraceEvent& Ext4InsertRangeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4InsertRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4InsertRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4InsertRangeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4InsertRangeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 offset = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4InsertRangeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4InsertRangeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4InsertRangeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->offset(), output);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4InsertRangeFtraceEvent)
}

size_t Ext4InsertRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4InsertRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4InsertRangeFtraceEvent*>(
      &from));
}

void Ext4InsertRangeFtraceEvent::MergeFrom(const Ext4InsertRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4InsertRangeFtraceEvent::CopyFrom(const Ext4InsertRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4InsertRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4InsertRangeFtraceEvent::InternalSwap(Ext4InsertRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(offset_, other->offset_);
  swap(len_, other->len_);
}

std::string Ext4InsertRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4InsertRangeFtraceEvent";
}


// ===================================================================

void Ext4InvalidatepageFtraceEvent::InitAsDefaultInstance() {
}
class Ext4InvalidatepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4InvalidatepageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
}
Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(const Ext4InvalidatepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
}

void Ext4InvalidatepageFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&length_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(length_));
}

Ext4InvalidatepageFtraceEvent::~Ext4InvalidatepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  SharedDtor();
}

void Ext4InvalidatepageFtraceEvent::SharedDtor() {
}

void Ext4InvalidatepageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4InvalidatepageFtraceEvent& Ext4InvalidatepageFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4InvalidatepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4InvalidatepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4InvalidatepageFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4InvalidatepageFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 index = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 offset = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 length = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_length(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4InvalidatepageFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->index(), output);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->offset(), output);
  }

  // optional uint32 length = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->length(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4InvalidatepageFtraceEvent)
}

size_t Ext4InvalidatepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->index());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->offset());
    }

    // optional uint32 length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->length());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4InvalidatepageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4InvalidatepageFtraceEvent*>(
      &from));
}

void Ext4InvalidatepageFtraceEvent::MergeFrom(const Ext4InvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4InvalidatepageFtraceEvent::CopyFrom(const Ext4InvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4InvalidatepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4InvalidatepageFtraceEvent::InternalSwap(Ext4InvalidatepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(index_, other->index_);
  swap(offset_, other->offset_);
  swap(length_, other->length_);
}

std::string Ext4InvalidatepageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4InvalidatepageFtraceEvent";
}


// ===================================================================

void Ext4JournalStartFtraceEvent::InitAsDefaultInstance() {
}
class Ext4JournalStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalStartFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rsv_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nblocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4JournalStartFtraceEvent)
}
Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(const Ext4JournalStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&nblocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(nblocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalStartFtraceEvent)
}

void Ext4JournalStartFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nblocks_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(nblocks_));
}

Ext4JournalStartFtraceEvent::~Ext4JournalStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalStartFtraceEvent)
  SharedDtor();
}

void Ext4JournalStartFtraceEvent::SharedDtor() {
}

void Ext4JournalStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4JournalStartFtraceEvent& Ext4JournalStartFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4JournalStartFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4JournalStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nblocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(nblocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4JournalStartFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ip(&has_bits);
          ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 rsv_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_rsv_blocks(&has_bits);
          rsv_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nblocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_nblocks(&has_bits);
          nblocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4JournalStartFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ip = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ip(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ip_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 blocks = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 rsv_blocks = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_rsv_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &rsv_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nblocks = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_nblocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &nblocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4JournalStartFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4JournalStartFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4JournalStartFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ip = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ip(), output);
  }

  // optional int32 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->blocks(), output);
  }

  // optional int32 rsv_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->rsv_blocks(), output);
  }

  // optional int32 nblocks = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->nblocks(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4JournalStartFtraceEvent)
}

size_t Ext4JournalStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ip());
    }

    // optional int32 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->blocks());
    }

    // optional int32 rsv_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->rsv_blocks());
    }

    // optional int32 nblocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->nblocks());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4JournalStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4JournalStartFtraceEvent*>(
      &from));
}

void Ext4JournalStartFtraceEvent::MergeFrom(const Ext4JournalStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ip_ = from.ip_;
    }
    if (cached_has_bits & 0x00000004u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      rsv_blocks_ = from.rsv_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      nblocks_ = from.nblocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4JournalStartFtraceEvent::CopyFrom(const Ext4JournalStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalStartFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalStartFtraceEvent::InternalSwap(Ext4JournalStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ip_, other->ip_);
  swap(blocks_, other->blocks_);
  swap(rsv_blocks_, other->rsv_blocks_);
  swap(nblocks_, other->nblocks_);
}

std::string Ext4JournalStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4JournalStartFtraceEvent";
}


// ===================================================================

void Ext4JournalStartReservedFtraceEvent::InitAsDefaultInstance() {
}
class Ext4JournalStartReservedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalStartReservedFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
}
Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(const Ext4JournalStartReservedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
}

void Ext4JournalStartReservedFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&blocks_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
}

Ext4JournalStartReservedFtraceEvent::~Ext4JournalStartReservedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  SharedDtor();
}

void Ext4JournalStartReservedFtraceEvent::SharedDtor() {
}

void Ext4JournalStartReservedFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4JournalStartReservedFtraceEvent& Ext4JournalStartReservedFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4JournalStartReservedFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4JournalStartReservedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4JournalStartReservedFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ip(&has_bits);
          ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4JournalStartReservedFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ip = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ip(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ip_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 blocks = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4JournalStartReservedFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ip = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ip(), output);
  }

  // optional int32 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->blocks(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
}

size_t Ext4JournalStartReservedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ip());
    }

    // optional int32 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->blocks());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4JournalStartReservedFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4JournalStartReservedFtraceEvent*>(
      &from));
}

void Ext4JournalStartReservedFtraceEvent::MergeFrom(const Ext4JournalStartReservedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ip_ = from.ip_;
    }
    if (cached_has_bits & 0x00000004u) {
      blocks_ = from.blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4JournalStartReservedFtraceEvent::CopyFrom(const Ext4JournalStartReservedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalStartReservedFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalStartReservedFtraceEvent::InternalSwap(Ext4JournalStartReservedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ip_, other->ip_);
  swap(blocks_, other->blocks_);
}

std::string Ext4JournalStartReservedFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4JournalStartReservedFtraceEvent";
}


// ===================================================================

void Ext4JournalledInvalidatepageFtraceEvent::InitAsDefaultInstance() {
}
class Ext4JournalledInvalidatepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalledInvalidatepageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
}
Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(const Ext4JournalledInvalidatepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
}

void Ext4JournalledInvalidatepageFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&length_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(length_));
}

Ext4JournalledInvalidatepageFtraceEvent::~Ext4JournalledInvalidatepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  SharedDtor();
}

void Ext4JournalledInvalidatepageFtraceEvent::SharedDtor() {
}

void Ext4JournalledInvalidatepageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4JournalledInvalidatepageFtraceEvent& Ext4JournalledInvalidatepageFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4JournalledInvalidatepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4JournalledInvalidatepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4JournalledInvalidatepageFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4JournalledInvalidatepageFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 index = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 offset = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 length = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_length(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4JournalledInvalidatepageFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->index(), output);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->offset(), output);
  }

  // optional uint32 length = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->length(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
}

size_t Ext4JournalledInvalidatepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->index());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->offset());
    }

    // optional uint32 length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->length());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4JournalledInvalidatepageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4JournalledInvalidatepageFtraceEvent*>(
      &from));
}

void Ext4JournalledInvalidatepageFtraceEvent::MergeFrom(const Ext4JournalledInvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4JournalledInvalidatepageFtraceEvent::CopyFrom(const Ext4JournalledInvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalledInvalidatepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalledInvalidatepageFtraceEvent::InternalSwap(Ext4JournalledInvalidatepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(index_, other->index_);
  swap(offset_, other->offset_);
  swap(length_, other->length_);
}

std::string Ext4JournalledInvalidatepageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent";
}


// ===================================================================

void Ext4JournalledWriteEndFtraceEvent::InitAsDefaultInstance() {
}
class Ext4JournalledWriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalledWriteEndFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
}
Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(const Ext4JournalledWriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
}

void Ext4JournalledWriteEndFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&copied_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
}

Ext4JournalledWriteEndFtraceEvent::~Ext4JournalledWriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  SharedDtor();
}

void Ext4JournalledWriteEndFtraceEvent::SharedDtor() {
}

void Ext4JournalledWriteEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4JournalledWriteEndFtraceEvent& Ext4JournalledWriteEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4JournalledWriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4JournalledWriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&copied_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4JournalledWriteEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4JournalledWriteEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 copied = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_copied(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &copied_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4JournalledWriteEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->pos(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->copied(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
}

size_t Ext4JournalledWriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->copied());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4JournalledWriteEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4JournalledWriteEndFtraceEvent*>(
      &from));
}

void Ext4JournalledWriteEndFtraceEvent::MergeFrom(const Ext4JournalledWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      copied_ = from.copied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4JournalledWriteEndFtraceEvent::CopyFrom(const Ext4JournalledWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalledWriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalledWriteEndFtraceEvent::InternalSwap(Ext4JournalledWriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pos_, other->pos_);
  swap(len_, other->len_);
  swap(copied_, other->copied_);
}

std::string Ext4JournalledWriteEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4JournalledWriteEndFtraceEvent";
}


// ===================================================================

void Ext4LoadInodeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4LoadInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4LoadInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
}
Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(const Ext4LoadInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ino_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
}

void Ext4LoadInodeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ino_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
}

Ext4LoadInodeFtraceEvent::~Ext4LoadInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
  SharedDtor();
}

void Ext4LoadInodeFtraceEvent::SharedDtor() {
}

void Ext4LoadInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4LoadInodeFtraceEvent& Ext4LoadInodeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4LoadInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4LoadInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ino_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4LoadInodeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4LoadInodeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4LoadInodeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4LoadInodeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4LoadInodeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4LoadInodeFtraceEvent)
}

size_t Ext4LoadInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4LoadInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4LoadInodeFtraceEvent*>(
      &from));
}

void Ext4LoadInodeFtraceEvent::MergeFrom(const Ext4LoadInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4LoadInodeFtraceEvent::CopyFrom(const Ext4LoadInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4LoadInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4LoadInodeFtraceEvent::InternalSwap(Ext4LoadInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
}

std::string Ext4LoadInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4LoadInodeFtraceEvent";
}


// ===================================================================

void Ext4LoadInodeBitmapFtraceEvent::InitAsDefaultInstance() {
}
class Ext4LoadInodeBitmapFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4LoadInodeBitmapFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
}
Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(const Ext4LoadInodeBitmapFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
}

void Ext4LoadInodeBitmapFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&group_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(group_));
}

Ext4LoadInodeBitmapFtraceEvent::~Ext4LoadInodeBitmapFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  SharedDtor();
}

void Ext4LoadInodeBitmapFtraceEvent::SharedDtor() {
}

void Ext4LoadInodeBitmapFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4LoadInodeBitmapFtraceEvent& Ext4LoadInodeBitmapFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4LoadInodeBitmapFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4LoadInodeBitmapFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4LoadInodeBitmapFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4LoadInodeBitmapFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 group = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4LoadInodeBitmapFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->group(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
}

size_t Ext4LoadInodeBitmapFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->group());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4LoadInodeBitmapFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4LoadInodeBitmapFtraceEvent*>(
      &from));
}

void Ext4LoadInodeBitmapFtraceEvent::MergeFrom(const Ext4LoadInodeBitmapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_ = from.group_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4LoadInodeBitmapFtraceEvent::CopyFrom(const Ext4LoadInodeBitmapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4LoadInodeBitmapFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4LoadInodeBitmapFtraceEvent::InternalSwap(Ext4LoadInodeBitmapFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(group_, other->group_);
}

std::string Ext4LoadInodeBitmapFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4LoadInodeBitmapFtraceEvent";
}


// ===================================================================

void Ext4MarkInodeDirtyFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MarkInodeDirtyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MarkInodeDirtyFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
}
Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(const Ext4MarkInodeDirtyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ip_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ip_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
}

void Ext4MarkInodeDirtyFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ip_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ip_));
}

Ext4MarkInodeDirtyFtraceEvent::~Ext4MarkInodeDirtyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  SharedDtor();
}

void Ext4MarkInodeDirtyFtraceEvent::SharedDtor() {
}

void Ext4MarkInodeDirtyFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MarkInodeDirtyFtraceEvent& Ext4MarkInodeDirtyFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MarkInodeDirtyFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MarkInodeDirtyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ip_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ip_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MarkInodeDirtyFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ip(&has_bits);
          ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MarkInodeDirtyFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ip = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_ip(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ip_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MarkInodeDirtyFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 ip = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->ip(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
}

size_t Ext4MarkInodeDirtyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 ip = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ip());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MarkInodeDirtyFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MarkInodeDirtyFtraceEvent*>(
      &from));
}

void Ext4MarkInodeDirtyFtraceEvent::MergeFrom(const Ext4MarkInodeDirtyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ip_ = from.ip_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MarkInodeDirtyFtraceEvent::CopyFrom(const Ext4MarkInodeDirtyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MarkInodeDirtyFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MarkInodeDirtyFtraceEvent::InternalSwap(Ext4MarkInodeDirtyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(ip_, other->ip_);
}

std::string Ext4MarkInodeDirtyFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MarkInodeDirtyFtraceEvent";
}


// ===================================================================

void Ext4MbBitmapLoadFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MbBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbBitmapLoadFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
}
Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(const Ext4MbBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
}

void Ext4MbBitmapLoadFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&group_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(group_));
}

Ext4MbBitmapLoadFtraceEvent::~Ext4MbBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  SharedDtor();
}

void Ext4MbBitmapLoadFtraceEvent::SharedDtor() {
}

void Ext4MbBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MbBitmapLoadFtraceEvent& Ext4MbBitmapLoadFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MbBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MbBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MbBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MbBitmapLoadFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 group = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MbBitmapLoadFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->group(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
}

size_t Ext4MbBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->group());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbBitmapLoadFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MbBitmapLoadFtraceEvent*>(
      &from));
}

void Ext4MbBitmapLoadFtraceEvent::MergeFrom(const Ext4MbBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_ = from.group_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MbBitmapLoadFtraceEvent::CopyFrom(const Ext4MbBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbBitmapLoadFtraceEvent::InternalSwap(Ext4MbBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(group_, other->group_);
}

std::string Ext4MbBitmapLoadFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbBitmapLoadFtraceEvent";
}


// ===================================================================

void Ext4MbBuddyBitmapLoadFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MbBuddyBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbBuddyBitmapLoadFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
}
Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(const Ext4MbBuddyBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
}

void Ext4MbBuddyBitmapLoadFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&group_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(group_));
}

Ext4MbBuddyBitmapLoadFtraceEvent::~Ext4MbBuddyBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  SharedDtor();
}

void Ext4MbBuddyBitmapLoadFtraceEvent::SharedDtor() {
}

void Ext4MbBuddyBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MbBuddyBitmapLoadFtraceEvent& Ext4MbBuddyBitmapLoadFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MbBuddyBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MbBuddyBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MbBuddyBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MbBuddyBitmapLoadFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 group = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MbBuddyBitmapLoadFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->group(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
}

size_t Ext4MbBuddyBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->group());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbBuddyBitmapLoadFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MbBuddyBitmapLoadFtraceEvent*>(
      &from));
}

void Ext4MbBuddyBitmapLoadFtraceEvent::MergeFrom(const Ext4MbBuddyBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_ = from.group_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MbBuddyBitmapLoadFtraceEvent::CopyFrom(const Ext4MbBuddyBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbBuddyBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbBuddyBitmapLoadFtraceEvent::InternalSwap(Ext4MbBuddyBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(group_, other->group_);
}

std::string Ext4MbBuddyBitmapLoadFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent";
}


// ===================================================================

void Ext4MbDiscardPreallocationsFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MbDiscardPreallocationsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbDiscardPreallocationsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
}
Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(const Ext4MbDiscardPreallocationsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&needed_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
}

void Ext4MbDiscardPreallocationsFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&needed_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
}

Ext4MbDiscardPreallocationsFtraceEvent::~Ext4MbDiscardPreallocationsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  SharedDtor();
}

void Ext4MbDiscardPreallocationsFtraceEvent::SharedDtor() {
}

void Ext4MbDiscardPreallocationsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MbDiscardPreallocationsFtraceEvent& Ext4MbDiscardPreallocationsFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MbDiscardPreallocationsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MbDiscardPreallocationsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&needed_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MbDiscardPreallocationsFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 needed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_needed(&has_bits);
          needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MbDiscardPreallocationsFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 needed = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_needed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &needed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MbDiscardPreallocationsFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional int32 needed = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->needed(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
}

size_t Ext4MbDiscardPreallocationsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional int32 needed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->needed());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbDiscardPreallocationsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MbDiscardPreallocationsFtraceEvent*>(
      &from));
}

void Ext4MbDiscardPreallocationsFtraceEvent::MergeFrom(const Ext4MbDiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      needed_ = from.needed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MbDiscardPreallocationsFtraceEvent::CopyFrom(const Ext4MbDiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbDiscardPreallocationsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbDiscardPreallocationsFtraceEvent::InternalSwap(Ext4MbDiscardPreallocationsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(needed_, other->needed_);
}

std::string Ext4MbDiscardPreallocationsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent";
}


// ===================================================================

void Ext4MbNewGroupPaFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MbNewGroupPaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbNewGroupPaFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pa_lstart(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
}
Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(const Ext4MbNewGroupPaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
}

void Ext4MbNewGroupPaFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pa_len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
}

Ext4MbNewGroupPaFtraceEvent::~Ext4MbNewGroupPaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  SharedDtor();
}

void Ext4MbNewGroupPaFtraceEvent::SharedDtor() {
}

void Ext4MbNewGroupPaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MbNewGroupPaFtraceEvent& Ext4MbNewGroupPaFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MbNewGroupPaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MbNewGroupPaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pa_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MbNewGroupPaFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pa_pstart = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pa_pstart(&has_bits);
          pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pa_lstart = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pa_lstart(&has_bits);
          pa_lstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 pa_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pa_len(&has_bits);
          pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MbNewGroupPaFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pa_pstart = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pa_pstart(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pa_pstart_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pa_lstart = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pa_lstart(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pa_lstart_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 pa_len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pa_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pa_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MbNewGroupPaFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 pa_pstart = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pa_pstart(), output);
  }

  // optional uint64 pa_lstart = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->pa_lstart(), output);
  }

  // optional uint32 pa_len = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->pa_len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
}

size_t Ext4MbNewGroupPaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 pa_pstart = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pa_pstart());
    }

    // optional uint64 pa_lstart = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pa_lstart());
    }

    // optional uint32 pa_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->pa_len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbNewGroupPaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MbNewGroupPaFtraceEvent*>(
      &from));
}

void Ext4MbNewGroupPaFtraceEvent::MergeFrom(const Ext4MbNewGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_pstart_ = from.pa_pstart_;
    }
    if (cached_has_bits & 0x00000008u) {
      pa_lstart_ = from.pa_lstart_;
    }
    if (cached_has_bits & 0x00000010u) {
      pa_len_ = from.pa_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MbNewGroupPaFtraceEvent::CopyFrom(const Ext4MbNewGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbNewGroupPaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbNewGroupPaFtraceEvent::InternalSwap(Ext4MbNewGroupPaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pa_pstart_, other->pa_pstart_);
  swap(pa_lstart_, other->pa_lstart_);
  swap(pa_len_, other->pa_len_);
}

std::string Ext4MbNewGroupPaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbNewGroupPaFtraceEvent";
}


// ===================================================================

void Ext4MbNewInodePaFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MbNewInodePaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbNewInodePaFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pa_lstart(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
}
Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(const Ext4MbNewInodePaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
}

void Ext4MbNewInodePaFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pa_len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
}

Ext4MbNewInodePaFtraceEvent::~Ext4MbNewInodePaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  SharedDtor();
}

void Ext4MbNewInodePaFtraceEvent::SharedDtor() {
}

void Ext4MbNewInodePaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MbNewInodePaFtraceEvent& Ext4MbNewInodePaFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MbNewInodePaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MbNewInodePaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pa_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MbNewInodePaFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pa_pstart = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pa_pstart(&has_bits);
          pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pa_lstart = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pa_lstart(&has_bits);
          pa_lstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 pa_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pa_len(&has_bits);
          pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MbNewInodePaFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pa_pstart = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pa_pstart(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pa_pstart_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pa_lstart = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pa_lstart(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pa_lstart_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 pa_len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pa_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pa_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MbNewInodePaFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 pa_pstart = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pa_pstart(), output);
  }

  // optional uint64 pa_lstart = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->pa_lstart(), output);
  }

  // optional uint32 pa_len = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->pa_len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
}

size_t Ext4MbNewInodePaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 pa_pstart = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pa_pstart());
    }

    // optional uint64 pa_lstart = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pa_lstart());
    }

    // optional uint32 pa_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->pa_len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbNewInodePaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MbNewInodePaFtraceEvent*>(
      &from));
}

void Ext4MbNewInodePaFtraceEvent::MergeFrom(const Ext4MbNewInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_pstart_ = from.pa_pstart_;
    }
    if (cached_has_bits & 0x00000008u) {
      pa_lstart_ = from.pa_lstart_;
    }
    if (cached_has_bits & 0x00000010u) {
      pa_len_ = from.pa_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MbNewInodePaFtraceEvent::CopyFrom(const Ext4MbNewInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbNewInodePaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbNewInodePaFtraceEvent::InternalSwap(Ext4MbNewInodePaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pa_pstart_, other->pa_pstart_);
  swap(pa_lstart_, other->pa_lstart_);
  swap(pa_len_, other->pa_len_);
}

std::string Ext4MbNewInodePaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbNewInodePaFtraceEvent";
}


// ===================================================================

void Ext4MbReleaseGroupPaFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MbReleaseGroupPaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbReleaseGroupPaFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
}
Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(const Ext4MbReleaseGroupPaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
}

void Ext4MbReleaseGroupPaFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pa_len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
}

Ext4MbReleaseGroupPaFtraceEvent::~Ext4MbReleaseGroupPaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  SharedDtor();
}

void Ext4MbReleaseGroupPaFtraceEvent::SharedDtor() {
}

void Ext4MbReleaseGroupPaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MbReleaseGroupPaFtraceEvent& Ext4MbReleaseGroupPaFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MbReleaseGroupPaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MbReleaseGroupPaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pa_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MbReleaseGroupPaFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pa_pstart = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pa_pstart(&has_bits);
          pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 pa_len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pa_len(&has_bits);
          pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MbReleaseGroupPaFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pa_pstart = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_pa_pstart(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pa_pstart_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 pa_len = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pa_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pa_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MbReleaseGroupPaFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 pa_pstart = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->pa_pstart(), output);
  }

  // optional uint32 pa_len = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->pa_len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
}

size_t Ext4MbReleaseGroupPaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 pa_pstart = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pa_pstart());
    }

    // optional uint32 pa_len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->pa_len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbReleaseGroupPaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MbReleaseGroupPaFtraceEvent*>(
      &from));
}

void Ext4MbReleaseGroupPaFtraceEvent::MergeFrom(const Ext4MbReleaseGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      pa_pstart_ = from.pa_pstart_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_len_ = from.pa_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MbReleaseGroupPaFtraceEvent::CopyFrom(const Ext4MbReleaseGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbReleaseGroupPaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbReleaseGroupPaFtraceEvent::InternalSwap(Ext4MbReleaseGroupPaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(pa_pstart_, other->pa_pstart_);
  swap(pa_len_, other->pa_len_);
}

std::string Ext4MbReleaseGroupPaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent";
}


// ===================================================================

void Ext4MbReleaseInodePaFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MbReleaseInodePaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbReleaseInodePaFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
}
Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(const Ext4MbReleaseInodePaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
}

void Ext4MbReleaseInodePaFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(count_));
}

Ext4MbReleaseInodePaFtraceEvent::~Ext4MbReleaseInodePaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  SharedDtor();
}

void Ext4MbReleaseInodePaFtraceEvent::SharedDtor() {
}

void Ext4MbReleaseInodePaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MbReleaseInodePaFtraceEvent& Ext4MbReleaseInodePaFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MbReleaseInodePaFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MbReleaseInodePaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MbReleaseInodePaFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MbReleaseInodePaFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 block = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_block(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 count = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MbReleaseInodePaFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->block(), output);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->count(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
}

size_t Ext4MbReleaseInodePaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->block());
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbReleaseInodePaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MbReleaseInodePaFtraceEvent*>(
      &from));
}

void Ext4MbReleaseInodePaFtraceEvent::MergeFrom(const Ext4MbReleaseInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      block_ = from.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MbReleaseInodePaFtraceEvent::CopyFrom(const Ext4MbReleaseInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbReleaseInodePaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbReleaseInodePaFtraceEvent::InternalSwap(Ext4MbReleaseInodePaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(block_, other->block_);
  swap(count_, other->count_);
}

std::string Ext4MbReleaseInodePaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbReleaseInodePaFtraceEvent";
}


// ===================================================================

void Ext4MballocAllocFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MballocAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocAllocFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orig_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_orig_group(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_orig_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_goal_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_goal_start(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_goal_group(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_goal_len(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_result_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_groups(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_buddy(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_tail(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_cr(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
}
Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(const Ext4MballocAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cr_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
}

void Ext4MballocAllocFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cr_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(cr_));
}

Ext4MballocAllocFtraceEvent::~Ext4MballocAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
  SharedDtor();
}

void Ext4MballocAllocFtraceEvent::SharedDtor() {
}

void Ext4MballocAllocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MballocAllocFtraceEvent& Ext4MballocAllocFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MballocAllocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MballocAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&goal_start_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(goal_start_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&goal_group_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&groups_) -
        reinterpret_cast<char*>(&goal_group_)) + sizeof(groups_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&buddy_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cr_) -
        reinterpret_cast<char*>(&buddy_)) + sizeof(cr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MballocAllocFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 orig_logical = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_orig_logical(&has_bits);
          orig_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 orig_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_orig_start(&has_bits);
          orig_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 orig_group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_orig_group(&has_bits);
          orig_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 orig_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_orig_len(&has_bits);
          orig_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 goal_logical = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_goal_logical(&has_bits);
          goal_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 goal_start = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_goal_start(&has_bits);
          goal_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 goal_group = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_goal_group(&has_bits);
          goal_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 goal_len = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_goal_len(&has_bits);
          goal_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 result_logical = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_result_logical(&has_bits);
          result_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_start = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_result_start(&has_bits);
          result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 result_group = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_result_group(&has_bits);
          result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_len = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_result_len(&has_bits);
          result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 found = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_found(&has_bits);
          found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 groups = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_groups(&has_bits);
          groups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 buddy = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_buddy(&has_bits);
          buddy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 tail = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_tail(&has_bits);
          tail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cr = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_cr(&has_bits);
          cr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MballocAllocFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 orig_logical = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_orig_logical(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &orig_logical_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 orig_start = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_orig_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &orig_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 orig_group = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_orig_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &orig_group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 orig_len = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_orig_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &orig_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 goal_logical = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_goal_logical(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &goal_logical_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 goal_start = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_goal_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &goal_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 goal_group = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_goal_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &goal_group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 goal_len = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_goal_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &goal_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 result_logical = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_result_logical(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_logical_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_start = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          _Internal::set_has_result_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 result_group = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          _Internal::set_has_result_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_len = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          _Internal::set_has_result_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 found = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (120 & 0xFF)) {
          _Internal::set_has_found(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &found_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 groups = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (128 & 0xFF)) {
          _Internal::set_has_groups(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &groups_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 buddy = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (136 & 0xFF)) {
          _Internal::set_has_buddy(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buddy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (144 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 tail = 19;
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (152 & 0xFF)) {
          _Internal::set_has_tail(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tail_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cr = 20;
      case 20: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (160 & 0xFF)) {
          _Internal::set_has_cr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MballocAllocFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MballocAllocFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MballocAllocFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 orig_logical = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->orig_logical(), output);
  }

  // optional int32 orig_start = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->orig_start(), output);
  }

  // optional uint32 orig_group = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->orig_group(), output);
  }

  // optional int32 orig_len = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->orig_len(), output);
  }

  // optional uint32 goal_logical = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->goal_logical(), output);
  }

  // optional int32 goal_start = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->goal_start(), output);
  }

  // optional uint32 goal_group = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->goal_group(), output);
  }

  // optional int32 goal_len = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(10, this->goal_len(), output);
  }

  // optional uint32 result_logical = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->result_logical(), output);
  }

  // optional int32 result_start = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(12, this->result_start(), output);
  }

  // optional uint32 result_group = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(13, this->result_group(), output);
  }

  // optional int32 result_len = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(14, this->result_len(), output);
  }

  // optional uint32 found = 15;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(15, this->found(), output);
  }

  // optional uint32 groups = 16;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(16, this->groups(), output);
  }

  // optional uint32 buddy = 17;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(17, this->buddy(), output);
  }

  // optional uint32 flags = 18;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(18, this->flags(), output);
  }

  // optional uint32 tail = 19;
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(19, this->tail(), output);
  }

  // optional uint32 cr = 20;
  if (cached_has_bits & 0x00080000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(20, this->cr(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MballocAllocFtraceEvent)
}

size_t Ext4MballocAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 orig_logical = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->orig_logical());
    }

    // optional int32 orig_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->orig_start());
    }

    // optional uint32 orig_group = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->orig_group());
    }

    // optional int32 orig_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->orig_len());
    }

    // optional uint32 goal_logical = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->goal_logical());
    }

    // optional int32 goal_start = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->goal_start());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 goal_group = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->goal_group());
    }

    // optional int32 goal_len = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->goal_len());
    }

    // optional uint32 result_logical = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->result_logical());
    }

    // optional int32 result_start = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_start());
    }

    // optional uint32 result_group = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->result_group());
    }

    // optional int32 result_len = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_len());
    }

    // optional uint32 found = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->found());
    }

    // optional uint32 groups = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->groups());
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional uint32 buddy = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->buddy());
    }

    // optional uint32 flags = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 tail = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->tail());
    }

    // optional uint32 cr = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cr());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MballocAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MballocAllocFtraceEvent*>(
      &from));
}

void Ext4MballocAllocFtraceEvent::MergeFrom(const Ext4MballocAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      orig_logical_ = from.orig_logical_;
    }
    if (cached_has_bits & 0x00000008u) {
      orig_start_ = from.orig_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      orig_group_ = from.orig_group_;
    }
    if (cached_has_bits & 0x00000020u) {
      orig_len_ = from.orig_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      goal_logical_ = from.goal_logical_;
    }
    if (cached_has_bits & 0x00000080u) {
      goal_start_ = from.goal_start_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      goal_group_ = from.goal_group_;
    }
    if (cached_has_bits & 0x00000200u) {
      goal_len_ = from.goal_len_;
    }
    if (cached_has_bits & 0x00000400u) {
      result_logical_ = from.result_logical_;
    }
    if (cached_has_bits & 0x00000800u) {
      result_start_ = from.result_start_;
    }
    if (cached_has_bits & 0x00001000u) {
      result_group_ = from.result_group_;
    }
    if (cached_has_bits & 0x00002000u) {
      result_len_ = from.result_len_;
    }
    if (cached_has_bits & 0x00004000u) {
      found_ = from.found_;
    }
    if (cached_has_bits & 0x00008000u) {
      groups_ = from.groups_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      buddy_ = from.buddy_;
    }
    if (cached_has_bits & 0x00020000u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00040000u) {
      tail_ = from.tail_;
    }
    if (cached_has_bits & 0x00080000u) {
      cr_ = from.cr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MballocAllocFtraceEvent::CopyFrom(const Ext4MballocAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocAllocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocAllocFtraceEvent::InternalSwap(Ext4MballocAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(orig_logical_, other->orig_logical_);
  swap(orig_start_, other->orig_start_);
  swap(orig_group_, other->orig_group_);
  swap(orig_len_, other->orig_len_);
  swap(goal_logical_, other->goal_logical_);
  swap(goal_start_, other->goal_start_);
  swap(goal_group_, other->goal_group_);
  swap(goal_len_, other->goal_len_);
  swap(result_logical_, other->result_logical_);
  swap(result_start_, other->result_start_);
  swap(result_group_, other->result_group_);
  swap(result_len_, other->result_len_);
  swap(found_, other->found_);
  swap(groups_, other->groups_);
  swap(buddy_, other->buddy_);
  swap(flags_, other->flags_);
  swap(tail_, other->tail_);
  swap(cr_, other->cr_);
}

std::string Ext4MballocAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MballocAllocFtraceEvent";
}


// ===================================================================

void Ext4MballocDiscardFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MballocDiscardFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocDiscardFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
}
Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(const Ext4MballocDiscardFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
}

void Ext4MballocDiscardFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&result_len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
}

Ext4MballocDiscardFtraceEvent::~Ext4MballocDiscardFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  SharedDtor();
}

void Ext4MballocDiscardFtraceEvent::SharedDtor() {
}

void Ext4MballocDiscardFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MballocDiscardFtraceEvent& Ext4MballocDiscardFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MballocDiscardFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MballocDiscardFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MballocDiscardFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_result_start(&has_bits);
          result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 result_group = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_result_group(&has_bits);
          result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_result_len(&has_bits);
          result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MballocDiscardFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_start = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_result_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 result_group = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_result_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_result_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MballocDiscardFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int32 result_start = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->result_start(), output);
  }

  // optional uint32 result_group = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->result_group(), output);
  }

  // optional int32 result_len = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->result_len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MballocDiscardFtraceEvent)
}

size_t Ext4MballocDiscardFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int32 result_start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_start());
    }

    // optional uint32 result_group = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->result_group());
    }

    // optional int32 result_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MballocDiscardFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MballocDiscardFtraceEvent*>(
      &from));
}

void Ext4MballocDiscardFtraceEvent::MergeFrom(const Ext4MballocDiscardFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      result_start_ = from.result_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      result_group_ = from.result_group_;
    }
    if (cached_has_bits & 0x00000010u) {
      result_len_ = from.result_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MballocDiscardFtraceEvent::CopyFrom(const Ext4MballocDiscardFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocDiscardFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocDiscardFtraceEvent::InternalSwap(Ext4MballocDiscardFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(result_start_, other->result_start_);
  swap(result_group_, other->result_group_);
  swap(result_len_, other->result_len_);
}

std::string Ext4MballocDiscardFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MballocDiscardFtraceEvent";
}


// ===================================================================

void Ext4MballocFreeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MballocFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocFreeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
}
Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(const Ext4MballocFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
}

void Ext4MballocFreeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&result_len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
}

Ext4MballocFreeFtraceEvent::~Ext4MballocFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
  SharedDtor();
}

void Ext4MballocFreeFtraceEvent::SharedDtor() {
}

void Ext4MballocFreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MballocFreeFtraceEvent& Ext4MballocFreeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MballocFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MballocFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MballocFreeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_result_start(&has_bits);
          result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 result_group = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_result_group(&has_bits);
          result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_result_len(&has_bits);
          result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MballocFreeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_start = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_result_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 result_group = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_result_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_result_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MballocFreeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MballocFreeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MballocFreeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int32 result_start = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->result_start(), output);
  }

  // optional uint32 result_group = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->result_group(), output);
  }

  // optional int32 result_len = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->result_len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MballocFreeFtraceEvent)
}

size_t Ext4MballocFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int32 result_start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_start());
    }

    // optional uint32 result_group = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->result_group());
    }

    // optional int32 result_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MballocFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MballocFreeFtraceEvent*>(
      &from));
}

void Ext4MballocFreeFtraceEvent::MergeFrom(const Ext4MballocFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      result_start_ = from.result_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      result_group_ = from.result_group_;
    }
    if (cached_has_bits & 0x00000010u) {
      result_len_ = from.result_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MballocFreeFtraceEvent::CopyFrom(const Ext4MballocFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocFreeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocFreeFtraceEvent::InternalSwap(Ext4MballocFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(result_start_, other->result_start_);
  swap(result_group_, other->result_group_);
  swap(result_len_, other->result_len_);
}

std::string Ext4MballocFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MballocFreeFtraceEvent";
}


// ===================================================================

void Ext4MballocPreallocFtraceEvent::InitAsDefaultInstance() {
}
class Ext4MballocPreallocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocPreallocFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orig_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_orig_group(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_orig_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_result_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
}
Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(const Ext4MballocPreallocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
}

void Ext4MballocPreallocFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&result_len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
}

Ext4MballocPreallocFtraceEvent::~Ext4MballocPreallocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  SharedDtor();
}

void Ext4MballocPreallocFtraceEvent::SharedDtor() {
}

void Ext4MballocPreallocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4MballocPreallocFtraceEvent& Ext4MballocPreallocFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4MballocPreallocFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4MballocPreallocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_start_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(result_start_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&result_group_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_len_) -
        reinterpret_cast<char*>(&result_group_)) + sizeof(result_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4MballocPreallocFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 orig_logical = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_orig_logical(&has_bits);
          orig_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 orig_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_orig_start(&has_bits);
          orig_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 orig_group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_orig_group(&has_bits);
          orig_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 orig_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_orig_len(&has_bits);
          orig_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 result_logical = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_result_logical(&has_bits);
          result_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_start = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_result_start(&has_bits);
          result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 result_group = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_result_group(&has_bits);
          result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 result_len = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_result_len(&has_bits);
          result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4MballocPreallocFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 orig_logical = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_orig_logical(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &orig_logical_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 orig_start = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_orig_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &orig_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 orig_group = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_orig_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &orig_group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 orig_len = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_orig_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &orig_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 result_logical = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_result_logical(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_logical_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_start = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_result_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 result_group = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_result_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 result_len = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_result_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4MballocPreallocFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 orig_logical = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->orig_logical(), output);
  }

  // optional int32 orig_start = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->orig_start(), output);
  }

  // optional uint32 orig_group = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->orig_group(), output);
  }

  // optional int32 orig_len = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->orig_len(), output);
  }

  // optional uint32 result_logical = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->result_logical(), output);
  }

  // optional int32 result_start = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->result_start(), output);
  }

  // optional uint32 result_group = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->result_group(), output);
  }

  // optional int32 result_len = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(10, this->result_len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4MballocPreallocFtraceEvent)
}

size_t Ext4MballocPreallocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 orig_logical = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->orig_logical());
    }

    // optional int32 orig_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->orig_start());
    }

    // optional uint32 orig_group = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->orig_group());
    }

    // optional int32 orig_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->orig_len());
    }

    // optional uint32 result_logical = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->result_logical());
    }

    // optional int32 result_start = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_start());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 result_group = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->result_group());
    }

    // optional int32 result_len = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->result_len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MballocPreallocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4MballocPreallocFtraceEvent*>(
      &from));
}

void Ext4MballocPreallocFtraceEvent::MergeFrom(const Ext4MballocPreallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      orig_logical_ = from.orig_logical_;
    }
    if (cached_has_bits & 0x00000008u) {
      orig_start_ = from.orig_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      orig_group_ = from.orig_group_;
    }
    if (cached_has_bits & 0x00000020u) {
      orig_len_ = from.orig_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      result_logical_ = from.result_logical_;
    }
    if (cached_has_bits & 0x00000080u) {
      result_start_ = from.result_start_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      result_group_ = from.result_group_;
    }
    if (cached_has_bits & 0x00000200u) {
      result_len_ = from.result_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4MballocPreallocFtraceEvent::CopyFrom(const Ext4MballocPreallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocPreallocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocPreallocFtraceEvent::InternalSwap(Ext4MballocPreallocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(orig_logical_, other->orig_logical_);
  swap(orig_start_, other->orig_start_);
  swap(orig_group_, other->orig_group_);
  swap(orig_len_, other->orig_len_);
  swap(result_logical_, other->result_logical_);
  swap(result_start_, other->result_start_);
  swap(result_group_, other->result_group_);
  swap(result_len_, other->result_len_);
}

std::string Ext4MballocPreallocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MballocPreallocFtraceEvent";
}


// ===================================================================

void Ext4OtherInodeUpdateTimeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4OtherInodeUpdateTimeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4OtherInodeUpdateTimeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
}
Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(const Ext4OtherInodeUpdateTimeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
}

void Ext4OtherInodeUpdateTimeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4OtherInodeUpdateTimeFtraceEvent::~Ext4OtherInodeUpdateTimeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  SharedDtor();
}

void Ext4OtherInodeUpdateTimeFtraceEvent::SharedDtor() {
}

void Ext4OtherInodeUpdateTimeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4OtherInodeUpdateTimeFtraceEvent& Ext4OtherInodeUpdateTimeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4OtherInodeUpdateTimeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4OtherInodeUpdateTimeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4OtherInodeUpdateTimeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 orig_ino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_orig_ino(&has_bits);
          orig_ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 uid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_uid(&has_bits);
          uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_gid(&has_bits);
          gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4OtherInodeUpdateTimeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 orig_ino = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_orig_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &orig_ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 uid = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_uid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gid = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_gid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4OtherInodeUpdateTimeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 orig_ino = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->orig_ino(), output);
  }

  // optional uint32 uid = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->uid(), output);
  }

  // optional uint32 gid = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->gid(), output);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
}

size_t Ext4OtherInodeUpdateTimeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 orig_ino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->orig_ino());
    }

    // optional uint32 uid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // optional uint32 gid = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gid());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4OtherInodeUpdateTimeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4OtherInodeUpdateTimeFtraceEvent*>(
      &from));
}

void Ext4OtherInodeUpdateTimeFtraceEvent::MergeFrom(const Ext4OtherInodeUpdateTimeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      orig_ino_ = from.orig_ino_;
    }
    if (cached_has_bits & 0x00000008u) {
      uid_ = from.uid_;
    }
    if (cached_has_bits & 0x00000010u) {
      gid_ = from.gid_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4OtherInodeUpdateTimeFtraceEvent::CopyFrom(const Ext4OtherInodeUpdateTimeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4OtherInodeUpdateTimeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4OtherInodeUpdateTimeFtraceEvent::InternalSwap(Ext4OtherInodeUpdateTimeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(orig_ino_, other->orig_ino_);
  swap(uid_, other->uid_);
  swap(gid_, other->gid_);
  swap(mode_, other->mode_);
}

std::string Ext4OtherInodeUpdateTimeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent";
}


// ===================================================================

void Ext4PunchHoleFtraceEvent::InitAsDefaultInstance() {
}
class Ext4PunchHoleFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4PunchHoleFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
}
Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(const Ext4PunchHoleFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
}

void Ext4PunchHoleFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4PunchHoleFtraceEvent::~Ext4PunchHoleFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
  SharedDtor();
}

void Ext4PunchHoleFtraceEvent::SharedDtor() {
}

void Ext4PunchHoleFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4PunchHoleFtraceEvent& Ext4PunchHoleFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4PunchHoleFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4PunchHoleFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4PunchHoleFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4PunchHoleFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 offset = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 mode = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4PunchHoleFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4PunchHoleFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4PunchHoleFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->offset(), output);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->len(), output);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4PunchHoleFtraceEvent)
}

size_t Ext4PunchHoleFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->len());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4PunchHoleFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4PunchHoleFtraceEvent*>(
      &from));
}

void Ext4PunchHoleFtraceEvent::MergeFrom(const Ext4PunchHoleFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4PunchHoleFtraceEvent::CopyFrom(const Ext4PunchHoleFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4PunchHoleFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4PunchHoleFtraceEvent::InternalSwap(Ext4PunchHoleFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(offset_, other->offset_);
  swap(len_, other->len_);
  swap(mode_, other->mode_);
}

std::string Ext4PunchHoleFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4PunchHoleFtraceEvent";
}


// ===================================================================

void Ext4ReadBlockBitmapLoadFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ReadBlockBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReadBlockBitmapLoadFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
}
Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(const Ext4ReadBlockBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
}

void Ext4ReadBlockBitmapLoadFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&group_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(group_));
}

Ext4ReadBlockBitmapLoadFtraceEvent::~Ext4ReadBlockBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  SharedDtor();
}

void Ext4ReadBlockBitmapLoadFtraceEvent::SharedDtor() {
}

void Ext4ReadBlockBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ReadBlockBitmapLoadFtraceEvent& Ext4ReadBlockBitmapLoadFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ReadBlockBitmapLoadFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ReadBlockBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ReadBlockBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ReadBlockBitmapLoadFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 group = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ReadBlockBitmapLoadFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->group(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
}

size_t Ext4ReadBlockBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->group());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ReadBlockBitmapLoadFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ReadBlockBitmapLoadFtraceEvent*>(
      &from));
}

void Ext4ReadBlockBitmapLoadFtraceEvent::MergeFrom(const Ext4ReadBlockBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_ = from.group_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ReadBlockBitmapLoadFtraceEvent::CopyFrom(const Ext4ReadBlockBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReadBlockBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReadBlockBitmapLoadFtraceEvent::InternalSwap(Ext4ReadBlockBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(group_, other->group_);
}

std::string Ext4ReadBlockBitmapLoadFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent";
}


// ===================================================================

void Ext4ReadpageFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ReadpageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReadpageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ReadpageFtraceEvent)
}
Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(const Ext4ReadpageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReadpageFtraceEvent)
}

void Ext4ReadpageFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(index_));
}

Ext4ReadpageFtraceEvent::~Ext4ReadpageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReadpageFtraceEvent)
  SharedDtor();
}

void Ext4ReadpageFtraceEvent::SharedDtor() {
}

void Ext4ReadpageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ReadpageFtraceEvent& Ext4ReadpageFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ReadpageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ReadpageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ReadpageFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ReadpageFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 index = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ReadpageFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ReadpageFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ReadpageFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->index(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ReadpageFtraceEvent)
}

size_t Ext4ReadpageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->index());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ReadpageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ReadpageFtraceEvent*>(
      &from));
}

void Ext4ReadpageFtraceEvent::MergeFrom(const Ext4ReadpageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ReadpageFtraceEvent::CopyFrom(const Ext4ReadpageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReadpageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReadpageFtraceEvent::InternalSwap(Ext4ReadpageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(index_, other->index_);
}

std::string Ext4ReadpageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ReadpageFtraceEvent";
}


// ===================================================================

void Ext4ReleasepageFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ReleasepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReleasepageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
}
Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(const Ext4ReleasepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
}

void Ext4ReleasepageFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(index_));
}

Ext4ReleasepageFtraceEvent::~Ext4ReleasepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
  SharedDtor();
}

void Ext4ReleasepageFtraceEvent::SharedDtor() {
}

void Ext4ReleasepageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ReleasepageFtraceEvent& Ext4ReleasepageFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ReleasepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ReleasepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ReleasepageFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ReleasepageFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 index = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ReleasepageFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ReleasepageFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ReleasepageFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->index(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ReleasepageFtraceEvent)
}

size_t Ext4ReleasepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->index());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ReleasepageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ReleasepageFtraceEvent*>(
      &from));
}

void Ext4ReleasepageFtraceEvent::MergeFrom(const Ext4ReleasepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ReleasepageFtraceEvent::CopyFrom(const Ext4ReleasepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReleasepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReleasepageFtraceEvent::InternalSwap(Ext4ReleasepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(index_, other->index_);
}

std::string Ext4ReleasepageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ReleasepageFtraceEvent";
}


// ===================================================================

void Ext4RemoveBlocksFtraceEvent::InitAsDefaultInstance() {
}
class Ext4RemoveBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RemoveBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ee_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ee_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ee_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
}
Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(const Ext4RemoveBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ee_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ee_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
}

void Ext4RemoveBlocksFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ee_len_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ee_len_));
}

Ext4RemoveBlocksFtraceEvent::~Ext4RemoveBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  SharedDtor();
}

void Ext4RemoveBlocksFtraceEvent::SharedDtor() {
}

void Ext4RemoveBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4RemoveBlocksFtraceEvent& Ext4RemoveBlocksFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4RemoveBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4RemoveBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ee_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ee_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4RemoveBlocksFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_from(&has_bits);
          from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_to(&has_bits);
          to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 partial = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_partial(&has_bits);
          partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ee_pblk = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ee_pblk(&has_bits);
          ee_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ee_lblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_ee_lblk(&has_bits);
          ee_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ee_len = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_ee_len(&has_bits);
          ee_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4RemoveBlocksFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 from = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_from(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 to = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_to(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 partial = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_partial(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &partial_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ee_pblk = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_ee_pblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ee_pblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ee_lblk = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_ee_lblk(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ee_lblk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ee_len = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_ee_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ee_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4RemoveBlocksFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 from = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->from(), output);
  }

  // optional uint32 to = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->to(), output);
  }

  // optional int64 partial = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->partial(), output);
  }

  // optional uint64 ee_pblk = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->ee_pblk(), output);
  }

  // optional uint32 ee_lblk = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->ee_lblk(), output);
  }

  // optional uint32 ee_len = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->ee_len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
}

size_t Ext4RemoveBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 from = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->from());
    }

    // optional uint32 to = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->to());
    }

    // optional int64 partial = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->partial());
    }

    // optional uint64 ee_pblk = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ee_pblk());
    }

    // optional uint32 ee_lblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ee_lblk());
    }

    // optional uint32 ee_len = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ee_len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4RemoveBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4RemoveBlocksFtraceEvent*>(
      &from));
}

void Ext4RemoveBlocksFtraceEvent::MergeFrom(const Ext4RemoveBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      from_ = from.from_;
    }
    if (cached_has_bits & 0x00000008u) {
      to_ = from.to_;
    }
    if (cached_has_bits & 0x00000010u) {
      partial_ = from.partial_;
    }
    if (cached_has_bits & 0x00000020u) {
      ee_pblk_ = from.ee_pblk_;
    }
    if (cached_has_bits & 0x00000040u) {
      ee_lblk_ = from.ee_lblk_;
    }
    if (cached_has_bits & 0x00000080u) {
      ee_len_ = from.ee_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4RemoveBlocksFtraceEvent::CopyFrom(const Ext4RemoveBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RemoveBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RemoveBlocksFtraceEvent::InternalSwap(Ext4RemoveBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(from_, other->from_);
  swap(to_, other->to_);
  swap(partial_, other->partial_);
  swap(ee_pblk_, other->ee_pblk_);
  swap(ee_lblk_, other->ee_lblk_);
  swap(ee_len_, other->ee_len_);
}

std::string Ext4RemoveBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4RemoveBlocksFtraceEvent";
}


// ===================================================================

void Ext4RequestBlocksFtraceEvent::InitAsDefaultInstance() {
}
class Ext4RequestBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RequestBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lleft(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lright(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pleft(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pright(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
}
Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(const Ext4RequestBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
}

void Ext4RequestBlocksFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4RequestBlocksFtraceEvent::~Ext4RequestBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  SharedDtor();
}

void Ext4RequestBlocksFtraceEvent::SharedDtor() {
}

void Ext4RequestBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4RequestBlocksFtraceEvent& Ext4RequestBlocksFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4RequestBlocksFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4RequestBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pleft_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pleft_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&pright_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&pright_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4RequestBlocksFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 logical = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_logical(&has_bits);
          logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lleft = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_lleft(&has_bits);
          lleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lright = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_lright(&has_bits);
          lright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 goal = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_goal(&has_bits);
          goal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pleft = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_pleft(&has_bits);
          pleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pright = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_pright(&has_bits);
          pright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4RequestBlocksFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 logical = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_logical(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &logical_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lleft = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_lleft(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lleft_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lright = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_lright(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lright_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 goal = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_goal(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &goal_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pleft = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_pleft(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pleft_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pright = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_pright(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pright_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4RequestBlocksFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint32 len = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->len(), output);
  }

  // optional uint32 logical = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->logical(), output);
  }

  // optional uint32 lleft = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->lleft(), output);
  }

  // optional uint32 lright = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->lright(), output);
  }

  // optional uint64 goal = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(7, this->goal(), output);
  }

  // optional uint64 pleft = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(8, this->pleft(), output);
  }

  // optional uint64 pright = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(9, this->pright(), output);
  }

  // optional uint32 flags = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(10, this->flags(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4RequestBlocksFtraceEvent)
}

size_t Ext4RequestBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint32 len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 logical = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->logical());
    }

    // optional uint32 lleft = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lleft());
    }

    // optional uint32 lright = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lright());
    }

    // optional uint64 goal = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->goal());
    }

    // optional uint64 pleft = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pleft());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 pright = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pright());
    }

    // optional uint32 flags = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4RequestBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4RequestBlocksFtraceEvent*>(
      &from));
}

void Ext4RequestBlocksFtraceEvent::MergeFrom(const Ext4RequestBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000008u) {
      logical_ = from.logical_;
    }
    if (cached_has_bits & 0x00000010u) {
      lleft_ = from.lleft_;
    }
    if (cached_has_bits & 0x00000020u) {
      lright_ = from.lright_;
    }
    if (cached_has_bits & 0x00000040u) {
      goal_ = from.goal_;
    }
    if (cached_has_bits & 0x00000080u) {
      pleft_ = from.pleft_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      pright_ = from.pright_;
    }
    if (cached_has_bits & 0x00000200u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4RequestBlocksFtraceEvent::CopyFrom(const Ext4RequestBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RequestBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RequestBlocksFtraceEvent::InternalSwap(Ext4RequestBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(len_, other->len_);
  swap(logical_, other->logical_);
  swap(lleft_, other->lleft_);
  swap(lright_, other->lright_);
  swap(goal_, other->goal_);
  swap(pleft_, other->pleft_);
  swap(pright_, other->pright_);
  swap(flags_, other->flags_);
}

std::string Ext4RequestBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4RequestBlocksFtraceEvent";
}


// ===================================================================

void Ext4RequestInodeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4RequestInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RequestInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
}
Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(const Ext4RequestInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
}

void Ext4RequestInodeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4RequestInodeFtraceEvent::~Ext4RequestInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
  SharedDtor();
}

void Ext4RequestInodeFtraceEvent::SharedDtor() {
}

void Ext4RequestInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4RequestInodeFtraceEvent& Ext4RequestInodeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4RequestInodeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4RequestInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4RequestInodeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_dir(&has_bits);
          dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4RequestInodeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 dir = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_dir(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dir_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 mode = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4RequestInodeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4RequestInodeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4RequestInodeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 dir = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->dir(), output);
  }

  // optional uint32 mode = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4RequestInodeFtraceEvent)
}

size_t Ext4RequestInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dir());
    }

    // optional uint32 mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4RequestInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4RequestInodeFtraceEvent*>(
      &from));
}

void Ext4RequestInodeFtraceEvent::MergeFrom(const Ext4RequestInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      dir_ = from.dir_;
    }
    if (cached_has_bits & 0x00000004u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4RequestInodeFtraceEvent::CopyFrom(const Ext4RequestInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RequestInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RequestInodeFtraceEvent::InternalSwap(Ext4RequestInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(dir_, other->dir_);
  swap(mode_, other->mode_);
}

std::string Ext4RequestInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4RequestInodeFtraceEvent";
}


// ===================================================================

void Ext4SyncFsFtraceEvent::InitAsDefaultInstance() {
}
class Ext4SyncFsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4SyncFsFtraceEvent)
}
Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(const Ext4SyncFsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&wait_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFsFtraceEvent)
}

void Ext4SyncFsFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&wait_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
}

Ext4SyncFsFtraceEvent::~Ext4SyncFsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFsFtraceEvent)
  SharedDtor();
}

void Ext4SyncFsFtraceEvent::SharedDtor() {
}

void Ext4SyncFsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4SyncFsFtraceEvent& Ext4SyncFsFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4SyncFsFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4SyncFsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&wait_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4SyncFsFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 wait = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_wait(&has_bits);
          wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4SyncFsFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 wait = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_wait(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &wait_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4SyncFsFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4SyncFsFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4SyncFsFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional int32 wait = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->wait(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4SyncFsFtraceEvent)
}

size_t Ext4SyncFsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional int32 wait = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->wait());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4SyncFsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4SyncFsFtraceEvent*>(
      &from));
}

void Ext4SyncFsFtraceEvent::MergeFrom(const Ext4SyncFsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      wait_ = from.wait_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4SyncFsFtraceEvent::CopyFrom(const Ext4SyncFsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFsFtraceEvent::InternalSwap(Ext4SyncFsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(wait_, other->wait_);
}

std::string Ext4SyncFsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4SyncFsFtraceEvent";
}


// ===================================================================

void Ext4TrimAllFreeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4TrimAllFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TrimAllFreeFtraceEvent>()._has_bits_);
  static void set_has_dev_major(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dev_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
}
Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(const Ext4TrimAllFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_major_, &from.dev_major_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
}

void Ext4TrimAllFreeFtraceEvent::SharedCtor() {
  ::memset(&dev_major_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
}

Ext4TrimAllFreeFtraceEvent::~Ext4TrimAllFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  SharedDtor();
}

void Ext4TrimAllFreeFtraceEvent::SharedDtor() {
}

void Ext4TrimAllFreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4TrimAllFreeFtraceEvent& Ext4TrimAllFreeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4TrimAllFreeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4TrimAllFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_major_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4TrimAllFreeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 dev_major = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev_major(&has_bits);
          dev_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 dev_minor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_dev_minor(&has_bits);
          dev_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4TrimAllFreeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 dev_major = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev_major(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &dev_major_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 dev_minor = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_dev_minor(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &dev_minor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 group = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 start = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4TrimAllFreeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 dev_major = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->dev_major(), output);
  }

  // optional int32 dev_minor = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->dev_minor(), output);
  }

  // optional uint32 group = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->group(), output);
  }

  // optional int32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->start(), output);
  }

  // optional int32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
}

size_t Ext4TrimAllFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 dev_major = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->dev_major());
    }

    // optional int32 dev_minor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->dev_minor());
    }

    // optional uint32 group = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->group());
    }

    // optional int32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->start());
    }

    // optional int32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4TrimAllFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4TrimAllFreeFtraceEvent*>(
      &from));
}

void Ext4TrimAllFreeFtraceEvent::MergeFrom(const Ext4TrimAllFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_major_ = from.dev_major_;
    }
    if (cached_has_bits & 0x00000002u) {
      dev_minor_ = from.dev_minor_;
    }
    if (cached_has_bits & 0x00000004u) {
      group_ = from.group_;
    }
    if (cached_has_bits & 0x00000008u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4TrimAllFreeFtraceEvent::CopyFrom(const Ext4TrimAllFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TrimAllFreeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TrimAllFreeFtraceEvent::InternalSwap(Ext4TrimAllFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_major_, other->dev_major_);
  swap(dev_minor_, other->dev_minor_);
  swap(group_, other->group_);
  swap(start_, other->start_);
  swap(len_, other->len_);
}

std::string Ext4TrimAllFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4TrimAllFreeFtraceEvent";
}


// ===================================================================

void Ext4TrimExtentFtraceEvent::InitAsDefaultInstance() {
}
class Ext4TrimExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TrimExtentFtraceEvent>()._has_bits_);
  static void set_has_dev_major(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dev_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
}
Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(const Ext4TrimExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_major_, &from.dev_major_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
}

void Ext4TrimExtentFtraceEvent::SharedCtor() {
  ::memset(&dev_major_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
}

Ext4TrimExtentFtraceEvent::~Ext4TrimExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
  SharedDtor();
}

void Ext4TrimExtentFtraceEvent::SharedDtor() {
}

void Ext4TrimExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4TrimExtentFtraceEvent& Ext4TrimExtentFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4TrimExtentFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4TrimExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_major_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4TrimExtentFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 dev_major = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev_major(&has_bits);
          dev_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 dev_minor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_dev_minor(&has_bits);
          dev_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4TrimExtentFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 dev_major = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev_major(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &dev_major_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 dev_minor = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_dev_minor(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &dev_minor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 group = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_group(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 start = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 len = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4TrimExtentFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4TrimExtentFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4TrimExtentFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 dev_major = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->dev_major(), output);
  }

  // optional int32 dev_minor = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->dev_minor(), output);
  }

  // optional uint32 group = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->group(), output);
  }

  // optional int32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->start(), output);
  }

  // optional int32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->len(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4TrimExtentFtraceEvent)
}

size_t Ext4TrimExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 dev_major = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->dev_major());
    }

    // optional int32 dev_minor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->dev_minor());
    }

    // optional uint32 group = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->group());
    }

    // optional int32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->start());
    }

    // optional int32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->len());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4TrimExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4TrimExtentFtraceEvent*>(
      &from));
}

void Ext4TrimExtentFtraceEvent::MergeFrom(const Ext4TrimExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_major_ = from.dev_major_;
    }
    if (cached_has_bits & 0x00000002u) {
      dev_minor_ = from.dev_minor_;
    }
    if (cached_has_bits & 0x00000004u) {
      group_ = from.group_;
    }
    if (cached_has_bits & 0x00000008u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4TrimExtentFtraceEvent::CopyFrom(const Ext4TrimExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TrimExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TrimExtentFtraceEvent::InternalSwap(Ext4TrimExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_major_, other->dev_major_);
  swap(dev_minor_, other->dev_minor_);
  swap(group_, other->group_);
  swap(start_, other->start_);
  swap(len_, other->len_);
}

std::string Ext4TrimExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4TrimExtentFtraceEvent";
}


// ===================================================================

void Ext4TruncateEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4TruncateEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TruncateEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
}
Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(const Ext4TruncateEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
}

void Ext4TruncateEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&blocks_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
}

Ext4TruncateEnterFtraceEvent::~Ext4TruncateEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  SharedDtor();
}

void Ext4TruncateEnterFtraceEvent::SharedDtor() {
}

void Ext4TruncateEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4TruncateEnterFtraceEvent& Ext4TruncateEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4TruncateEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4TruncateEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4TruncateEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4TruncateEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 blocks = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4TruncateEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->blocks(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4TruncateEnterFtraceEvent)
}

size_t Ext4TruncateEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->blocks());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4TruncateEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4TruncateEnterFtraceEvent*>(
      &from));
}

void Ext4TruncateEnterFtraceEvent::MergeFrom(const Ext4TruncateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      blocks_ = from.blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4TruncateEnterFtraceEvent::CopyFrom(const Ext4TruncateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TruncateEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TruncateEnterFtraceEvent::InternalSwap(Ext4TruncateEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(blocks_, other->blocks_);
}

std::string Ext4TruncateEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4TruncateEnterFtraceEvent";
}


// ===================================================================

void Ext4TruncateExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4TruncateExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TruncateExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
}
Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(const Ext4TruncateExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
}

void Ext4TruncateExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&blocks_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
}

Ext4TruncateExitFtraceEvent::~Ext4TruncateExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
  SharedDtor();
}

void Ext4TruncateExitFtraceEvent::SharedDtor() {
}

void Ext4TruncateExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4TruncateExitFtraceEvent& Ext4TruncateExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4TruncateExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4TruncateExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4TruncateExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4TruncateExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 blocks = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_blocks(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4TruncateExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4TruncateExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4TruncateExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->blocks(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4TruncateExitFtraceEvent)
}

size_t Ext4TruncateExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->blocks());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4TruncateExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4TruncateExitFtraceEvent*>(
      &from));
}

void Ext4TruncateExitFtraceEvent::MergeFrom(const Ext4TruncateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      blocks_ = from.blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4TruncateExitFtraceEvent::CopyFrom(const Ext4TruncateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TruncateExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TruncateExitFtraceEvent::InternalSwap(Ext4TruncateExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(blocks_, other->blocks_);
}

std::string Ext4TruncateExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4TruncateExitFtraceEvent";
}


// ===================================================================

void Ext4UnlinkEnterFtraceEvent::InitAsDefaultInstance() {
}
class Ext4UnlinkEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4UnlinkEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
}
Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(const Ext4UnlinkEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
}

void Ext4UnlinkEnterFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&size_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(size_));
}

Ext4UnlinkEnterFtraceEvent::~Ext4UnlinkEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  SharedDtor();
}

void Ext4UnlinkEnterFtraceEvent::SharedDtor() {
}

void Ext4UnlinkEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4UnlinkEnterFtraceEvent& Ext4UnlinkEnterFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4UnlinkEnterFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4UnlinkEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&size_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4UnlinkEnterFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_parent(&has_bits);
          parent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4UnlinkEnterFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 parent = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_parent(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &parent_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 size = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4UnlinkEnterFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 parent = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->parent(), output);
  }

  // optional int64 size = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
}

size_t Ext4UnlinkEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 parent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->parent());
    }

    // optional int64 size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4UnlinkEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4UnlinkEnterFtraceEvent*>(
      &from));
}

void Ext4UnlinkEnterFtraceEvent::MergeFrom(const Ext4UnlinkEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      parent_ = from.parent_;
    }
    if (cached_has_bits & 0x00000008u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4UnlinkEnterFtraceEvent::CopyFrom(const Ext4UnlinkEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4UnlinkEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4UnlinkEnterFtraceEvent::InternalSwap(Ext4UnlinkEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(parent_, other->parent_);
  swap(size_, other->size_);
}

std::string Ext4UnlinkEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4UnlinkEnterFtraceEvent";
}


// ===================================================================

void Ext4UnlinkExitFtraceEvent::InitAsDefaultInstance() {
}
class Ext4UnlinkExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4UnlinkExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
}
Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(const Ext4UnlinkExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
}

void Ext4UnlinkExitFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ret_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4UnlinkExitFtraceEvent::~Ext4UnlinkExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  SharedDtor();
}

void Ext4UnlinkExitFtraceEvent::SharedDtor() {
}

void Ext4UnlinkExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4UnlinkExitFtraceEvent& Ext4UnlinkExitFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4UnlinkExitFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4UnlinkExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4UnlinkExitFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4UnlinkExitFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4UnlinkExitFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->ret(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4UnlinkExitFtraceEvent)
}

size_t Ext4UnlinkExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4UnlinkExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4UnlinkExitFtraceEvent*>(
      &from));
}

void Ext4UnlinkExitFtraceEvent::MergeFrom(const Ext4UnlinkExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4UnlinkExitFtraceEvent::CopyFrom(const Ext4UnlinkExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4UnlinkExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4UnlinkExitFtraceEvent::InternalSwap(Ext4UnlinkExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(ret_, other->ret_);
}

std::string Ext4UnlinkExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4UnlinkExitFtraceEvent";
}


// ===================================================================

void Ext4WriteBeginFtraceEvent::InitAsDefaultInstance() {
}
class Ext4WriteBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WriteBeginFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
}
Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(const Ext4WriteBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
}

void Ext4WriteBeginFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4WriteBeginFtraceEvent::~Ext4WriteBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
  SharedDtor();
}

void Ext4WriteBeginFtraceEvent::SharedDtor() {
}

void Ext4WriteBeginFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4WriteBeginFtraceEvent& Ext4WriteBeginFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4WriteBeginFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4WriteBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4WriteBeginFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4WriteBeginFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_flags(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4WriteBeginFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4WriteBeginFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4WriteBeginFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->pos(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->flags(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4WriteBeginFtraceEvent)
}

size_t Ext4WriteBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WriteBeginFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4WriteBeginFtraceEvent*>(
      &from));
}

void Ext4WriteBeginFtraceEvent::MergeFrom(const Ext4WriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4WriteBeginFtraceEvent::CopyFrom(const Ext4WriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WriteBeginFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WriteBeginFtraceEvent::InternalSwap(Ext4WriteBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pos_, other->pos_);
  swap(len_, other->len_);
  swap(flags_, other->flags_);
}

std::string Ext4WriteBeginFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WriteBeginFtraceEvent";
}


// ===================================================================

void Ext4WriteEndFtraceEvent::InitAsDefaultInstance() {
}
class Ext4WriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WriteEndFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4WriteEndFtraceEvent)
}
Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(const Ext4WriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WriteEndFtraceEvent)
}

void Ext4WriteEndFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&copied_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
}

Ext4WriteEndFtraceEvent::~Ext4WriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WriteEndFtraceEvent)
  SharedDtor();
}

void Ext4WriteEndFtraceEvent::SharedDtor() {
}

void Ext4WriteEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4WriteEndFtraceEvent& Ext4WriteEndFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4WriteEndFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4WriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&copied_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4WriteEndFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4WriteEndFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pos = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_pos(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 copied = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_copied(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &copied_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4WriteEndFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4WriteEndFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4WriteEndFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->pos(), output);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->len(), output);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->copied(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4WriteEndFtraceEvent)
}

size_t Ext4WriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->copied());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WriteEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4WriteEndFtraceEvent*>(
      &from));
}

void Ext4WriteEndFtraceEvent::MergeFrom(const Ext4WriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      copied_ = from.copied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4WriteEndFtraceEvent::CopyFrom(const Ext4WriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WriteEndFtraceEvent::InternalSwap(Ext4WriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(pos_, other->pos_);
  swap(len_, other->len_);
  swap(copied_, other->copied_);
}

std::string Ext4WriteEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WriteEndFtraceEvent";
}


// ===================================================================

void Ext4WritepageFtraceEvent::InitAsDefaultInstance() {
}
class Ext4WritepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4WritepageFtraceEvent)
}
Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(const Ext4WritepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepageFtraceEvent)
}

void Ext4WritepageFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(index_));
}

Ext4WritepageFtraceEvent::~Ext4WritepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepageFtraceEvent)
  SharedDtor();
}

void Ext4WritepageFtraceEvent::SharedDtor() {
}

void Ext4WritepageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4WritepageFtraceEvent& Ext4WritepageFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4WritepageFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4WritepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4WritepageFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4WritepageFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4WritepageFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 index = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4WritepageFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4WritepageFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4WritepageFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4WritepageFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->index(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4WritepageFtraceEvent)
}

size_t Ext4WritepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepageFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->index());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WritepageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4WritepageFtraceEvent*>(
      &from));
}

void Ext4WritepageFtraceEvent::MergeFrom(const Ext4WritepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4WritepageFtraceEvent::CopyFrom(const Ext4WritepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepageFtraceEvent::InternalSwap(Ext4WritepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(index_, other->index_);
}

std::string Ext4WritepageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WritepageFtraceEvent";
}


// ===================================================================

void Ext4WritepagesFtraceEvent::InitAsDefaultInstance() {
}
class Ext4WritepagesFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepagesFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nr_to_write(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pages_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_range_start(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_range_end(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_writeback_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_for_kupdate(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_range_cyclic(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4WritepagesFtraceEvent)
}
Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(const Ext4WritepagesFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&range_cyclic_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(range_cyclic_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepagesFtraceEvent)
}

void Ext4WritepagesFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&range_cyclic_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(range_cyclic_));
}

Ext4WritepagesFtraceEvent::~Ext4WritepagesFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepagesFtraceEvent)
  SharedDtor();
}

void Ext4WritepagesFtraceEvent::SharedDtor() {
}

void Ext4WritepagesFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4WritepagesFtraceEvent& Ext4WritepagesFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4WritepagesFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4WritepagesFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sync_mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(sync_mode_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&for_kupdate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&range_cyclic_) -
        reinterpret_cast<char*>(&for_kupdate_)) + sizeof(range_cyclic_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4WritepagesFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 nr_to_write = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_nr_to_write(&has_bits);
          nr_to_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pages_skipped = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pages_skipped(&has_bits);
          pages_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 range_start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_range_start(&has_bits);
          range_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 range_end = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_range_end(&has_bits);
          range_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 writeback_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_writeback_index(&has_bits);
          writeback_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 sync_mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_sync_mode(&has_bits);
          sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 for_kupdate = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_for_kupdate(&has_bits);
          for_kupdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 range_cyclic = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_range_cyclic(&has_bits);
          range_cyclic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4WritepagesFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 nr_to_write = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_nr_to_write(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &nr_to_write_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pages_skipped = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pages_skipped(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pages_skipped_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 range_start = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_range_start(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 range_end = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_range_end(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_end_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 writeback_index = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_writeback_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &writeback_index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sync_mode = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_sync_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &sync_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 for_kupdate = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_for_kupdate(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &for_kupdate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 range_cyclic = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_range_cyclic(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &range_cyclic_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4WritepagesFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4WritepagesFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4WritepagesFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 nr_to_write = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->nr_to_write(), output);
  }

  // optional int64 pages_skipped = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->pages_skipped(), output);
  }

  // optional int64 range_start = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->range_start(), output);
  }

  // optional int64 range_end = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(6, this->range_end(), output);
  }

  // optional uint64 writeback_index = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(7, this->writeback_index(), output);
  }

  // optional int32 sync_mode = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->sync_mode(), output);
  }

  // optional uint32 for_kupdate = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->for_kupdate(), output);
  }

  // optional uint32 range_cyclic = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(10, this->range_cyclic(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4WritepagesFtraceEvent)
}

size_t Ext4WritepagesFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 nr_to_write = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->nr_to_write());
    }

    // optional int64 pages_skipped = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pages_skipped());
    }

    // optional int64 range_start = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->range_start());
    }

    // optional int64 range_end = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->range_end());
    }

    // optional uint64 writeback_index = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->writeback_index());
    }

    // optional int32 sync_mode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->sync_mode());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 for_kupdate = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->for_kupdate());
    }

    // optional uint32 range_cyclic = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->range_cyclic());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WritepagesFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4WritepagesFtraceEvent*>(
      &from));
}

void Ext4WritepagesFtraceEvent::MergeFrom(const Ext4WritepagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      nr_to_write_ = from.nr_to_write_;
    }
    if (cached_has_bits & 0x00000008u) {
      pages_skipped_ = from.pages_skipped_;
    }
    if (cached_has_bits & 0x00000010u) {
      range_start_ = from.range_start_;
    }
    if (cached_has_bits & 0x00000020u) {
      range_end_ = from.range_end_;
    }
    if (cached_has_bits & 0x00000040u) {
      writeback_index_ = from.writeback_index_;
    }
    if (cached_has_bits & 0x00000080u) {
      sync_mode_ = from.sync_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      for_kupdate_ = from.for_kupdate_;
    }
    if (cached_has_bits & 0x00000200u) {
      range_cyclic_ = from.range_cyclic_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4WritepagesFtraceEvent::CopyFrom(const Ext4WritepagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepagesFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepagesFtraceEvent::InternalSwap(Ext4WritepagesFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(nr_to_write_, other->nr_to_write_);
  swap(pages_skipped_, other->pages_skipped_);
  swap(range_start_, other->range_start_);
  swap(range_end_, other->range_end_);
  swap(writeback_index_, other->writeback_index_);
  swap(sync_mode_, other->sync_mode_);
  swap(for_kupdate_, other->for_kupdate_);
  swap(range_cyclic_, other->range_cyclic_);
}

std::string Ext4WritepagesFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WritepagesFtraceEvent";
}


// ===================================================================

void Ext4WritepagesResultFtraceEvent::InitAsDefaultInstance() {
}
class Ext4WritepagesResultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepagesResultFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pages_written(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pages_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_writeback_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
}
Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(const Ext4WritepagesResultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&sync_mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(sync_mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
}

void Ext4WritepagesResultFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sync_mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(sync_mode_));
}

Ext4WritepagesResultFtraceEvent::~Ext4WritepagesResultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  SharedDtor();
}

void Ext4WritepagesResultFtraceEvent::SharedDtor() {
}

void Ext4WritepagesResultFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4WritepagesResultFtraceEvent& Ext4WritepagesResultFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4WritepagesResultFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4WritepagesResultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sync_mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(sync_mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4WritepagesResultFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pages_written = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_pages_written(&has_bits);
          pages_written_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 pages_skipped = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_pages_skipped(&has_bits);
          pages_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 writeback_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_writeback_index(&has_bits);
          writeback_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 sync_mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_sync_mode(&has_bits);
          sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4WritepagesResultFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ret = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_ret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pages_written = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_pages_written(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &pages_written_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 pages_skipped = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_pages_skipped(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &pages_skipped_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 writeback_index = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_writeback_index(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &writeback_index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sync_mode = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_sync_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &sync_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4WritepagesResultFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->ret(), output);
  }

  // optional int32 pages_written = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->pages_written(), output);
  }

  // optional int64 pages_skipped = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->pages_skipped(), output);
  }

  // optional uint64 writeback_index = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->writeback_index(), output);
  }

  // optional int32 sync_mode = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->sync_mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4WritepagesResultFtraceEvent)
}

size_t Ext4WritepagesResultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 pages_written = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->pages_written());
    }

    // optional int64 pages_skipped = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->pages_skipped());
    }

    // optional uint64 writeback_index = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->writeback_index());
    }

    // optional int32 sync_mode = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->sync_mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WritepagesResultFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4WritepagesResultFtraceEvent*>(
      &from));
}

void Ext4WritepagesResultFtraceEvent::MergeFrom(const Ext4WritepagesResultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    if (cached_has_bits & 0x00000008u) {
      pages_written_ = from.pages_written_;
    }
    if (cached_has_bits & 0x00000010u) {
      pages_skipped_ = from.pages_skipped_;
    }
    if (cached_has_bits & 0x00000020u) {
      writeback_index_ = from.writeback_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      sync_mode_ = from.sync_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4WritepagesResultFtraceEvent::CopyFrom(const Ext4WritepagesResultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepagesResultFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepagesResultFtraceEvent::InternalSwap(Ext4WritepagesResultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(ret_, other->ret_);
  swap(pages_written_, other->pages_written_);
  swap(pages_skipped_, other->pages_skipped_);
  swap(writeback_index_, other->writeback_index_);
  swap(sync_mode_, other->sync_mode_);
}

std::string Ext4WritepagesResultFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WritepagesResultFtraceEvent";
}


// ===================================================================

void Ext4ZeroRangeFtraceEvent::InitAsDefaultInstance() {
}
class Ext4ZeroRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ZeroRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
}
Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(const Ext4ZeroRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
}

void Ext4ZeroRangeFtraceEvent::SharedCtor() {
  ::memset(&dev_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mode_) -
      reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4ZeroRangeFtraceEvent::~Ext4ZeroRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  SharedDtor();
}

void Ext4ZeroRangeFtraceEvent::SharedDtor() {
}

void Ext4ZeroRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Ext4ZeroRangeFtraceEvent& Ext4ZeroRangeFtraceEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Ext4ZeroRangeFtraceEvent_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto.base);
  return *internal_default_instance();
}


void Ext4ZeroRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Ext4ZeroRangeFtraceEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Ext4ZeroRangeFtraceEvent::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dev = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_dev(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dev_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 ino = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_ino(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ino_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 offset = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 len = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_len(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 mode = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_mode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Ext4ZeroRangeFtraceEvent::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->dev(), output);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->ino(), output);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->offset(), output);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->len(), output);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->mode(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Ext4ZeroRangeFtraceEvent)
}

size_t Ext4ZeroRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->len());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->mode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ZeroRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Ext4ZeroRangeFtraceEvent*>(
      &from));
}

void Ext4ZeroRangeFtraceEvent::MergeFrom(const Ext4ZeroRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ext4ZeroRangeFtraceEvent::CopyFrom(const Ext4ZeroRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ZeroRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ZeroRangeFtraceEvent::InternalSwap(Ext4ZeroRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dev_, other->dev_);
  swap(ino_, other->ino_);
  swap(offset_, other->offset_);
  swap(len_, other->len_);
  swap(mode_, other->mode_);
}

std::string Ext4ZeroRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ZeroRangeFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWriteBeginFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWriteBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DaWriteBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWriteEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DaWriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFileEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFileEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4SyncFileEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFileExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFileExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4SyncFileExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocateBlocksFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocateBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4AllocateBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocateInodeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocateInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4AllocateInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4CollapseRangeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4CollapseRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4CollapseRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWritePagesFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWritePagesFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DaWritePagesFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DirectIOEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DirectIOEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DirectIOEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DirectIOExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DirectIOExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DirectIOExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DiscardBlocksFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DiscardBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DiscardBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DropInodeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DropInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4DropInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsCacheExtentFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsCacheExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsCacheExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsInsertExtentFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsInsertExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsInsertExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsShrinkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkCountFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkCountFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsShrinkCountFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EvictInodeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EvictInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4EvictInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtInCacheFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtInCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtInCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRmIdxFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRmIdxFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtRmIdxFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRmLeafFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRmLeafFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtRmLeafFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtShowExtentFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtShowExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ExtShowExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FallocateEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FallocateEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4FallocateEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FallocateExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FallocateExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4FallocateExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ForgetFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ForgetFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ForgetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FreeBlocksFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FreeBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4FreeBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FreeInodeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FreeInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4FreeInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4InsertRangeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4InsertRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4InsertRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4InvalidatepageFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4InvalidatepageFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4InvalidatepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalStartFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalStartFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4JournalStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalStartReservedFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalStartReservedFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4JournalStartReservedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4LoadInodeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4LoadInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4LoadInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbNewInodePaFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbNewInodePaFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MbNewInodePaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocAllocFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MballocAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocDiscardFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocDiscardFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MballocDiscardFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocFreeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MballocFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocPreallocFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocPreallocFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4MballocPreallocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4PunchHoleFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4PunchHoleFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4PunchHoleFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReadpageFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReadpageFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ReadpageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReleasepageFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReleasepageFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ReleasepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RemoveBlocksFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RemoveBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4RemoveBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RequestBlocksFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RequestBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4RequestBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RequestInodeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RequestInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4RequestInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFsFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFsFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4SyncFsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TrimAllFreeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TrimAllFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4TrimAllFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TrimExtentFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TrimExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4TrimExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TruncateEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TruncateEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4TruncateEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TruncateExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TruncateExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4TruncateExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4UnlinkEnterFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4UnlinkEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4UnlinkEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4UnlinkExitFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4UnlinkExitFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4UnlinkExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WriteBeginFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WriteBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4WriteBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WriteEndFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4WriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepageFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepageFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4WritepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepagesFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepagesFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4WritepagesFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepagesResultFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepagesResultFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4WritepagesResultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ZeroRangeFtraceEvent* Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ZeroRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateInternal< ::perfetto::protos::Ext4ZeroRangeFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
