// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_COMPACTION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_COMPACTION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmCompactionWakeupKcompactdFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionWakeupKcompactdFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionWakeupKcompactdFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionWakeupKcompactdFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  int32_t order() const { return at<2>().as_int32(); }
  bool has_classzone_idx() const { return at<3>().valid(); }
  uint32_t classzone_idx() const { return at<3>().as_uint32(); }
};

class MmCompactionWakeupKcompactdFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionWakeupKcompactdFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
    kClasszoneIdxFieldNumber = 3,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_classzone_idx(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionTryToCompactPagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionTryToCompactPagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionTryToCompactPagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionTryToCompactPagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_order() const { return at<1>().valid(); }
  int32_t order() const { return at<1>().as_int32(); }
  bool has_gfp_mask() const { return at<2>().valid(); }
  uint32_t gfp_mask() const { return at<2>().as_uint32(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
};

class MmCompactionTryToCompactPagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionTryToCompactPagesFtraceEvent_Decoder;
  enum : int32_t {
    kOrderFieldNumber = 1,
    kGfpMaskFieldNumber = 2,
    kModeFieldNumber = 3,
  };
  void set_order(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_gfp_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionSuitableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionSuitableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionSuitableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionSuitableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class MmCompactionSuitableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionSuitableFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionMigratepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionMigratepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionMigratepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionMigratepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nr_migrated() const { return at<1>().valid(); }
  uint64_t nr_migrated() const { return at<1>().as_uint64(); }
  bool has_nr_failed() const { return at<2>().valid(); }
  uint64_t nr_failed() const { return at<2>().as_uint64(); }
};

class MmCompactionMigratepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionMigratepagesFtraceEvent_Decoder;
  enum : int32_t {
    kNrMigratedFieldNumber = 1,
    kNrFailedFieldNumber = 2,
  };
  void set_nr_migrated(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_failed(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class MmCompactionKcompactdWakeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionKcompactdWakeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionKcompactdWakeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionKcompactdWakeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  int32_t order() const { return at<2>().as_int32(); }
  bool has_classzone_idx() const { return at<3>().valid(); }
  uint32_t classzone_idx() const { return at<3>().as_uint32(); }
};

class MmCompactionKcompactdWakeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionKcompactdWakeFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
    kClasszoneIdxFieldNumber = 3,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_classzone_idx(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionKcompactdSleepFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionKcompactdSleepFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionKcompactdSleepFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionKcompactdSleepFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
};

class MmCompactionKcompactdSleepFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionKcompactdSleepFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MmCompactionIsolateMigratepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start_pfn() const { return at<1>().valid(); }
  uint64_t start_pfn() const { return at<1>().as_uint64(); }
  bool has_end_pfn() const { return at<2>().valid(); }
  uint64_t end_pfn() const { return at<2>().as_uint64(); }
  bool has_nr_scanned() const { return at<3>().valid(); }
  uint64_t nr_scanned() const { return at<3>().as_uint64(); }
  bool has_nr_taken() const { return at<4>().valid(); }
  uint64_t nr_taken() const { return at<4>().as_uint64(); }
};

class MmCompactionIsolateMigratepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionIsolateMigratepagesFtraceEvent_Decoder;
  enum : int32_t {
    kStartPfnFieldNumber = 1,
    kEndPfnFieldNumber = 2,
    kNrScannedFieldNumber = 3,
    kNrTakenFieldNumber = 4,
  };
  void set_start_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_end_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_scanned(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_taken(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionIsolateFreepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionIsolateFreepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionIsolateFreepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionIsolateFreepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start_pfn() const { return at<1>().valid(); }
  uint64_t start_pfn() const { return at<1>().as_uint64(); }
  bool has_end_pfn() const { return at<2>().valid(); }
  uint64_t end_pfn() const { return at<2>().as_uint64(); }
  bool has_nr_scanned() const { return at<3>().valid(); }
  uint64_t nr_scanned() const { return at<3>().as_uint64(); }
  bool has_nr_taken() const { return at<4>().valid(); }
  uint64_t nr_taken() const { return at<4>().as_uint64(); }
};

class MmCompactionIsolateFreepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionIsolateFreepagesFtraceEvent_Decoder;
  enum : int32_t {
    kStartPfnFieldNumber = 1,
    kEndPfnFieldNumber = 2,
    kNrScannedFieldNumber = 3,
    kNrTakenFieldNumber = 4,
  };
  void set_start_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_end_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_scanned(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_taken(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionFinishedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionFinishedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionFinishedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionFinishedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class MmCompactionFinishedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionFinishedFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_zone_start() const { return at<1>().valid(); }
  uint64_t zone_start() const { return at<1>().as_uint64(); }
  bool has_migrate_pfn() const { return at<2>().valid(); }
  uint64_t migrate_pfn() const { return at<2>().as_uint64(); }
  bool has_free_pfn() const { return at<3>().valid(); }
  uint64_t free_pfn() const { return at<3>().as_uint64(); }
  bool has_zone_end() const { return at<4>().valid(); }
  uint64_t zone_end() const { return at<4>().as_uint64(); }
  bool has_sync() const { return at<5>().valid(); }
  uint32_t sync() const { return at<5>().as_uint32(); }
  bool has_status() const { return at<6>().valid(); }
  int32_t status() const { return at<6>().as_int32(); }
};

class MmCompactionEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionEndFtraceEvent_Decoder;
  enum : int32_t {
    kZoneStartFieldNumber = 1,
    kMigratePfnFieldNumber = 2,
    kFreePfnFieldNumber = 3,
    kZoneEndFieldNumber = 4,
    kSyncFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_zone_start(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_migrate_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_free_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_zone_end(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_status(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferResetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferResetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferResetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferResetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferResetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferResetFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferredFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferredFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferredFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferredFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferredFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferredFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferCompactionFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferCompactionFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferCompactionFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferCompactionFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferCompactionFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferCompactionFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_zone_start() const { return at<1>().valid(); }
  uint64_t zone_start() const { return at<1>().as_uint64(); }
  bool has_migrate_pfn() const { return at<2>().valid(); }
  uint64_t migrate_pfn() const { return at<2>().as_uint64(); }
  bool has_free_pfn() const { return at<3>().valid(); }
  uint64_t free_pfn() const { return at<3>().as_uint64(); }
  bool has_zone_end() const { return at<4>().valid(); }
  uint64_t zone_end() const { return at<4>().as_uint64(); }
  bool has_sync() const { return at<5>().valid(); }
  uint32_t sync() const { return at<5>().as_uint32(); }
};

class MmCompactionBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionBeginFtraceEvent_Decoder;
  enum : int32_t {
    kZoneStartFieldNumber = 1,
    kMigratePfnFieldNumber = 2,
    kFreePfnFieldNumber = 3,
    kZoneEndFieldNumber = 4,
    kSyncFieldNumber = 5,
  };
  void set_zone_start(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_migrate_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_free_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_zone_end(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
