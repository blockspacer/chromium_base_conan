#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/f2fs.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent() = default;
F2fsWriteEndFtraceEvent::~F2fsWriteEndFtraceEvent() = default;
F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent(const F2fsWriteEndFtraceEvent&) = default;
F2fsWriteEndFtraceEvent& F2fsWriteEndFtraceEvent::operator=(const F2fsWriteEndFtraceEvent&) = default;
F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent(F2fsWriteEndFtraceEvent&&) noexcept = default;
F2fsWriteEndFtraceEvent& F2fsWriteEndFtraceEvent::operator=(F2fsWriteEndFtraceEvent&&) = default;

bool F2fsWriteEndFtraceEvent::operator==(const F2fsWriteEndFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && copied_ == other.copied_;
}

bool F2fsWriteEndFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* copied */:
        field.get(&copied_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsWriteEndFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsWriteEndFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsWriteEndFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: copied
  if (_has_field_[5]) {
    msg->AppendVarInt(5, copied_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent() = default;
F2fsWriteCheckpointFtraceEvent::~F2fsWriteCheckpointFtraceEvent() = default;
F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent(const F2fsWriteCheckpointFtraceEvent&) = default;
F2fsWriteCheckpointFtraceEvent& F2fsWriteCheckpointFtraceEvent::operator=(const F2fsWriteCheckpointFtraceEvent&) = default;
F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent(F2fsWriteCheckpointFtraceEvent&&) noexcept = default;
F2fsWriteCheckpointFtraceEvent& F2fsWriteCheckpointFtraceEvent::operator=(F2fsWriteCheckpointFtraceEvent&&) = default;

bool F2fsWriteCheckpointFtraceEvent::operator==(const F2fsWriteCheckpointFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && is_umount_ == other.is_umount_
   && msg_ == other.msg_;
}

bool F2fsWriteCheckpointFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* is_umount */:
        field.get(&is_umount_);
        break;
      case 3 /* msg */:
        field.get(&msg_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsWriteCheckpointFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsWriteCheckpointFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsWriteCheckpointFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: is_umount
  if (_has_field_[2]) {
    msg->AppendVarInt(2, is_umount_);
  }

  // Field 3: msg
  if (_has_field_[3]) {
    msg->AppendString(3, msg_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent() = default;
F2fsWriteBeginFtraceEvent::~F2fsWriteBeginFtraceEvent() = default;
F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent(const F2fsWriteBeginFtraceEvent&) = default;
F2fsWriteBeginFtraceEvent& F2fsWriteBeginFtraceEvent::operator=(const F2fsWriteBeginFtraceEvent&) = default;
F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent(F2fsWriteBeginFtraceEvent&&) noexcept = default;
F2fsWriteBeginFtraceEvent& F2fsWriteBeginFtraceEvent::operator=(F2fsWriteBeginFtraceEvent&&) = default;

bool F2fsWriteBeginFtraceEvent::operator==(const F2fsWriteBeginFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pos_ == other.pos_
   && len_ == other.len_
   && flags_ == other.flags_;
}

bool F2fsWriteBeginFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pos */:
        field.get(&pos_);
        break;
      case 4 /* len */:
        field.get(&len_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsWriteBeginFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsWriteBeginFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsWriteBeginFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pos
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pos_);
  }

  // Field 4: len
  if (_has_field_[4]) {
    msg->AppendVarInt(4, len_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent() = default;
F2fsVmPageMkwriteFtraceEvent::~F2fsVmPageMkwriteFtraceEvent() = default;
F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent(const F2fsVmPageMkwriteFtraceEvent&) = default;
F2fsVmPageMkwriteFtraceEvent& F2fsVmPageMkwriteFtraceEvent::operator=(const F2fsVmPageMkwriteFtraceEvent&) = default;
F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent(F2fsVmPageMkwriteFtraceEvent&&) noexcept = default;
F2fsVmPageMkwriteFtraceEvent& F2fsVmPageMkwriteFtraceEvent::operator=(F2fsVmPageMkwriteFtraceEvent&&) = default;

bool F2fsVmPageMkwriteFtraceEvent::operator==(const F2fsVmPageMkwriteFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && type_ == other.type_
   && dir_ == other.dir_
   && index_ == other.index_
   && dirty_ == other.dirty_;
}

bool F2fsVmPageMkwriteFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* type */:
        field.get(&type_);
        break;
      case 4 /* dir */:
        field.get(&dir_);
        break;
      case 5 /* index */:
        field.get(&index_);
        break;
      case 6 /* dirty */:
        field.get(&dirty_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsVmPageMkwriteFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsVmPageMkwriteFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsVmPageMkwriteFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: type
  if (_has_field_[3]) {
    msg->AppendVarInt(3, type_);
  }

  // Field 4: dir
  if (_has_field_[4]) {
    msg->AppendVarInt(4, dir_);
  }

  // Field 5: index
  if (_has_field_[5]) {
    msg->AppendVarInt(5, index_);
  }

  // Field 6: dirty
  if (_has_field_[6]) {
    msg->AppendVarInt(6, dirty_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent() = default;
F2fsUnlinkExitFtraceEvent::~F2fsUnlinkExitFtraceEvent() = default;
F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent(const F2fsUnlinkExitFtraceEvent&) = default;
F2fsUnlinkExitFtraceEvent& F2fsUnlinkExitFtraceEvent::operator=(const F2fsUnlinkExitFtraceEvent&) = default;
F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent(F2fsUnlinkExitFtraceEvent&&) noexcept = default;
F2fsUnlinkExitFtraceEvent& F2fsUnlinkExitFtraceEvent::operator=(F2fsUnlinkExitFtraceEvent&&) = default;

bool F2fsUnlinkExitFtraceEvent::operator==(const F2fsUnlinkExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_;
}

bool F2fsUnlinkExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsUnlinkExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsUnlinkExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsUnlinkExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent() = default;
F2fsUnlinkEnterFtraceEvent::~F2fsUnlinkEnterFtraceEvent() = default;
F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent(const F2fsUnlinkEnterFtraceEvent&) = default;
F2fsUnlinkEnterFtraceEvent& F2fsUnlinkEnterFtraceEvent::operator=(const F2fsUnlinkEnterFtraceEvent&) = default;
F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent(F2fsUnlinkEnterFtraceEvent&&) noexcept = default;
F2fsUnlinkEnterFtraceEvent& F2fsUnlinkEnterFtraceEvent::operator=(F2fsUnlinkEnterFtraceEvent&&) = default;

bool F2fsUnlinkEnterFtraceEvent::operator==(const F2fsUnlinkEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && size_ == other.size_
   && blocks_ == other.blocks_
   && name_ == other.name_;
}

bool F2fsUnlinkEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* size */:
        field.get(&size_);
        break;
      case 4 /* blocks */:
        field.get(&blocks_);
        break;
      case 5 /* name */:
        field.get(&name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsUnlinkEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsUnlinkEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsUnlinkEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: size
  if (_has_field_[3]) {
    msg->AppendVarInt(3, size_);
  }

  // Field 4: blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, blocks_);
  }

  // Field 5: name
  if (_has_field_[5]) {
    msg->AppendString(5, name_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent() = default;
F2fsTruncatePartialNodesFtraceEvent::~F2fsTruncatePartialNodesFtraceEvent() = default;
F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent(const F2fsTruncatePartialNodesFtraceEvent&) = default;
F2fsTruncatePartialNodesFtraceEvent& F2fsTruncatePartialNodesFtraceEvent::operator=(const F2fsTruncatePartialNodesFtraceEvent&) = default;
F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent(F2fsTruncatePartialNodesFtraceEvent&&) noexcept = default;
F2fsTruncatePartialNodesFtraceEvent& F2fsTruncatePartialNodesFtraceEvent::operator=(F2fsTruncatePartialNodesFtraceEvent&&) = default;

bool F2fsTruncatePartialNodesFtraceEvent::operator==(const F2fsTruncatePartialNodesFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && nid_ == other.nid_
   && depth_ == other.depth_
   && err_ == other.err_;
}

bool F2fsTruncatePartialNodesFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* nid */:
        field.get(&nid_);
        break;
      case 4 /* depth */:
        field.get(&depth_);
        break;
      case 5 /* err */:
        field.get(&err_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncatePartialNodesFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncatePartialNodesFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncatePartialNodesFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: nid
  if (_has_field_[3]) {
    msg->AppendVarInt(3, nid_);
  }

  // Field 4: depth
  if (_has_field_[4]) {
    msg->AppendVarInt(4, depth_);
  }

  // Field 5: err
  if (_has_field_[5]) {
    msg->AppendVarInt(5, err_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent() = default;
F2fsTruncateNodesExitFtraceEvent::~F2fsTruncateNodesExitFtraceEvent() = default;
F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent(const F2fsTruncateNodesExitFtraceEvent&) = default;
F2fsTruncateNodesExitFtraceEvent& F2fsTruncateNodesExitFtraceEvent::operator=(const F2fsTruncateNodesExitFtraceEvent&) = default;
F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent(F2fsTruncateNodesExitFtraceEvent&&) noexcept = default;
F2fsTruncateNodesExitFtraceEvent& F2fsTruncateNodesExitFtraceEvent::operator=(F2fsTruncateNodesExitFtraceEvent&&) = default;

bool F2fsTruncateNodesExitFtraceEvent::operator==(const F2fsTruncateNodesExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_;
}

bool F2fsTruncateNodesExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateNodesExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateNodesExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateNodesExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent() = default;
F2fsTruncateNodesEnterFtraceEvent::~F2fsTruncateNodesEnterFtraceEvent() = default;
F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent(const F2fsTruncateNodesEnterFtraceEvent&) = default;
F2fsTruncateNodesEnterFtraceEvent& F2fsTruncateNodesEnterFtraceEvent::operator=(const F2fsTruncateNodesEnterFtraceEvent&) = default;
F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent(F2fsTruncateNodesEnterFtraceEvent&&) noexcept = default;
F2fsTruncateNodesEnterFtraceEvent& F2fsTruncateNodesEnterFtraceEvent::operator=(F2fsTruncateNodesEnterFtraceEvent&&) = default;

bool F2fsTruncateNodesEnterFtraceEvent::operator==(const F2fsTruncateNodesEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && nid_ == other.nid_
   && blk_addr_ == other.blk_addr_;
}

bool F2fsTruncateNodesEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* nid */:
        field.get(&nid_);
        break;
      case 4 /* blk_addr */:
        field.get(&blk_addr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateNodesEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateNodesEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateNodesEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: nid
  if (_has_field_[3]) {
    msg->AppendVarInt(3, nid_);
  }

  // Field 4: blk_addr
  if (_has_field_[4]) {
    msg->AppendVarInt(4, blk_addr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent() = default;
F2fsTruncateNodeFtraceEvent::~F2fsTruncateNodeFtraceEvent() = default;
F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent(const F2fsTruncateNodeFtraceEvent&) = default;
F2fsTruncateNodeFtraceEvent& F2fsTruncateNodeFtraceEvent::operator=(const F2fsTruncateNodeFtraceEvent&) = default;
F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent(F2fsTruncateNodeFtraceEvent&&) noexcept = default;
F2fsTruncateNodeFtraceEvent& F2fsTruncateNodeFtraceEvent::operator=(F2fsTruncateNodeFtraceEvent&&) = default;

bool F2fsTruncateNodeFtraceEvent::operator==(const F2fsTruncateNodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && nid_ == other.nid_
   && blk_addr_ == other.blk_addr_;
}

bool F2fsTruncateNodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* nid */:
        field.get(&nid_);
        break;
      case 4 /* blk_addr */:
        field.get(&blk_addr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateNodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateNodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateNodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: nid
  if (_has_field_[3]) {
    msg->AppendVarInt(3, nid_);
  }

  // Field 4: blk_addr
  if (_has_field_[4]) {
    msg->AppendVarInt(4, blk_addr_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent() = default;
F2fsTruncateInodeBlocksExitFtraceEvent::~F2fsTruncateInodeBlocksExitFtraceEvent() = default;
F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent(const F2fsTruncateInodeBlocksExitFtraceEvent&) = default;
F2fsTruncateInodeBlocksExitFtraceEvent& F2fsTruncateInodeBlocksExitFtraceEvent::operator=(const F2fsTruncateInodeBlocksExitFtraceEvent&) = default;
F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent(F2fsTruncateInodeBlocksExitFtraceEvent&&) noexcept = default;
F2fsTruncateInodeBlocksExitFtraceEvent& F2fsTruncateInodeBlocksExitFtraceEvent::operator=(F2fsTruncateInodeBlocksExitFtraceEvent&&) = default;

bool F2fsTruncateInodeBlocksExitFtraceEvent::operator==(const F2fsTruncateInodeBlocksExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_;
}

bool F2fsTruncateInodeBlocksExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateInodeBlocksExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateInodeBlocksExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateInodeBlocksExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent() = default;
F2fsTruncateInodeBlocksEnterFtraceEvent::~F2fsTruncateInodeBlocksEnterFtraceEvent() = default;
F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent(const F2fsTruncateInodeBlocksEnterFtraceEvent&) = default;
F2fsTruncateInodeBlocksEnterFtraceEvent& F2fsTruncateInodeBlocksEnterFtraceEvent::operator=(const F2fsTruncateInodeBlocksEnterFtraceEvent&) = default;
F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent(F2fsTruncateInodeBlocksEnterFtraceEvent&&) noexcept = default;
F2fsTruncateInodeBlocksEnterFtraceEvent& F2fsTruncateInodeBlocksEnterFtraceEvent::operator=(F2fsTruncateInodeBlocksEnterFtraceEvent&&) = default;

bool F2fsTruncateInodeBlocksEnterFtraceEvent::operator==(const F2fsTruncateInodeBlocksEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && size_ == other.size_
   && blocks_ == other.blocks_
   && from_ == other.from_;
}

bool F2fsTruncateInodeBlocksEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* size */:
        field.get(&size_);
        break;
      case 4 /* blocks */:
        field.get(&blocks_);
        break;
      case 5 /* from */:
        field.get(&from_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateInodeBlocksEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateInodeBlocksEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: size
  if (_has_field_[3]) {
    msg->AppendVarInt(3, size_);
  }

  // Field 4: blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, blocks_);
  }

  // Field 5: from
  if (_has_field_[5]) {
    msg->AppendVarInt(5, from_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent() = default;
F2fsTruncateDataBlocksRangeFtraceEvent::~F2fsTruncateDataBlocksRangeFtraceEvent() = default;
F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent(const F2fsTruncateDataBlocksRangeFtraceEvent&) = default;
F2fsTruncateDataBlocksRangeFtraceEvent& F2fsTruncateDataBlocksRangeFtraceEvent::operator=(const F2fsTruncateDataBlocksRangeFtraceEvent&) = default;
F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent(F2fsTruncateDataBlocksRangeFtraceEvent&&) noexcept = default;
F2fsTruncateDataBlocksRangeFtraceEvent& F2fsTruncateDataBlocksRangeFtraceEvent::operator=(F2fsTruncateDataBlocksRangeFtraceEvent&&) = default;

bool F2fsTruncateDataBlocksRangeFtraceEvent::operator==(const F2fsTruncateDataBlocksRangeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && nid_ == other.nid_
   && ofs_ == other.ofs_
   && free_ == other.free_;
}

bool F2fsTruncateDataBlocksRangeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* nid */:
        field.get(&nid_);
        break;
      case 4 /* ofs */:
        field.get(&ofs_);
        break;
      case 5 /* free */:
        field.get(&free_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateDataBlocksRangeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateDataBlocksRangeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateDataBlocksRangeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: nid
  if (_has_field_[3]) {
    msg->AppendVarInt(3, nid_);
  }

  // Field 4: ofs
  if (_has_field_[4]) {
    msg->AppendVarInt(4, ofs_);
  }

  // Field 5: free
  if (_has_field_[5]) {
    msg->AppendVarInt(5, free_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent() = default;
F2fsTruncateBlocksExitFtraceEvent::~F2fsTruncateBlocksExitFtraceEvent() = default;
F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent(const F2fsTruncateBlocksExitFtraceEvent&) = default;
F2fsTruncateBlocksExitFtraceEvent& F2fsTruncateBlocksExitFtraceEvent::operator=(const F2fsTruncateBlocksExitFtraceEvent&) = default;
F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent(F2fsTruncateBlocksExitFtraceEvent&&) noexcept = default;
F2fsTruncateBlocksExitFtraceEvent& F2fsTruncateBlocksExitFtraceEvent::operator=(F2fsTruncateBlocksExitFtraceEvent&&) = default;

bool F2fsTruncateBlocksExitFtraceEvent::operator==(const F2fsTruncateBlocksExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_;
}

bool F2fsTruncateBlocksExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateBlocksExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateBlocksExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateBlocksExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent() = default;
F2fsTruncateBlocksEnterFtraceEvent::~F2fsTruncateBlocksEnterFtraceEvent() = default;
F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent(const F2fsTruncateBlocksEnterFtraceEvent&) = default;
F2fsTruncateBlocksEnterFtraceEvent& F2fsTruncateBlocksEnterFtraceEvent::operator=(const F2fsTruncateBlocksEnterFtraceEvent&) = default;
F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent(F2fsTruncateBlocksEnterFtraceEvent&&) noexcept = default;
F2fsTruncateBlocksEnterFtraceEvent& F2fsTruncateBlocksEnterFtraceEvent::operator=(F2fsTruncateBlocksEnterFtraceEvent&&) = default;

bool F2fsTruncateBlocksEnterFtraceEvent::operator==(const F2fsTruncateBlocksEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && size_ == other.size_
   && blocks_ == other.blocks_
   && from_ == other.from_;
}

bool F2fsTruncateBlocksEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* size */:
        field.get(&size_);
        break;
      case 4 /* blocks */:
        field.get(&blocks_);
        break;
      case 5 /* from */:
        field.get(&from_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateBlocksEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateBlocksEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateBlocksEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: size
  if (_has_field_[3]) {
    msg->AppendVarInt(3, size_);
  }

  // Field 4: blocks
  if (_has_field_[4]) {
    msg->AppendVarInt(4, blocks_);
  }

  // Field 5: from
  if (_has_field_[5]) {
    msg->AppendVarInt(5, from_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent() = default;
F2fsTruncateFtraceEvent::~F2fsTruncateFtraceEvent() = default;
F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent(const F2fsTruncateFtraceEvent&) = default;
F2fsTruncateFtraceEvent& F2fsTruncateFtraceEvent::operator=(const F2fsTruncateFtraceEvent&) = default;
F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent(F2fsTruncateFtraceEvent&&) noexcept = default;
F2fsTruncateFtraceEvent& F2fsTruncateFtraceEvent::operator=(F2fsTruncateFtraceEvent&&) = default;

bool F2fsTruncateFtraceEvent::operator==(const F2fsTruncateFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pino_ == other.pino_
   && mode_ == other.mode_
   && size_ == other.size_
   && nlink_ == other.nlink_
   && blocks_ == other.blocks_
   && advise_ == other.advise_;
}

bool F2fsTruncateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pino */:
        field.get(&pino_);
        break;
      case 4 /* mode */:
        field.get(&mode_);
        break;
      case 5 /* size */:
        field.get(&size_);
        break;
      case 6 /* nlink */:
        field.get(&nlink_);
        break;
      case 7 /* blocks */:
        field.get(&blocks_);
        break;
      case 8 /* advise */:
        field.get(&advise_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsTruncateFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsTruncateFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsTruncateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pino
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pino_);
  }

  // Field 4: mode
  if (_has_field_[4]) {
    msg->AppendVarInt(4, mode_);
  }

  // Field 5: size
  if (_has_field_[5]) {
    msg->AppendVarInt(5, size_);
  }

  // Field 6: nlink
  if (_has_field_[6]) {
    msg->AppendVarInt(6, nlink_);
  }

  // Field 7: blocks
  if (_has_field_[7]) {
    msg->AppendVarInt(7, blocks_);
  }

  // Field 8: advise
  if (_has_field_[8]) {
    msg->AppendVarInt(8, advise_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent() = default;
F2fsSyncFsFtraceEvent::~F2fsSyncFsFtraceEvent() = default;
F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent(const F2fsSyncFsFtraceEvent&) = default;
F2fsSyncFsFtraceEvent& F2fsSyncFsFtraceEvent::operator=(const F2fsSyncFsFtraceEvent&) = default;
F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent(F2fsSyncFsFtraceEvent&&) noexcept = default;
F2fsSyncFsFtraceEvent& F2fsSyncFsFtraceEvent::operator=(F2fsSyncFsFtraceEvent&&) = default;

bool F2fsSyncFsFtraceEvent::operator==(const F2fsSyncFsFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && dirty_ == other.dirty_
   && wait_ == other.wait_;
}

bool F2fsSyncFsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* dirty */:
        field.get(&dirty_);
        break;
      case 3 /* wait */:
        field.get(&wait_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsSyncFsFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsSyncFsFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsSyncFsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: dirty
  if (_has_field_[2]) {
    msg->AppendVarInt(2, dirty_);
  }

  // Field 3: wait
  if (_has_field_[3]) {
    msg->AppendVarInt(3, wait_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent() = default;
F2fsSyncFileExitFtraceEvent::~F2fsSyncFileExitFtraceEvent() = default;
F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent(const F2fsSyncFileExitFtraceEvent&) = default;
F2fsSyncFileExitFtraceEvent& F2fsSyncFileExitFtraceEvent::operator=(const F2fsSyncFileExitFtraceEvent&) = default;
F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent(F2fsSyncFileExitFtraceEvent&&) noexcept = default;
F2fsSyncFileExitFtraceEvent& F2fsSyncFileExitFtraceEvent::operator=(F2fsSyncFileExitFtraceEvent&&) = default;

bool F2fsSyncFileExitFtraceEvent::operator==(const F2fsSyncFileExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && need_cp_ == other.need_cp_
   && datasync_ == other.datasync_
   && ret_ == other.ret_;
}

bool F2fsSyncFileExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* need_cp */:
        field.get(&need_cp_);
        break;
      case 4 /* datasync */:
        field.get(&datasync_);
        break;
      case 5 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsSyncFileExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsSyncFileExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsSyncFileExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: need_cp
  if (_has_field_[3]) {
    msg->AppendVarInt(3, need_cp_);
  }

  // Field 4: datasync
  if (_has_field_[4]) {
    msg->AppendVarInt(4, datasync_);
  }

  // Field 5: ret
  if (_has_field_[5]) {
    msg->AppendVarInt(5, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent() = default;
F2fsSyncFileEnterFtraceEvent::~F2fsSyncFileEnterFtraceEvent() = default;
F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent(const F2fsSyncFileEnterFtraceEvent&) = default;
F2fsSyncFileEnterFtraceEvent& F2fsSyncFileEnterFtraceEvent::operator=(const F2fsSyncFileEnterFtraceEvent&) = default;
F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent(F2fsSyncFileEnterFtraceEvent&&) noexcept = default;
F2fsSyncFileEnterFtraceEvent& F2fsSyncFileEnterFtraceEvent::operator=(F2fsSyncFileEnterFtraceEvent&&) = default;

bool F2fsSyncFileEnterFtraceEvent::operator==(const F2fsSyncFileEnterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pino_ == other.pino_
   && mode_ == other.mode_
   && size_ == other.size_
   && nlink_ == other.nlink_
   && blocks_ == other.blocks_
   && advise_ == other.advise_;
}

bool F2fsSyncFileEnterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pino */:
        field.get(&pino_);
        break;
      case 4 /* mode */:
        field.get(&mode_);
        break;
      case 5 /* size */:
        field.get(&size_);
        break;
      case 6 /* nlink */:
        field.get(&nlink_);
        break;
      case 7 /* blocks */:
        field.get(&blocks_);
        break;
      case 8 /* advise */:
        field.get(&advise_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsSyncFileEnterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsSyncFileEnterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsSyncFileEnterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pino
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pino_);
  }

  // Field 4: mode
  if (_has_field_[4]) {
    msg->AppendVarInt(4, mode_);
  }

  // Field 5: size
  if (_has_field_[5]) {
    msg->AppendVarInt(5, size_);
  }

  // Field 6: nlink
  if (_has_field_[6]) {
    msg->AppendVarInt(6, nlink_);
  }

  // Field 7: blocks
  if (_has_field_[7]) {
    msg->AppendVarInt(7, blocks_);
  }

  // Field 8: advise
  if (_has_field_[8]) {
    msg->AppendVarInt(8, advise_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent() = default;
F2fsSubmitWritePageFtraceEvent::~F2fsSubmitWritePageFtraceEvent() = default;
F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent(const F2fsSubmitWritePageFtraceEvent&) = default;
F2fsSubmitWritePageFtraceEvent& F2fsSubmitWritePageFtraceEvent::operator=(const F2fsSubmitWritePageFtraceEvent&) = default;
F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent(F2fsSubmitWritePageFtraceEvent&&) noexcept = default;
F2fsSubmitWritePageFtraceEvent& F2fsSubmitWritePageFtraceEvent::operator=(F2fsSubmitWritePageFtraceEvent&&) = default;

bool F2fsSubmitWritePageFtraceEvent::operator==(const F2fsSubmitWritePageFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && type_ == other.type_
   && index_ == other.index_
   && block_ == other.block_;
}

bool F2fsSubmitWritePageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* type */:
        field.get(&type_);
        break;
      case 4 /* index */:
        field.get(&index_);
        break;
      case 5 /* block */:
        field.get(&block_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsSubmitWritePageFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsSubmitWritePageFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsSubmitWritePageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: type
  if (_has_field_[3]) {
    msg->AppendVarInt(3, type_);
  }

  // Field 4: index
  if (_has_field_[4]) {
    msg->AppendVarInt(4, index_);
  }

  // Field 5: block
  if (_has_field_[5]) {
    msg->AppendVarInt(5, block_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent() = default;
F2fsSetPageDirtyFtraceEvent::~F2fsSetPageDirtyFtraceEvent() = default;
F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent(const F2fsSetPageDirtyFtraceEvent&) = default;
F2fsSetPageDirtyFtraceEvent& F2fsSetPageDirtyFtraceEvent::operator=(const F2fsSetPageDirtyFtraceEvent&) = default;
F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent(F2fsSetPageDirtyFtraceEvent&&) noexcept = default;
F2fsSetPageDirtyFtraceEvent& F2fsSetPageDirtyFtraceEvent::operator=(F2fsSetPageDirtyFtraceEvent&&) = default;

bool F2fsSetPageDirtyFtraceEvent::operator==(const F2fsSetPageDirtyFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && type_ == other.type_
   && dir_ == other.dir_
   && index_ == other.index_
   && dirty_ == other.dirty_;
}

bool F2fsSetPageDirtyFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* type */:
        field.get(&type_);
        break;
      case 4 /* dir */:
        field.get(&dir_);
        break;
      case 5 /* index */:
        field.get(&index_);
        break;
      case 6 /* dirty */:
        field.get(&dirty_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsSetPageDirtyFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsSetPageDirtyFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsSetPageDirtyFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: type
  if (_has_field_[3]) {
    msg->AppendVarInt(3, type_);
  }

  // Field 4: dir
  if (_has_field_[4]) {
    msg->AppendVarInt(4, dir_);
  }

  // Field 5: index
  if (_has_field_[5]) {
    msg->AppendVarInt(5, index_);
  }

  // Field 6: dirty
  if (_has_field_[6]) {
    msg->AppendVarInt(6, dirty_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent() = default;
F2fsReserveNewBlockFtraceEvent::~F2fsReserveNewBlockFtraceEvent() = default;
F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent(const F2fsReserveNewBlockFtraceEvent&) = default;
F2fsReserveNewBlockFtraceEvent& F2fsReserveNewBlockFtraceEvent::operator=(const F2fsReserveNewBlockFtraceEvent&) = default;
F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent(F2fsReserveNewBlockFtraceEvent&&) noexcept = default;
F2fsReserveNewBlockFtraceEvent& F2fsReserveNewBlockFtraceEvent::operator=(F2fsReserveNewBlockFtraceEvent&&) = default;

bool F2fsReserveNewBlockFtraceEvent::operator==(const F2fsReserveNewBlockFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && nid_ == other.nid_
   && ofs_in_node_ == other.ofs_in_node_;
}

bool F2fsReserveNewBlockFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* nid */:
        field.get(&nid_);
        break;
      case 3 /* ofs_in_node */:
        field.get(&ofs_in_node_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsReserveNewBlockFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsReserveNewBlockFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsReserveNewBlockFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: nid
  if (_has_field_[2]) {
    msg->AppendVarInt(2, nid_);
  }

  // Field 3: ofs_in_node
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ofs_in_node_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent() = default;
F2fsReadpageFtraceEvent::~F2fsReadpageFtraceEvent() = default;
F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent(const F2fsReadpageFtraceEvent&) = default;
F2fsReadpageFtraceEvent& F2fsReadpageFtraceEvent::operator=(const F2fsReadpageFtraceEvent&) = default;
F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent(F2fsReadpageFtraceEvent&&) noexcept = default;
F2fsReadpageFtraceEvent& F2fsReadpageFtraceEvent::operator=(F2fsReadpageFtraceEvent&&) = default;

bool F2fsReadpageFtraceEvent::operator==(const F2fsReadpageFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && index_ == other.index_
   && blkaddr_ == other.blkaddr_
   && type_ == other.type_;
}

bool F2fsReadpageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* index */:
        field.get(&index_);
        break;
      case 4 /* blkaddr */:
        field.get(&blkaddr_);
        break;
      case 5 /* type */:
        field.get(&type_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsReadpageFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsReadpageFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsReadpageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: index
  if (_has_field_[3]) {
    msg->AppendVarInt(3, index_);
  }

  // Field 4: blkaddr
  if (_has_field_[4]) {
    msg->AppendVarInt(4, blkaddr_);
  }

  // Field 5: type
  if (_has_field_[5]) {
    msg->AppendVarInt(5, type_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent() = default;
F2fsNewInodeFtraceEvent::~F2fsNewInodeFtraceEvent() = default;
F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent(const F2fsNewInodeFtraceEvent&) = default;
F2fsNewInodeFtraceEvent& F2fsNewInodeFtraceEvent::operator=(const F2fsNewInodeFtraceEvent&) = default;
F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent(F2fsNewInodeFtraceEvent&&) noexcept = default;
F2fsNewInodeFtraceEvent& F2fsNewInodeFtraceEvent::operator=(F2fsNewInodeFtraceEvent&&) = default;

bool F2fsNewInodeFtraceEvent::operator==(const F2fsNewInodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_;
}

bool F2fsNewInodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsNewInodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsNewInodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsNewInodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent() = default;
F2fsIgetExitFtraceEvent::~F2fsIgetExitFtraceEvent() = default;
F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent(const F2fsIgetExitFtraceEvent&) = default;
F2fsIgetExitFtraceEvent& F2fsIgetExitFtraceEvent::operator=(const F2fsIgetExitFtraceEvent&) = default;
F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent(F2fsIgetExitFtraceEvent&&) noexcept = default;
F2fsIgetExitFtraceEvent& F2fsIgetExitFtraceEvent::operator=(F2fsIgetExitFtraceEvent&&) = default;

bool F2fsIgetExitFtraceEvent::operator==(const F2fsIgetExitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && ret_ == other.ret_;
}

bool F2fsIgetExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsIgetExitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsIgetExitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsIgetExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: ret
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsIgetFtraceEvent::F2fsIgetFtraceEvent() = default;
F2fsIgetFtraceEvent::~F2fsIgetFtraceEvent() = default;
F2fsIgetFtraceEvent::F2fsIgetFtraceEvent(const F2fsIgetFtraceEvent&) = default;
F2fsIgetFtraceEvent& F2fsIgetFtraceEvent::operator=(const F2fsIgetFtraceEvent&) = default;
F2fsIgetFtraceEvent::F2fsIgetFtraceEvent(F2fsIgetFtraceEvent&&) noexcept = default;
F2fsIgetFtraceEvent& F2fsIgetFtraceEvent::operator=(F2fsIgetFtraceEvent&&) = default;

bool F2fsIgetFtraceEvent::operator==(const F2fsIgetFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pino_ == other.pino_
   && mode_ == other.mode_
   && size_ == other.size_
   && nlink_ == other.nlink_
   && blocks_ == other.blocks_
   && advise_ == other.advise_;
}

bool F2fsIgetFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pino */:
        field.get(&pino_);
        break;
      case 4 /* mode */:
        field.get(&mode_);
        break;
      case 5 /* size */:
        field.get(&size_);
        break;
      case 6 /* nlink */:
        field.get(&nlink_);
        break;
      case 7 /* blocks */:
        field.get(&blocks_);
        break;
      case 8 /* advise */:
        field.get(&advise_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsIgetFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsIgetFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsIgetFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pino
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pino_);
  }

  // Field 4: mode
  if (_has_field_[4]) {
    msg->AppendVarInt(4, mode_);
  }

  // Field 5: size
  if (_has_field_[5]) {
    msg->AppendVarInt(5, size_);
  }

  // Field 6: nlink
  if (_has_field_[6]) {
    msg->AppendVarInt(6, nlink_);
  }

  // Field 7: blocks
  if (_has_field_[7]) {
    msg->AppendVarInt(7, blocks_);
  }

  // Field 8: advise
  if (_has_field_[8]) {
    msg->AppendVarInt(8, advise_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent() = default;
F2fsGetVictimFtraceEvent::~F2fsGetVictimFtraceEvent() = default;
F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent(const F2fsGetVictimFtraceEvent&) = default;
F2fsGetVictimFtraceEvent& F2fsGetVictimFtraceEvent::operator=(const F2fsGetVictimFtraceEvent&) = default;
F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent(F2fsGetVictimFtraceEvent&&) noexcept = default;
F2fsGetVictimFtraceEvent& F2fsGetVictimFtraceEvent::operator=(F2fsGetVictimFtraceEvent&&) = default;

bool F2fsGetVictimFtraceEvent::operator==(const F2fsGetVictimFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && type_ == other.type_
   && gc_type_ == other.gc_type_
   && alloc_mode_ == other.alloc_mode_
   && gc_mode_ == other.gc_mode_
   && victim_ == other.victim_
   && ofs_unit_ == other.ofs_unit_
   && pre_victim_ == other.pre_victim_
   && prefree_ == other.prefree_
   && free_ == other.free_;
}

bool F2fsGetVictimFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* type */:
        field.get(&type_);
        break;
      case 3 /* gc_type */:
        field.get(&gc_type_);
        break;
      case 4 /* alloc_mode */:
        field.get(&alloc_mode_);
        break;
      case 5 /* gc_mode */:
        field.get(&gc_mode_);
        break;
      case 6 /* victim */:
        field.get(&victim_);
        break;
      case 7 /* ofs_unit */:
        field.get(&ofs_unit_);
        break;
      case 8 /* pre_victim */:
        field.get(&pre_victim_);
        break;
      case 9 /* prefree */:
        field.get(&prefree_);
        break;
      case 10 /* free */:
        field.get(&free_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsGetVictimFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsGetVictimFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsGetVictimFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: type
  if (_has_field_[2]) {
    msg->AppendVarInt(2, type_);
  }

  // Field 3: gc_type
  if (_has_field_[3]) {
    msg->AppendVarInt(3, gc_type_);
  }

  // Field 4: alloc_mode
  if (_has_field_[4]) {
    msg->AppendVarInt(4, alloc_mode_);
  }

  // Field 5: gc_mode
  if (_has_field_[5]) {
    msg->AppendVarInt(5, gc_mode_);
  }

  // Field 6: victim
  if (_has_field_[6]) {
    msg->AppendVarInt(6, victim_);
  }

  // Field 7: ofs_unit
  if (_has_field_[7]) {
    msg->AppendVarInt(7, ofs_unit_);
  }

  // Field 8: pre_victim
  if (_has_field_[8]) {
    msg->AppendVarInt(8, pre_victim_);
  }

  // Field 9: prefree
  if (_has_field_[9]) {
    msg->AppendVarInt(9, prefree_);
  }

  // Field 10: free
  if (_has_field_[10]) {
    msg->AppendVarInt(10, free_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent() = default;
F2fsGetDataBlockFtraceEvent::~F2fsGetDataBlockFtraceEvent() = default;
F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent(const F2fsGetDataBlockFtraceEvent&) = default;
F2fsGetDataBlockFtraceEvent& F2fsGetDataBlockFtraceEvent::operator=(const F2fsGetDataBlockFtraceEvent&) = default;
F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent(F2fsGetDataBlockFtraceEvent&&) noexcept = default;
F2fsGetDataBlockFtraceEvent& F2fsGetDataBlockFtraceEvent::operator=(F2fsGetDataBlockFtraceEvent&&) = default;

bool F2fsGetDataBlockFtraceEvent::operator==(const F2fsGetDataBlockFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && iblock_ == other.iblock_
   && bh_start_ == other.bh_start_
   && bh_size_ == other.bh_size_
   && ret_ == other.ret_;
}

bool F2fsGetDataBlockFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* iblock */:
        field.get(&iblock_);
        break;
      case 4 /* bh_start */:
        field.get(&bh_start_);
        break;
      case 5 /* bh_size */:
        field.get(&bh_size_);
        break;
      case 6 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsGetDataBlockFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsGetDataBlockFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsGetDataBlockFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: iblock
  if (_has_field_[3]) {
    msg->AppendVarInt(3, iblock_);
  }

  // Field 4: bh_start
  if (_has_field_[4]) {
    msg->AppendVarInt(4, bh_start_);
  }

  // Field 5: bh_size
  if (_has_field_[5]) {
    msg->AppendVarInt(5, bh_size_);
  }

  // Field 6: ret
  if (_has_field_[6]) {
    msg->AppendVarInt(6, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent() = default;
F2fsFallocateFtraceEvent::~F2fsFallocateFtraceEvent() = default;
F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent(const F2fsFallocateFtraceEvent&) = default;
F2fsFallocateFtraceEvent& F2fsFallocateFtraceEvent::operator=(const F2fsFallocateFtraceEvent&) = default;
F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent(F2fsFallocateFtraceEvent&&) noexcept = default;
F2fsFallocateFtraceEvent& F2fsFallocateFtraceEvent::operator=(F2fsFallocateFtraceEvent&&) = default;

bool F2fsFallocateFtraceEvent::operator==(const F2fsFallocateFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && mode_ == other.mode_
   && offset_ == other.offset_
   && len_ == other.len_
   && size_ == other.size_
   && blocks_ == other.blocks_
   && ret_ == other.ret_;
}

bool F2fsFallocateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* mode */:
        field.get(&mode_);
        break;
      case 4 /* offset */:
        field.get(&offset_);
        break;
      case 5 /* len */:
        field.get(&len_);
        break;
      case 6 /* size */:
        field.get(&size_);
        break;
      case 7 /* blocks */:
        field.get(&blocks_);
        break;
      case 8 /* ret */:
        field.get(&ret_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsFallocateFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsFallocateFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsFallocateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: mode
  if (_has_field_[3]) {
    msg->AppendVarInt(3, mode_);
  }

  // Field 4: offset
  if (_has_field_[4]) {
    msg->AppendVarInt(4, offset_);
  }

  // Field 5: len
  if (_has_field_[5]) {
    msg->AppendVarInt(5, len_);
  }

  // Field 6: size
  if (_has_field_[6]) {
    msg->AppendVarInt(6, size_);
  }

  // Field 7: blocks
  if (_has_field_[7]) {
    msg->AppendVarInt(7, blocks_);
  }

  // Field 8: ret
  if (_has_field_[8]) {
    msg->AppendVarInt(8, ret_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent() = default;
F2fsEvictInodeFtraceEvent::~F2fsEvictInodeFtraceEvent() = default;
F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent(const F2fsEvictInodeFtraceEvent&) = default;
F2fsEvictInodeFtraceEvent& F2fsEvictInodeFtraceEvent::operator=(const F2fsEvictInodeFtraceEvent&) = default;
F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent(F2fsEvictInodeFtraceEvent&&) noexcept = default;
F2fsEvictInodeFtraceEvent& F2fsEvictInodeFtraceEvent::operator=(F2fsEvictInodeFtraceEvent&&) = default;

bool F2fsEvictInodeFtraceEvent::operator==(const F2fsEvictInodeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && ino_ == other.ino_
   && pino_ == other.pino_
   && mode_ == other.mode_
   && size_ == other.size_
   && nlink_ == other.nlink_
   && blocks_ == other.blocks_
   && advise_ == other.advise_;
}

bool F2fsEvictInodeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* ino */:
        field.get(&ino_);
        break;
      case 3 /* pino */:
        field.get(&pino_);
        break;
      case 4 /* mode */:
        field.get(&mode_);
        break;
      case 5 /* size */:
        field.get(&size_);
        break;
      case 6 /* nlink */:
        field.get(&nlink_);
        break;
      case 7 /* blocks */:
        field.get(&blocks_);
        break;
      case 8 /* advise */:
        field.get(&advise_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsEvictInodeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsEvictInodeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsEvictInodeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: ino
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ino_);
  }

  // Field 3: pino
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pino_);
  }

  // Field 4: mode
  if (_has_field_[4]) {
    msg->AppendVarInt(4, mode_);
  }

  // Field 5: size
  if (_has_field_[5]) {
    msg->AppendVarInt(5, size_);
  }

  // Field 6: nlink
  if (_has_field_[6]) {
    msg->AppendVarInt(6, nlink_);
  }

  // Field 7: blocks
  if (_has_field_[7]) {
    msg->AppendVarInt(7, blocks_);
  }

  // Field 8: advise
  if (_has_field_[8]) {
    msg->AppendVarInt(8, advise_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent() = default;
F2fsDoSubmitBioFtraceEvent::~F2fsDoSubmitBioFtraceEvent() = default;
F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent(const F2fsDoSubmitBioFtraceEvent&) = default;
F2fsDoSubmitBioFtraceEvent& F2fsDoSubmitBioFtraceEvent::operator=(const F2fsDoSubmitBioFtraceEvent&) = default;
F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent(F2fsDoSubmitBioFtraceEvent&&) noexcept = default;
F2fsDoSubmitBioFtraceEvent& F2fsDoSubmitBioFtraceEvent::operator=(F2fsDoSubmitBioFtraceEvent&&) = default;

bool F2fsDoSubmitBioFtraceEvent::operator==(const F2fsDoSubmitBioFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && dev_ == other.dev_
   && btype_ == other.btype_
   && sync_ == other.sync_
   && sector_ == other.sector_
   && size_ == other.size_;
}

bool F2fsDoSubmitBioFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* dev */:
        field.get(&dev_);
        break;
      case 2 /* btype */:
        field.get(&btype_);
        break;
      case 3 /* sync */:
        field.get(&sync_);
        break;
      case 4 /* sector */:
        field.get(&sector_);
        break;
      case 5 /* size */:
        field.get(&size_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string F2fsDoSubmitBioFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> F2fsDoSubmitBioFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void F2fsDoSubmitBioFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: dev
  if (_has_field_[1]) {
    msg->AppendVarInt(1, dev_);
  }

  // Field 2: btype
  if (_has_field_[2]) {
    msg->AppendVarInt(2, btype_);
  }

  // Field 3: sync
  if (_has_field_[3]) {
    msg->AppendVarInt(3, sync_);
  }

  // Field 4: sector
  if (_has_field_[4]) {
    msg->AppendVarInt(4, sector_);
  }

  // Field 5: size
  if (_has_field_[5]) {
    msg->AppendVarInt(5, size_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
