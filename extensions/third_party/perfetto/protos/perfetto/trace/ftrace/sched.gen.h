// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class SchedProcessWaitFtraceEvent;
class SchedProcessHangFtraceEvent;
class SchedProcessFreeFtraceEvent;
class SchedProcessForkFtraceEvent;
class SchedProcessExitFtraceEvent;
class SchedProcessExecFtraceEvent;
class SchedWakeupNewFtraceEvent;
class SchedWakingFtraceEvent;
class SchedCpuHotplugFtraceEvent;
class SchedBlockedReasonFtraceEvent;
class SchedWakeupFtraceEvent;
class SchedSwitchFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT SchedProcessWaitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };

  SchedProcessWaitFtraceEvent();
  ~SchedProcessWaitFtraceEvent() override;
  SchedProcessWaitFtraceEvent(SchedProcessWaitFtraceEvent&&) noexcept;
  SchedProcessWaitFtraceEvent& operator=(SchedProcessWaitFtraceEvent&&);
  SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent&);
  SchedProcessWaitFtraceEvent& operator=(const SchedProcessWaitFtraceEvent&);
  bool operator==(const SchedProcessWaitFtraceEvent&) const;
  bool operator!=(const SchedProcessWaitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT SchedProcessHangFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
  };

  SchedProcessHangFtraceEvent();
  ~SchedProcessHangFtraceEvent() override;
  SchedProcessHangFtraceEvent(SchedProcessHangFtraceEvent&&) noexcept;
  SchedProcessHangFtraceEvent& operator=(SchedProcessHangFtraceEvent&&);
  SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent&);
  SchedProcessHangFtraceEvent& operator=(const SchedProcessHangFtraceEvent&);
  bool operator==(const SchedProcessHangFtraceEvent&) const;
  bool operator!=(const SchedProcessHangFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

 private:
  std::string comm_{};
  int32_t pid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT SchedProcessFreeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };

  SchedProcessFreeFtraceEvent();
  ~SchedProcessFreeFtraceEvent() override;
  SchedProcessFreeFtraceEvent(SchedProcessFreeFtraceEvent&&) noexcept;
  SchedProcessFreeFtraceEvent& operator=(SchedProcessFreeFtraceEvent&&);
  SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent&);
  SchedProcessFreeFtraceEvent& operator=(const SchedProcessFreeFtraceEvent&);
  bool operator==(const SchedProcessFreeFtraceEvent&) const;
  bool operator!=(const SchedProcessFreeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT SchedProcessForkFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kParentCommFieldNumber = 1,
    kParentPidFieldNumber = 2,
    kChildCommFieldNumber = 3,
    kChildPidFieldNumber = 4,
  };

  SchedProcessForkFtraceEvent();
  ~SchedProcessForkFtraceEvent() override;
  SchedProcessForkFtraceEvent(SchedProcessForkFtraceEvent&&) noexcept;
  SchedProcessForkFtraceEvent& operator=(SchedProcessForkFtraceEvent&&);
  SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent&);
  SchedProcessForkFtraceEvent& operator=(const SchedProcessForkFtraceEvent&);
  bool operator==(const SchedProcessForkFtraceEvent&) const;
  bool operator!=(const SchedProcessForkFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_parent_comm() const { return _has_field_[1]; }
  const std::string& parent_comm() const { return parent_comm_; }
  void set_parent_comm(const std::string& value) { parent_comm_ = value; _has_field_.set(1); }

  bool has_parent_pid() const { return _has_field_[2]; }
  int32_t parent_pid() const { return parent_pid_; }
  void set_parent_pid(int32_t value) { parent_pid_ = value; _has_field_.set(2); }

  bool has_child_comm() const { return _has_field_[3]; }
  const std::string& child_comm() const { return child_comm_; }
  void set_child_comm(const std::string& value) { child_comm_ = value; _has_field_.set(3); }

  bool has_child_pid() const { return _has_field_[4]; }
  int32_t child_pid() const { return child_pid_; }
  void set_child_pid(int32_t value) { child_pid_ = value; _has_field_.set(4); }

 private:
  std::string parent_comm_{};
  int32_t parent_pid_{};
  std::string child_comm_{};
  int32_t child_pid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT SchedProcessExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kTgidFieldNumber = 3,
    kPrioFieldNumber = 4,
  };

  SchedProcessExitFtraceEvent();
  ~SchedProcessExitFtraceEvent() override;
  SchedProcessExitFtraceEvent(SchedProcessExitFtraceEvent&&) noexcept;
  SchedProcessExitFtraceEvent& operator=(SchedProcessExitFtraceEvent&&);
  SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent&);
  SchedProcessExitFtraceEvent& operator=(const SchedProcessExitFtraceEvent&);
  bool operator==(const SchedProcessExitFtraceEvent&) const;
  bool operator!=(const SchedProcessExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_tgid() const { return _has_field_[3]; }
  int32_t tgid() const { return tgid_; }
  void set_tgid(int32_t value) { tgid_ = value; _has_field_.set(3); }

  bool has_prio() const { return _has_field_[4]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(4); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t tgid_{};
  int32_t prio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT SchedProcessExecFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFilenameFieldNumber = 1,
    kPidFieldNumber = 2,
    kOldPidFieldNumber = 3,
  };

  SchedProcessExecFtraceEvent();
  ~SchedProcessExecFtraceEvent() override;
  SchedProcessExecFtraceEvent(SchedProcessExecFtraceEvent&&) noexcept;
  SchedProcessExecFtraceEvent& operator=(SchedProcessExecFtraceEvent&&);
  SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent&);
  SchedProcessExecFtraceEvent& operator=(const SchedProcessExecFtraceEvent&);
  bool operator==(const SchedProcessExecFtraceEvent&) const;
  bool operator!=(const SchedProcessExecFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_filename() const { return _has_field_[1]; }
  const std::string& filename() const { return filename_; }
  void set_filename(const std::string& value) { filename_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_old_pid() const { return _has_field_[3]; }
  int32_t old_pid() const { return old_pid_; }
  void set_old_pid(int32_t value) { old_pid_ = value; _has_field_.set(3); }

 private:
  std::string filename_{};
  int32_t pid_{};
  int32_t old_pid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT SchedWakeupNewFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };

  SchedWakeupNewFtraceEvent();
  ~SchedWakeupNewFtraceEvent() override;
  SchedWakeupNewFtraceEvent(SchedWakeupNewFtraceEvent&&) noexcept;
  SchedWakeupNewFtraceEvent& operator=(SchedWakeupNewFtraceEvent&&);
  SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent&);
  SchedWakeupNewFtraceEvent& operator=(const SchedWakeupNewFtraceEvent&);
  bool operator==(const SchedWakeupNewFtraceEvent&) const;
  bool operator!=(const SchedWakeupNewFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

  bool has_success() const { return _has_field_[4]; }
  int32_t success() const { return success_; }
  void set_success(int32_t value) { success_ = value; _has_field_.set(4); }

  bool has_target_cpu() const { return _has_field_[5]; }
  int32_t target_cpu() const { return target_cpu_; }
  void set_target_cpu(int32_t value) { target_cpu_ = value; _has_field_.set(5); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};
  int32_t success_{};
  int32_t target_cpu_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT SchedWakingFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };

  SchedWakingFtraceEvent();
  ~SchedWakingFtraceEvent() override;
  SchedWakingFtraceEvent(SchedWakingFtraceEvent&&) noexcept;
  SchedWakingFtraceEvent& operator=(SchedWakingFtraceEvent&&);
  SchedWakingFtraceEvent(const SchedWakingFtraceEvent&);
  SchedWakingFtraceEvent& operator=(const SchedWakingFtraceEvent&);
  bool operator==(const SchedWakingFtraceEvent&) const;
  bool operator!=(const SchedWakingFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

  bool has_success() const { return _has_field_[4]; }
  int32_t success() const { return success_; }
  void set_success(int32_t value) { success_ = value; _has_field_.set(4); }

  bool has_target_cpu() const { return _has_field_[5]; }
  int32_t target_cpu() const { return target_cpu_; }
  void set_target_cpu(int32_t value) { target_cpu_ = value; _has_field_.set(5); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};
  int32_t success_{};
  int32_t target_cpu_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT SchedCpuHotplugFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAffectedCpuFieldNumber = 1,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 3,
  };

  SchedCpuHotplugFtraceEvent();
  ~SchedCpuHotplugFtraceEvent() override;
  SchedCpuHotplugFtraceEvent(SchedCpuHotplugFtraceEvent&&) noexcept;
  SchedCpuHotplugFtraceEvent& operator=(SchedCpuHotplugFtraceEvent&&);
  SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent&);
  SchedCpuHotplugFtraceEvent& operator=(const SchedCpuHotplugFtraceEvent&);
  bool operator==(const SchedCpuHotplugFtraceEvent&) const;
  bool operator!=(const SchedCpuHotplugFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_affected_cpu() const { return _has_field_[1]; }
  int32_t affected_cpu() const { return affected_cpu_; }
  void set_affected_cpu(int32_t value) { affected_cpu_ = value; _has_field_.set(1); }

  bool has_error() const { return _has_field_[2]; }
  int32_t error() const { return error_; }
  void set_error(int32_t value) { error_ = value; _has_field_.set(2); }

  bool has_status() const { return _has_field_[3]; }
  int32_t status() const { return status_; }
  void set_status(int32_t value) { status_ = value; _has_field_.set(3); }

 private:
  int32_t affected_cpu_{};
  int32_t error_{};
  int32_t status_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT SchedBlockedReasonFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPidFieldNumber = 1,
    kCallerFieldNumber = 2,
    kIoWaitFieldNumber = 3,
  };

  SchedBlockedReasonFtraceEvent();
  ~SchedBlockedReasonFtraceEvent() override;
  SchedBlockedReasonFtraceEvent(SchedBlockedReasonFtraceEvent&&) noexcept;
  SchedBlockedReasonFtraceEvent& operator=(SchedBlockedReasonFtraceEvent&&);
  SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent&);
  SchedBlockedReasonFtraceEvent& operator=(const SchedBlockedReasonFtraceEvent&);
  bool operator==(const SchedBlockedReasonFtraceEvent&) const;
  bool operator!=(const SchedBlockedReasonFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pid() const { return _has_field_[1]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(1); }

  bool has_caller() const { return _has_field_[2]; }
  uint64_t caller() const { return caller_; }
  void set_caller(uint64_t value) { caller_ = value; _has_field_.set(2); }

  bool has_io_wait() const { return _has_field_[3]; }
  uint32_t io_wait() const { return io_wait_; }
  void set_io_wait(uint32_t value) { io_wait_ = value; _has_field_.set(3); }

 private:
  int32_t pid_{};
  uint64_t caller_{};
  uint32_t io_wait_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT SchedWakeupFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };

  SchedWakeupFtraceEvent();
  ~SchedWakeupFtraceEvent() override;
  SchedWakeupFtraceEvent(SchedWakeupFtraceEvent&&) noexcept;
  SchedWakeupFtraceEvent& operator=(SchedWakeupFtraceEvent&&);
  SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent&);
  SchedWakeupFtraceEvent& operator=(const SchedWakeupFtraceEvent&);
  bool operator==(const SchedWakeupFtraceEvent&) const;
  bool operator!=(const SchedWakeupFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

  bool has_success() const { return _has_field_[4]; }
  int32_t success() const { return success_; }
  void set_success(int32_t value) { success_ = value; _has_field_.set(4); }

  bool has_target_cpu() const { return _has_field_[5]; }
  int32_t target_cpu() const { return target_cpu_; }
  void set_target_cpu(int32_t value) { target_cpu_ = value; _has_field_.set(5); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};
  int32_t success_{};
  int32_t target_cpu_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT SchedSwitchFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPrevCommFieldNumber = 1,
    kPrevPidFieldNumber = 2,
    kPrevPrioFieldNumber = 3,
    kPrevStateFieldNumber = 4,
    kNextCommFieldNumber = 5,
    kNextPidFieldNumber = 6,
    kNextPrioFieldNumber = 7,
  };

  SchedSwitchFtraceEvent();
  ~SchedSwitchFtraceEvent() override;
  SchedSwitchFtraceEvent(SchedSwitchFtraceEvent&&) noexcept;
  SchedSwitchFtraceEvent& operator=(SchedSwitchFtraceEvent&&);
  SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent&);
  SchedSwitchFtraceEvent& operator=(const SchedSwitchFtraceEvent&);
  bool operator==(const SchedSwitchFtraceEvent&) const;
  bool operator!=(const SchedSwitchFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_prev_comm() const { return _has_field_[1]; }
  const std::string& prev_comm() const { return prev_comm_; }
  void set_prev_comm(const std::string& value) { prev_comm_ = value; _has_field_.set(1); }

  bool has_prev_pid() const { return _has_field_[2]; }
  int32_t prev_pid() const { return prev_pid_; }
  void set_prev_pid(int32_t value) { prev_pid_ = value; _has_field_.set(2); }

  bool has_prev_prio() const { return _has_field_[3]; }
  int32_t prev_prio() const { return prev_prio_; }
  void set_prev_prio(int32_t value) { prev_prio_ = value; _has_field_.set(3); }

  bool has_prev_state() const { return _has_field_[4]; }
  int64_t prev_state() const { return prev_state_; }
  void set_prev_state(int64_t value) { prev_state_ = value; _has_field_.set(4); }

  bool has_next_comm() const { return _has_field_[5]; }
  const std::string& next_comm() const { return next_comm_; }
  void set_next_comm(const std::string& value) { next_comm_ = value; _has_field_.set(5); }

  bool has_next_pid() const { return _has_field_[6]; }
  int32_t next_pid() const { return next_pid_; }
  void set_next_pid(int32_t value) { next_pid_ = value; _has_field_.set(6); }

  bool has_next_prio() const { return _has_field_[7]; }
  int32_t next_prio() const { return next_prio_; }
  void set_next_prio(int32_t value) { next_prio_ = value; _has_field_.set(7); }

 private:
  std::string prev_comm_{};
  int32_t prev_pid_{};
  int32_t prev_prio_{};
  int64_t prev_state_{};
  std::string next_comm_{};
  int32_t next_pid_{};
  int32_t next_prio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_CPP_H_
