#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/mdss.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

RotatorBwAoAsContextFtraceEvent::RotatorBwAoAsContextFtraceEvent() = default;
RotatorBwAoAsContextFtraceEvent::~RotatorBwAoAsContextFtraceEvent() = default;
RotatorBwAoAsContextFtraceEvent::RotatorBwAoAsContextFtraceEvent(const RotatorBwAoAsContextFtraceEvent&) = default;
RotatorBwAoAsContextFtraceEvent& RotatorBwAoAsContextFtraceEvent::operator=(const RotatorBwAoAsContextFtraceEvent&) = default;
RotatorBwAoAsContextFtraceEvent::RotatorBwAoAsContextFtraceEvent(RotatorBwAoAsContextFtraceEvent&&) noexcept = default;
RotatorBwAoAsContextFtraceEvent& RotatorBwAoAsContextFtraceEvent::operator=(RotatorBwAoAsContextFtraceEvent&&) = default;

bool RotatorBwAoAsContextFtraceEvent::operator==(const RotatorBwAoAsContextFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && state_ == other.state_;
}

bool RotatorBwAoAsContextFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* state */:
        field.get(&state_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string RotatorBwAoAsContextFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> RotatorBwAoAsContextFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void RotatorBwAoAsContextFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: state
  if (_has_field_[1]) {
    msg->AppendVarInt(1, state_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpPerfUpdateBusFtraceEvent::MdpPerfUpdateBusFtraceEvent() = default;
MdpPerfUpdateBusFtraceEvent::~MdpPerfUpdateBusFtraceEvent() = default;
MdpPerfUpdateBusFtraceEvent::MdpPerfUpdateBusFtraceEvent(const MdpPerfUpdateBusFtraceEvent&) = default;
MdpPerfUpdateBusFtraceEvent& MdpPerfUpdateBusFtraceEvent::operator=(const MdpPerfUpdateBusFtraceEvent&) = default;
MdpPerfUpdateBusFtraceEvent::MdpPerfUpdateBusFtraceEvent(MdpPerfUpdateBusFtraceEvent&&) noexcept = default;
MdpPerfUpdateBusFtraceEvent& MdpPerfUpdateBusFtraceEvent::operator=(MdpPerfUpdateBusFtraceEvent&&) = default;

bool MdpPerfUpdateBusFtraceEvent::operator==(const MdpPerfUpdateBusFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && client_ == other.client_
   && ab_quota_ == other.ab_quota_
   && ib_quota_ == other.ib_quota_;
}

bool MdpPerfUpdateBusFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* client */:
        field.get(&client_);
        break;
      case 2 /* ab_quota */:
        field.get(&ab_quota_);
        break;
      case 3 /* ib_quota */:
        field.get(&ib_quota_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpPerfUpdateBusFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpPerfUpdateBusFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpPerfUpdateBusFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: client
  if (_has_field_[1]) {
    msg->AppendVarInt(1, client_);
  }

  // Field 2: ab_quota
  if (_has_field_[2]) {
    msg->AppendVarInt(2, ab_quota_);
  }

  // Field 3: ib_quota
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ib_quota_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpPerfPrefillCalcFtraceEvent::MdpPerfPrefillCalcFtraceEvent() = default;
MdpPerfPrefillCalcFtraceEvent::~MdpPerfPrefillCalcFtraceEvent() = default;
MdpPerfPrefillCalcFtraceEvent::MdpPerfPrefillCalcFtraceEvent(const MdpPerfPrefillCalcFtraceEvent&) = default;
MdpPerfPrefillCalcFtraceEvent& MdpPerfPrefillCalcFtraceEvent::operator=(const MdpPerfPrefillCalcFtraceEvent&) = default;
MdpPerfPrefillCalcFtraceEvent::MdpPerfPrefillCalcFtraceEvent(MdpPerfPrefillCalcFtraceEvent&&) noexcept = default;
MdpPerfPrefillCalcFtraceEvent& MdpPerfPrefillCalcFtraceEvent::operator=(MdpPerfPrefillCalcFtraceEvent&&) = default;

bool MdpPerfPrefillCalcFtraceEvent::operator==(const MdpPerfPrefillCalcFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pnum_ == other.pnum_
   && latency_buf_ == other.latency_buf_
   && ot_ == other.ot_
   && y_buf_ == other.y_buf_
   && y_scaler_ == other.y_scaler_
   && pp_lines_ == other.pp_lines_
   && pp_bytes_ == other.pp_bytes_
   && post_sc_ == other.post_sc_
   && fbc_bytes_ == other.fbc_bytes_
   && prefill_bytes_ == other.prefill_bytes_;
}

bool MdpPerfPrefillCalcFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pnum */:
        field.get(&pnum_);
        break;
      case 2 /* latency_buf */:
        field.get(&latency_buf_);
        break;
      case 3 /* ot */:
        field.get(&ot_);
        break;
      case 4 /* y_buf */:
        field.get(&y_buf_);
        break;
      case 5 /* y_scaler */:
        field.get(&y_scaler_);
        break;
      case 6 /* pp_lines */:
        field.get(&pp_lines_);
        break;
      case 7 /* pp_bytes */:
        field.get(&pp_bytes_);
        break;
      case 8 /* post_sc */:
        field.get(&post_sc_);
        break;
      case 9 /* fbc_bytes */:
        field.get(&fbc_bytes_);
        break;
      case 10 /* prefill_bytes */:
        field.get(&prefill_bytes_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpPerfPrefillCalcFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpPerfPrefillCalcFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpPerfPrefillCalcFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pnum
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pnum_);
  }

  // Field 2: latency_buf
  if (_has_field_[2]) {
    msg->AppendVarInt(2, latency_buf_);
  }

  // Field 3: ot
  if (_has_field_[3]) {
    msg->AppendVarInt(3, ot_);
  }

  // Field 4: y_buf
  if (_has_field_[4]) {
    msg->AppendVarInt(4, y_buf_);
  }

  // Field 5: y_scaler
  if (_has_field_[5]) {
    msg->AppendVarInt(5, y_scaler_);
  }

  // Field 6: pp_lines
  if (_has_field_[6]) {
    msg->AppendVarInt(6, pp_lines_);
  }

  // Field 7: pp_bytes
  if (_has_field_[7]) {
    msg->AppendVarInt(7, pp_bytes_);
  }

  // Field 8: post_sc
  if (_has_field_[8]) {
    msg->AppendVarInt(8, post_sc_);
  }

  // Field 9: fbc_bytes
  if (_has_field_[9]) {
    msg->AppendVarInt(9, fbc_bytes_);
  }

  // Field 10: prefill_bytes
  if (_has_field_[10]) {
    msg->AppendVarInt(10, prefill_bytes_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpCmdWaitPingpongFtraceEvent::MdpCmdWaitPingpongFtraceEvent() = default;
MdpCmdWaitPingpongFtraceEvent::~MdpCmdWaitPingpongFtraceEvent() = default;
MdpCmdWaitPingpongFtraceEvent::MdpCmdWaitPingpongFtraceEvent(const MdpCmdWaitPingpongFtraceEvent&) = default;
MdpCmdWaitPingpongFtraceEvent& MdpCmdWaitPingpongFtraceEvent::operator=(const MdpCmdWaitPingpongFtraceEvent&) = default;
MdpCmdWaitPingpongFtraceEvent::MdpCmdWaitPingpongFtraceEvent(MdpCmdWaitPingpongFtraceEvent&&) noexcept = default;
MdpCmdWaitPingpongFtraceEvent& MdpCmdWaitPingpongFtraceEvent::operator=(MdpCmdWaitPingpongFtraceEvent&&) = default;

bool MdpCmdWaitPingpongFtraceEvent::operator==(const MdpCmdWaitPingpongFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && ctl_num_ == other.ctl_num_
   && kickoff_cnt_ == other.kickoff_cnt_;
}

bool MdpCmdWaitPingpongFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ctl_num */:
        field.get(&ctl_num_);
        break;
      case 2 /* kickoff_cnt */:
        field.get(&kickoff_cnt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpCmdWaitPingpongFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpCmdWaitPingpongFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpCmdWaitPingpongFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ctl_num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, ctl_num_);
  }

  // Field 2: kickoff_cnt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, kickoff_cnt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpVideoUnderrunDoneFtraceEvent::MdpVideoUnderrunDoneFtraceEvent() = default;
MdpVideoUnderrunDoneFtraceEvent::~MdpVideoUnderrunDoneFtraceEvent() = default;
MdpVideoUnderrunDoneFtraceEvent::MdpVideoUnderrunDoneFtraceEvent(const MdpVideoUnderrunDoneFtraceEvent&) = default;
MdpVideoUnderrunDoneFtraceEvent& MdpVideoUnderrunDoneFtraceEvent::operator=(const MdpVideoUnderrunDoneFtraceEvent&) = default;
MdpVideoUnderrunDoneFtraceEvent::MdpVideoUnderrunDoneFtraceEvent(MdpVideoUnderrunDoneFtraceEvent&&) noexcept = default;
MdpVideoUnderrunDoneFtraceEvent& MdpVideoUnderrunDoneFtraceEvent::operator=(MdpVideoUnderrunDoneFtraceEvent&&) = default;

bool MdpVideoUnderrunDoneFtraceEvent::operator==(const MdpVideoUnderrunDoneFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && ctl_num_ == other.ctl_num_
   && underrun_cnt_ == other.underrun_cnt_;
}

bool MdpVideoUnderrunDoneFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ctl_num */:
        field.get(&ctl_num_);
        break;
      case 2 /* underrun_cnt */:
        field.get(&underrun_cnt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpVideoUnderrunDoneFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpVideoUnderrunDoneFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpVideoUnderrunDoneFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ctl_num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, ctl_num_);
  }

  // Field 2: underrun_cnt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, underrun_cnt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpPerfSetWmLevelsFtraceEvent::MdpPerfSetWmLevelsFtraceEvent() = default;
MdpPerfSetWmLevelsFtraceEvent::~MdpPerfSetWmLevelsFtraceEvent() = default;
MdpPerfSetWmLevelsFtraceEvent::MdpPerfSetWmLevelsFtraceEvent(const MdpPerfSetWmLevelsFtraceEvent&) = default;
MdpPerfSetWmLevelsFtraceEvent& MdpPerfSetWmLevelsFtraceEvent::operator=(const MdpPerfSetWmLevelsFtraceEvent&) = default;
MdpPerfSetWmLevelsFtraceEvent::MdpPerfSetWmLevelsFtraceEvent(MdpPerfSetWmLevelsFtraceEvent&&) noexcept = default;
MdpPerfSetWmLevelsFtraceEvent& MdpPerfSetWmLevelsFtraceEvent::operator=(MdpPerfSetWmLevelsFtraceEvent&&) = default;

bool MdpPerfSetWmLevelsFtraceEvent::operator==(const MdpPerfSetWmLevelsFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pnum_ == other.pnum_
   && use_space_ == other.use_space_
   && priority_bytes_ == other.priority_bytes_
   && wm0_ == other.wm0_
   && wm1_ == other.wm1_
   && wm2_ == other.wm2_
   && mb_cnt_ == other.mb_cnt_
   && mb_size_ == other.mb_size_;
}

bool MdpPerfSetWmLevelsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pnum */:
        field.get(&pnum_);
        break;
      case 2 /* use_space */:
        field.get(&use_space_);
        break;
      case 3 /* priority_bytes */:
        field.get(&priority_bytes_);
        break;
      case 4 /* wm0 */:
        field.get(&wm0_);
        break;
      case 5 /* wm1 */:
        field.get(&wm1_);
        break;
      case 6 /* wm2 */:
        field.get(&wm2_);
        break;
      case 7 /* mb_cnt */:
        field.get(&mb_cnt_);
        break;
      case 8 /* mb_size */:
        field.get(&mb_size_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpPerfSetWmLevelsFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpPerfSetWmLevelsFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpPerfSetWmLevelsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pnum
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pnum_);
  }

  // Field 2: use_space
  if (_has_field_[2]) {
    msg->AppendVarInt(2, use_space_);
  }

  // Field 3: priority_bytes
  if (_has_field_[3]) {
    msg->AppendVarInt(3, priority_bytes_);
  }

  // Field 4: wm0
  if (_has_field_[4]) {
    msg->AppendVarInt(4, wm0_);
  }

  // Field 5: wm1
  if (_has_field_[5]) {
    msg->AppendVarInt(5, wm1_);
  }

  // Field 6: wm2
  if (_has_field_[6]) {
    msg->AppendVarInt(6, wm2_);
  }

  // Field 7: mb_cnt
  if (_has_field_[7]) {
    msg->AppendVarInt(7, mb_cnt_);
  }

  // Field 8: mb_size
  if (_has_field_[8]) {
    msg->AppendVarInt(8, mb_size_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpMixerUpdateFtraceEvent::MdpMixerUpdateFtraceEvent() = default;
MdpMixerUpdateFtraceEvent::~MdpMixerUpdateFtraceEvent() = default;
MdpMixerUpdateFtraceEvent::MdpMixerUpdateFtraceEvent(const MdpMixerUpdateFtraceEvent&) = default;
MdpMixerUpdateFtraceEvent& MdpMixerUpdateFtraceEvent::operator=(const MdpMixerUpdateFtraceEvent&) = default;
MdpMixerUpdateFtraceEvent::MdpMixerUpdateFtraceEvent(MdpMixerUpdateFtraceEvent&&) noexcept = default;
MdpMixerUpdateFtraceEvent& MdpMixerUpdateFtraceEvent::operator=(MdpMixerUpdateFtraceEvent&&) = default;

bool MdpMixerUpdateFtraceEvent::operator==(const MdpMixerUpdateFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && mixer_num_ == other.mixer_num_;
}

bool MdpMixerUpdateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* mixer_num */:
        field.get(&mixer_num_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpMixerUpdateFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpMixerUpdateFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpMixerUpdateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: mixer_num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, mixer_num_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpCmdReleaseBwFtraceEvent::MdpCmdReleaseBwFtraceEvent() = default;
MdpCmdReleaseBwFtraceEvent::~MdpCmdReleaseBwFtraceEvent() = default;
MdpCmdReleaseBwFtraceEvent::MdpCmdReleaseBwFtraceEvent(const MdpCmdReleaseBwFtraceEvent&) = default;
MdpCmdReleaseBwFtraceEvent& MdpCmdReleaseBwFtraceEvent::operator=(const MdpCmdReleaseBwFtraceEvent&) = default;
MdpCmdReleaseBwFtraceEvent::MdpCmdReleaseBwFtraceEvent(MdpCmdReleaseBwFtraceEvent&&) noexcept = default;
MdpCmdReleaseBwFtraceEvent& MdpCmdReleaseBwFtraceEvent::operator=(MdpCmdReleaseBwFtraceEvent&&) = default;

bool MdpCmdReleaseBwFtraceEvent::operator==(const MdpCmdReleaseBwFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && ctl_num_ == other.ctl_num_;
}

bool MdpCmdReleaseBwFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ctl_num */:
        field.get(&ctl_num_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpCmdReleaseBwFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpCmdReleaseBwFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpCmdReleaseBwFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ctl_num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, ctl_num_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpTraceCounterFtraceEvent::MdpTraceCounterFtraceEvent() = default;
MdpTraceCounterFtraceEvent::~MdpTraceCounterFtraceEvent() = default;
MdpTraceCounterFtraceEvent::MdpTraceCounterFtraceEvent(const MdpTraceCounterFtraceEvent&) = default;
MdpTraceCounterFtraceEvent& MdpTraceCounterFtraceEvent::operator=(const MdpTraceCounterFtraceEvent&) = default;
MdpTraceCounterFtraceEvent::MdpTraceCounterFtraceEvent(MdpTraceCounterFtraceEvent&&) noexcept = default;
MdpTraceCounterFtraceEvent& MdpTraceCounterFtraceEvent::operator=(MdpTraceCounterFtraceEvent&&) = default;

bool MdpTraceCounterFtraceEvent::operator==(const MdpTraceCounterFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pid_ == other.pid_
   && counter_name_ == other.counter_name_
   && value_ == other.value_;
}

bool MdpTraceCounterFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pid */:
        field.get(&pid_);
        break;
      case 2 /* counter_name */:
        field.get(&counter_name_);
        break;
      case 3 /* value */:
        field.get(&value_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpTraceCounterFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpTraceCounterFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpTraceCounterFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pid_);
  }

  // Field 2: counter_name
  if (_has_field_[2]) {
    msg->AppendString(2, counter_name_);
  }

  // Field 3: value
  if (_has_field_[3]) {
    msg->AppendVarInt(3, value_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpPerfSetQosLutsFtraceEvent::MdpPerfSetQosLutsFtraceEvent() = default;
MdpPerfSetQosLutsFtraceEvent::~MdpPerfSetQosLutsFtraceEvent() = default;
MdpPerfSetQosLutsFtraceEvent::MdpPerfSetQosLutsFtraceEvent(const MdpPerfSetQosLutsFtraceEvent&) = default;
MdpPerfSetQosLutsFtraceEvent& MdpPerfSetQosLutsFtraceEvent::operator=(const MdpPerfSetQosLutsFtraceEvent&) = default;
MdpPerfSetQosLutsFtraceEvent::MdpPerfSetQosLutsFtraceEvent(MdpPerfSetQosLutsFtraceEvent&&) noexcept = default;
MdpPerfSetQosLutsFtraceEvent& MdpPerfSetQosLutsFtraceEvent::operator=(MdpPerfSetQosLutsFtraceEvent&&) = default;

bool MdpPerfSetQosLutsFtraceEvent::operator==(const MdpPerfSetQosLutsFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pnum_ == other.pnum_
   && fmt_ == other.fmt_
   && intf_ == other.intf_
   && rot_ == other.rot_
   && fl_ == other.fl_
   && lut_ == other.lut_
   && linear_ == other.linear_;
}

bool MdpPerfSetQosLutsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pnum */:
        field.get(&pnum_);
        break;
      case 2 /* fmt */:
        field.get(&fmt_);
        break;
      case 3 /* intf */:
        field.get(&intf_);
        break;
      case 4 /* rot */:
        field.get(&rot_);
        break;
      case 5 /* fl */:
        field.get(&fl_);
        break;
      case 6 /* lut */:
        field.get(&lut_);
        break;
      case 7 /* linear */:
        field.get(&linear_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpPerfSetQosLutsFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpPerfSetQosLutsFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpPerfSetQosLutsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pnum
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pnum_);
  }

  // Field 2: fmt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, fmt_);
  }

  // Field 3: intf
  if (_has_field_[3]) {
    msg->AppendVarInt(3, intf_);
  }

  // Field 4: rot
  if (_has_field_[4]) {
    msg->AppendVarInt(4, rot_);
  }

  // Field 5: fl
  if (_has_field_[5]) {
    msg->AppendVarInt(5, fl_);
  }

  // Field 6: lut
  if (_has_field_[6]) {
    msg->AppendVarInt(6, lut_);
  }

  // Field 7: linear
  if (_has_field_[7]) {
    msg->AppendVarInt(7, linear_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpMisrCrcFtraceEvent::MdpMisrCrcFtraceEvent() = default;
MdpMisrCrcFtraceEvent::~MdpMisrCrcFtraceEvent() = default;
MdpMisrCrcFtraceEvent::MdpMisrCrcFtraceEvent(const MdpMisrCrcFtraceEvent&) = default;
MdpMisrCrcFtraceEvent& MdpMisrCrcFtraceEvent::operator=(const MdpMisrCrcFtraceEvent&) = default;
MdpMisrCrcFtraceEvent::MdpMisrCrcFtraceEvent(MdpMisrCrcFtraceEvent&&) noexcept = default;
MdpMisrCrcFtraceEvent& MdpMisrCrcFtraceEvent::operator=(MdpMisrCrcFtraceEvent&&) = default;

bool MdpMisrCrcFtraceEvent::operator==(const MdpMisrCrcFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && block_id_ == other.block_id_
   && vsync_cnt_ == other.vsync_cnt_
   && crc_ == other.crc_;
}

bool MdpMisrCrcFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* block_id */:
        field.get(&block_id_);
        break;
      case 2 /* vsync_cnt */:
        field.get(&vsync_cnt_);
        break;
      case 3 /* crc */:
        field.get(&crc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpMisrCrcFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpMisrCrcFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpMisrCrcFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: block_id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, block_id_);
  }

  // Field 2: vsync_cnt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, vsync_cnt_);
  }

  // Field 3: crc
  if (_has_field_[3]) {
    msg->AppendVarInt(3, crc_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpCmdReadptrDoneFtraceEvent::MdpCmdReadptrDoneFtraceEvent() = default;
MdpCmdReadptrDoneFtraceEvent::~MdpCmdReadptrDoneFtraceEvent() = default;
MdpCmdReadptrDoneFtraceEvent::MdpCmdReadptrDoneFtraceEvent(const MdpCmdReadptrDoneFtraceEvent&) = default;
MdpCmdReadptrDoneFtraceEvent& MdpCmdReadptrDoneFtraceEvent::operator=(const MdpCmdReadptrDoneFtraceEvent&) = default;
MdpCmdReadptrDoneFtraceEvent::MdpCmdReadptrDoneFtraceEvent(MdpCmdReadptrDoneFtraceEvent&&) noexcept = default;
MdpCmdReadptrDoneFtraceEvent& MdpCmdReadptrDoneFtraceEvent::operator=(MdpCmdReadptrDoneFtraceEvent&&) = default;

bool MdpCmdReadptrDoneFtraceEvent::operator==(const MdpCmdReadptrDoneFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && ctl_num_ == other.ctl_num_
   && koff_cnt_ == other.koff_cnt_;
}

bool MdpCmdReadptrDoneFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ctl_num */:
        field.get(&ctl_num_);
        break;
      case 2 /* koff_cnt */:
        field.get(&koff_cnt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpCmdReadptrDoneFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpCmdReadptrDoneFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpCmdReadptrDoneFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ctl_num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, ctl_num_);
  }

  // Field 2: koff_cnt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, koff_cnt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpSsppSetFtraceEvent::MdpSsppSetFtraceEvent() = default;
MdpSsppSetFtraceEvent::~MdpSsppSetFtraceEvent() = default;
MdpSsppSetFtraceEvent::MdpSsppSetFtraceEvent(const MdpSsppSetFtraceEvent&) = default;
MdpSsppSetFtraceEvent& MdpSsppSetFtraceEvent::operator=(const MdpSsppSetFtraceEvent&) = default;
MdpSsppSetFtraceEvent::MdpSsppSetFtraceEvent(MdpSsppSetFtraceEvent&&) noexcept = default;
MdpSsppSetFtraceEvent& MdpSsppSetFtraceEvent::operator=(MdpSsppSetFtraceEvent&&) = default;

bool MdpSsppSetFtraceEvent::operator==(const MdpSsppSetFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && num_ == other.num_
   && play_cnt_ == other.play_cnt_
   && mixer_ == other.mixer_
   && stage_ == other.stage_
   && flags_ == other.flags_
   && format_ == other.format_
   && img_w_ == other.img_w_
   && img_h_ == other.img_h_
   && src_x_ == other.src_x_
   && src_y_ == other.src_y_
   && src_w_ == other.src_w_
   && src_h_ == other.src_h_
   && dst_x_ == other.dst_x_
   && dst_y_ == other.dst_y_
   && dst_w_ == other.dst_w_
   && dst_h_ == other.dst_h_;
}

bool MdpSsppSetFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* num */:
        field.get(&num_);
        break;
      case 2 /* play_cnt */:
        field.get(&play_cnt_);
        break;
      case 3 /* mixer */:
        field.get(&mixer_);
        break;
      case 4 /* stage */:
        field.get(&stage_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      case 6 /* format */:
        field.get(&format_);
        break;
      case 7 /* img_w */:
        field.get(&img_w_);
        break;
      case 8 /* img_h */:
        field.get(&img_h_);
        break;
      case 9 /* src_x */:
        field.get(&src_x_);
        break;
      case 10 /* src_y */:
        field.get(&src_y_);
        break;
      case 11 /* src_w */:
        field.get(&src_w_);
        break;
      case 12 /* src_h */:
        field.get(&src_h_);
        break;
      case 13 /* dst_x */:
        field.get(&dst_x_);
        break;
      case 14 /* dst_y */:
        field.get(&dst_y_);
        break;
      case 15 /* dst_w */:
        field.get(&dst_w_);
        break;
      case 16 /* dst_h */:
        field.get(&dst_h_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpSsppSetFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpSsppSetFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpSsppSetFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, num_);
  }

  // Field 2: play_cnt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, play_cnt_);
  }

  // Field 3: mixer
  if (_has_field_[3]) {
    msg->AppendVarInt(3, mixer_);
  }

  // Field 4: stage
  if (_has_field_[4]) {
    msg->AppendVarInt(4, stage_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  // Field 6: format
  if (_has_field_[6]) {
    msg->AppendVarInt(6, format_);
  }

  // Field 7: img_w
  if (_has_field_[7]) {
    msg->AppendVarInt(7, img_w_);
  }

  // Field 8: img_h
  if (_has_field_[8]) {
    msg->AppendVarInt(8, img_h_);
  }

  // Field 9: src_x
  if (_has_field_[9]) {
    msg->AppendVarInt(9, src_x_);
  }

  // Field 10: src_y
  if (_has_field_[10]) {
    msg->AppendVarInt(10, src_y_);
  }

  // Field 11: src_w
  if (_has_field_[11]) {
    msg->AppendVarInt(11, src_w_);
  }

  // Field 12: src_h
  if (_has_field_[12]) {
    msg->AppendVarInt(12, src_h_);
  }

  // Field 13: dst_x
  if (_has_field_[13]) {
    msg->AppendVarInt(13, dst_x_);
  }

  // Field 14: dst_y
  if (_has_field_[14]) {
    msg->AppendVarInt(14, dst_y_);
  }

  // Field 15: dst_w
  if (_has_field_[15]) {
    msg->AppendVarInt(15, dst_w_);
  }

  // Field 16: dst_h
  if (_has_field_[16]) {
    msg->AppendVarInt(16, dst_h_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpPerfSetPanicLutsFtraceEvent::MdpPerfSetPanicLutsFtraceEvent() = default;
MdpPerfSetPanicLutsFtraceEvent::~MdpPerfSetPanicLutsFtraceEvent() = default;
MdpPerfSetPanicLutsFtraceEvent::MdpPerfSetPanicLutsFtraceEvent(const MdpPerfSetPanicLutsFtraceEvent&) = default;
MdpPerfSetPanicLutsFtraceEvent& MdpPerfSetPanicLutsFtraceEvent::operator=(const MdpPerfSetPanicLutsFtraceEvent&) = default;
MdpPerfSetPanicLutsFtraceEvent::MdpPerfSetPanicLutsFtraceEvent(MdpPerfSetPanicLutsFtraceEvent&&) noexcept = default;
MdpPerfSetPanicLutsFtraceEvent& MdpPerfSetPanicLutsFtraceEvent::operator=(MdpPerfSetPanicLutsFtraceEvent&&) = default;

bool MdpPerfSetPanicLutsFtraceEvent::operator==(const MdpPerfSetPanicLutsFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pnum_ == other.pnum_
   && fmt_ == other.fmt_
   && mode_ == other.mode_
   && panic_lut_ == other.panic_lut_
   && robust_lut_ == other.robust_lut_;
}

bool MdpPerfSetPanicLutsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pnum */:
        field.get(&pnum_);
        break;
      case 2 /* fmt */:
        field.get(&fmt_);
        break;
      case 3 /* mode */:
        field.get(&mode_);
        break;
      case 4 /* panic_lut */:
        field.get(&panic_lut_);
        break;
      case 5 /* robust_lut */:
        field.get(&robust_lut_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpPerfSetPanicLutsFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpPerfSetPanicLutsFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpPerfSetPanicLutsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pnum
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pnum_);
  }

  // Field 2: fmt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, fmt_);
  }

  // Field 3: mode
  if (_has_field_[3]) {
    msg->AppendVarInt(3, mode_);
  }

  // Field 4: panic_lut
  if (_has_field_[4]) {
    msg->AppendVarInt(4, panic_lut_);
  }

  // Field 5: robust_lut
  if (_has_field_[5]) {
    msg->AppendVarInt(5, robust_lut_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpCompareBwFtraceEvent::MdpCompareBwFtraceEvent() = default;
MdpCompareBwFtraceEvent::~MdpCompareBwFtraceEvent() = default;
MdpCompareBwFtraceEvent::MdpCompareBwFtraceEvent(const MdpCompareBwFtraceEvent&) = default;
MdpCompareBwFtraceEvent& MdpCompareBwFtraceEvent::operator=(const MdpCompareBwFtraceEvent&) = default;
MdpCompareBwFtraceEvent::MdpCompareBwFtraceEvent(MdpCompareBwFtraceEvent&&) noexcept = default;
MdpCompareBwFtraceEvent& MdpCompareBwFtraceEvent::operator=(MdpCompareBwFtraceEvent&&) = default;

bool MdpCompareBwFtraceEvent::operator==(const MdpCompareBwFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && new_ab_ == other.new_ab_
   && new_ib_ == other.new_ib_
   && new_wb_ == other.new_wb_
   && old_ab_ == other.old_ab_
   && old_ib_ == other.old_ib_
   && old_wb_ == other.old_wb_
   && params_changed_ == other.params_changed_
   && update_bw_ == other.update_bw_;
}

bool MdpCompareBwFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* new_ab */:
        field.get(&new_ab_);
        break;
      case 2 /* new_ib */:
        field.get(&new_ib_);
        break;
      case 3 /* new_wb */:
        field.get(&new_wb_);
        break;
      case 4 /* old_ab */:
        field.get(&old_ab_);
        break;
      case 5 /* old_ib */:
        field.get(&old_ib_);
        break;
      case 6 /* old_wb */:
        field.get(&old_wb_);
        break;
      case 7 /* params_changed */:
        field.get(&params_changed_);
        break;
      case 8 /* update_bw */:
        field.get(&update_bw_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpCompareBwFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpCompareBwFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpCompareBwFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: new_ab
  if (_has_field_[1]) {
    msg->AppendVarInt(1, new_ab_);
  }

  // Field 2: new_ib
  if (_has_field_[2]) {
    msg->AppendVarInt(2, new_ib_);
  }

  // Field 3: new_wb
  if (_has_field_[3]) {
    msg->AppendVarInt(3, new_wb_);
  }

  // Field 4: old_ab
  if (_has_field_[4]) {
    msg->AppendVarInt(4, old_ab_);
  }

  // Field 5: old_ib
  if (_has_field_[5]) {
    msg->AppendVarInt(5, old_ib_);
  }

  // Field 6: old_wb
  if (_has_field_[6]) {
    msg->AppendVarInt(6, old_wb_);
  }

  // Field 7: params_changed
  if (_has_field_[7]) {
    msg->AppendVarInt(7, params_changed_);
  }

  // Field 8: update_bw
  if (_has_field_[8]) {
    msg->AppendVarInt(8, update_bw_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpCmdPingpongDoneFtraceEvent::MdpCmdPingpongDoneFtraceEvent() = default;
MdpCmdPingpongDoneFtraceEvent::~MdpCmdPingpongDoneFtraceEvent() = default;
MdpCmdPingpongDoneFtraceEvent::MdpCmdPingpongDoneFtraceEvent(const MdpCmdPingpongDoneFtraceEvent&) = default;
MdpCmdPingpongDoneFtraceEvent& MdpCmdPingpongDoneFtraceEvent::operator=(const MdpCmdPingpongDoneFtraceEvent&) = default;
MdpCmdPingpongDoneFtraceEvent::MdpCmdPingpongDoneFtraceEvent(MdpCmdPingpongDoneFtraceEvent&&) noexcept = default;
MdpCmdPingpongDoneFtraceEvent& MdpCmdPingpongDoneFtraceEvent::operator=(MdpCmdPingpongDoneFtraceEvent&&) = default;

bool MdpCmdPingpongDoneFtraceEvent::operator==(const MdpCmdPingpongDoneFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && ctl_num_ == other.ctl_num_
   && intf_num_ == other.intf_num_
   && pp_num_ == other.pp_num_
   && koff_cnt_ == other.koff_cnt_;
}

bool MdpCmdPingpongDoneFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ctl_num */:
        field.get(&ctl_num_);
        break;
      case 2 /* intf_num */:
        field.get(&intf_num_);
        break;
      case 3 /* pp_num */:
        field.get(&pp_num_);
        break;
      case 4 /* koff_cnt */:
        field.get(&koff_cnt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpCmdPingpongDoneFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpCmdPingpongDoneFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpCmdPingpongDoneFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ctl_num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, ctl_num_);
  }

  // Field 2: intf_num
  if (_has_field_[2]) {
    msg->AppendVarInt(2, intf_num_);
  }

  // Field 3: pp_num
  if (_has_field_[3]) {
    msg->AppendVarInt(3, pp_num_);
  }

  // Field 4: koff_cnt
  if (_has_field_[4]) {
    msg->AppendVarInt(4, koff_cnt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


TracingMarkWriteFtraceEvent::TracingMarkWriteFtraceEvent() = default;
TracingMarkWriteFtraceEvent::~TracingMarkWriteFtraceEvent() = default;
TracingMarkWriteFtraceEvent::TracingMarkWriteFtraceEvent(const TracingMarkWriteFtraceEvent&) = default;
TracingMarkWriteFtraceEvent& TracingMarkWriteFtraceEvent::operator=(const TracingMarkWriteFtraceEvent&) = default;
TracingMarkWriteFtraceEvent::TracingMarkWriteFtraceEvent(TracingMarkWriteFtraceEvent&&) noexcept = default;
TracingMarkWriteFtraceEvent& TracingMarkWriteFtraceEvent::operator=(TracingMarkWriteFtraceEvent&&) = default;

bool TracingMarkWriteFtraceEvent::operator==(const TracingMarkWriteFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pid_ == other.pid_
   && trace_name_ == other.trace_name_
   && trace_begin_ == other.trace_begin_;
}

bool TracingMarkWriteFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pid */:
        field.get(&pid_);
        break;
      case 2 /* trace_name */:
        field.get(&trace_name_);
        break;
      case 3 /* trace_begin */:
        field.get(&trace_begin_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TracingMarkWriteFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TracingMarkWriteFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TracingMarkWriteFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pid_);
  }

  // Field 2: trace_name
  if (_has_field_[2]) {
    msg->AppendString(2, trace_name_);
  }

  // Field 3: trace_begin
  if (_has_field_[3]) {
    msg->AppendVarInt(3, trace_begin_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpSsppChangeFtraceEvent::MdpSsppChangeFtraceEvent() = default;
MdpSsppChangeFtraceEvent::~MdpSsppChangeFtraceEvent() = default;
MdpSsppChangeFtraceEvent::MdpSsppChangeFtraceEvent(const MdpSsppChangeFtraceEvent&) = default;
MdpSsppChangeFtraceEvent& MdpSsppChangeFtraceEvent::operator=(const MdpSsppChangeFtraceEvent&) = default;
MdpSsppChangeFtraceEvent::MdpSsppChangeFtraceEvent(MdpSsppChangeFtraceEvent&&) noexcept = default;
MdpSsppChangeFtraceEvent& MdpSsppChangeFtraceEvent::operator=(MdpSsppChangeFtraceEvent&&) = default;

bool MdpSsppChangeFtraceEvent::operator==(const MdpSsppChangeFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && num_ == other.num_
   && play_cnt_ == other.play_cnt_
   && mixer_ == other.mixer_
   && stage_ == other.stage_
   && flags_ == other.flags_
   && format_ == other.format_
   && img_w_ == other.img_w_
   && img_h_ == other.img_h_
   && src_x_ == other.src_x_
   && src_y_ == other.src_y_
   && src_w_ == other.src_w_
   && src_h_ == other.src_h_
   && dst_x_ == other.dst_x_
   && dst_y_ == other.dst_y_
   && dst_w_ == other.dst_w_
   && dst_h_ == other.dst_h_;
}

bool MdpSsppChangeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* num */:
        field.get(&num_);
        break;
      case 2 /* play_cnt */:
        field.get(&play_cnt_);
        break;
      case 3 /* mixer */:
        field.get(&mixer_);
        break;
      case 4 /* stage */:
        field.get(&stage_);
        break;
      case 5 /* flags */:
        field.get(&flags_);
        break;
      case 6 /* format */:
        field.get(&format_);
        break;
      case 7 /* img_w */:
        field.get(&img_w_);
        break;
      case 8 /* img_h */:
        field.get(&img_h_);
        break;
      case 9 /* src_x */:
        field.get(&src_x_);
        break;
      case 10 /* src_y */:
        field.get(&src_y_);
        break;
      case 11 /* src_w */:
        field.get(&src_w_);
        break;
      case 12 /* src_h */:
        field.get(&src_h_);
        break;
      case 13 /* dst_x */:
        field.get(&dst_x_);
        break;
      case 14 /* dst_y */:
        field.get(&dst_y_);
        break;
      case 15 /* dst_w */:
        field.get(&dst_w_);
        break;
      case 16 /* dst_h */:
        field.get(&dst_h_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpSsppChangeFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpSsppChangeFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpSsppChangeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, num_);
  }

  // Field 2: play_cnt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, play_cnt_);
  }

  // Field 3: mixer
  if (_has_field_[3]) {
    msg->AppendVarInt(3, mixer_);
  }

  // Field 4: stage
  if (_has_field_[4]) {
    msg->AppendVarInt(4, stage_);
  }

  // Field 5: flags
  if (_has_field_[5]) {
    msg->AppendVarInt(5, flags_);
  }

  // Field 6: format
  if (_has_field_[6]) {
    msg->AppendVarInt(6, format_);
  }

  // Field 7: img_w
  if (_has_field_[7]) {
    msg->AppendVarInt(7, img_w_);
  }

  // Field 8: img_h
  if (_has_field_[8]) {
    msg->AppendVarInt(8, img_h_);
  }

  // Field 9: src_x
  if (_has_field_[9]) {
    msg->AppendVarInt(9, src_x_);
  }

  // Field 10: src_y
  if (_has_field_[10]) {
    msg->AppendVarInt(10, src_y_);
  }

  // Field 11: src_w
  if (_has_field_[11]) {
    msg->AppendVarInt(11, src_w_);
  }

  // Field 12: src_h
  if (_has_field_[12]) {
    msg->AppendVarInt(12, src_h_);
  }

  // Field 13: dst_x
  if (_has_field_[13]) {
    msg->AppendVarInt(13, dst_x_);
  }

  // Field 14: dst_y
  if (_has_field_[14]) {
    msg->AppendVarInt(14, dst_y_);
  }

  // Field 15: dst_w
  if (_has_field_[15]) {
    msg->AppendVarInt(15, dst_w_);
  }

  // Field 16: dst_h
  if (_has_field_[16]) {
    msg->AppendVarInt(16, dst_h_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpPerfSetOtFtraceEvent::MdpPerfSetOtFtraceEvent() = default;
MdpPerfSetOtFtraceEvent::~MdpPerfSetOtFtraceEvent() = default;
MdpPerfSetOtFtraceEvent::MdpPerfSetOtFtraceEvent(const MdpPerfSetOtFtraceEvent&) = default;
MdpPerfSetOtFtraceEvent& MdpPerfSetOtFtraceEvent::operator=(const MdpPerfSetOtFtraceEvent&) = default;
MdpPerfSetOtFtraceEvent::MdpPerfSetOtFtraceEvent(MdpPerfSetOtFtraceEvent&&) noexcept = default;
MdpPerfSetOtFtraceEvent& MdpPerfSetOtFtraceEvent::operator=(MdpPerfSetOtFtraceEvent&&) = default;

bool MdpPerfSetOtFtraceEvent::operator==(const MdpPerfSetOtFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pnum_ == other.pnum_
   && xin_id_ == other.xin_id_
   && rd_lim_ == other.rd_lim_
   && is_vbif_rt_ == other.is_vbif_rt_;
}

bool MdpPerfSetOtFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pnum */:
        field.get(&pnum_);
        break;
      case 2 /* xin_id */:
        field.get(&xin_id_);
        break;
      case 3 /* rd_lim */:
        field.get(&rd_lim_);
        break;
      case 4 /* is_vbif_rt */:
        field.get(&is_vbif_rt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpPerfSetOtFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpPerfSetOtFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpPerfSetOtFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pnum
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pnum_);
  }

  // Field 2: xin_id
  if (_has_field_[2]) {
    msg->AppendVarInt(2, xin_id_);
  }

  // Field 3: rd_lim
  if (_has_field_[3]) {
    msg->AppendVarInt(3, rd_lim_);
  }

  // Field 4: is_vbif_rt
  if (_has_field_[4]) {
    msg->AppendVarInt(4, is_vbif_rt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpCommitFtraceEvent::MdpCommitFtraceEvent() = default;
MdpCommitFtraceEvent::~MdpCommitFtraceEvent() = default;
MdpCommitFtraceEvent::MdpCommitFtraceEvent(const MdpCommitFtraceEvent&) = default;
MdpCommitFtraceEvent& MdpCommitFtraceEvent::operator=(const MdpCommitFtraceEvent&) = default;
MdpCommitFtraceEvent::MdpCommitFtraceEvent(MdpCommitFtraceEvent&&) noexcept = default;
MdpCommitFtraceEvent& MdpCommitFtraceEvent::operator=(MdpCommitFtraceEvent&&) = default;

bool MdpCommitFtraceEvent::operator==(const MdpCommitFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && num_ == other.num_
   && play_cnt_ == other.play_cnt_
   && clk_rate_ == other.clk_rate_
   && bandwidth_ == other.bandwidth_;
}

bool MdpCommitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* num */:
        field.get(&num_);
        break;
      case 2 /* play_cnt */:
        field.get(&play_cnt_);
        break;
      case 3 /* clk_rate */:
        field.get(&clk_rate_);
        break;
      case 4 /* bandwidth */:
        field.get(&bandwidth_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpCommitFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpCommitFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpCommitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, num_);
  }

  // Field 2: play_cnt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, play_cnt_);
  }

  // Field 3: clk_rate
  if (_has_field_[3]) {
    msg->AppendVarInt(3, clk_rate_);
  }

  // Field 4: bandwidth
  if (_has_field_[4]) {
    msg->AppendVarInt(4, bandwidth_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MdpCmdKickoffFtraceEvent::MdpCmdKickoffFtraceEvent() = default;
MdpCmdKickoffFtraceEvent::~MdpCmdKickoffFtraceEvent() = default;
MdpCmdKickoffFtraceEvent::MdpCmdKickoffFtraceEvent(const MdpCmdKickoffFtraceEvent&) = default;
MdpCmdKickoffFtraceEvent& MdpCmdKickoffFtraceEvent::operator=(const MdpCmdKickoffFtraceEvent&) = default;
MdpCmdKickoffFtraceEvent::MdpCmdKickoffFtraceEvent(MdpCmdKickoffFtraceEvent&&) noexcept = default;
MdpCmdKickoffFtraceEvent& MdpCmdKickoffFtraceEvent::operator=(MdpCmdKickoffFtraceEvent&&) = default;

bool MdpCmdKickoffFtraceEvent::operator==(const MdpCmdKickoffFtraceEvent& other) const {
  return unknown_fields_ == other.unknown_fields_
   && ctl_num_ == other.ctl_num_
   && kickoff_cnt_ == other.kickoff_cnt_;
}

bool MdpCmdKickoffFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ctl_num */:
        field.get(&ctl_num_);
        break;
      case 2 /* kickoff_cnt */:
        field.get(&kickoff_cnt_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MdpCmdKickoffFtraceEvent::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MdpCmdKickoffFtraceEvent::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MdpCmdKickoffFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ctl_num
  if (_has_field_[1]) {
    msg->AppendVarInt(1, ctl_num_);
  }

  // Field 2: kickoff_cnt
  if (_has_field_[2]) {
    msg->AppendVarInt(2, kickoff_cnt_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
