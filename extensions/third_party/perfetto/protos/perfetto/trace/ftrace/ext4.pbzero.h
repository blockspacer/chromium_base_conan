// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class Ext4ZeroRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ZeroRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ZeroRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ZeroRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
};

class Ext4ZeroRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ZeroRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4WritepagesResultFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepagesResultFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepagesResultFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepagesResultFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
  bool has_pages_written() const { return at<4>().valid(); }
  int32_t pages_written() const { return at<4>().as_int32(); }
  bool has_pages_skipped() const { return at<5>().valid(); }
  int64_t pages_skipped() const { return at<5>().as_int64(); }
  bool has_writeback_index() const { return at<6>().valid(); }
  uint64_t writeback_index() const { return at<6>().as_uint64(); }
  bool has_sync_mode() const { return at<7>().valid(); }
  int32_t sync_mode() const { return at<7>().as_int32(); }
};

class Ext4WritepagesResultFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepagesResultFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
    kPagesWrittenFieldNumber = 4,
    kPagesSkippedFieldNumber = 5,
    kWritebackIndexFieldNumber = 6,
    kSyncModeFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_pages_written(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_pages_skipped(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_writeback_index(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4WritepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nr_to_write() const { return at<3>().valid(); }
  int64_t nr_to_write() const { return at<3>().as_int64(); }
  bool has_pages_skipped() const { return at<4>().valid(); }
  int64_t pages_skipped() const { return at<4>().as_int64(); }
  bool has_range_start() const { return at<5>().valid(); }
  int64_t range_start() const { return at<5>().as_int64(); }
  bool has_range_end() const { return at<6>().valid(); }
  int64_t range_end() const { return at<6>().as_int64(); }
  bool has_writeback_index() const { return at<7>().valid(); }
  uint64_t writeback_index() const { return at<7>().as_uint64(); }
  bool has_sync_mode() const { return at<8>().valid(); }
  int32_t sync_mode() const { return at<8>().as_int32(); }
  bool has_for_kupdate() const { return at<9>().valid(); }
  uint32_t for_kupdate() const { return at<9>().as_uint32(); }
  bool has_range_cyclic() const { return at<10>().valid(); }
  uint32_t range_cyclic() const { return at<10>().as_uint32(); }
};

class Ext4WritepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepagesFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNrToWriteFieldNumber = 3,
    kPagesSkippedFieldNumber = 4,
    kRangeStartFieldNumber = 5,
    kRangeEndFieldNumber = 6,
    kWritebackIndexFieldNumber = 7,
    kSyncModeFieldNumber = 8,
    kForKupdateFieldNumber = 9,
    kRangeCyclicFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_to_write(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_pages_skipped(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_range_start(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_range_end(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_writeback_index(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_for_kupdate(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_range_cyclic(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4WritepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4WritepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4WriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4WriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4WriteBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WriteBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WriteBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WriteBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4WriteBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WriteBeginFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4UnlinkExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4UnlinkExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4UnlinkExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4UnlinkExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class Ext4UnlinkExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4UnlinkExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4UnlinkEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4UnlinkEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4UnlinkEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4UnlinkEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_parent() const { return at<3>().valid(); }
  uint64_t parent() const { return at<3>().as_uint64(); }
  bool has_size() const { return at<4>().valid(); }
  int64_t size() const { return at<4>().as_int64(); }
};

class Ext4UnlinkEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4UnlinkEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kParentFieldNumber = 3,
    kSizeFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_parent(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4TruncateExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TruncateExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TruncateExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TruncateExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  uint64_t blocks() const { return at<3>().as_uint64(); }
};

class Ext4TruncateExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TruncateExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4TruncateEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TruncateEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TruncateEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TruncateEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  uint64_t blocks() const { return at<3>().as_uint64(); }
};

class Ext4TruncateEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TruncateEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4TrimExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TrimExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TrimExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TrimExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev_major() const { return at<1>().valid(); }
  int32_t dev_major() const { return at<1>().as_int32(); }
  bool has_dev_minor() const { return at<2>().valid(); }
  int32_t dev_minor() const { return at<2>().as_int32(); }
  bool has_group() const { return at<3>().valid(); }
  uint32_t group() const { return at<3>().as_uint32(); }
  bool has_start() const { return at<4>().valid(); }
  int32_t start() const { return at<4>().as_int32(); }
  bool has_len() const { return at<5>().valid(); }
  int32_t len() const { return at<5>().as_int32(); }
};

class Ext4TrimExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TrimExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevMajorFieldNumber = 1,
    kDevMinorFieldNumber = 2,
    kGroupFieldNumber = 3,
    kStartFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev_major(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dev_minor(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4TrimAllFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TrimAllFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TrimAllFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TrimAllFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev_major() const { return at<1>().valid(); }
  int32_t dev_major() const { return at<1>().as_int32(); }
  bool has_dev_minor() const { return at<2>().valid(); }
  int32_t dev_minor() const { return at<2>().as_int32(); }
  bool has_group() const { return at<3>().valid(); }
  uint32_t group() const { return at<3>().as_uint32(); }
  bool has_start() const { return at<4>().valid(); }
  int32_t start() const { return at<4>().as_int32(); }
  bool has_len() const { return at<5>().valid(); }
  int32_t len() const { return at<5>().as_int32(); }
};

class Ext4TrimAllFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TrimAllFreeFtraceEvent_Decoder;
  enum : int32_t {
    kDevMajorFieldNumber = 1,
    kDevMinorFieldNumber = 2,
    kGroupFieldNumber = 3,
    kStartFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev_major(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dev_minor(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4SyncFsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_wait() const { return at<2>().valid(); }
  int32_t wait() const { return at<2>().as_int32(); }
};

class Ext4SyncFsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kWaitFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_wait(int32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4RequestInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RequestInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RequestInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RequestInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_dir() const { return at<2>().valid(); }
  uint64_t dir() const { return at<2>().as_uint64(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
};

class Ext4RequestInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RequestInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kDirFieldNumber = 2,
    kModeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_dir(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4RequestBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RequestBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RequestBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RequestBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_len() const { return at<3>().valid(); }
  uint32_t len() const { return at<3>().as_uint32(); }
  bool has_logical() const { return at<4>().valid(); }
  uint32_t logical() const { return at<4>().as_uint32(); }
  bool has_lleft() const { return at<5>().valid(); }
  uint32_t lleft() const { return at<5>().as_uint32(); }
  bool has_lright() const { return at<6>().valid(); }
  uint32_t lright() const { return at<6>().as_uint32(); }
  bool has_goal() const { return at<7>().valid(); }
  uint64_t goal() const { return at<7>().as_uint64(); }
  bool has_pleft() const { return at<8>().valid(); }
  uint64_t pleft() const { return at<8>().as_uint64(); }
  bool has_pright() const { return at<9>().valid(); }
  uint64_t pright() const { return at<9>().as_uint64(); }
  bool has_flags() const { return at<10>().valid(); }
  uint32_t flags() const { return at<10>().as_uint32(); }
};

class Ext4RequestBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RequestBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLenFieldNumber = 3,
    kLogicalFieldNumber = 4,
    kLleftFieldNumber = 5,
    kLrightFieldNumber = 6,
    kGoalFieldNumber = 7,
    kPleftFieldNumber = 8,
    kPrightFieldNumber = 9,
    kFlagsFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_logical(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_lleft(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lright(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_goal(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_pleft(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_pright(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4RemoveBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RemoveBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RemoveBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RemoveBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_from() const { return at<3>().valid(); }
  uint32_t from() const { return at<3>().as_uint32(); }
  bool has_to() const { return at<4>().valid(); }
  uint32_t to() const { return at<4>().as_uint32(); }
  bool has_partial() const { return at<5>().valid(); }
  int64_t partial() const { return at<5>().as_int64(); }
  bool has_ee_pblk() const { return at<6>().valid(); }
  uint64_t ee_pblk() const { return at<6>().as_uint64(); }
  bool has_ee_lblk() const { return at<7>().valid(); }
  uint32_t ee_lblk() const { return at<7>().as_uint32(); }
  bool has_ee_len() const { return at<8>().valid(); }
  uint32_t ee_len() const { return at<8>().as_uint32(); }
};

class Ext4RemoveBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RemoveBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kPartialFieldNumber = 5,
    kEePblkFieldNumber = 6,
    kEeLblkFieldNumber = 7,
    kEeLenFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_from(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_to(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_ee_pblk(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_ee_lblk(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ee_len(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ReleasepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReleasepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReleasepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReleasepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4ReleasepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReleasepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ReadpageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReadpageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReadpageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReadpageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4ReadpageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReadpageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ReadBlockBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4ReadBlockBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReadBlockBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4PunchHoleFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4PunchHoleFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4PunchHoleFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4PunchHoleFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
};

class Ext4PunchHoleFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4PunchHoleFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4OtherInodeUpdateTimeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_ino() const { return at<3>().valid(); }
  uint64_t orig_ino() const { return at<3>().as_uint64(); }
  bool has_uid() const { return at<4>().valid(); }
  uint32_t uid() const { return at<4>().as_uint32(); }
  bool has_gid() const { return at<5>().valid(); }
  uint32_t gid() const { return at<5>().as_uint32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4OtherInodeUpdateTimeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4OtherInodeUpdateTimeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigInoFieldNumber = 3,
    kUidFieldNumber = 4,
    kGidFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_ino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_uid(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_gid(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4MballocPreallocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocPreallocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocPreallocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocPreallocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_logical() const { return at<3>().valid(); }
  uint32_t orig_logical() const { return at<3>().as_uint32(); }
  bool has_orig_start() const { return at<4>().valid(); }
  int32_t orig_start() const { return at<4>().as_int32(); }
  bool has_orig_group() const { return at<5>().valid(); }
  uint32_t orig_group() const { return at<5>().as_uint32(); }
  bool has_orig_len() const { return at<6>().valid(); }
  int32_t orig_len() const { return at<6>().as_int32(); }
  bool has_result_logical() const { return at<7>().valid(); }
  uint32_t result_logical() const { return at<7>().as_uint32(); }
  bool has_result_start() const { return at<8>().valid(); }
  int32_t result_start() const { return at<8>().as_int32(); }
  bool has_result_group() const { return at<9>().valid(); }
  uint32_t result_group() const { return at<9>().as_uint32(); }
  bool has_result_len() const { return at<10>().valid(); }
  int32_t result_len() const { return at<10>().as_int32(); }
};

class Ext4MballocPreallocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocPreallocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigLogicalFieldNumber = 3,
    kOrigStartFieldNumber = 4,
    kOrigGroupFieldNumber = 5,
    kOrigLenFieldNumber = 6,
    kResultLogicalFieldNumber = 7,
    kResultStartFieldNumber = 8,
    kResultGroupFieldNumber = 9,
    kResultLenFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_logical(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_orig_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_orig_group(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_orig_len(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_result_logical(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4MballocFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_result_start() const { return at<3>().valid(); }
  int32_t result_start() const { return at<3>().as_int32(); }
  bool has_result_group() const { return at<4>().valid(); }
  uint32_t result_group() const { return at<4>().as_uint32(); }
  bool has_result_len() const { return at<5>().valid(); }
  int32_t result_len() const { return at<5>().as_int32(); }
};

class Ext4MballocFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocFreeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kResultStartFieldNumber = 3,
    kResultGroupFieldNumber = 4,
    kResultLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MballocDiscardFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocDiscardFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocDiscardFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocDiscardFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_result_start() const { return at<3>().valid(); }
  int32_t result_start() const { return at<3>().as_int32(); }
  bool has_result_group() const { return at<4>().valid(); }
  uint32_t result_group() const { return at<4>().as_uint32(); }
  bool has_result_len() const { return at<5>().valid(); }
  int32_t result_len() const { return at<5>().as_int32(); }
};

class Ext4MballocDiscardFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocDiscardFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kResultStartFieldNumber = 3,
    kResultGroupFieldNumber = 4,
    kResultLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MballocAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/20, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_logical() const { return at<3>().valid(); }
  uint32_t orig_logical() const { return at<3>().as_uint32(); }
  bool has_orig_start() const { return at<4>().valid(); }
  int32_t orig_start() const { return at<4>().as_int32(); }
  bool has_orig_group() const { return at<5>().valid(); }
  uint32_t orig_group() const { return at<5>().as_uint32(); }
  bool has_orig_len() const { return at<6>().valid(); }
  int32_t orig_len() const { return at<6>().as_int32(); }
  bool has_goal_logical() const { return at<7>().valid(); }
  uint32_t goal_logical() const { return at<7>().as_uint32(); }
  bool has_goal_start() const { return at<8>().valid(); }
  int32_t goal_start() const { return at<8>().as_int32(); }
  bool has_goal_group() const { return at<9>().valid(); }
  uint32_t goal_group() const { return at<9>().as_uint32(); }
  bool has_goal_len() const { return at<10>().valid(); }
  int32_t goal_len() const { return at<10>().as_int32(); }
  bool has_result_logical() const { return at<11>().valid(); }
  uint32_t result_logical() const { return at<11>().as_uint32(); }
  bool has_result_start() const { return at<12>().valid(); }
  int32_t result_start() const { return at<12>().as_int32(); }
  bool has_result_group() const { return at<13>().valid(); }
  uint32_t result_group() const { return at<13>().as_uint32(); }
  bool has_result_len() const { return at<14>().valid(); }
  int32_t result_len() const { return at<14>().as_int32(); }
  bool has_found() const { return at<15>().valid(); }
  uint32_t found() const { return at<15>().as_uint32(); }
  bool has_groups() const { return at<16>().valid(); }
  uint32_t groups() const { return at<16>().as_uint32(); }
  bool has_buddy() const { return at<17>().valid(); }
  uint32_t buddy() const { return at<17>().as_uint32(); }
  bool has_flags() const { return at<18>().valid(); }
  uint32_t flags() const { return at<18>().as_uint32(); }
  bool has_tail() const { return at<19>().valid(); }
  uint32_t tail() const { return at<19>().as_uint32(); }
  bool has_cr() const { return at<20>().valid(); }
  uint32_t cr() const { return at<20>().as_uint32(); }
};

class Ext4MballocAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocAllocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigLogicalFieldNumber = 3,
    kOrigStartFieldNumber = 4,
    kOrigGroupFieldNumber = 5,
    kOrigLenFieldNumber = 6,
    kGoalLogicalFieldNumber = 7,
    kGoalStartFieldNumber = 8,
    kGoalGroupFieldNumber = 9,
    kGoalLenFieldNumber = 10,
    kResultLogicalFieldNumber = 11,
    kResultStartFieldNumber = 12,
    kResultGroupFieldNumber = 13,
    kResultLenFieldNumber = 14,
    kFoundFieldNumber = 15,
    kGroupsFieldNumber = 16,
    kBuddyFieldNumber = 17,
    kFlagsFieldNumber = 18,
    kTailFieldNumber = 19,
    kCrFieldNumber = 20,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_logical(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_orig_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_orig_group(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_orig_len(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_goal_logical(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_goal_start(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_goal_group(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_goal_len(int32_t value) {
    AppendVarInt(10, value);
  }
  void set_result_logical(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(12, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(14, value);
  }
  void set_found(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_groups(uint32_t value) {
    AppendVarInt(16, value);
  }
  void set_buddy(uint32_t value) {
    AppendVarInt(17, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(18, value);
  }
  void set_tail(uint32_t value) {
    AppendVarInt(19, value);
  }
  void set_cr(uint32_t value) {
    AppendVarInt(20, value);
  }
};

class Ext4MbReleaseInodePaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbReleaseInodePaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbReleaseInodePaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbReleaseInodePaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_count() const { return at<4>().valid(); }
  uint32_t count() const { return at<4>().as_uint32(); }
};

class Ext4MbReleaseInodePaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbReleaseInodePaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_count(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4MbReleaseGroupPaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbReleaseGroupPaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbReleaseGroupPaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbReleaseGroupPaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_pa_pstart() const { return at<2>().valid(); }
  uint64_t pa_pstart() const { return at<2>().as_uint64(); }
  bool has_pa_len() const { return at<3>().valid(); }
  uint32_t pa_len() const { return at<3>().as_uint32(); }
};

class Ext4MbReleaseGroupPaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbReleaseGroupPaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kPaPstartFieldNumber = 2,
    kPaLenFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4MbNewInodePaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbNewInodePaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbNewInodePaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbNewInodePaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pa_pstart() const { return at<3>().valid(); }
  uint64_t pa_pstart() const { return at<3>().as_uint64(); }
  bool has_pa_lstart() const { return at<4>().valid(); }
  uint64_t pa_lstart() const { return at<4>().as_uint64(); }
  bool has_pa_len() const { return at<5>().valid(); }
  uint32_t pa_len() const { return at<5>().as_uint32(); }
};

class Ext4MbNewInodePaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbNewInodePaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPaPstartFieldNumber = 3,
    kPaLstartFieldNumber = 4,
    kPaLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pa_lstart(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MbNewGroupPaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbNewGroupPaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbNewGroupPaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbNewGroupPaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pa_pstart() const { return at<3>().valid(); }
  uint64_t pa_pstart() const { return at<3>().as_uint64(); }
  bool has_pa_lstart() const { return at<4>().valid(); }
  uint64_t pa_lstart() const { return at<4>().as_uint64(); }
  bool has_pa_len() const { return at<5>().valid(); }
  uint32_t pa_len() const { return at<5>().as_uint32(); }
};

class Ext4MbNewGroupPaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbNewGroupPaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPaPstartFieldNumber = 3,
    kPaLstartFieldNumber = 4,
    kPaLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pa_lstart(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MbDiscardPreallocationsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_needed() const { return at<2>().valid(); }
  int32_t needed() const { return at<2>().as_int32(); }
};

class Ext4MbDiscardPreallocationsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbDiscardPreallocationsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNeededFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_needed(int32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MbBuddyBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4MbBuddyBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbBuddyBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MbBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4MbBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MarkInodeDirtyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MarkInodeDirtyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MarkInodeDirtyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MarkInodeDirtyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ip() const { return at<3>().valid(); }
  uint64_t ip() const { return at<3>().as_uint64(); }
};

class Ext4MarkInodeDirtyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MarkInodeDirtyFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIpFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4LoadInodeBitmapFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4LoadInodeBitmapFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4LoadInodeBitmapFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4LoadInodeBitmapFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4LoadInodeBitmapFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4LoadInodeBitmapFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4LoadInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4LoadInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4LoadInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4LoadInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
};

class Ext4LoadInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4LoadInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4JournalledWriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalledWriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalledWriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalledWriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4JournalledWriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalledWriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4JournalledInvalidatepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalledInvalidatepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalledInvalidatepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalledInvalidatepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_offset() const { return at<4>().valid(); }
  uint64_t offset() const { return at<4>().as_uint64(); }
  bool has_length() const { return at<5>().valid(); }
  uint32_t length() const { return at<5>().as_uint32(); }
};

class Ext4JournalledInvalidatepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalledInvalidatepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_length(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4JournalStartReservedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalStartReservedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalStartReservedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalStartReservedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ip() const { return at<2>().valid(); }
  uint64_t ip() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  int32_t blocks() const { return at<3>().as_int32(); }
};

class Ext4JournalStartReservedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalStartReservedFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kIpFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4JournalStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ip() const { return at<2>().valid(); }
  uint64_t ip() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  int32_t blocks() const { return at<3>().as_int32(); }
  bool has_rsv_blocks() const { return at<4>().valid(); }
  int32_t rsv_blocks() const { return at<4>().as_int32(); }
  bool has_nblocks() const { return at<5>().valid(); }
  int32_t nblocks() const { return at<5>().as_int32(); }
};

class Ext4JournalStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalStartFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kIpFieldNumber = 2,
    kBlocksFieldNumber = 3,
    kRsvBlocksFieldNumber = 4,
    kNblocksFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_rsv_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_nblocks(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4InvalidatepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4InvalidatepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4InvalidatepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4InvalidatepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_offset() const { return at<4>().valid(); }
  uint64_t offset() const { return at<4>().as_uint64(); }
  bool has_length() const { return at<5>().valid(); }
  uint32_t length() const { return at<5>().as_uint32(); }
};

class Ext4InvalidatepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4InvalidatepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_length(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4InsertRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4InsertRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4InsertRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4InsertRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4InsertRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4InsertRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4IndMapBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4IndMapBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4IndMapBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4IndMapBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_lblk() const { return at<5>().valid(); }
  uint32_t lblk() const { return at<5>().as_uint32(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_mflags() const { return at<7>().valid(); }
  uint32_t mflags() const { return at<7>().as_uint32(); }
  bool has_ret() const { return at<8>().valid(); }
  int32_t ret() const { return at<8>().as_int32(); }
};

class Ext4IndMapBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4IndMapBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kMflagsFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mflags(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4IndMapBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4IndMapBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4IndMapBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4IndMapBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4IndMapBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4IndMapBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4GetReservedClusterAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4GetReservedClusterAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4GetReservedClusterAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4GetReservedClusterAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
};

class Ext4GetReservedClusterAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4GetReservedClusterAllocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_ret() const { return at<6>().valid(); }
  int32_t ret() const { return at<6>().as_int32(); }
};

class Ext4GetImpliedClusterAllocExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLblkFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLenFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4FreeInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FreeInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FreeInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FreeInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_uid() const { return at<3>().valid(); }
  uint32_t uid() const { return at<3>().as_uint32(); }
  bool has_gid() const { return at<4>().valid(); }
  uint32_t gid() const { return at<4>().as_uint32(); }
  bool has_blocks() const { return at<5>().valid(); }
  uint64_t blocks() const { return at<5>().as_uint64(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4FreeInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FreeInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kUidFieldNumber = 3,
    kGidFieldNumber = 4,
    kBlocksFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_uid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_gid(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4FreeBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FreeBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FreeBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FreeBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_count() const { return at<4>().valid(); }
  uint64_t count() const { return at<4>().as_uint64(); }
  bool has_flags() const { return at<5>().valid(); }
  int32_t flags() const { return at<5>().as_int32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4FreeBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FreeBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kCountFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4ForgetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ForgetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ForgetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ForgetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_is_metadata() const { return at<4>().valid(); }
  int32_t is_metadata() const { return at<4>().as_int32(); }
  bool has_mode() const { return at<5>().valid(); }
  uint32_t mode() const { return at<5>().as_uint32(); }
};

class Ext4ForgetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ForgetFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kIsMetadataFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_is_metadata(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4FindDelallocRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FindDelallocRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FindDelallocRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FindDelallocRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_from() const { return at<3>().valid(); }
  uint32_t from() const { return at<3>().as_uint32(); }
  bool has_to() const { return at<4>().valid(); }
  uint32_t to() const { return at<4>().as_uint32(); }
  bool has_reverse() const { return at<5>().valid(); }
  int32_t reverse() const { return at<5>().as_int32(); }
  bool has_found() const { return at<6>().valid(); }
  int32_t found() const { return at<6>().as_int32(); }
  bool has_found_blk() const { return at<7>().valid(); }
  uint32_t found_blk() const { return at<7>().as_uint32(); }
};

class Ext4FindDelallocRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FindDelallocRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kReverseFieldNumber = 5,
    kFoundFieldNumber = 6,
    kFoundBlkFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_from(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_to(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_reverse(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_found(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_found_blk(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4FallocateExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FallocateExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FallocateExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FallocateExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint32_t blocks() const { return at<4>().as_uint32(); }
  bool has_ret() const { return at<5>().valid(); }
  int32_t ret() const { return at<5>().as_int32(); }
};

class Ext4FallocateExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FallocateExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4FallocateEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FallocateEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FallocateEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FallocateEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
  bool has_pos() const { return at<6>().valid(); }
  int64_t pos() const { return at<6>().as_int64(); }
};

class Ext4FallocateEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FallocateEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
    kPosFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4ExtShowExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtShowExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtShowExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtShowExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
};

class Ext4ExtShowExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtShowExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
    kLblkFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtRmLeafFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRmLeafFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRmLeafFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRmLeafFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_partial() const { return at<3>().valid(); }
  int64_t partial() const { return at<3>().as_int64(); }
  bool has_start() const { return at<4>().valid(); }
  uint32_t start() const { return at<4>().as_uint32(); }
  bool has_ee_lblk() const { return at<5>().valid(); }
  uint32_t ee_lblk() const { return at<5>().as_uint32(); }
  bool has_ee_pblk() const { return at<6>().valid(); }
  uint64_t ee_pblk() const { return at<6>().as_uint64(); }
  bool has_ee_len() const { return at<7>().valid(); }
  int32_t ee_len() const { return at<7>().as_int32(); }
};

class Ext4ExtRmLeafFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRmLeafFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPartialFieldNumber = 3,
    kStartFieldNumber = 4,
    kEeLblkFieldNumber = 5,
    kEePblkFieldNumber = 6,
    kEeLenFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ee_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_ee_pblk(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_ee_len(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4ExtRmIdxFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRmIdxFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRmIdxFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRmIdxFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
};

class Ext4ExtRmIdxFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRmIdxFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
  bool has_end() const { return at<4>().valid(); }
  uint32_t end() const { return at<4>().as_uint32(); }
  bool has_depth() const { return at<5>().valid(); }
  int32_t depth() const { return at<5>().as_int32(); }
  bool has_partial() const { return at<6>().valid(); }
  int64_t partial() const { return at<6>().as_int64(); }
  bool has_eh_entries() const { return at<7>().valid(); }
  uint32_t eh_entries() const { return at<7>().as_uint32(); }
};

class Ext4ExtRemoveSpaceDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDepthFieldNumber = 5,
    kPartialFieldNumber = 6,
    kEhEntriesFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_end(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_eh_entries(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4ExtRemoveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRemoveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRemoveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRemoveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
  bool has_end() const { return at<4>().valid(); }
  uint32_t end() const { return at<4>().as_uint32(); }
  bool has_depth() const { return at<5>().valid(); }
  int32_t depth() const { return at<5>().as_int32(); }
};

class Ext4ExtRemoveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRemoveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDepthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_end(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtPutInCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtPutInCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtPutInCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtPutInCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_start() const { return at<5>().valid(); }
  uint64_t start() const { return at<5>().as_uint64(); }
};

class Ext4ExtPutInCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtPutInCacheFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kStartFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_start(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtMapBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtMapBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtMapBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtMapBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_lblk() const { return at<5>().valid(); }
  uint32_t lblk() const { return at<5>().as_uint32(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_mflags() const { return at<7>().valid(); }
  uint32_t mflags() const { return at<7>().as_uint32(); }
  bool has_ret() const { return at<8>().valid(); }
  int32_t ret() const { return at<8>().as_int32(); }
};

class Ext4ExtMapBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtMapBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kMflagsFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mflags(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ExtMapBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4ExtMapBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtMapBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtLoadExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtLoadExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtLoadExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtLoadExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
};

class Ext4ExtLoadExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtLoadExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
    kLblkFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4ExtInCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtInCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtInCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtInCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class Ext4ExtInCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtInCacheFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  int32_t flags() const { return at<3>().as_int32(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_allocated() const { return at<7>().valid(); }
  uint32_t allocated() const { return at<7>().as_uint32(); }
  bool has_newblk() const { return at<8>().valid(); }
  uint64_t newblk() const { return at<8>().as_uint64(); }
};

class Ext4ExtHandleUnwrittenExtentsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kLblkFieldNumber = 4,
    kPblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kAllocatedFieldNumber = 7,
    kNewblkFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_newblk(uint64_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_m_lblk() const { return at<3>().valid(); }
  uint32_t m_lblk() const { return at<3>().as_uint32(); }
  bool has_m_len() const { return at<4>().valid(); }
  uint32_t m_len() const { return at<4>().as_uint32(); }
  bool has_u_lblk() const { return at<5>().valid(); }
  uint32_t u_lblk() const { return at<5>().as_uint32(); }
  bool has_u_len() const { return at<6>().valid(); }
  uint32_t u_len() const { return at<6>().as_uint32(); }
  bool has_u_pblk() const { return at<7>().valid(); }
  uint64_t u_pblk() const { return at<7>().as_uint64(); }
  bool has_i_lblk() const { return at<8>().valid(); }
  uint32_t i_lblk() const { return at<8>().as_uint32(); }
  bool has_i_len() const { return at<9>().valid(); }
  uint32_t i_len() const { return at<9>().as_uint32(); }
  bool has_i_pblk() const { return at<10>().valid(); }
  uint64_t i_pblk() const { return at<10>().as_uint64(); }
};

class Ext4ExtConvertToInitializedFastpathFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kMLblkFieldNumber = 3,
    kMLenFieldNumber = 4,
    kULblkFieldNumber = 5,
    kULenFieldNumber = 6,
    kUPblkFieldNumber = 7,
    kILblkFieldNumber = 8,
    kILenFieldNumber = 9,
    kIPblkFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_m_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_m_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_u_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_u_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_u_pblk(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_i_lblk(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_i_len(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_i_pblk(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_m_lblk() const { return at<3>().valid(); }
  uint32_t m_lblk() const { return at<3>().as_uint32(); }
  bool has_m_len() const { return at<4>().valid(); }
  uint32_t m_len() const { return at<4>().as_uint32(); }
  bool has_u_lblk() const { return at<5>().valid(); }
  uint32_t u_lblk() const { return at<5>().as_uint32(); }
  bool has_u_len() const { return at<6>().valid(); }
  uint32_t u_len() const { return at<6>().as_uint32(); }
  bool has_u_pblk() const { return at<7>().valid(); }
  uint64_t u_pblk() const { return at<7>().as_uint64(); }
};

class Ext4ExtConvertToInitializedEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kMLblkFieldNumber = 3,
    kMLenFieldNumber = 4,
    kULblkFieldNumber = 5,
    kULenFieldNumber = 6,
    kUPblkFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_m_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_m_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_u_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_u_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_u_pblk(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4EvictInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EvictInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EvictInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EvictInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nlink() const { return at<3>().valid(); }
  int32_t nlink() const { return at<3>().as_int32(); }
};

class Ext4EvictInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EvictInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNlinkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nlink(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkScanExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkScanExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkScanExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkScanExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_shrunk() const { return at<2>().valid(); }
  int32_t nr_shrunk() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkScanExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkScanExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrShrunkFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_shrunk(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkScanEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkScanEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkScanEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkScanEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_to_scan() const { return at<2>().valid(); }
  int32_t nr_to_scan() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkScanEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkScanEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrToScanFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_to_scan(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkCountFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkCountFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkCountFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkCountFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_to_scan() const { return at<2>().valid(); }
  int32_t nr_to_scan() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkCountFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkCountFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrToScanFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_to_scan(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_shrunk() const { return at<2>().valid(); }
  int32_t nr_shrunk() const { return at<2>().as_int32(); }
  bool has_scan_time() const { return at<3>().valid(); }
  uint64_t scan_time() const { return at<3>().as_uint64(); }
  bool has_nr_skipped() const { return at<4>().valid(); }
  int32_t nr_skipped() const { return at<4>().as_int32(); }
  bool has_retried() const { return at<5>().valid(); }
  int32_t retried() const { return at<5>().as_int32(); }
};

class Ext4EsShrinkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrShrunkFieldNumber = 2,
    kScanTimeFieldNumber = 3,
    kNrSkippedFieldNumber = 4,
    kRetriedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_shrunk(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_scan_time(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_skipped(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_retried(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4EsRemoveExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsRemoveExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsRemoveExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsRemoveExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  int64_t lblk() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4EsRemoveExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsRemoveExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4EsLookupExtentExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsLookupExtentExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsLookupExtentExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsLookupExtentExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
  bool has_found() const { return at<7>().valid(); }
  int32_t found() const { return at<7>().as_int32(); }
};

class Ext4EsLookupExtentExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsLookupExtentExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
    kFoundFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_found(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4EsLookupExtentEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsLookupExtentEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsLookupExtentEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsLookupExtentEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
};

class Ext4EsLookupExtentEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsLookupExtentEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsInsertExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsInsertExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsInsertExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsInsertExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
};

class Ext4EsInsertExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsInsertExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
};

class Ext4EsFindDelayedExtentRangeExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
};

class Ext4EsFindDelayedExtentRangeEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsCacheExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsCacheExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsCacheExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsCacheExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint32_t status() const { return at<6>().as_uint32(); }
};

class Ext4EsCacheExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsCacheExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4DropInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DropInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DropInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DropInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_drop() const { return at<3>().valid(); }
  int32_t drop() const { return at<3>().as_int32(); }
};

class Ext4DropInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DropInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDropFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_drop(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4DiscardPreallocationsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DiscardPreallocationsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DiscardPreallocationsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DiscardPreallocationsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
};

class Ext4DiscardPreallocationsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DiscardPreallocationsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4DiscardBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DiscardBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DiscardBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DiscardBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_blk() const { return at<2>().valid(); }
  uint64_t blk() const { return at<2>().as_uint64(); }
  bool has_count() const { return at<3>().valid(); }
  uint64_t count() const { return at<3>().as_uint64(); }
};

class Ext4DiscardBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DiscardBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kBlkFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_blk(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4DirectIOExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DirectIOExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DirectIOExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DirectIOExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_rw() const { return at<5>().valid(); }
  int32_t rw() const { return at<5>().as_int32(); }
  bool has_ret() const { return at<6>().valid(); }
  int32_t ret() const { return at<6>().as_int32(); }
};

class Ext4DirectIOExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DirectIOExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kRwFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_rw(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4DirectIOEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DirectIOEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DirectIOEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DirectIOEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_rw() const { return at<5>().valid(); }
  int32_t rw() const { return at<5>().as_int32(); }
};

class Ext4DirectIOEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DirectIOEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kRwFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_rw(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWritePagesExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWritePagesExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWritePagesExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWritePagesExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint64_t lblk() const { return at<3>().as_uint64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4DaWritePagesExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWritePagesExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWritePagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWritePagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWritePagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWritePagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_first_page() const { return at<3>().valid(); }
  uint64_t first_page() const { return at<3>().as_uint64(); }
  bool has_nr_to_write() const { return at<4>().valid(); }
  int64_t nr_to_write() const { return at<4>().as_int64(); }
  bool has_sync_mode() const { return at<5>().valid(); }
  int32_t sync_mode() const { return at<5>().as_int32(); }
  bool has_b_blocknr() const { return at<6>().valid(); }
  uint64_t b_blocknr() const { return at<6>().as_uint64(); }
  bool has_b_size() const { return at<7>().valid(); }
  uint32_t b_size() const { return at<7>().as_uint32(); }
  bool has_b_state() const { return at<8>().valid(); }
  uint32_t b_state() const { return at<8>().as_uint32(); }
  bool has_io_done() const { return at<9>().valid(); }
  int32_t io_done() const { return at<9>().as_int32(); }
  bool has_pages_written() const { return at<10>().valid(); }
  int32_t pages_written() const { return at<10>().as_int32(); }
};

class Ext4DaWritePagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWritePagesFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFirstPageFieldNumber = 3,
    kNrToWriteFieldNumber = 4,
    kSyncModeFieldNumber = 5,
    kBBlocknrFieldNumber = 6,
    kBSizeFieldNumber = 7,
    kBStateFieldNumber = 8,
    kIoDoneFieldNumber = 9,
    kPagesWrittenFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_first_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_to_write(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_b_blocknr(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_b_size(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_b_state(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_io_done(int32_t value) {
    AppendVarInt(9, value);
  }
  void set_pages_written(int32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4DaUpdateReserveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_used_blocks() const { return at<4>().valid(); }
  int32_t used_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_data_blocks() const { return at<5>().valid(); }
  int32_t reserved_data_blocks() const { return at<5>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<6>().valid(); }
  int32_t reserved_meta_blocks() const { return at<6>().as_int32(); }
  bool has_allocated_meta_blocks() const { return at<7>().valid(); }
  int32_t allocated_meta_blocks() const { return at<7>().as_int32(); }
  bool has_quota_claim() const { return at<8>().valid(); }
  int32_t quota_claim() const { return at<8>().as_int32(); }
  bool has_mode() const { return at<9>().valid(); }
  uint32_t mode() const { return at<9>().as_uint32(); }
};

class Ext4DaUpdateReserveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaUpdateReserveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kUsedBlocksFieldNumber = 4,
    kReservedDataBlocksFieldNumber = 5,
    kReservedMetaBlocksFieldNumber = 6,
    kAllocatedMetaBlocksFieldNumber = 7,
    kQuotaClaimFieldNumber = 8,
    kModeFieldNumber = 9,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_used_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated_meta_blocks(int32_t value) {
    AppendVarInt(7, value);
  }
  void set_quota_claim(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(9, value);
  }
};

class Ext4DaReserveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaReserveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaReserveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaReserveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_reserved_data_blocks() const { return at<4>().valid(); }
  int32_t reserved_data_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<5>().valid(); }
  int32_t reserved_meta_blocks() const { return at<5>().as_int32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
  bool has_md_needed() const { return at<7>().valid(); }
  int32_t md_needed() const { return at<7>().as_int32(); }
};

class Ext4DaReserveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaReserveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kReservedDataBlocksFieldNumber = 4,
    kReservedMetaBlocksFieldNumber = 5,
    kModeFieldNumber = 6,
    kMdNeededFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_md_needed(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4DaReleaseSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaReleaseSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaReleaseSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaReleaseSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_freed_blocks() const { return at<4>().valid(); }
  int32_t freed_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_data_blocks() const { return at<5>().valid(); }
  int32_t reserved_data_blocks() const { return at<5>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<6>().valid(); }
  int32_t reserved_meta_blocks() const { return at<6>().as_int32(); }
  bool has_allocated_meta_blocks() const { return at<7>().valid(); }
  int32_t allocated_meta_blocks() const { return at<7>().as_int32(); }
  bool has_mode() const { return at<8>().valid(); }
  uint32_t mode() const { return at<8>().as_uint32(); }
};

class Ext4DaReleaseSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaReleaseSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kFreedBlocksFieldNumber = 4,
    kReservedDataBlocksFieldNumber = 5,
    kReservedMetaBlocksFieldNumber = 6,
    kAllocatedMetaBlocksFieldNumber = 7,
    kModeFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_freed_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated_meta_blocks(int32_t value) {
    AppendVarInt(7, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4CollapseRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4CollapseRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4CollapseRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4CollapseRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4CollapseRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4CollapseRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4BeginOrderedTruncateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4BeginOrderedTruncateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4BeginOrderedTruncateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4BeginOrderedTruncateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_new_size() const { return at<3>().valid(); }
  int64_t new_size() const { return at<3>().as_int64(); }
};

class Ext4BeginOrderedTruncateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4BeginOrderedTruncateFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNewSizeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_size(int64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4AllocateInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocateInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocateInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocateInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_dir() const { return at<3>().valid(); }
  uint64_t dir() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
};

class Ext4AllocateInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocateInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDirFieldNumber = 3,
    kModeFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_dir(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4AllocateBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocateBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocateBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocateBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_logical() const { return at<5>().valid(); }
  uint32_t logical() const { return at<5>().as_uint32(); }
  bool has_lleft() const { return at<6>().valid(); }
  uint32_t lleft() const { return at<6>().as_uint32(); }
  bool has_lright() const { return at<7>().valid(); }
  uint32_t lright() const { return at<7>().as_uint32(); }
  bool has_goal() const { return at<8>().valid(); }
  uint64_t goal() const { return at<8>().as_uint64(); }
  bool has_pleft() const { return at<9>().valid(); }
  uint64_t pleft() const { return at<9>().as_uint64(); }
  bool has_pright() const { return at<10>().valid(); }
  uint64_t pright() const { return at<10>().as_uint64(); }
  bool has_flags() const { return at<11>().valid(); }
  uint32_t flags() const { return at<11>().as_uint32(); }
};

class Ext4AllocateBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocateBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kLenFieldNumber = 4,
    kLogicalFieldNumber = 5,
    kLleftFieldNumber = 6,
    kLrightFieldNumber = 7,
    kGoalFieldNumber = 8,
    kPleftFieldNumber = 9,
    kPrightFieldNumber = 10,
    kFlagsFieldNumber = 11,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_logical(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lleft(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_lright(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_goal(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_pleft(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_pright(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(11, value);
  }
};

class Ext4AllocDaBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocDaBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocDaBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocDaBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_data_blocks() const { return at<3>().valid(); }
  uint32_t data_blocks() const { return at<3>().as_uint32(); }
  bool has_meta_blocks() const { return at<4>().valid(); }
  uint32_t meta_blocks() const { return at<4>().as_uint32(); }
};

class Ext4AllocDaBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocDaBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDataBlocksFieldNumber = 3,
    kMetaBlocksFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_data_blocks(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_meta_blocks(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4SyncFileExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFileExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFileExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFileExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class Ext4SyncFileExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFileExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4SyncFileEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFileEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFileEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFileEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_parent() const { return at<3>().valid(); }
  uint64_t parent() const { return at<3>().as_uint64(); }
  bool has_datasync() const { return at<4>().valid(); }
  int32_t datasync() const { return at<4>().as_int32(); }
};

class Ext4SyncFileEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFileEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kParentFieldNumber = 3,
    kDatasyncFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_parent(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_datasync(int32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4DaWriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4DaWriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWriteBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWriteBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWriteBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWriteBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4DaWriteBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWriteBeginFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
