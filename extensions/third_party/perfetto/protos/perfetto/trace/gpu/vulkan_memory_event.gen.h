// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_VULKAN_MEMORY_EVENT_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_VULKAN_MEMORY_EVENT_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class VulkanMemoryEvent;
class VulkanMemoryEventAnnotation;
enum VulkanMemoryEvent_Source : int;
enum VulkanMemoryEvent_Operation : int;
enum VulkanMemoryEvent_AllocationScope : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum VulkanMemoryEvent_Source : int {
  VulkanMemoryEvent_Source_SOURCE_UNSPECIFIED = 0,
  VulkanMemoryEvent_Source_SOURCE_DRIVER = 1,
  VulkanMemoryEvent_Source_SOURCE_DEVICE = 2,
  VulkanMemoryEvent_Source_SOURCE_DEVICE_MEMORY = 3,
  VulkanMemoryEvent_Source_SOURCE_BUFFER = 4,
  VulkanMemoryEvent_Source_SOURCE_IMAGE = 5,
};
enum VulkanMemoryEvent_Operation : int {
  VulkanMemoryEvent_Operation_OP_UNSPECIFIED = 0,
  VulkanMemoryEvent_Operation_OP_CREATE = 1,
  VulkanMemoryEvent_Operation_OP_DESTROY = 2,
  VulkanMemoryEvent_Operation_OP_BIND = 3,
  VulkanMemoryEvent_Operation_OP_DESTROY_BOUND = 4,
  VulkanMemoryEvent_Operation_OP_ANNOTATIONS = 5,
};
enum VulkanMemoryEvent_AllocationScope : int {
  VulkanMemoryEvent_AllocationScope_SCOPE_UNSPECIFIED = 0,
  VulkanMemoryEvent_AllocationScope_SCOPE_COMMAND = 1,
  VulkanMemoryEvent_AllocationScope_SCOPE_OBJECT = 2,
  VulkanMemoryEvent_AllocationScope_SCOPE_CACHE = 3,
  VulkanMemoryEvent_AllocationScope_SCOPE_DEVICE = 4,
  VulkanMemoryEvent_AllocationScope_SCOPE_INSTANCE = 5,
};

class PERFETTO_EXPORT VulkanMemoryEvent : public ::protozero::CppMessageObj {
 public:
  using Source = VulkanMemoryEvent_Source;
  static constexpr auto SOURCE_UNSPECIFIED = VulkanMemoryEvent_Source_SOURCE_UNSPECIFIED;
  static constexpr auto SOURCE_DRIVER = VulkanMemoryEvent_Source_SOURCE_DRIVER;
  static constexpr auto SOURCE_DEVICE = VulkanMemoryEvent_Source_SOURCE_DEVICE;
  static constexpr auto SOURCE_DEVICE_MEMORY = VulkanMemoryEvent_Source_SOURCE_DEVICE_MEMORY;
  static constexpr auto SOURCE_BUFFER = VulkanMemoryEvent_Source_SOURCE_BUFFER;
  static constexpr auto SOURCE_IMAGE = VulkanMemoryEvent_Source_SOURCE_IMAGE;
  static constexpr auto Source_MIN = VulkanMemoryEvent_Source_SOURCE_UNSPECIFIED;
  static constexpr auto Source_MAX = VulkanMemoryEvent_Source_SOURCE_IMAGE;
  using Operation = VulkanMemoryEvent_Operation;
  static constexpr auto OP_UNSPECIFIED = VulkanMemoryEvent_Operation_OP_UNSPECIFIED;
  static constexpr auto OP_CREATE = VulkanMemoryEvent_Operation_OP_CREATE;
  static constexpr auto OP_DESTROY = VulkanMemoryEvent_Operation_OP_DESTROY;
  static constexpr auto OP_BIND = VulkanMemoryEvent_Operation_OP_BIND;
  static constexpr auto OP_DESTROY_BOUND = VulkanMemoryEvent_Operation_OP_DESTROY_BOUND;
  static constexpr auto OP_ANNOTATIONS = VulkanMemoryEvent_Operation_OP_ANNOTATIONS;
  static constexpr auto Operation_MIN = VulkanMemoryEvent_Operation_OP_UNSPECIFIED;
  static constexpr auto Operation_MAX = VulkanMemoryEvent_Operation_OP_ANNOTATIONS;
  using AllocationScope = VulkanMemoryEvent_AllocationScope;
  static constexpr auto SCOPE_UNSPECIFIED = VulkanMemoryEvent_AllocationScope_SCOPE_UNSPECIFIED;
  static constexpr auto SCOPE_COMMAND = VulkanMemoryEvent_AllocationScope_SCOPE_COMMAND;
  static constexpr auto SCOPE_OBJECT = VulkanMemoryEvent_AllocationScope_SCOPE_OBJECT;
  static constexpr auto SCOPE_CACHE = VulkanMemoryEvent_AllocationScope_SCOPE_CACHE;
  static constexpr auto SCOPE_DEVICE = VulkanMemoryEvent_AllocationScope_SCOPE_DEVICE;
  static constexpr auto SCOPE_INSTANCE = VulkanMemoryEvent_AllocationScope_SCOPE_INSTANCE;
  static constexpr auto AllocationScope_MIN = VulkanMemoryEvent_AllocationScope_SCOPE_UNSPECIFIED;
  static constexpr auto AllocationScope_MAX = VulkanMemoryEvent_AllocationScope_SCOPE_INSTANCE;
  enum FieldNumbers {
    kSourceFieldNumber = 1,
    kOperationFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kPidFieldNumber = 4,
    kMemoryAddressFieldNumber = 5,
    kMemorySizeFieldNumber = 6,
    kCallerIidFieldNumber = 7,
    kAllocationScopeFieldNumber = 8,
    kAnnotationsFieldNumber = 9,
    kDeviceFieldNumber = 16,
    kDeviceMemoryFieldNumber = 17,
    kMemoryTypeFieldNumber = 18,
    kHeapFieldNumber = 19,
    kObjectHandleFieldNumber = 20,
  };

  VulkanMemoryEvent();
  ~VulkanMemoryEvent() override;
  VulkanMemoryEvent(VulkanMemoryEvent&&) noexcept;
  VulkanMemoryEvent& operator=(VulkanMemoryEvent&&);
  VulkanMemoryEvent(const VulkanMemoryEvent&);
  VulkanMemoryEvent& operator=(const VulkanMemoryEvent&);
  bool operator==(const VulkanMemoryEvent&) const;
  bool operator!=(const VulkanMemoryEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_source() const { return _has_field_[1]; }
  VulkanMemoryEvent_Source source() const { return source_; }
  void set_source(VulkanMemoryEvent_Source value) { source_ = value; _has_field_.set(1); }

  bool has_operation() const { return _has_field_[2]; }
  VulkanMemoryEvent_Operation operation() const { return operation_; }
  void set_operation(VulkanMemoryEvent_Operation value) { operation_ = value; _has_field_.set(2); }

  bool has_timestamp() const { return _has_field_[3]; }
  int64_t timestamp() const { return timestamp_; }
  void set_timestamp(int64_t value) { timestamp_ = value; _has_field_.set(3); }

  bool has_pid() const { return _has_field_[4]; }
  uint32_t pid() const { return pid_; }
  void set_pid(uint32_t value) { pid_ = value; _has_field_.set(4); }

  bool has_memory_address() const { return _has_field_[5]; }
  uint64_t memory_address() const { return memory_address_; }
  void set_memory_address(uint64_t value) { memory_address_ = value; _has_field_.set(5); }

  bool has_memory_size() const { return _has_field_[6]; }
  uint64_t memory_size() const { return memory_size_; }
  void set_memory_size(uint64_t value) { memory_size_ = value; _has_field_.set(6); }

  bool has_caller_iid() const { return _has_field_[7]; }
  uint64_t caller_iid() const { return caller_iid_; }
  void set_caller_iid(uint64_t value) { caller_iid_ = value; _has_field_.set(7); }

  bool has_allocation_scope() const { return _has_field_[8]; }
  VulkanMemoryEvent_AllocationScope allocation_scope() const { return allocation_scope_; }
  void set_allocation_scope(VulkanMemoryEvent_AllocationScope value) { allocation_scope_ = value; _has_field_.set(8); }

  const std::vector<VulkanMemoryEventAnnotation>& annotations() const { return annotations_; }
  std::vector<VulkanMemoryEventAnnotation>* mutable_annotations() { return &annotations_; }
  int annotations_size() const;
  void clear_annotations();
  VulkanMemoryEventAnnotation* add_annotations();

  bool has_device() const { return _has_field_[16]; }
  uint64_t device() const { return device_; }
  void set_device(uint64_t value) { device_ = value; _has_field_.set(16); }

  bool has_device_memory() const { return _has_field_[17]; }
  uint64_t device_memory() const { return device_memory_; }
  void set_device_memory(uint64_t value) { device_memory_ = value; _has_field_.set(17); }

  bool has_memory_type() const { return _has_field_[18]; }
  uint32_t memory_type() const { return memory_type_; }
  void set_memory_type(uint32_t value) { memory_type_ = value; _has_field_.set(18); }

  bool has_heap() const { return _has_field_[19]; }
  uint32_t heap() const { return heap_; }
  void set_heap(uint32_t value) { heap_ = value; _has_field_.set(19); }

  bool has_object_handle() const { return _has_field_[20]; }
  uint64_t object_handle() const { return object_handle_; }
  void set_object_handle(uint64_t value) { object_handle_ = value; _has_field_.set(20); }

 private:
  VulkanMemoryEvent_Source source_{};
  VulkanMemoryEvent_Operation operation_{};
  int64_t timestamp_{};
  uint32_t pid_{};
  uint64_t memory_address_{};
  uint64_t memory_size_{};
  uint64_t caller_iid_{};
  VulkanMemoryEvent_AllocationScope allocation_scope_{};
  std::vector<VulkanMemoryEventAnnotation> annotations_;
  uint64_t device_{};
  uint64_t device_memory_{};
  uint32_t memory_type_{};
  uint32_t heap_{};
  uint64_t object_handle_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<21> _has_field_{};
};


class PERFETTO_EXPORT VulkanMemoryEventAnnotation : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKeyIidFieldNumber = 1,
    kIntValueFieldNumber = 2,
    kDoubleValueFieldNumber = 3,
    kStringIidFieldNumber = 4,
  };

  VulkanMemoryEventAnnotation();
  ~VulkanMemoryEventAnnotation() override;
  VulkanMemoryEventAnnotation(VulkanMemoryEventAnnotation&&) noexcept;
  VulkanMemoryEventAnnotation& operator=(VulkanMemoryEventAnnotation&&);
  VulkanMemoryEventAnnotation(const VulkanMemoryEventAnnotation&);
  VulkanMemoryEventAnnotation& operator=(const VulkanMemoryEventAnnotation&);
  bool operator==(const VulkanMemoryEventAnnotation&) const;
  bool operator!=(const VulkanMemoryEventAnnotation& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_key_iid() const { return _has_field_[1]; }
  uint64_t key_iid() const { return key_iid_; }
  void set_key_iid(uint64_t value) { key_iid_ = value; _has_field_.set(1); }

  bool has_int_value() const { return _has_field_[2]; }
  int64_t int_value() const { return int_value_; }
  void set_int_value(int64_t value) { int_value_ = value; _has_field_.set(2); }

  bool has_double_value() const { return _has_field_[3]; }
  double double_value() const { return double_value_; }
  void set_double_value(double value) { double_value_ = value; _has_field_.set(3); }

  bool has_string_iid() const { return _has_field_[4]; }
  uint64_t string_iid() const { return string_iid_; }
  void set_string_iid(uint64_t value) { string_iid_ = value; _has_field_.set(4); }

 private:
  uint64_t key_iid_{};
  int64_t int_value_{};
  double double_value_{};
  uint64_t string_iid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_VULKAN_MEMORY_EVENT_PROTO_CPP_H_
