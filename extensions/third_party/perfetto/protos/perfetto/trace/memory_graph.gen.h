// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_MEMORY_GRAPH_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_MEMORY_GRAPH_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class MemoryTrackerSnapshot;
class MemoryTrackerSnapshot_ProcessSnapshot;
class MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge;
class MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode;
class MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry;
enum MemoryTrackerSnapshot_LevelOfDetail : int;
enum MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum MemoryTrackerSnapshot_LevelOfDetail : int {
  MemoryTrackerSnapshot_LevelOfDetail_DETAIL_FULL = 0,
  MemoryTrackerSnapshot_LevelOfDetail_DETAIL_LIGHT = 1,
  MemoryTrackerSnapshot_LevelOfDetail_DETAIL_BACKGROUND = 2,
};
enum MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units : int {
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units_UNSPECIFIED = 0,
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units_BYTES = 1,
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units_COUNT = 2,
};

class PERFETTO_EXPORT MemoryTrackerSnapshot : public ::protozero::CppMessageObj {
 public:
  using ProcessSnapshot = MemoryTrackerSnapshot_ProcessSnapshot;
  using LevelOfDetail = MemoryTrackerSnapshot_LevelOfDetail;
  static constexpr auto DETAIL_FULL = MemoryTrackerSnapshot_LevelOfDetail_DETAIL_FULL;
  static constexpr auto DETAIL_LIGHT = MemoryTrackerSnapshot_LevelOfDetail_DETAIL_LIGHT;
  static constexpr auto DETAIL_BACKGROUND = MemoryTrackerSnapshot_LevelOfDetail_DETAIL_BACKGROUND;
  static constexpr auto LevelOfDetail_MIN = MemoryTrackerSnapshot_LevelOfDetail_DETAIL_FULL;
  static constexpr auto LevelOfDetail_MAX = MemoryTrackerSnapshot_LevelOfDetail_DETAIL_BACKGROUND;
  enum FieldNumbers {
    kGlobalDumpIdFieldNumber = 1,
    kLevelOfDetailFieldNumber = 2,
    kProcessMemoryDumpsFieldNumber = 3,
  };

  MemoryTrackerSnapshot();
  ~MemoryTrackerSnapshot() override;
  MemoryTrackerSnapshot(MemoryTrackerSnapshot&&) noexcept;
  MemoryTrackerSnapshot& operator=(MemoryTrackerSnapshot&&);
  MemoryTrackerSnapshot(const MemoryTrackerSnapshot&);
  MemoryTrackerSnapshot& operator=(const MemoryTrackerSnapshot&);
  bool operator==(const MemoryTrackerSnapshot&) const;
  bool operator!=(const MemoryTrackerSnapshot& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_global_dump_id() const { return _has_field_[1]; }
  uint64_t global_dump_id() const { return global_dump_id_; }
  void set_global_dump_id(uint64_t value) { global_dump_id_ = value; _has_field_.set(1); }

  bool has_level_of_detail() const { return _has_field_[2]; }
  MemoryTrackerSnapshot_LevelOfDetail level_of_detail() const { return level_of_detail_; }
  void set_level_of_detail(MemoryTrackerSnapshot_LevelOfDetail value) { level_of_detail_ = value; _has_field_.set(2); }

  const std::vector<MemoryTrackerSnapshot_ProcessSnapshot>& process_memory_dumps() const { return process_memory_dumps_; }
  std::vector<MemoryTrackerSnapshot_ProcessSnapshot>* mutable_process_memory_dumps() { return &process_memory_dumps_; }
  int process_memory_dumps_size() const;
  void clear_process_memory_dumps();
  MemoryTrackerSnapshot_ProcessSnapshot* add_process_memory_dumps();

 private:
  uint64_t global_dump_id_{};
  MemoryTrackerSnapshot_LevelOfDetail level_of_detail_{};
  std::vector<MemoryTrackerSnapshot_ProcessSnapshot> process_memory_dumps_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT MemoryTrackerSnapshot_ProcessSnapshot : public ::protozero::CppMessageObj {
 public:
  using MemoryNode = MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode;
  using MemoryEdge = MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge;
  enum FieldNumbers {
    kPidFieldNumber = 1,
    kAllocatorDumpsFieldNumber = 2,
    kMemoryEdgesFieldNumber = 3,
  };

  MemoryTrackerSnapshot_ProcessSnapshot();
  ~MemoryTrackerSnapshot_ProcessSnapshot() override;
  MemoryTrackerSnapshot_ProcessSnapshot(MemoryTrackerSnapshot_ProcessSnapshot&&) noexcept;
  MemoryTrackerSnapshot_ProcessSnapshot& operator=(MemoryTrackerSnapshot_ProcessSnapshot&&);
  MemoryTrackerSnapshot_ProcessSnapshot(const MemoryTrackerSnapshot_ProcessSnapshot&);
  MemoryTrackerSnapshot_ProcessSnapshot& operator=(const MemoryTrackerSnapshot_ProcessSnapshot&);
  bool operator==(const MemoryTrackerSnapshot_ProcessSnapshot&) const;
  bool operator!=(const MemoryTrackerSnapshot_ProcessSnapshot& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pid() const { return _has_field_[1]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(1); }

  const std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode>& allocator_dumps() const { return allocator_dumps_; }
  std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode>* mutable_allocator_dumps() { return &allocator_dumps_; }
  int allocator_dumps_size() const;
  void clear_allocator_dumps();
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode* add_allocator_dumps();

  const std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge>& memory_edges() const { return memory_edges_; }
  std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge>* mutable_memory_edges() { return &memory_edges_; }
  int memory_edges_size() const;
  void clear_memory_edges();
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge* add_memory_edges();

 private:
  int32_t pid_{};
  std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode> allocator_dumps_;
  std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge> memory_edges_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kSourceIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kImportanceFieldNumber = 3,
    kOverridableFieldNumber = 4,
  };

  MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge();
  ~MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge() override;
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge(MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&&) noexcept;
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge& operator=(MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&&);
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&);
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge& operator=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&);
  bool operator==(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&) const;
  bool operator!=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_source_id() const { return _has_field_[1]; }
  uint64_t source_id() const { return source_id_; }
  void set_source_id(uint64_t value) { source_id_ = value; _has_field_.set(1); }

  bool has_target_id() const { return _has_field_[2]; }
  uint64_t target_id() const { return target_id_; }
  void set_target_id(uint64_t value) { target_id_ = value; _has_field_.set(2); }

  bool has_importance() const { return _has_field_[3]; }
  uint32_t importance() const { return importance_; }
  void set_importance(uint32_t value) { importance_ = value; _has_field_.set(3); }

  bool has_overridable() const { return _has_field_[4]; }
  bool overridable() const { return overridable_; }
  void set_overridable(bool value) { overridable_ = value; _has_field_.set(4); }

 private:
  uint64_t source_id_{};
  uint64_t target_id_{};
  uint32_t importance_{};
  bool overridable_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode : public ::protozero::CppMessageObj {
 public:
  using MemoryNodeEntry = MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry;
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kAbsoluteNameFieldNumber = 2,
    kWeakFieldNumber = 3,
    kSizeBytesFieldNumber = 4,
    kEntriesFieldNumber = 5,
  };

  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode();
  ~MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode() override;
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&&) noexcept;
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode& operator=(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&&);
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&);
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode& operator=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&);
  bool operator==(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&) const;
  bool operator!=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  uint64_t id() const { return id_; }
  void set_id(uint64_t value) { id_ = value; _has_field_.set(1); }

  bool has_absolute_name() const { return _has_field_[2]; }
  const std::string& absolute_name() const { return absolute_name_; }
  void set_absolute_name(const std::string& value) { absolute_name_ = value; _has_field_.set(2); }

  bool has_weak() const { return _has_field_[3]; }
  bool weak() const { return weak_; }
  void set_weak(bool value) { weak_ = value; _has_field_.set(3); }

  bool has_size_bytes() const { return _has_field_[4]; }
  uint64_t size_bytes() const { return size_bytes_; }
  void set_size_bytes(uint64_t value) { size_bytes_ = value; _has_field_.set(4); }

  const std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry>& entries() const { return entries_; }
  std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry>* mutable_entries() { return &entries_; }
  int entries_size() const;
  void clear_entries();
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry* add_entries();

 private:
  uint64_t id_{};
  std::string absolute_name_{};
  bool weak_{};
  uint64_t size_bytes_{};
  std::vector<MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry> entries_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry : public ::protozero::CppMessageObj {
 public:
  using Units = MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units;
  static constexpr auto UNSPECIFIED = MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units_UNSPECIFIED;
  static constexpr auto BYTES = MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units_BYTES;
  static constexpr auto COUNT = MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units_COUNT;
  static constexpr auto Units_MIN = MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units_UNSPECIFIED;
  static constexpr auto Units_MAX = MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units_COUNT;
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kUnitsFieldNumber = 2,
    kValueUint64FieldNumber = 3,
    kValueStringFieldNumber = 4,
  };

  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry();
  ~MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry() override;
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&&) noexcept;
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry& operator=(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&&);
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&);
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry& operator=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&);
  bool operator==(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&) const;
  bool operator!=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_units() const { return _has_field_[2]; }
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units units() const { return units_; }
  void set_units(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units value) { units_ = value; _has_field_.set(2); }

  bool has_value_uint64() const { return _has_field_[3]; }
  uint64_t value_uint64() const { return value_uint64_; }
  void set_value_uint64(uint64_t value) { value_uint64_ = value; _has_field_.set(3); }

  bool has_value_string() const { return _has_field_[4]; }
  const std::string& value_string() const { return value_string_; }
  void set_value_string(const std::string& value) { value_string_ = value; _has_field_.set(4); }

 private:
  std::string name_{};
  MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry_Units units_{};
  uint64_t value_uint64_{};
  std::string value_string_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_MEMORY_GRAPH_PROTO_CPP_H_
