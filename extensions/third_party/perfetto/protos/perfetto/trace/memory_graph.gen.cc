#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/memory_graph.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

MemoryTrackerSnapshot::MemoryTrackerSnapshot() = default;
MemoryTrackerSnapshot::~MemoryTrackerSnapshot() = default;
MemoryTrackerSnapshot::MemoryTrackerSnapshot(const MemoryTrackerSnapshot&) = default;
MemoryTrackerSnapshot& MemoryTrackerSnapshot::operator=(const MemoryTrackerSnapshot&) = default;
MemoryTrackerSnapshot::MemoryTrackerSnapshot(MemoryTrackerSnapshot&&) noexcept = default;
MemoryTrackerSnapshot& MemoryTrackerSnapshot::operator=(MemoryTrackerSnapshot&&) = default;

bool MemoryTrackerSnapshot::operator==(const MemoryTrackerSnapshot& other) const {
  return unknown_fields_ == other.unknown_fields_
   && global_dump_id_ == other.global_dump_id_
   && level_of_detail_ == other.level_of_detail_
   && process_memory_dumps_ == other.process_memory_dumps_;
}

int MemoryTrackerSnapshot::process_memory_dumps_size() const { return static_cast<int>(process_memory_dumps_.size()); }
void MemoryTrackerSnapshot::clear_process_memory_dumps() { process_memory_dumps_.clear(); }
MemoryTrackerSnapshot_ProcessSnapshot* MemoryTrackerSnapshot::add_process_memory_dumps() { process_memory_dumps_.emplace_back(); return &process_memory_dumps_.back(); }
bool MemoryTrackerSnapshot::ParseFromArray(const void* raw, size_t size) {
  process_memory_dumps_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* global_dump_id */:
        field.get(&global_dump_id_);
        break;
      case 2 /* level_of_detail */:
        field.get(&level_of_detail_);
        break;
      case 3 /* process_memory_dumps */:
        process_memory_dumps_.emplace_back();
        process_memory_dumps_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MemoryTrackerSnapshot::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MemoryTrackerSnapshot::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MemoryTrackerSnapshot::Serialize(::protozero::Message* msg) const {
  // Field 1: global_dump_id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, global_dump_id_);
  }

  // Field 2: level_of_detail
  if (_has_field_[2]) {
    msg->AppendVarInt(2, level_of_detail_);
  }

  // Field 3: process_memory_dumps
  for (auto& it : process_memory_dumps_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MemoryTrackerSnapshot_ProcessSnapshot::MemoryTrackerSnapshot_ProcessSnapshot() = default;
MemoryTrackerSnapshot_ProcessSnapshot::~MemoryTrackerSnapshot_ProcessSnapshot() = default;
MemoryTrackerSnapshot_ProcessSnapshot::MemoryTrackerSnapshot_ProcessSnapshot(const MemoryTrackerSnapshot_ProcessSnapshot&) = default;
MemoryTrackerSnapshot_ProcessSnapshot& MemoryTrackerSnapshot_ProcessSnapshot::operator=(const MemoryTrackerSnapshot_ProcessSnapshot&) = default;
MemoryTrackerSnapshot_ProcessSnapshot::MemoryTrackerSnapshot_ProcessSnapshot(MemoryTrackerSnapshot_ProcessSnapshot&&) noexcept = default;
MemoryTrackerSnapshot_ProcessSnapshot& MemoryTrackerSnapshot_ProcessSnapshot::operator=(MemoryTrackerSnapshot_ProcessSnapshot&&) = default;

bool MemoryTrackerSnapshot_ProcessSnapshot::operator==(const MemoryTrackerSnapshot_ProcessSnapshot& other) const {
  return unknown_fields_ == other.unknown_fields_
   && pid_ == other.pid_
   && allocator_dumps_ == other.allocator_dumps_
   && memory_edges_ == other.memory_edges_;
}

int MemoryTrackerSnapshot_ProcessSnapshot::allocator_dumps_size() const { return static_cast<int>(allocator_dumps_.size()); }
void MemoryTrackerSnapshot_ProcessSnapshot::clear_allocator_dumps() { allocator_dumps_.clear(); }
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode* MemoryTrackerSnapshot_ProcessSnapshot::add_allocator_dumps() { allocator_dumps_.emplace_back(); return &allocator_dumps_.back(); }
int MemoryTrackerSnapshot_ProcessSnapshot::memory_edges_size() const { return static_cast<int>(memory_edges_.size()); }
void MemoryTrackerSnapshot_ProcessSnapshot::clear_memory_edges() { memory_edges_.clear(); }
MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge* MemoryTrackerSnapshot_ProcessSnapshot::add_memory_edges() { memory_edges_.emplace_back(); return &memory_edges_.back(); }
bool MemoryTrackerSnapshot_ProcessSnapshot::ParseFromArray(const void* raw, size_t size) {
  allocator_dumps_.clear();
  memory_edges_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pid */:
        field.get(&pid_);
        break;
      case 2 /* allocator_dumps */:
        allocator_dumps_.emplace_back();
        allocator_dumps_.back().ParseFromArray(field.data(), field.size());
        break;
      case 3 /* memory_edges */:
        memory_edges_.emplace_back();
        memory_edges_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MemoryTrackerSnapshot_ProcessSnapshot::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MemoryTrackerSnapshot_ProcessSnapshot::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MemoryTrackerSnapshot_ProcessSnapshot::Serialize(::protozero::Message* msg) const {
  // Field 1: pid
  if (_has_field_[1]) {
    msg->AppendVarInt(1, pid_);
  }

  // Field 2: allocator_dumps
  for (auto& it : allocator_dumps_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  // Field 3: memory_edges
  for (auto& it : memory_edges_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge() = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::~MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge() = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&) = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge& MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::operator=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&) = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge(MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&&) noexcept = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge& MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::operator=(MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge&&) = default;

bool MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::operator==(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge& other) const {
  return unknown_fields_ == other.unknown_fields_
   && source_id_ == other.source_id_
   && target_id_ == other.target_id_
   && importance_ == other.importance_
   && overridable_ == other.overridable_;
}

bool MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* source_id */:
        field.get(&source_id_);
        break;
      case 2 /* target_id */:
        field.get(&target_id_);
        break;
      case 3 /* importance */:
        field.get(&importance_);
        break;
      case 4 /* overridable */:
        field.get(&overridable_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MemoryTrackerSnapshot_ProcessSnapshot_MemoryEdge::Serialize(::protozero::Message* msg) const {
  // Field 1: source_id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, source_id_);
  }

  // Field 2: target_id
  if (_has_field_[2]) {
    msg->AppendVarInt(2, target_id_);
  }

  // Field 3: importance
  if (_has_field_[3]) {
    msg->AppendVarInt(3, importance_);
  }

  // Field 4: overridable
  if (_has_field_[4]) {
    msg->AppendTinyVarInt(4, overridable_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode() = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::~MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode() = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&) = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode& MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::operator=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&) = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&&) noexcept = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode& MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::operator=(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode&&) = default;

bool MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::operator==(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode& other) const {
  return unknown_fields_ == other.unknown_fields_
   && id_ == other.id_
   && absolute_name_ == other.absolute_name_
   && weak_ == other.weak_
   && size_bytes_ == other.size_bytes_
   && entries_ == other.entries_;
}

int MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::entries_size() const { return static_cast<int>(entries_.size()); }
void MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::clear_entries() { entries_.clear(); }
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry* MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::add_entries() { entries_.emplace_back(); return &entries_.back(); }
bool MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::ParseFromArray(const void* raw, size_t size) {
  entries_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* id */:
        field.get(&id_);
        break;
      case 2 /* absolute_name */:
        field.get(&absolute_name_);
        break;
      case 3 /* weak */:
        field.get(&weak_);
        break;
      case 4 /* size_bytes */:
        field.get(&size_bytes_);
        break;
      case 5 /* entries */:
        entries_.emplace_back();
        entries_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode::Serialize(::protozero::Message* msg) const {
  // Field 1: id
  if (_has_field_[1]) {
    msg->AppendVarInt(1, id_);
  }

  // Field 2: absolute_name
  if (_has_field_[2]) {
    msg->AppendString(2, absolute_name_);
  }

  // Field 3: weak
  if (_has_field_[3]) {
    msg->AppendTinyVarInt(3, weak_);
  }

  // Field 4: size_bytes
  if (_has_field_[4]) {
    msg->AppendVarInt(4, size_bytes_);
  }

  // Field 5: entries
  for (auto& it : entries_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(5));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry() = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::~MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry() = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&) = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry& MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::operator=(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&) = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&&) noexcept = default;
MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry& MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::operator=(MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry&&) = default;

bool MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::operator==(const MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry& other) const {
  return unknown_fields_ == other.unknown_fields_
   && name_ == other.name_
   && units_ == other.units_
   && value_uint64_ == other.value_uint64_
   && value_string_ == other.value_string_;
}

bool MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      case 2 /* units */:
        field.get(&units_);
        break;
      case 3 /* value_uint64 */:
        field.get(&value_uint64_);
        break;
      case 4 /* value_string */:
        field.get(&value_string_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void MemoryTrackerSnapshot_ProcessSnapshot_MemoryNode_MemoryNodeEntry::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    msg->AppendString(1, name_);
  }

  // Field 2: units
  if (_has_field_[2]) {
    msg->AppendVarInt(2, units_);
  }

  // Field 3: value_uint64
  if (_has_field_[3]) {
    msg->AppendVarInt(3, value_uint64_);
  }

  // Field 4: value_string
  if (_has_field_[4]) {
    msg->AppendString(4, value_string_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
