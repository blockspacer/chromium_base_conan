// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_PACKAGES_LIST_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_PACKAGES_LIST_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class PackagesList;
class PackagesList_PackageInfo;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT PackagesList : public ::protozero::CppMessageObj {
 public:
  using PackageInfo = PackagesList_PackageInfo;
  enum FieldNumbers {
    kPackagesFieldNumber = 1,
    kParseErrorFieldNumber = 2,
    kReadErrorFieldNumber = 3,
  };

  PackagesList();
  ~PackagesList() override;
  PackagesList(PackagesList&&) noexcept;
  PackagesList& operator=(PackagesList&&);
  PackagesList(const PackagesList&);
  PackagesList& operator=(const PackagesList&);
  bool operator==(const PackagesList&) const;
  bool operator!=(const PackagesList& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<PackagesList_PackageInfo>& packages() const { return packages_; }
  std::vector<PackagesList_PackageInfo>* mutable_packages() { return &packages_; }
  int packages_size() const;
  void clear_packages();
  PackagesList_PackageInfo* add_packages();

  bool has_parse_error() const { return _has_field_[2]; }
  bool parse_error() const { return parse_error_; }
  void set_parse_error(bool value) { parse_error_ = value; _has_field_.set(2); }

  bool has_read_error() const { return _has_field_[3]; }
  bool read_error() const { return read_error_; }
  void set_read_error(bool value) { read_error_ = value; _has_field_.set(3); }

 private:
  std::vector<PackagesList_PackageInfo> packages_;
  bool parse_error_{};
  bool read_error_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT PackagesList_PackageInfo : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kUidFieldNumber = 2,
    kDebuggableFieldNumber = 3,
    kProfileableFromShellFieldNumber = 4,
    kVersionCodeFieldNumber = 5,
  };

  PackagesList_PackageInfo();
  ~PackagesList_PackageInfo() override;
  PackagesList_PackageInfo(PackagesList_PackageInfo&&) noexcept;
  PackagesList_PackageInfo& operator=(PackagesList_PackageInfo&&);
  PackagesList_PackageInfo(const PackagesList_PackageInfo&);
  PackagesList_PackageInfo& operator=(const PackagesList_PackageInfo&);
  bool operator==(const PackagesList_PackageInfo&) const;
  bool operator!=(const PackagesList_PackageInfo& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_uid() const { return _has_field_[2]; }
  uint64_t uid() const { return uid_; }
  void set_uid(uint64_t value) { uid_ = value; _has_field_.set(2); }

  bool has_debuggable() const { return _has_field_[3]; }
  bool debuggable() const { return debuggable_; }
  void set_debuggable(bool value) { debuggable_ = value; _has_field_.set(3); }

  bool has_profileable_from_shell() const { return _has_field_[4]; }
  bool profileable_from_shell() const { return profileable_from_shell_; }
  void set_profileable_from_shell(bool value) { profileable_from_shell_ = value; _has_field_.set(4); }

  bool has_version_code() const { return _has_field_[5]; }
  int64_t version_code() const { return version_code_; }
  void set_version_code(int64_t value) { version_code_ = value; _has_field_.set(5); }

 private:
  std::string name_{};
  uint64_t uid_{};
  bool debuggable_{};
  bool profileable_from_shell_{};
  int64_t version_code_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_PACKAGES_LIST_PROTO_CPP_H_
