#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/chrome/chrome_metadata.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

BackgroundTracingMetadata::BackgroundTracingMetadata() = default;
BackgroundTracingMetadata::~BackgroundTracingMetadata() = default;
BackgroundTracingMetadata::BackgroundTracingMetadata(const BackgroundTracingMetadata&) = default;
BackgroundTracingMetadata& BackgroundTracingMetadata::operator=(const BackgroundTracingMetadata&) = default;
BackgroundTracingMetadata::BackgroundTracingMetadata(BackgroundTracingMetadata&&) noexcept = default;
BackgroundTracingMetadata& BackgroundTracingMetadata::operator=(BackgroundTracingMetadata&&) = default;

bool BackgroundTracingMetadata::operator==(const BackgroundTracingMetadata& other) const {
  return unknown_fields_ == other.unknown_fields_
   && triggered_rule_ == other.triggered_rule_
   && active_rules_ == other.active_rules_;
}

int BackgroundTracingMetadata::active_rules_size() const { return static_cast<int>(active_rules_.size()); }
void BackgroundTracingMetadata::clear_active_rules() { active_rules_.clear(); }
BackgroundTracingMetadata_TriggerRule* BackgroundTracingMetadata::add_active_rules() { active_rules_.emplace_back(); return &active_rules_.back(); }
bool BackgroundTracingMetadata::ParseFromArray(const void* raw, size_t size) {
  active_rules_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* triggered_rule */:
        (*triggered_rule_).ParseFromArray(field.data(), field.size());
        break;
      case 2 /* active_rules */:
        active_rules_.emplace_back();
        active_rules_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string BackgroundTracingMetadata::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> BackgroundTracingMetadata::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void BackgroundTracingMetadata::Serialize(::protozero::Message* msg) const {
  // Field 1: triggered_rule
  if (_has_field_[1]) {
    (*triggered_rule_).Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  // Field 2: active_rules
  for (auto& it : active_rules_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


BackgroundTracingMetadata_TriggerRule::BackgroundTracingMetadata_TriggerRule() = default;
BackgroundTracingMetadata_TriggerRule::~BackgroundTracingMetadata_TriggerRule() = default;
BackgroundTracingMetadata_TriggerRule::BackgroundTracingMetadata_TriggerRule(const BackgroundTracingMetadata_TriggerRule&) = default;
BackgroundTracingMetadata_TriggerRule& BackgroundTracingMetadata_TriggerRule::operator=(const BackgroundTracingMetadata_TriggerRule&) = default;
BackgroundTracingMetadata_TriggerRule::BackgroundTracingMetadata_TriggerRule(BackgroundTracingMetadata_TriggerRule&&) noexcept = default;
BackgroundTracingMetadata_TriggerRule& BackgroundTracingMetadata_TriggerRule::operator=(BackgroundTracingMetadata_TriggerRule&&) = default;

bool BackgroundTracingMetadata_TriggerRule::operator==(const BackgroundTracingMetadata_TriggerRule& other) const {
  return unknown_fields_ == other.unknown_fields_
   && trigger_type_ == other.trigger_type_
   && histogram_rule_ == other.histogram_rule_
   && named_rule_ == other.named_rule_;
}

bool BackgroundTracingMetadata_TriggerRule::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* trigger_type */:
        field.get(&trigger_type_);
        break;
      case 2 /* histogram_rule */:
        (*histogram_rule_).ParseFromArray(field.data(), field.size());
        break;
      case 3 /* named_rule */:
        (*named_rule_).ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string BackgroundTracingMetadata_TriggerRule::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> BackgroundTracingMetadata_TriggerRule::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void BackgroundTracingMetadata_TriggerRule::Serialize(::protozero::Message* msg) const {
  // Field 1: trigger_type
  if (_has_field_[1]) {
    msg->AppendVarInt(1, trigger_type_);
  }

  // Field 2: histogram_rule
  if (_has_field_[2]) {
    (*histogram_rule_).Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  // Field 3: named_rule
  if (_has_field_[3]) {
    (*named_rule_).Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


BackgroundTracingMetadata_TriggerRule_NamedRule::BackgroundTracingMetadata_TriggerRule_NamedRule() = default;
BackgroundTracingMetadata_TriggerRule_NamedRule::~BackgroundTracingMetadata_TriggerRule_NamedRule() = default;
BackgroundTracingMetadata_TriggerRule_NamedRule::BackgroundTracingMetadata_TriggerRule_NamedRule(const BackgroundTracingMetadata_TriggerRule_NamedRule&) = default;
BackgroundTracingMetadata_TriggerRule_NamedRule& BackgroundTracingMetadata_TriggerRule_NamedRule::operator=(const BackgroundTracingMetadata_TriggerRule_NamedRule&) = default;
BackgroundTracingMetadata_TriggerRule_NamedRule::BackgroundTracingMetadata_TriggerRule_NamedRule(BackgroundTracingMetadata_TriggerRule_NamedRule&&) noexcept = default;
BackgroundTracingMetadata_TriggerRule_NamedRule& BackgroundTracingMetadata_TriggerRule_NamedRule::operator=(BackgroundTracingMetadata_TriggerRule_NamedRule&&) = default;

bool BackgroundTracingMetadata_TriggerRule_NamedRule::operator==(const BackgroundTracingMetadata_TriggerRule_NamedRule& other) const {
  return unknown_fields_ == other.unknown_fields_
   && event_type_ == other.event_type_;
}

bool BackgroundTracingMetadata_TriggerRule_NamedRule::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* event_type */:
        field.get(&event_type_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string BackgroundTracingMetadata_TriggerRule_NamedRule::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> BackgroundTracingMetadata_TriggerRule_NamedRule::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void BackgroundTracingMetadata_TriggerRule_NamedRule::Serialize(::protozero::Message* msg) const {
  // Field 1: event_type
  if (_has_field_[1]) {
    msg->AppendVarInt(1, event_type_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


BackgroundTracingMetadata_TriggerRule_HistogramRule::BackgroundTracingMetadata_TriggerRule_HistogramRule() = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule::~BackgroundTracingMetadata_TriggerRule_HistogramRule() = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule::BackgroundTracingMetadata_TriggerRule_HistogramRule(const BackgroundTracingMetadata_TriggerRule_HistogramRule&) = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule& BackgroundTracingMetadata_TriggerRule_HistogramRule::operator=(const BackgroundTracingMetadata_TriggerRule_HistogramRule&) = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule::BackgroundTracingMetadata_TriggerRule_HistogramRule(BackgroundTracingMetadata_TriggerRule_HistogramRule&&) noexcept = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule& BackgroundTracingMetadata_TriggerRule_HistogramRule::operator=(BackgroundTracingMetadata_TriggerRule_HistogramRule&&) = default;

bool BackgroundTracingMetadata_TriggerRule_HistogramRule::operator==(const BackgroundTracingMetadata_TriggerRule_HistogramRule& other) const {
  return unknown_fields_ == other.unknown_fields_
   && histogram_name_hash_ == other.histogram_name_hash_
   && histogram_min_trigger_ == other.histogram_min_trigger_
   && histogram_max_trigger_ == other.histogram_max_trigger_;
}

bool BackgroundTracingMetadata_TriggerRule_HistogramRule::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* histogram_name_hash */:
        field.get(&histogram_name_hash_);
        break;
      case 2 /* histogram_min_trigger */:
        field.get(&histogram_min_trigger_);
        break;
      case 3 /* histogram_max_trigger */:
        field.get(&histogram_max_trigger_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string BackgroundTracingMetadata_TriggerRule_HistogramRule::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> BackgroundTracingMetadata_TriggerRule_HistogramRule::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void BackgroundTracingMetadata_TriggerRule_HistogramRule::Serialize(::protozero::Message* msg) const {
  // Field 1: histogram_name_hash
  if (_has_field_[1]) {
    msg->AppendFixed(1, histogram_name_hash_);
  }

  // Field 2: histogram_min_trigger
  if (_has_field_[2]) {
    msg->AppendVarInt(2, histogram_min_trigger_);
  }

  // Field 3: histogram_max_trigger
  if (_has_field_[3]) {
    msg->AppendVarInt(3, histogram_max_trigger_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}


ChromeMetadataPacket::ChromeMetadataPacket() = default;
ChromeMetadataPacket::~ChromeMetadataPacket() = default;
ChromeMetadataPacket::ChromeMetadataPacket(const ChromeMetadataPacket&) = default;
ChromeMetadataPacket& ChromeMetadataPacket::operator=(const ChromeMetadataPacket&) = default;
ChromeMetadataPacket::ChromeMetadataPacket(ChromeMetadataPacket&&) noexcept = default;
ChromeMetadataPacket& ChromeMetadataPacket::operator=(ChromeMetadataPacket&&) = default;

bool ChromeMetadataPacket::operator==(const ChromeMetadataPacket& other) const {
  return unknown_fields_ == other.unknown_fields_
   && background_tracing_metadata_ == other.background_tracing_metadata_
   && chrome_version_code_ == other.chrome_version_code_;
}

bool ChromeMetadataPacket::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* background_tracing_metadata */:
        (*background_tracing_metadata_).ParseFromArray(field.data(), field.size());
        break;
      case 2 /* chrome_version_code */:
        field.get(&chrome_version_code_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ChromeMetadataPacket::SerializeAsString() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ChromeMetadataPacket::SerializeAsArray() const {
  ::protozero::HeapBuffered<::protozero::Message> msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ChromeMetadataPacket::Serialize(::protozero::Message* msg) const {
  // Field 1: background_tracing_metadata
  if (_has_field_[1]) {
    (*background_tracing_metadata_).Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  // Field 2: chrome_version_code
  if (_has_field_[2]) {
    msg->AppendVarInt(2, chrome_version_code_);
  }

  msg->AppendRawProtoBytes(unknown_fields_.data(), unknown_fields_.size());
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
