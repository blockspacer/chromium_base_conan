// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_TRACE_EVENT_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_TRACE_EVENT_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class ChromeEventBundle;
class ChromeStringTableEntry;
class ChromeLegacyJsonTrace;
class ChromeMetadata;
class ChromeTraceEvent;
class ChromeTraceEvent_Arg;
class ChromeTracedValue;
enum ChromeLegacyJsonTrace_TraceType : int;
enum ChromeTracedValue_NestedType : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum ChromeLegacyJsonTrace_TraceType : int {
  ChromeLegacyJsonTrace_TraceType_USER_TRACE = 0,
  ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE = 1,
};
enum ChromeTracedValue_NestedType : int {
  ChromeTracedValue_NestedType_DICT = 0,
  ChromeTracedValue_NestedType_ARRAY = 1,
};

class PERFETTO_EXPORT ChromeEventBundle : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kTraceEventsFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kLegacyFtraceOutputFieldNumber = 4,
    kLegacyJsonTraceFieldNumber = 5,
    kStringTableFieldNumber = 3,
  };

  ChromeEventBundle();
  ~ChromeEventBundle() override;
  ChromeEventBundle(ChromeEventBundle&&) noexcept;
  ChromeEventBundle& operator=(ChromeEventBundle&&);
  ChromeEventBundle(const ChromeEventBundle&);
  ChromeEventBundle& operator=(const ChromeEventBundle&);
  bool operator==(const ChromeEventBundle&) const;
  bool operator!=(const ChromeEventBundle& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<ChromeTraceEvent>& trace_events() const { return trace_events_; }
  std::vector<ChromeTraceEvent>* mutable_trace_events() { return &trace_events_; }
  int trace_events_size() const;
  void clear_trace_events();
  ChromeTraceEvent* add_trace_events();

  const std::vector<ChromeMetadata>& metadata() const { return metadata_; }
  std::vector<ChromeMetadata>* mutable_metadata() { return &metadata_; }
  int metadata_size() const;
  void clear_metadata();
  ChromeMetadata* add_metadata();

  const std::vector<std::string>& legacy_ftrace_output() const { return legacy_ftrace_output_; }
  std::vector<std::string>* mutable_legacy_ftrace_output() { return &legacy_ftrace_output_; }
  int legacy_ftrace_output_size() const { return static_cast<int>(legacy_ftrace_output_.size()); }
  void clear_legacy_ftrace_output() { legacy_ftrace_output_.clear(); }
  void add_legacy_ftrace_output(std::string value) { legacy_ftrace_output_.emplace_back(value); }
  std::string* add_legacy_ftrace_output() { legacy_ftrace_output_.emplace_back(); return &legacy_ftrace_output_.back(); }

  const std::vector<ChromeLegacyJsonTrace>& legacy_json_trace() const { return legacy_json_trace_; }
  std::vector<ChromeLegacyJsonTrace>* mutable_legacy_json_trace() { return &legacy_json_trace_; }
  int legacy_json_trace_size() const;
  void clear_legacy_json_trace();
  ChromeLegacyJsonTrace* add_legacy_json_trace();

  const std::vector<ChromeStringTableEntry>& string_table() const { return string_table_; }
  std::vector<ChromeStringTableEntry>* mutable_string_table() { return &string_table_; }
  int string_table_size() const;
  void clear_string_table();
  ChromeStringTableEntry* add_string_table();

 private:
  std::vector<ChromeTraceEvent> trace_events_;
  std::vector<ChromeMetadata> metadata_;
  std::vector<std::string> legacy_ftrace_output_;
  std::vector<ChromeLegacyJsonTrace> legacy_json_trace_;
  std::vector<ChromeStringTableEntry> string_table_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT ChromeStringTableEntry : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kValueFieldNumber = 1,
    kIndexFieldNumber = 2,
  };

  ChromeStringTableEntry();
  ~ChromeStringTableEntry() override;
  ChromeStringTableEntry(ChromeStringTableEntry&&) noexcept;
  ChromeStringTableEntry& operator=(ChromeStringTableEntry&&);
  ChromeStringTableEntry(const ChromeStringTableEntry&);
  ChromeStringTableEntry& operator=(const ChromeStringTableEntry&);
  bool operator==(const ChromeStringTableEntry&) const;
  bool operator!=(const ChromeStringTableEntry& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_value() const { return _has_field_[1]; }
  const std::string& value() const { return value_; }
  void set_value(const std::string& value) { value_ = value; _has_field_.set(1); }

  bool has_index() const { return _has_field_[2]; }
  int32_t index() const { return index_; }
  void set_index(int32_t value) { index_ = value; _has_field_.set(2); }

 private:
  std::string value_{};
  int32_t index_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT ChromeLegacyJsonTrace : public ::protozero::CppMessageObj {
 public:
  using TraceType = ChromeLegacyJsonTrace_TraceType;
  static constexpr auto USER_TRACE = ChromeLegacyJsonTrace_TraceType_USER_TRACE;
  static constexpr auto SYSTEM_TRACE = ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE;
  static constexpr auto TraceType_MIN = ChromeLegacyJsonTrace_TraceType_USER_TRACE;
  static constexpr auto TraceType_MAX = ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE;
  enum FieldNumbers {
    kTypeFieldNumber = 1,
    kDataFieldNumber = 2,
  };

  ChromeLegacyJsonTrace();
  ~ChromeLegacyJsonTrace() override;
  ChromeLegacyJsonTrace(ChromeLegacyJsonTrace&&) noexcept;
  ChromeLegacyJsonTrace& operator=(ChromeLegacyJsonTrace&&);
  ChromeLegacyJsonTrace(const ChromeLegacyJsonTrace&);
  ChromeLegacyJsonTrace& operator=(const ChromeLegacyJsonTrace&);
  bool operator==(const ChromeLegacyJsonTrace&) const;
  bool operator!=(const ChromeLegacyJsonTrace& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_type() const { return _has_field_[1]; }
  ChromeLegacyJsonTrace_TraceType type() const { return type_; }
  void set_type(ChromeLegacyJsonTrace_TraceType value) { type_ = value; _has_field_.set(1); }

  bool has_data() const { return _has_field_[2]; }
  const std::string& data() const { return data_; }
  void set_data(const std::string& value) { data_ = value; _has_field_.set(2); }

 private:
  ChromeLegacyJsonTrace_TraceType type_{};
  std::string data_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT ChromeMetadata : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kStringValueFieldNumber = 2,
    kBoolValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kJsonValueFieldNumber = 5,
  };

  ChromeMetadata();
  ~ChromeMetadata() override;
  ChromeMetadata(ChromeMetadata&&) noexcept;
  ChromeMetadata& operator=(ChromeMetadata&&);
  ChromeMetadata(const ChromeMetadata&);
  ChromeMetadata& operator=(const ChromeMetadata&);
  bool operator==(const ChromeMetadata&) const;
  bool operator!=(const ChromeMetadata& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_string_value() const { return _has_field_[2]; }
  const std::string& string_value() const { return string_value_; }
  void set_string_value(const std::string& value) { string_value_ = value; _has_field_.set(2); }

  bool has_bool_value() const { return _has_field_[3]; }
  bool bool_value() const { return bool_value_; }
  void set_bool_value(bool value) { bool_value_ = value; _has_field_.set(3); }

  bool has_int_value() const { return _has_field_[4]; }
  int64_t int_value() const { return int_value_; }
  void set_int_value(int64_t value) { int_value_ = value; _has_field_.set(4); }

  bool has_json_value() const { return _has_field_[5]; }
  const std::string& json_value() const { return json_value_; }
  void set_json_value(const std::string& value) { json_value_ = value; _has_field_.set(5); }

 private:
  std::string name_{};
  std::string string_value_{};
  bool bool_value_{};
  int64_t int_value_{};
  std::string json_value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT ChromeTraceEvent : public ::protozero::CppMessageObj {
 public:
  using Arg = ChromeTraceEvent_Arg;
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kPhaseFieldNumber = 3,
    kThreadIdFieldNumber = 4,
    kDurationFieldNumber = 5,
    kThreadDurationFieldNumber = 6,
    kScopeFieldNumber = 7,
    kIdFieldNumber = 8,
    kFlagsFieldNumber = 9,
    kCategoryGroupNameFieldNumber = 10,
    kProcessIdFieldNumber = 11,
    kThreadTimestampFieldNumber = 12,
    kBindIdFieldNumber = 13,
    kArgsFieldNumber = 14,
    kNameIndexFieldNumber = 15,
    kCategoryGroupNameIndexFieldNumber = 16,
  };

  ChromeTraceEvent();
  ~ChromeTraceEvent() override;
  ChromeTraceEvent(ChromeTraceEvent&&) noexcept;
  ChromeTraceEvent& operator=(ChromeTraceEvent&&);
  ChromeTraceEvent(const ChromeTraceEvent&);
  ChromeTraceEvent& operator=(const ChromeTraceEvent&);
  bool operator==(const ChromeTraceEvent&) const;
  bool operator!=(const ChromeTraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_timestamp() const { return _has_field_[2]; }
  int64_t timestamp() const { return timestamp_; }
  void set_timestamp(int64_t value) { timestamp_ = value; _has_field_.set(2); }

  bool has_phase() const { return _has_field_[3]; }
  int32_t phase() const { return phase_; }
  void set_phase(int32_t value) { phase_ = value; _has_field_.set(3); }

  bool has_thread_id() const { return _has_field_[4]; }
  int32_t thread_id() const { return thread_id_; }
  void set_thread_id(int32_t value) { thread_id_ = value; _has_field_.set(4); }

  bool has_duration() const { return _has_field_[5]; }
  int64_t duration() const { return duration_; }
  void set_duration(int64_t value) { duration_ = value; _has_field_.set(5); }

  bool has_thread_duration() const { return _has_field_[6]; }
  int64_t thread_duration() const { return thread_duration_; }
  void set_thread_duration(int64_t value) { thread_duration_ = value; _has_field_.set(6); }

  bool has_scope() const { return _has_field_[7]; }
  const std::string& scope() const { return scope_; }
  void set_scope(const std::string& value) { scope_ = value; _has_field_.set(7); }

  bool has_id() const { return _has_field_[8]; }
  uint64_t id() const { return id_; }
  void set_id(uint64_t value) { id_ = value; _has_field_.set(8); }

  bool has_flags() const { return _has_field_[9]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(9); }

  bool has_category_group_name() const { return _has_field_[10]; }
  const std::string& category_group_name() const { return category_group_name_; }
  void set_category_group_name(const std::string& value) { category_group_name_ = value; _has_field_.set(10); }

  bool has_process_id() const { return _has_field_[11]; }
  int32_t process_id() const { return process_id_; }
  void set_process_id(int32_t value) { process_id_ = value; _has_field_.set(11); }

  bool has_thread_timestamp() const { return _has_field_[12]; }
  int64_t thread_timestamp() const { return thread_timestamp_; }
  void set_thread_timestamp(int64_t value) { thread_timestamp_ = value; _has_field_.set(12); }

  bool has_bind_id() const { return _has_field_[13]; }
  uint64_t bind_id() const { return bind_id_; }
  void set_bind_id(uint64_t value) { bind_id_ = value; _has_field_.set(13); }

  const std::vector<ChromeTraceEvent_Arg>& args() const { return args_; }
  std::vector<ChromeTraceEvent_Arg>* mutable_args() { return &args_; }
  int args_size() const;
  void clear_args();
  ChromeTraceEvent_Arg* add_args();

  bool has_name_index() const { return _has_field_[15]; }
  uint32_t name_index() const { return name_index_; }
  void set_name_index(uint32_t value) { name_index_ = value; _has_field_.set(15); }

  bool has_category_group_name_index() const { return _has_field_[16]; }
  uint32_t category_group_name_index() const { return category_group_name_index_; }
  void set_category_group_name_index(uint32_t value) { category_group_name_index_ = value; _has_field_.set(16); }

 private:
  std::string name_{};
  int64_t timestamp_{};
  int32_t phase_{};
  int32_t thread_id_{};
  int64_t duration_{};
  int64_t thread_duration_{};
  std::string scope_{};
  uint64_t id_{};
  uint32_t flags_{};
  std::string category_group_name_{};
  int32_t process_id_{};
  int64_t thread_timestamp_{};
  uint64_t bind_id_{};
  std::vector<ChromeTraceEvent_Arg> args_;
  uint32_t name_index_{};
  uint32_t category_group_name_index_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<17> _has_field_{};
};


class PERFETTO_EXPORT ChromeTraceEvent_Arg : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kUintValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kDoubleValueFieldNumber = 5,
    kStringValueFieldNumber = 6,
    kPointerValueFieldNumber = 7,
    kJsonValueFieldNumber = 8,
    kTracedValueFieldNumber = 10,
    kNameIndexFieldNumber = 9,
  };

  ChromeTraceEvent_Arg();
  ~ChromeTraceEvent_Arg() override;
  ChromeTraceEvent_Arg(ChromeTraceEvent_Arg&&) noexcept;
  ChromeTraceEvent_Arg& operator=(ChromeTraceEvent_Arg&&);
  ChromeTraceEvent_Arg(const ChromeTraceEvent_Arg&);
  ChromeTraceEvent_Arg& operator=(const ChromeTraceEvent_Arg&);
  bool operator==(const ChromeTraceEvent_Arg&) const;
  bool operator!=(const ChromeTraceEvent_Arg& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_bool_value() const { return _has_field_[2]; }
  bool bool_value() const { return bool_value_; }
  void set_bool_value(bool value) { bool_value_ = value; _has_field_.set(2); }

  bool has_uint_value() const { return _has_field_[3]; }
  uint64_t uint_value() const { return uint_value_; }
  void set_uint_value(uint64_t value) { uint_value_ = value; _has_field_.set(3); }

  bool has_int_value() const { return _has_field_[4]; }
  int64_t int_value() const { return int_value_; }
  void set_int_value(int64_t value) { int_value_ = value; _has_field_.set(4); }

  bool has_double_value() const { return _has_field_[5]; }
  double double_value() const { return double_value_; }
  void set_double_value(double value) { double_value_ = value; _has_field_.set(5); }

  bool has_string_value() const { return _has_field_[6]; }
  const std::string& string_value() const { return string_value_; }
  void set_string_value(const std::string& value) { string_value_ = value; _has_field_.set(6); }

  bool has_pointer_value() const { return _has_field_[7]; }
  uint64_t pointer_value() const { return pointer_value_; }
  void set_pointer_value(uint64_t value) { pointer_value_ = value; _has_field_.set(7); }

  bool has_json_value() const { return _has_field_[8]; }
  const std::string& json_value() const { return json_value_; }
  void set_json_value(const std::string& value) { json_value_ = value; _has_field_.set(8); }

  bool has_traced_value() const { return _has_field_[10]; }
  const ChromeTracedValue& traced_value() const { return *traced_value_; }
  ChromeTracedValue* mutable_traced_value() { _has_field_.set(10); return traced_value_.get(); }

  bool has_name_index() const { return _has_field_[9]; }
  uint32_t name_index() const { return name_index_; }
  void set_name_index(uint32_t value) { name_index_ = value; _has_field_.set(9); }

 private:
  std::string name_{};
  bool bool_value_{};
  uint64_t uint_value_{};
  int64_t int_value_{};
  double double_value_{};
  std::string string_value_{};
  uint64_t pointer_value_{};
  std::string json_value_{};
  ::protozero::CopyablePtr<ChromeTracedValue> traced_value_;
  uint32_t name_index_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT ChromeTracedValue : public ::protozero::CppMessageObj {
 public:
  using NestedType = ChromeTracedValue_NestedType;
  static constexpr auto DICT = ChromeTracedValue_NestedType_DICT;
  static constexpr auto ARRAY = ChromeTracedValue_NestedType_ARRAY;
  static constexpr auto NestedType_MIN = ChromeTracedValue_NestedType_DICT;
  static constexpr auto NestedType_MAX = ChromeTracedValue_NestedType_ARRAY;
  enum FieldNumbers {
    kNestedTypeFieldNumber = 1,
    kDictKeysFieldNumber = 2,
    kDictValuesFieldNumber = 3,
    kArrayValuesFieldNumber = 4,
    kIntValueFieldNumber = 5,
    kDoubleValueFieldNumber = 6,
    kBoolValueFieldNumber = 7,
    kStringValueFieldNumber = 8,
  };

  ChromeTracedValue();
  ~ChromeTracedValue() override;
  ChromeTracedValue(ChromeTracedValue&&) noexcept;
  ChromeTracedValue& operator=(ChromeTracedValue&&);
  ChromeTracedValue(const ChromeTracedValue&);
  ChromeTracedValue& operator=(const ChromeTracedValue&);
  bool operator==(const ChromeTracedValue&) const;
  bool operator!=(const ChromeTracedValue& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_nested_type() const { return _has_field_[1]; }
  ChromeTracedValue_NestedType nested_type() const { return nested_type_; }
  void set_nested_type(ChromeTracedValue_NestedType value) { nested_type_ = value; _has_field_.set(1); }

  const std::vector<std::string>& dict_keys() const { return dict_keys_; }
  std::vector<std::string>* mutable_dict_keys() { return &dict_keys_; }
  int dict_keys_size() const { return static_cast<int>(dict_keys_.size()); }
  void clear_dict_keys() { dict_keys_.clear(); }
  void add_dict_keys(std::string value) { dict_keys_.emplace_back(value); }
  std::string* add_dict_keys() { dict_keys_.emplace_back(); return &dict_keys_.back(); }

  const std::vector<ChromeTracedValue>& dict_values() const { return dict_values_; }
  std::vector<ChromeTracedValue>* mutable_dict_values() { return &dict_values_; }
  int dict_values_size() const;
  void clear_dict_values();
  ChromeTracedValue* add_dict_values();

  const std::vector<ChromeTracedValue>& array_values() const { return array_values_; }
  std::vector<ChromeTracedValue>* mutable_array_values() { return &array_values_; }
  int array_values_size() const;
  void clear_array_values();
  ChromeTracedValue* add_array_values();

  bool has_int_value() const { return _has_field_[5]; }
  int32_t int_value() const { return int_value_; }
  void set_int_value(int32_t value) { int_value_ = value; _has_field_.set(5); }

  bool has_double_value() const { return _has_field_[6]; }
  double double_value() const { return double_value_; }
  void set_double_value(double value) { double_value_ = value; _has_field_.set(6); }

  bool has_bool_value() const { return _has_field_[7]; }
  bool bool_value() const { return bool_value_; }
  void set_bool_value(bool value) { bool_value_ = value; _has_field_.set(7); }

  bool has_string_value() const { return _has_field_[8]; }
  const std::string& string_value() const { return string_value_; }
  void set_string_value(const std::string& value) { string_value_ = value; _has_field_.set(8); }

 private:
  ChromeTracedValue_NestedType nested_type_{};
  std::vector<std::string> dict_keys_;
  std::vector<ChromeTracedValue> dict_values_;
  std::vector<ChromeTracedValue> array_values_;
  int32_t int_value_{};
  double double_value_{};
  bool bool_value_{};
  std::string string_value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_TRACE_EVENT_PROTO_CPP_H_
