// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class SysStats;
class SysStats_InterruptCount;
class SysStats_CpuTimes;
class SysStats_VmstatValue;
class SysStats_MeminfoValue;
enum VmstatCounters : int;
enum MeminfoCounters : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT SysStats : public ::protozero::CppMessageObj {
 public:
  using MeminfoValue = SysStats_MeminfoValue;
  using VmstatValue = SysStats_VmstatValue;
  using CpuTimes = SysStats_CpuTimes;
  using InterruptCount = SysStats_InterruptCount;
  enum FieldNumbers {
    kMeminfoFieldNumber = 1,
    kVmstatFieldNumber = 2,
    kCpuStatFieldNumber = 3,
    kNumForksFieldNumber = 4,
    kNumIrqTotalFieldNumber = 5,
    kNumIrqFieldNumber = 6,
    kNumSoftirqTotalFieldNumber = 7,
    kNumSoftirqFieldNumber = 8,
    kCollectionEndTimestampFieldNumber = 9,
  };

  SysStats();
  ~SysStats() override;
  SysStats(SysStats&&) noexcept;
  SysStats& operator=(SysStats&&);
  SysStats(const SysStats&);
  SysStats& operator=(const SysStats&);
  bool operator==(const SysStats&) const;
  bool operator!=(const SysStats& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<SysStats_MeminfoValue>& meminfo() const { return meminfo_; }
  std::vector<SysStats_MeminfoValue>* mutable_meminfo() { return &meminfo_; }
  int meminfo_size() const;
  void clear_meminfo();
  SysStats_MeminfoValue* add_meminfo();

  const std::vector<SysStats_VmstatValue>& vmstat() const { return vmstat_; }
  std::vector<SysStats_VmstatValue>* mutable_vmstat() { return &vmstat_; }
  int vmstat_size() const;
  void clear_vmstat();
  SysStats_VmstatValue* add_vmstat();

  const std::vector<SysStats_CpuTimes>& cpu_stat() const { return cpu_stat_; }
  std::vector<SysStats_CpuTimes>* mutable_cpu_stat() { return &cpu_stat_; }
  int cpu_stat_size() const;
  void clear_cpu_stat();
  SysStats_CpuTimes* add_cpu_stat();

  bool has_num_forks() const { return _has_field_[4]; }
  uint64_t num_forks() const { return num_forks_; }
  void set_num_forks(uint64_t value) { num_forks_ = value; _has_field_.set(4); }

  bool has_num_irq_total() const { return _has_field_[5]; }
  uint64_t num_irq_total() const { return num_irq_total_; }
  void set_num_irq_total(uint64_t value) { num_irq_total_ = value; _has_field_.set(5); }

  const std::vector<SysStats_InterruptCount>& num_irq() const { return num_irq_; }
  std::vector<SysStats_InterruptCount>* mutable_num_irq() { return &num_irq_; }
  int num_irq_size() const;
  void clear_num_irq();
  SysStats_InterruptCount* add_num_irq();

  bool has_num_softirq_total() const { return _has_field_[7]; }
  uint64_t num_softirq_total() const { return num_softirq_total_; }
  void set_num_softirq_total(uint64_t value) { num_softirq_total_ = value; _has_field_.set(7); }

  const std::vector<SysStats_InterruptCount>& num_softirq() const { return num_softirq_; }
  std::vector<SysStats_InterruptCount>* mutable_num_softirq() { return &num_softirq_; }
  int num_softirq_size() const;
  void clear_num_softirq();
  SysStats_InterruptCount* add_num_softirq();

  bool has_collection_end_timestamp() const { return _has_field_[9]; }
  uint64_t collection_end_timestamp() const { return collection_end_timestamp_; }
  void set_collection_end_timestamp(uint64_t value) { collection_end_timestamp_ = value; _has_field_.set(9); }

 private:
  std::vector<SysStats_MeminfoValue> meminfo_;
  std::vector<SysStats_VmstatValue> vmstat_;
  std::vector<SysStats_CpuTimes> cpu_stat_;
  uint64_t num_forks_{};
  uint64_t num_irq_total_{};
  std::vector<SysStats_InterruptCount> num_irq_;
  uint64_t num_softirq_total_{};
  std::vector<SysStats_InterruptCount> num_softirq_;
  uint64_t collection_end_timestamp_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};


class PERFETTO_EXPORT SysStats_InterruptCount : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIrqFieldNumber = 1,
    kCountFieldNumber = 2,
  };

  SysStats_InterruptCount();
  ~SysStats_InterruptCount() override;
  SysStats_InterruptCount(SysStats_InterruptCount&&) noexcept;
  SysStats_InterruptCount& operator=(SysStats_InterruptCount&&);
  SysStats_InterruptCount(const SysStats_InterruptCount&);
  SysStats_InterruptCount& operator=(const SysStats_InterruptCount&);
  bool operator==(const SysStats_InterruptCount&) const;
  bool operator!=(const SysStats_InterruptCount& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_irq() const { return _has_field_[1]; }
  int32_t irq() const { return irq_; }
  void set_irq(int32_t value) { irq_ = value; _has_field_.set(1); }

  bool has_count() const { return _has_field_[2]; }
  uint64_t count() const { return count_; }
  void set_count(uint64_t value) { count_ = value; _has_field_.set(2); }

 private:
  int32_t irq_{};
  uint64_t count_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT SysStats_CpuTimes : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCpuIdFieldNumber = 1,
    kUserNsFieldNumber = 2,
    kUserIceNsFieldNumber = 3,
    kSystemModeNsFieldNumber = 4,
    kIdleNsFieldNumber = 5,
    kIoWaitNsFieldNumber = 6,
    kIrqNsFieldNumber = 7,
    kSoftirqNsFieldNumber = 8,
  };

  SysStats_CpuTimes();
  ~SysStats_CpuTimes() override;
  SysStats_CpuTimes(SysStats_CpuTimes&&) noexcept;
  SysStats_CpuTimes& operator=(SysStats_CpuTimes&&);
  SysStats_CpuTimes(const SysStats_CpuTimes&);
  SysStats_CpuTimes& operator=(const SysStats_CpuTimes&);
  bool operator==(const SysStats_CpuTimes&) const;
  bool operator!=(const SysStats_CpuTimes& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cpu_id() const { return _has_field_[1]; }
  uint32_t cpu_id() const { return cpu_id_; }
  void set_cpu_id(uint32_t value) { cpu_id_ = value; _has_field_.set(1); }

  bool has_user_ns() const { return _has_field_[2]; }
  uint64_t user_ns() const { return user_ns_; }
  void set_user_ns(uint64_t value) { user_ns_ = value; _has_field_.set(2); }

  bool has_user_ice_ns() const { return _has_field_[3]; }
  uint64_t user_ice_ns() const { return user_ice_ns_; }
  void set_user_ice_ns(uint64_t value) { user_ice_ns_ = value; _has_field_.set(3); }

  bool has_system_mode_ns() const { return _has_field_[4]; }
  uint64_t system_mode_ns() const { return system_mode_ns_; }
  void set_system_mode_ns(uint64_t value) { system_mode_ns_ = value; _has_field_.set(4); }

  bool has_idle_ns() const { return _has_field_[5]; }
  uint64_t idle_ns() const { return idle_ns_; }
  void set_idle_ns(uint64_t value) { idle_ns_ = value; _has_field_.set(5); }

  bool has_io_wait_ns() const { return _has_field_[6]; }
  uint64_t io_wait_ns() const { return io_wait_ns_; }
  void set_io_wait_ns(uint64_t value) { io_wait_ns_ = value; _has_field_.set(6); }

  bool has_irq_ns() const { return _has_field_[7]; }
  uint64_t irq_ns() const { return irq_ns_; }
  void set_irq_ns(uint64_t value) { irq_ns_ = value; _has_field_.set(7); }

  bool has_softirq_ns() const { return _has_field_[8]; }
  uint64_t softirq_ns() const { return softirq_ns_; }
  void set_softirq_ns(uint64_t value) { softirq_ns_ = value; _has_field_.set(8); }

 private:
  uint32_t cpu_id_{};
  uint64_t user_ns_{};
  uint64_t user_ice_ns_{};
  uint64_t system_mode_ns_{};
  uint64_t idle_ns_{};
  uint64_t io_wait_ns_{};
  uint64_t irq_ns_{};
  uint64_t softirq_ns_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT SysStats_VmstatValue : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };

  SysStats_VmstatValue();
  ~SysStats_VmstatValue() override;
  SysStats_VmstatValue(SysStats_VmstatValue&&) noexcept;
  SysStats_VmstatValue& operator=(SysStats_VmstatValue&&);
  SysStats_VmstatValue(const SysStats_VmstatValue&);
  SysStats_VmstatValue& operator=(const SysStats_VmstatValue&);
  bool operator==(const SysStats_VmstatValue&) const;
  bool operator!=(const SysStats_VmstatValue& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_key() const { return _has_field_[1]; }
  VmstatCounters key() const { return key_; }
  void set_key(VmstatCounters value) { key_ = value; _has_field_.set(1); }

  bool has_value() const { return _has_field_[2]; }
  uint64_t value() const { return value_; }
  void set_value(uint64_t value) { value_ = value; _has_field_.set(2); }

 private:
  VmstatCounters key_{};
  uint64_t value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT SysStats_MeminfoValue : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };

  SysStats_MeminfoValue();
  ~SysStats_MeminfoValue() override;
  SysStats_MeminfoValue(SysStats_MeminfoValue&&) noexcept;
  SysStats_MeminfoValue& operator=(SysStats_MeminfoValue&&);
  SysStats_MeminfoValue(const SysStats_MeminfoValue&);
  SysStats_MeminfoValue& operator=(const SysStats_MeminfoValue&);
  bool operator==(const SysStats_MeminfoValue&) const;
  bool operator!=(const SysStats_MeminfoValue& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_key() const { return _has_field_[1]; }
  MeminfoCounters key() const { return key_; }
  void set_key(MeminfoCounters value) { key_ = value; _has_field_.set(1); }

  bool has_value() const { return _has_field_[2]; }
  uint64_t value() const { return value_; }
  void set_value(uint64_t value) { value_ = value; _has_field_.set(2); }

 private:
  MeminfoCounters key_{};
  uint64_t value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_CPP_H_
