// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROCESSOR_TRACE_PROCESSOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROCESSOR_TRACE_PROCESSOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DescriptorProto;
class DescriptorSet;
class QueryResult_CellsBatch;
class RawQueryResult_ColumnDesc;
class RawQueryResult_ColumnValues;
enum ComputeMetricArgs_ResultFormat : int32_t;
enum QueryResult_CellsBatch_CellType : int32_t;
enum RawQueryResult_ColumnDesc_Type : int32_t;

enum ComputeMetricArgs_ResultFormat : int32_t {
  ComputeMetricArgs_ResultFormat_BINARY_PROTOBUF = 0,
  ComputeMetricArgs_ResultFormat_TEXTPROTO = 1,
};

const ComputeMetricArgs_ResultFormat ComputeMetricArgs_ResultFormat_MIN = ComputeMetricArgs_ResultFormat_BINARY_PROTOBUF;
const ComputeMetricArgs_ResultFormat ComputeMetricArgs_ResultFormat_MAX = ComputeMetricArgs_ResultFormat_TEXTPROTO;

enum QueryResult_CellsBatch_CellType : int32_t {
  QueryResult_CellsBatch_CellType_CELL_INVALID = 0,
  QueryResult_CellsBatch_CellType_CELL_NULL = 1,
  QueryResult_CellsBatch_CellType_CELL_VARINT = 2,
  QueryResult_CellsBatch_CellType_CELL_FLOAT64 = 3,
  QueryResult_CellsBatch_CellType_CELL_STRING = 4,
  QueryResult_CellsBatch_CellType_CELL_BLOB = 5,
};

const QueryResult_CellsBatch_CellType QueryResult_CellsBatch_CellType_MIN = QueryResult_CellsBatch_CellType_CELL_INVALID;
const QueryResult_CellsBatch_CellType QueryResult_CellsBatch_CellType_MAX = QueryResult_CellsBatch_CellType_CELL_BLOB;

enum RawQueryResult_ColumnDesc_Type : int32_t {
  RawQueryResult_ColumnDesc_Type_UNKNOWN = 0,
  RawQueryResult_ColumnDesc_Type_LONG = 1,
  RawQueryResult_ColumnDesc_Type_DOUBLE = 2,
  RawQueryResult_ColumnDesc_Type_STRING = 3,
};

const RawQueryResult_ColumnDesc_Type RawQueryResult_ColumnDesc_Type_MIN = RawQueryResult_ColumnDesc_Type_UNKNOWN;
const RawQueryResult_ColumnDesc_Type RawQueryResult_ColumnDesc_Type_MAX = RawQueryResult_ColumnDesc_Type_STRING;

class GetMetricDescriptorsResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GetMetricDescriptorsResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GetMetricDescriptorsResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GetMetricDescriptorsResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_descriptor_set() const { return at<1>().valid(); }
  ::protozero::ConstBytes descriptor_set() const { return at<1>().as_bytes(); }
};

class GetMetricDescriptorsResult : public ::protozero::Message {
 public:
  using Decoder = GetMetricDescriptorsResult_Decoder;
  enum : int32_t {
    kDescriptorSetFieldNumber = 1,
  };
  template <typename T = DescriptorSet> T* set_descriptor_set() {
    return BeginNestedMessage<T>(1);
  }

};

class GetMetricDescriptorsArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GetMetricDescriptorsArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GetMetricDescriptorsArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GetMetricDescriptorsArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class GetMetricDescriptorsArgs : public ::protozero::Message {
 public:
  using Decoder = GetMetricDescriptorsArgs_Decoder;
};

class DescriptorSet_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DescriptorSet_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorSet_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorSet_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_descriptors() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> descriptors() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class DescriptorSet : public ::protozero::Message {
 public:
  using Decoder = DescriptorSet_Decoder;
  enum : int32_t {
    kDescriptorsFieldNumber = 1,
  };
  template <typename T = DescriptorProto> T* add_descriptors() {
    return BeginNestedMessage<T>(1);
  }

};

class DisableAndReadMetatraceResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DisableAndReadMetatraceResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisableAndReadMetatraceResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisableAndReadMetatraceResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metatrace() const { return at<1>().valid(); }
  ::protozero::ConstBytes metatrace() const { return at<1>().as_bytes(); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
};

class DisableAndReadMetatraceResult : public ::protozero::Message {
 public:
  using Decoder = DisableAndReadMetatraceResult_Decoder;
  enum : int32_t {
    kMetatraceFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  void set_metatrace(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_metatrace(const uint8_t* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_error(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_error(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class DisableAndReadMetatraceArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DisableAndReadMetatraceArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisableAndReadMetatraceArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisableAndReadMetatraceArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class DisableAndReadMetatraceArgs : public ::protozero::Message {
 public:
  using Decoder = DisableAndReadMetatraceArgs_Decoder;
};

class EnableMetatraceResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnableMetatraceResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnableMetatraceResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnableMetatraceResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class EnableMetatraceResult : public ::protozero::Message {
 public:
  using Decoder = EnableMetatraceResult_Decoder;
};

class EnableMetatraceArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnableMetatraceArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnableMetatraceArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnableMetatraceArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class EnableMetatraceArgs : public ::protozero::Message {
 public:
  using Decoder = EnableMetatraceArgs_Decoder;
};

class ComputeMetricResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ComputeMetricResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ComputeMetricResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ComputeMetricResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metrics() const { return at<1>().valid(); }
  ::protozero::ConstBytes metrics() const { return at<1>().as_bytes(); }
  bool has_metrics_as_prototext() const { return at<3>().valid(); }
  ::protozero::ConstChars metrics_as_prototext() const { return at<3>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
};

class ComputeMetricResult : public ::protozero::Message {
 public:
  using Decoder = ComputeMetricResult_Decoder;
  enum : int32_t {
    kMetricsFieldNumber = 1,
    kMetricsAsPrototextFieldNumber = 3,
    kErrorFieldNumber = 2,
  };
  void set_metrics(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_metrics(const uint8_t* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_metrics_as_prototext(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_metrics_as_prototext(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_error(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_error(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class ComputeMetricArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ComputeMetricArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ComputeMetricArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ComputeMetricArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metric_names() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> metric_names() const { return GetRepeated<::protozero::ConstChars>(1); }
  bool has_format() const { return at<2>().valid(); }
  int32_t format() const { return at<2>().as_int32(); }
};

class ComputeMetricArgs : public ::protozero::Message {
 public:
  using Decoder = ComputeMetricArgs_Decoder;
  enum : int32_t {
    kMetricNamesFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  using ResultFormat = ::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat;
  static const ResultFormat BINARY_PROTOBUF = ComputeMetricArgs_ResultFormat_BINARY_PROTOBUF;
  static const ResultFormat TEXTPROTO = ComputeMetricArgs_ResultFormat_TEXTPROTO;
  void add_metric_names(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void add_metric_names(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_format(::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat value) {
    AppendTinyVarInt(2, value);
  }
};

class StatusResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  StatusResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StatusResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StatusResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_loaded_trace_name() const { return at<1>().valid(); }
  ::protozero::ConstChars loaded_trace_name() const { return at<1>().as_string(); }
};

class StatusResult : public ::protozero::Message {
 public:
  using Decoder = StatusResult_Decoder;
  enum : int32_t {
    kLoadedTraceNameFieldNumber = 1,
  };
  void set_loaded_trace_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_loaded_trace_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class StatusArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  StatusArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StatusArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StatusArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class StatusArgs : public ::protozero::Message {
 public:
  using Decoder = StatusArgs_Decoder;
};

class QueryResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  QueryResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit QueryResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit QueryResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_column_names() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> column_names() const { return GetRepeated<::protozero::ConstChars>(1); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
  bool has_batch() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> batch() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class QueryResult : public ::protozero::Message {
 public:
  using Decoder = QueryResult_Decoder;
  enum : int32_t {
    kColumnNamesFieldNumber = 1,
    kErrorFieldNumber = 2,
    kBatchFieldNumber = 3,
  };
  using CellsBatch = ::perfetto::protos::pbzero::QueryResult_CellsBatch;
  void add_column_names(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void add_column_names(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_error(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_error(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  template <typename T = QueryResult_CellsBatch> T* add_batch() {
    return BeginNestedMessage<T>(3);
  }

};

class QueryResult_CellsBatch_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  QueryResult_CellsBatch_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit QueryResult_CellsBatch_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit QueryResult_CellsBatch_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cells() const { return at<1>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t> cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t>(1, parse_error_ptr); }
  bool has_varint_cells() const { return at<2>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t> varint_cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t>(2, parse_error_ptr); }
  bool has_float64_cells() const { return at<3>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kFixed64, double> float64_cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kFixed64, double>(3, parse_error_ptr); }
  bool has_blob_cells() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> blob_cells() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_string_cells() const { return at<5>().valid(); }
  ::protozero::ConstChars string_cells() const { return at<5>().as_string(); }
  bool has_is_last_batch() const { return at<6>().valid(); }
  bool is_last_batch() const { return at<6>().as_bool(); }
};

class QueryResult_CellsBatch : public ::protozero::Message {
 public:
  using Decoder = QueryResult_CellsBatch_Decoder;
  enum : int32_t {
    kCellsFieldNumber = 1,
    kVarintCellsFieldNumber = 2,
    kFloat64CellsFieldNumber = 3,
    kBlobCellsFieldNumber = 4,
    kStringCellsFieldNumber = 5,
    kIsLastBatchFieldNumber = 6,
  };
  using CellType = ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType;
  static const CellType CELL_INVALID = QueryResult_CellsBatch_CellType_CELL_INVALID;
  static const CellType CELL_NULL = QueryResult_CellsBatch_CellType_CELL_NULL;
  static const CellType CELL_VARINT = QueryResult_CellsBatch_CellType_CELL_VARINT;
  static const CellType CELL_FLOAT64 = QueryResult_CellsBatch_CellType_CELL_FLOAT64;
  static const CellType CELL_STRING = QueryResult_CellsBatch_CellType_CELL_STRING;
  static const CellType CELL_BLOB = QueryResult_CellsBatch_CellType_CELL_BLOB;
  void set_cells(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(1, packed_buffer.data(), packed_buffer.size());
  }
  void set_varint_cells(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(2, packed_buffer.data(), packed_buffer.size());
  }
  void set_float64_cells(const ::protozero::PackedFixedSizeInt<double>& packed_buffer) {
    AppendBytes(3, packed_buffer.data(), packed_buffer.size());
  }
  void add_blob_cells(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void add_blob_cells(const uint8_t* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_string_cells(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_string_cells(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_is_last_batch(bool value) {
    AppendTinyVarInt(6, value);
  }
};

class RawQueryResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RawQueryResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RawQueryResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RawQueryResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_column_descriptors() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> column_descriptors() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_num_records() const { return at<2>().valid(); }
  uint64_t num_records() const { return at<2>().as_uint64(); }
  bool has_columns() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> columns() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_error() const { return at<4>().valid(); }
  ::protozero::ConstChars error() const { return at<4>().as_string(); }
  bool has_execution_time_ns() const { return at<5>().valid(); }
  uint64_t execution_time_ns() const { return at<5>().as_uint64(); }
};

class RawQueryResult : public ::protozero::Message {
 public:
  using Decoder = RawQueryResult_Decoder;
  enum : int32_t {
    kColumnDescriptorsFieldNumber = 1,
    kNumRecordsFieldNumber = 2,
    kColumnsFieldNumber = 3,
    kErrorFieldNumber = 4,
    kExecutionTimeNsFieldNumber = 5,
  };
  using ColumnDesc = ::perfetto::protos::pbzero::RawQueryResult_ColumnDesc;
  using ColumnValues = ::perfetto::protos::pbzero::RawQueryResult_ColumnValues;
  template <typename T = RawQueryResult_ColumnDesc> T* add_column_descriptors() {
    return BeginNestedMessage<T>(1);
  }

  void set_num_records(uint64_t value) {
    AppendVarInt(2, value);
  }
  template <typename T = RawQueryResult_ColumnValues> T* add_columns() {
    return BeginNestedMessage<T>(3);
  }

  void set_error(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_error(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_execution_time_ns(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class RawQueryResult_ColumnValues_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RawQueryResult_ColumnValues_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RawQueryResult_ColumnValues_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RawQueryResult_ColumnValues_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_long_values() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<int64_t> long_values() const { return GetRepeated<int64_t>(1); }
  bool has_double_values() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<double> double_values() const { return GetRepeated<double>(2); }
  bool has_string_values() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> string_values() const { return GetRepeated<::protozero::ConstChars>(3); }
  bool has_is_nulls() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<bool> is_nulls() const { return GetRepeated<bool>(4); }
};

class RawQueryResult_ColumnValues : public ::protozero::Message {
 public:
  using Decoder = RawQueryResult_ColumnValues_Decoder;
  enum : int32_t {
    kLongValuesFieldNumber = 1,
    kDoubleValuesFieldNumber = 2,
    kStringValuesFieldNumber = 3,
    kIsNullsFieldNumber = 4,
  };
  void add_long_values(int64_t value) {
    AppendVarInt(1, value);
  }
  void add_double_values(double value) {
    AppendFixed(2, value);
  }
  void add_string_values(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void add_string_values(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void add_is_nulls(bool value) {
    AppendTinyVarInt(4, value);
  }
};

class RawQueryResult_ColumnDesc_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RawQueryResult_ColumnDesc_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RawQueryResult_ColumnDesc_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RawQueryResult_ColumnDesc_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_type() const { return at<2>().valid(); }
  int32_t type() const { return at<2>().as_int32(); }
};

class RawQueryResult_ColumnDesc : public ::protozero::Message {
 public:
  using Decoder = RawQueryResult_ColumnDesc_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  using Type = ::perfetto::protos::pbzero::RawQueryResult_ColumnDesc_Type;
  static const Type UNKNOWN = RawQueryResult_ColumnDesc_Type_UNKNOWN;
  static const Type LONG = RawQueryResult_ColumnDesc_Type_LONG;
  static const Type DOUBLE = RawQueryResult_ColumnDesc_Type_DOUBLE;
  static const Type STRING = RawQueryResult_ColumnDesc_Type_STRING;
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_type(::perfetto::protos::pbzero::RawQueryResult_ColumnDesc_Type value) {
    AppendTinyVarInt(2, value);
  }
};

class RawQueryArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RawQueryArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RawQueryArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RawQueryArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sql_query() const { return at<1>().valid(); }
  ::protozero::ConstChars sql_query() const { return at<1>().as_string(); }
  bool has_time_queued_ns() const { return at<2>().valid(); }
  uint64_t time_queued_ns() const { return at<2>().as_uint64(); }
};

class RawQueryArgs : public ::protozero::Message {
 public:
  using Decoder = RawQueryArgs_Decoder;
  enum : int32_t {
    kSqlQueryFieldNumber = 1,
    kTimeQueuedNsFieldNumber = 2,
  };
  void set_sql_query(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_sql_query(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_time_queued_ns(uint64_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
